// /Users/vincent/phaser-game/example/node_modules/phaser-game/dist/index.js
var x0 = function() {
  let R0, H0;
  const Y0 = { type: B0.default.AUTO, width: 800, height: 600, physics: { default: "arcade", arcade: { gravity: { x: 0, y: 300 }, debug: false } }, scene: { preload() {
    this.load.image("sky", "assets/sky.png"), this.load.image("ground", "assets/platform.png"), this.load.image("star", "assets/star.png"), this.load.image("bomb", "assets/bomb.png"), this.load.spritesheet("dude", "assets/dude.png", { frameWidth: 32, frameHeight: 48 });
  }, create() {
    let M0 = 0;
    this.add.image(400, 300, "sky");
    const M = this.physics.add.staticGroup();
    M.create(400, 568, "ground").setScale(2).refreshBody(), M.create(600, 400, "ground"), M.create(50, 250, "ground"), M.create(750, 220, "ground"), H0 = this.physics.add.sprite(100, 450, "dude"), H0.setBounce(0.2), H0.setCollideWorldBounds(true), this.anims.create({ key: "left", frames: this.anims.generateFrameNumbers("dude", { start: 0, end: 3 }), frameRate: 10, repeat: -1 }), this.anims.create({ key: "turn", frames: [{ key: "dude", frame: 4 }], frameRate: 20 }), this.anims.create({ key: "right", frames: this.anims.generateFrameNumbers("dude", { start: 5, end: 8 }), frameRate: 10, repeat: -1 }), this.physics.add.collider(H0, M), R0 = this.input.keyboard?.createCursorKeys();
    const B = this.physics.add.group({ key: "star", repeat: 11, setXY: { x: 12, y: 0, stepX: 70 } });
    B.children.iterate(function(z) {
      return z.setBounceY(B0.default.Math.FloatBetween(0.4, 0.8)), null;
    });
    const $ = this.add.text(16, 16, "score: 0", { fontSize: "32px", color: "#000" });
    this.physics.add.collider(B, M), this.physics.add.overlap(H0, B, (z, U) => {
      if (U.disableBody(true, true), M0 += 10, $.setText("Score: " + M0), B.countActive(true) === 0) {
        B.children.iterate(function(Z) {
          return Z.enableBody(true, Z.x, 0, true, true), null;
        });
        var K = z.x < 400 ? B0.default.Math.Between(400, 800) : B0.default.Math.Between(0, 400), J = E.create(K, 16, "bomb");
        J.setBounce(1), J.setCollideWorldBounds(true), J.setVelocity(B0.default.Math.Between(-200, 200), 20);
      }
    }, undefined, this);
    const E = this.physics.add.group();
    this.physics.add.collider(E, M);
    let L = false;
    this.physics.add.collider(H0, E, (z, U) => {
      this.physics.pause(), z.setTint(16711680), z.anims.play("turn"), L = true;
    }, undefined, this);
  }, update() {
    if (R0?.left.isDown)
      H0?.setVelocityX(-160), H0?.anims.play("left", true);
    else if (R0?.right.isDown)
      H0?.setVelocityX(160), H0?.anims.play("right", true);
    else
      H0?.setVelocityX(0), H0?.anims.play("turn");
    if (R0?.up.isDown && H0?.body.touching.down)
      H0.setVelocityY(-330);
  } } };
  return new B0.default.Game(Y0);
};
var S0 = Object.create;
var { defineProperty: T0, getPrototypeOf: O0, getOwnPropertyNames: C0 } = Object;
var q0 = Object.prototype.hasOwnProperty;
var v0 = (R0, H0, Y0) => {
  Y0 = R0 != null ? S0(O0(R0)) : {};
  const M0 = H0 || !R0 || !R0.__esModule ? T0(Y0, "default", { value: R0, enumerable: true }) : Y0;
  for (let M of C0(R0))
    if (!q0.call(M0, M))
      T0(M0, M, { get: () => R0[M], enumerable: true });
  return M0;
};
var f0 = (R0, H0) => () => (H0 || R0((H0 = { exports: {} }).exports, H0), H0.exports);
var j0 = f0((A0, F0) => {
  (function R0(H0, Y0) {
    if (typeof A0 === "object" && typeof F0 === "object")
      F0.exports = Y0();
    else if (typeof define === "function" && define.amd)
      define("Phaser", [], Y0);
    else if (typeof A0 === "object")
      A0.Phaser = Y0();
    else
      H0.Phaser = Y0();
  })(A0, () => {
    return (() => {
      var R0 = { 50792: (M) => {
        var B = Object.prototype.hasOwnProperty, $ = "~";
        function E() {
        }
        if (Object.create) {
          if (E.prototype = Object.create(null), !new E().__proto__)
            $ = false;
        }
        function L(J, Z, D) {
          this.fn = J, this.context = Z, this.once = D || false;
        }
        function z(J, Z, D, Q, H) {
          if (typeof D !== "function")
            throw new TypeError("The listener must be a function");
          var N = new L(D, Q || J, H), W = $ ? $ + Z : Z;
          if (!J._events[W])
            J._events[W] = N, J._eventsCount++;
          else if (!J._events[W].fn)
            J._events[W].push(N);
          else
            J._events[W] = [J._events[W], N];
          return J;
        }
        function U(J, Z) {
          if (--J._eventsCount === 0)
            J._events = new E;
          else
            delete J._events[Z];
        }
        function K() {
          this._events = new E, this._eventsCount = 0;
        }
        K.prototype.eventNames = function J() {
          var Z = [], D, Q;
          if (this._eventsCount === 0)
            return Z;
          for (Q in D = this._events)
            if (B.call(D, Q))
              Z.push($ ? Q.slice(1) : Q);
          if (Object.getOwnPropertySymbols)
            return Z.concat(Object.getOwnPropertySymbols(D));
          return Z;
        }, K.prototype.listeners = function J(Z) {
          var D = $ ? $ + Z : Z, Q = this._events[D];
          if (!Q)
            return [];
          if (Q.fn)
            return [Q.fn];
          for (var H = 0, N = Q.length, W = new Array(N);H < N; H++)
            W[H] = Q[H].fn;
          return W;
        }, K.prototype.listenerCount = function J(Z) {
          var D = $ ? $ + Z : Z, Q = this._events[D];
          if (!Q)
            return 0;
          if (Q.fn)
            return 1;
          return Q.length;
        }, K.prototype.emit = function J(Z, D, Q, H, N, W) {
          var R = $ ? $ + Z : Z;
          if (!this._events[R])
            return false;
          var Y = this._events[R], I = arguments.length, P, X;
          if (Y.fn) {
            if (Y.once)
              this.removeListener(Z, Y.fn, undefined, true);
            switch (I) {
              case 1:
                return Y.fn.call(Y.context), true;
              case 2:
                return Y.fn.call(Y.context, D), true;
              case 3:
                return Y.fn.call(Y.context, D, Q), true;
              case 4:
                return Y.fn.call(Y.context, D, Q, H), true;
              case 5:
                return Y.fn.call(Y.context, D, Q, H, N), true;
              case 6:
                return Y.fn.call(Y.context, D, Q, H, N, W), true;
            }
            for (X = 1, P = new Array(I - 1);X < I; X++)
              P[X - 1] = arguments[X];
            Y.fn.apply(Y.context, P);
          } else {
            var G = Y.length, V;
            for (X = 0;X < G; X++) {
              if (Y[X].once)
                this.removeListener(Z, Y[X].fn, undefined, true);
              switch (I) {
                case 1:
                  Y[X].fn.call(Y[X].context);
                  break;
                case 2:
                  Y[X].fn.call(Y[X].context, D);
                  break;
                case 3:
                  Y[X].fn.call(Y[X].context, D, Q);
                  break;
                case 4:
                  Y[X].fn.call(Y[X].context, D, Q, H);
                  break;
                default:
                  if (!P)
                    for (V = 1, P = new Array(I - 1);V < I; V++)
                      P[V - 1] = arguments[V];
                  Y[X].fn.apply(Y[X].context, P);
              }
            }
          }
          return true;
        }, K.prototype.on = function J(Z, D, Q) {
          return z(this, Z, D, Q, false);
        }, K.prototype.once = function J(Z, D, Q) {
          return z(this, Z, D, Q, true);
        }, K.prototype.removeListener = function J(Z, D, Q, H) {
          var N = $ ? $ + Z : Z;
          if (!this._events[N])
            return this;
          if (!D)
            return U(this, N), this;
          var W = this._events[N];
          if (W.fn) {
            if (W.fn === D && (!H || W.once) && (!Q || W.context === Q))
              U(this, N);
          } else {
            for (var R = 0, Y = [], I = W.length;R < I; R++)
              if (W[R].fn !== D || H && !W[R].once || Q && W[R].context !== Q)
                Y.push(W[R]);
            if (Y.length)
              this._events[N] = Y.length === 1 ? Y[0] : Y;
            else
              U(this, N);
          }
          return this;
        }, K.prototype.removeAllListeners = function J(Z) {
          var D;
          if (Z) {
            if (D = $ ? $ + Z : Z, this._events[D])
              U(this, D);
          } else
            this._events = new E, this._eventsCount = 0;
          return this;
        }, K.prototype.off = K.prototype.removeListener, K.prototype.addListener = K.prototype.on, K.prefixed = $, K.EventEmitter = K, M.exports = K;
      }, 11517: (M, B, $) => {
        var E = $(38829), L = function(z, U, K, J) {
          var Z = z[0];
          for (var D = 1;D < z.length; D++) {
            var Q = z[D];
            E(Q, Z, U, K, J), Z = Q;
          }
          return z;
        };
        M.exports = L;
      }, 80318: (M, B, $) => {
        var E = $(66979), L = function(z, U, K, J, Z) {
          return E(z, "angle", U, K, J, Z);
        };
        M.exports = L;
      }, 60757: (M) => {
        var B = function($, E, L) {
          for (var z = 0;z < $.length; z++) {
            var U = $[z];
            E.call(L, U);
          }
          return $;
        };
        M.exports = B;
      }, 69927: (M) => {
        var B = function($, E, L) {
          if (L === undefined)
            L = 0;
          for (var z = L;z < $.length; z++) {
            var U = $[z], K = true;
            for (var J in E)
              if (U[J] !== E[J])
                K = false;
            if (K)
              return U;
          }
          return null;
        };
        M.exports = B;
      }, 32265: (M) => {
        var B = function($, E, L) {
          if (L === undefined)
            L = 0;
          for (var z = $.length - 1;z >= L; z--) {
            var U = $[z], K = true;
            for (var J in E)
              if (U[J] !== E[J])
                K = false;
            if (K)
              return U;
          }
          return null;
        };
        M.exports = B;
      }, 94420: (M, B, $) => {
        var E = $(11879), L = $(60461), z = $(95540), U = $(29747), K = $(41481), J = new K({ sys: { queueDepthSort: U, events: { once: U } } }, 0, 0, 1, 1).setOrigin(0, 0), Z = function(D, Q) {
          if (Q === undefined)
            Q = {};
          var H = Q.hasOwnProperty("width"), N = Q.hasOwnProperty("height"), W = z(Q, "width", -1), R = z(Q, "height", -1), Y = z(Q, "cellWidth", 1), I = z(Q, "cellHeight", Y), P = z(Q, "position", L.TOP_LEFT), X = z(Q, "x", 0), G = z(Q, "y", 0), V = 0, A = 0, F = W * Y, j = R * I;
          J.setPosition(X, G), J.setSize(Y, I);
          for (var T = 0;T < D.length; T++)
            if (E(D[T], J, P), H && W === -1)
              J.x += Y;
            else if (N && R === -1)
              J.y += I;
            else if (N && !H) {
              if (A += I, J.y += I, A === j) {
                if (A = 0, V += Y, J.y = G, J.x += Y, V === F)
                  break;
              }
            } else if (V += Y, J.x += Y, V === F) {
              if (V = 0, A += I, J.x = X, J.y += I, A === j)
                break;
            }
          return D;
        };
        M.exports = Z;
      }, 41721: (M, B, $) => {
        var E = $(66979), L = function(z, U, K, J, Z) {
          return E(z, "alpha", U, K, J, Z);
        };
        M.exports = L;
      }, 67285: (M, B, $) => {
        var E = $(66979), L = function(z, U, K, J, Z) {
          return E(z, "x", U, K, J, Z);
        };
        M.exports = L;
      }, 9074: (M, B, $) => {
        var E = $(66979), L = function(z, U, K, J, Z, D, Q) {
          if (K === undefined || K === null)
            K = U;
          return E(z, "x", U, J, D, Q), E(z, "y", K, Z, D, Q);
        };
        M.exports = L;
      }, 75222: (M, B, $) => {
        var E = $(66979), L = function(z, U, K, J, Z) {
          return E(z, "y", U, K, J, Z);
        };
        M.exports = L;
      }, 22983: (M) => {
        var B = function($, E, L, z) {
          if (L === undefined)
            L = 0;
          if (z === undefined)
            z = 6.28;
          var U = L, K = (z - L) / $.length, J = E.x, Z = E.y, D = E.radius;
          for (var Q = 0;Q < $.length; Q++)
            $[Q].x = J + D * Math.cos(U), $[Q].y = Z + D * Math.sin(U), U += K;
          return $;
        };
        M.exports = B;
      }, 95253: (M) => {
        var B = function($, E, L, z) {
          if (L === undefined)
            L = 0;
          if (z === undefined)
            z = 6.28;
          var U = L, K = (z - L) / $.length, J = E.width / 2, Z = E.height / 2;
          for (var D = 0;D < $.length; D++)
            $[D].x = E.x + J * Math.cos(U), $[D].y = E.y + Z * Math.sin(U), U += K;
          return $;
        };
        M.exports = B;
      }, 88505: (M, B, $) => {
        var E = $(15258), L = $(26708), z = function(U, K, J) {
          var Z;
          if (J)
            Z = L(K, J, U.length);
          else
            Z = E(K, U.length);
          for (var D = 0;D < U.length; D++) {
            var Q = U[D], H = Z[D];
            Q.x = H.x, Q.y = H.y;
          }
          return U;
        };
        M.exports = z;
      }, 41346: (M, B, $) => {
        var E = $(14649), L = $(86003), z = $(49498), U = function(K, J, Z) {
          if (Z === undefined)
            Z = 0;
          var D = E(J, false, K.length);
          if (Z > 0)
            L(D, Z);
          else if (Z < 0)
            z(D, Math.abs(Z));
          for (var Q = 0;Q < K.length; Q++)
            K[Q].x = D[Q].x, K[Q].y = D[Q].y;
          return K;
        };
        M.exports = U;
      }, 11575: (M, B, $) => {
        var E = $(84993), L = function(z, U, K) {
          var J = E({ x1: U.x1, y1: U.y1, x2: U.x2, y2: U.y2 }, K), Z = E({ x1: U.x2, y1: U.y2, x2: U.x3, y2: U.y3 }, K), D = E({ x1: U.x3, y1: U.y3, x2: U.x1, y2: U.y1 }, K);
          J.pop(), Z.pop(), D.pop(), J = J.concat(Z, D);
          var Q = J.length / z.length, H = 0;
          for (var N = 0;N < z.length; N++) {
            var W = z[N], R = J[Math.floor(H)];
            W.x = R.x, W.y = R.y, H += Q;
          }
          return z;
        };
        M.exports = L;
      }, 29953: (M) => {
        var B = function($, E, L) {
          for (var z = 0;z < $.length; z++) {
            var U = $[z];
            if (U.anims)
              U.anims.play(E, L);
          }
          return $;
        };
        M.exports = B;
      }, 66979: (M) => {
        var B = function($, E, L, z, U, K) {
          if (z === undefined)
            z = 0;
          if (U === undefined)
            U = 0;
          if (K === undefined)
            K = 1;
          var J, Z = 0, D = $.length;
          if (K === 1)
            for (J = U;J < D; J++)
              $[J][E] += L + Z * z, Z++;
          else
            for (J = U;J >= 0; J--)
              $[J][E] += L + Z * z, Z++;
          return $;
        };
        M.exports = B;
      }, 43967: (M) => {
        var B = function($, E, L, z, U, K) {
          if (z === undefined)
            z = 0;
          if (U === undefined)
            U = 0;
          if (K === undefined)
            K = 1;
          var J, Z = 0, D = $.length;
          if (K === 1)
            for (J = U;J < D; J++)
              $[J][E] = L + Z * z, Z++;
          else
            for (J = U;J >= 0; J--)
              $[J][E] = L + Z * z, Z++;
          return $;
        };
        M.exports = B;
      }, 88926: (M, B, $) => {
        var E = $(28176), L = function(z, U) {
          for (var K = 0;K < z.length; K++)
            E(U, z[K]);
          return z;
        };
        M.exports = L;
      }, 33286: (M, B, $) => {
        var E = $(24820), L = function(z, U) {
          for (var K = 0;K < z.length; K++)
            E(U, z[K]);
          return z;
        };
        M.exports = L;
      }, 96000: (M, B, $) => {
        var E = $(65822), L = function(z, U) {
          for (var K = 0;K < z.length; K++)
            E(U, z[K]);
          return z;
        };
        M.exports = L;
      }, 28789: (M, B, $) => {
        var E = $(26597), L = function(z, U) {
          for (var K = 0;K < z.length; K++)
            E(U, z[K]);
          return z;
        };
        M.exports = L;
      }, 97154: (M, B, $) => {
        var E = $(90260), L = function(z, U) {
          for (var K = 0;K < z.length; K++)
            E(U, z[K]);
          return z;
        };
        M.exports = L;
      }, 20510: (M, B, $) => {
        var E = $(66979), L = function(z, U, K, J, Z) {
          return E(z, "rotation", U, K, J, Z);
        };
        M.exports = L;
      }, 91051: (M, B, $) => {
        var E = $(1163), L = $(20339), z = function(U, K, J) {
          var { x: Z, y: D } = K;
          for (var Q = 0;Q < U.length; Q++) {
            var H = U[Q];
            E(H, Z, D, J, Math.max(1, L(H.x, H.y, Z, D)));
          }
          return U;
        };
        M.exports = z;
      }, 76332: (M, B, $) => {
        var E = $(1163), L = function(z, U, K, J) {
          var { x: Z, y: D } = U;
          if (J === 0)
            return z;
          for (var Q = 0;Q < z.length; Q++)
            E(z[Q], Z, D, K, J);
          return z;
        };
        M.exports = L;
      }, 61619: (M, B, $) => {
        var E = $(66979), L = function(z, U, K, J, Z) {
          return E(z, "scaleX", U, K, J, Z);
        };
        M.exports = L;
      }, 94868: (M, B, $) => {
        var E = $(66979), L = function(z, U, K, J, Z, D, Q) {
          if (K === undefined || K === null)
            K = U;
          return E(z, "scaleX", U, J, D, Q), E(z, "scaleY", K, Z, D, Q);
        };
        M.exports = L;
      }, 95532: (M, B, $) => {
        var E = $(66979), L = function(z, U, K, J, Z) {
          return E(z, "scaleY", U, K, J, Z);
        };
        M.exports = L;
      }, 8689: (M, B, $) => {
        var E = $(43967), L = function(z, U, K, J, Z) {
          return E(z, "alpha", U, K, J, Z);
        };
        M.exports = L;
      }, 2645: (M, B, $) => {
        var E = $(43967), L = function(z, U, K, J) {
          return E(z, "blendMode", U, 0, K, J);
        };
        M.exports = L;
      }, 32372: (M, B, $) => {
        var E = $(43967), L = function(z, U, K, J, Z) {
          return E(z, "depth", U, K, J, Z);
        };
        M.exports = L;
      }, 85373: (M) => {
        var B = function($, E, L) {
          for (var z = 0;z < $.length; z++)
            $[z].setInteractive(E, L);
          return $;
        };
        M.exports = B;
      }, 81583: (M, B, $) => {
        var E = $(43967), L = function(z, U, K, J, Z, D, Q) {
          if (K === undefined || K === null)
            K = U;
          return E(z, "originX", U, J, D, Q), E(z, "originY", K, Z, D, Q), z.forEach(function(H) {
            H.updateDisplayOrigin();
          }), z;
        };
        M.exports = L;
      }, 79939: (M, B, $) => {
        var E = $(43967), L = function(z, U, K, J, Z) {
          return E(z, "rotation", U, K, J, Z);
        };
        M.exports = L;
      }, 2699: (M, B, $) => {
        var E = $(43967), L = function(z, U, K, J, Z, D, Q) {
          if (K === undefined || K === null)
            K = U;
          return E(z, "scaleX", U, J, D, Q), E(z, "scaleY", K, Z, D, Q);
        };
        M.exports = L;
      }, 98739: (M, B, $) => {
        var E = $(43967), L = function(z, U, K, J, Z) {
          return E(z, "scaleX", U, K, J, Z);
        };
        M.exports = L;
      }, 98476: (M, B, $) => {
        var E = $(43967), L = function(z, U, K, J, Z) {
          return E(z, "scaleY", U, K, J, Z);
        };
        M.exports = L;
      }, 6207: (M, B, $) => {
        var E = $(43967), L = function(z, U, K, J, Z, D, Q) {
          if (K === undefined || K === null)
            K = U;
          return E(z, "scrollFactorX", U, J, D, Q), E(z, "scrollFactorY", K, Z, D, Q);
        };
        M.exports = L;
      }, 6607: (M, B, $) => {
        var E = $(43967), L = function(z, U, K, J, Z) {
          return E(z, "scrollFactorX", U, K, J, Z);
        };
        M.exports = L;
      }, 72248: (M, B, $) => {
        var E = $(43967), L = function(z, U, K, J, Z) {
          return E(z, "scrollFactorY", U, K, J, Z);
        };
        M.exports = L;
      }, 14036: (M) => {
        var B = function($, E, L, z, U) {
          for (var K = 0;K < $.length; K++)
            $[K].setTint(E, L, z, U);
          return $;
        };
        M.exports = B;
      }, 50159: (M, B, $) => {
        var E = $(43967), L = function(z, U, K, J) {
          return E(z, "visible", U, 0, K, J);
        };
        M.exports = L;
      }, 77597: (M, B, $) => {
        var E = $(43967), L = function(z, U, K, J, Z) {
          return E(z, "x", U, K, J, Z);
        };
        M.exports = L;
      }, 83194: (M, B, $) => {
        var E = $(43967), L = function(z, U, K, J, Z, D, Q) {
          if (K === undefined || K === null)
            K = U;
          return E(z, "x", U, J, D, Q), E(z, "y", K, Z, D, Q);
        };
        M.exports = L;
      }, 67678: (M, B, $) => {
        var E = $(43967), L = function(z, U, K, J, Z) {
          return E(z, "y", U, K, J, Z);
        };
        M.exports = L;
      }, 35850: (M, B, $) => {
        var E = $(26099), L = function(z, U, K, J, Z) {
          if (J === undefined)
            J = 0;
          if (Z === undefined)
            Z = new E;
          var D, Q, H = z.length;
          if (H === 1)
            D = z[0].x, Q = z[0].y, z[0].x = U, z[0].y = K;
          else {
            var N = 1, W = 0;
            if (J === 0)
              W = H - 1, N = H - 2;
            D = z[W].x, Q = z[W].y, z[W].x = U, z[W].y = K;
            for (var R = 0;R < H; R++) {
              if (N >= H || N === -1)
                continue;
              var Y = z[N], I = Y.x, P = Y.y;
              if (Y.x = D, Y.y = Q, D = I, Q = P, J === 0)
                N--;
              else
                N++;
            }
          }
          return Z.x = D, Z.y = Q, Z;
        };
        M.exports = L;
      }, 8628: (M, B, $) => {
        var E = $(33680), L = function(z) {
          return E(z);
        };
        M.exports = L;
      }, 21837: (M, B, $) => {
        var E = $(7602), L = function(z, U, K, J, Z) {
          if (Z === undefined)
            Z = false;
          var D = Math.abs(J - K) / z.length, Q;
          if (Z)
            for (Q = 0;Q < z.length; Q++)
              z[Q][U] += E(Q * D, K, J);
          else
            for (Q = 0;Q < z.length; Q++)
              z[Q][U] = E(Q * D, K, J);
          return z;
        };
        M.exports = L;
      }, 21910: (M, B, $) => {
        var E = $(54261), L = function(z, U, K, J, Z) {
          if (Z === undefined)
            Z = false;
          var D = Math.abs(J - K) / z.length, Q;
          if (Z)
            for (Q = 0;Q < z.length; Q++)
              z[Q][U] += E(Q * D, K, J);
          else
            for (Q = 0;Q < z.length; Q++)
              z[Q][U] = E(Q * D, K, J);
          return z;
        };
        M.exports = L;
      }, 62054: (M) => {
        var B = function($, E, L, z, U) {
          if (U === undefined)
            U = false;
          if ($.length === 0)
            return $;
          if ($.length === 1) {
            if (U)
              $[0][E] += (z + L) / 2;
            else
              $[0][E] = (z + L) / 2;
            return $;
          }
          var K = Math.abs(z - L) / ($.length - 1), J;
          if (U)
            for (J = 0;J < $.length; J++)
              $[J][E] += J * K + L;
          else
            for (J = 0;J < $.length; J++)
              $[J][E] = J * K + L;
          return $;
        };
        M.exports = B;
      }, 79815: (M) => {
        var B = function($) {
          for (var E = 0;E < $.length; E++)
            $[E].visible = !$[E].visible;
          return $;
        };
        M.exports = B;
      }, 39665: (M, B, $) => {
        var E = $(15994), L = function(z, U, K) {
          if (K === undefined)
            K = 0;
          for (var J = 0;J < z.length; J++) {
            var Z = z[J];
            Z.x = E(Z.x, U.left - K, U.right + K), Z.y = E(Z.y, U.top - K, U.bottom + K);
          }
          return z;
        };
        M.exports = L;
      }, 61061: (M, B, $) => {
        M.exports = { AlignTo: $(11517), Angle: $(80318), Call: $(60757), GetFirst: $(69927), GetLast: $(32265), GridAlign: $(94420), IncAlpha: $(41721), IncX: $(67285), IncXY: $(9074), IncY: $(75222), PlaceOnCircle: $(22983), PlaceOnEllipse: $(95253), PlaceOnLine: $(88505), PlaceOnRectangle: $(41346), PlaceOnTriangle: $(11575), PlayAnimation: $(29953), PropertyValueInc: $(66979), PropertyValueSet: $(43967), RandomCircle: $(88926), RandomEllipse: $(33286), RandomLine: $(96000), RandomRectangle: $(28789), RandomTriangle: $(97154), Rotate: $(20510), RotateAround: $(91051), RotateAroundDistance: $(76332), ScaleX: $(61619), ScaleXY: $(94868), ScaleY: $(95532), SetAlpha: $(8689), SetBlendMode: $(2645), SetDepth: $(32372), SetHitArea: $(85373), SetOrigin: $(81583), SetRotation: $(79939), SetScale: $(2699), SetScaleX: $(98739), SetScaleY: $(98476), SetScrollFactor: $(6207), SetScrollFactorX: $(6607), SetScrollFactorY: $(72248), SetTint: $(14036), SetVisible: $(50159), SetX: $(77597), SetXY: $(83194), SetY: $(67678), ShiftPosition: $(35850), Shuffle: $(8628), SmootherStep: $(21910), SmoothStep: $(21837), Spread: $(62054), ToggleVisible: $(79815), WrapInRectangle: $(39665) };
      }, 42099: (M, B, $) => {
        var E = $(45319), L = $(83419), z = $(74943), U = $(81957), K = $(41138), J = $(35154), Z = $(90126), D = new L({ initialize: function Q(H, N, W) {
          if (this.manager = H, this.key = N, this.type = "frame", this.frames = this.getFrames(H.textureManager, J(W, "frames", []), J(W, "defaultTextureKey", null), J(W, "sortFrames", true)), this.frameRate = J(W, "frameRate", null), this.duration = J(W, "duration", null), this.msPerFrame, this.skipMissedFrames = J(W, "skipMissedFrames", true), this.delay = J(W, "delay", 0), this.repeat = J(W, "repeat", 0), this.repeatDelay = J(W, "repeatDelay", 0), this.yoyo = J(W, "yoyo", false), this.showBeforeDelay = J(W, "showBeforeDelay", false), this.showOnStart = J(W, "showOnStart", false), this.hideOnComplete = J(W, "hideOnComplete", false), this.randomFrame = J(W, "randomFrame", false), this.paused = false, this.calculateDuration(this, this.getTotalFrames(), this.duration, this.frameRate), this.manager.on)
            this.manager.on(z.PAUSE_ALL, this.pause, this), this.manager.on(z.RESUME_ALL, this.resume, this);
        }, getTotalFrames: function() {
          return this.frames.length;
        }, calculateDuration: function(Q, H, N, W) {
          if (N === null && W === null)
            Q.frameRate = 24, Q.duration = 24 / H * 1000;
          else if (N && W === null)
            Q.duration = N, Q.frameRate = H / (N / 1000);
          else
            Q.frameRate = W, Q.duration = H / W * 1000;
          Q.msPerFrame = 1000 / Q.frameRate;
        }, addFrame: function(Q) {
          return this.addFrameAt(this.frames.length, Q);
        }, addFrameAt: function(Q, H) {
          var N = this.getFrames(this.manager.textureManager, H);
          if (N.length > 0) {
            if (Q === 0)
              this.frames = N.concat(this.frames);
            else if (Q === this.frames.length)
              this.frames = this.frames.concat(N);
            else {
              var W = this.frames.slice(0, Q), R = this.frames.slice(Q);
              this.frames = W.concat(N, R);
            }
            this.updateFrameSequence();
          }
          return this;
        }, checkFrame: function(Q) {
          return Q >= 0 && Q < this.frames.length;
        }, getFirstTick: function(Q) {
          Q.accumulator = 0, Q.nextTick = Q.currentFrame.duration ? Q.currentFrame.duration : Q.msPerFrame;
        }, getFrameAt: function(Q) {
          return this.frames[Q];
        }, getFrames: function(Q, H, N, W) {
          if (W === undefined)
            W = true;
          var R = [], Y, I, P = 1, X, G;
          if (typeof H === "string") {
            if (G = H, !Q.exists(G))
              return console.warn('Texture "%s" not found', G), R;
            var V = Q.get(G), A = V.getFrameNames();
            if (W)
              Z(A);
            H = [], A.forEach(function(O) {
              H.push({ key: G, frame: O });
            });
          }
          if (!Array.isArray(H) || H.length === 0)
            return R;
          for (X = 0;X < H.length; X++) {
            var F = H[X], j = J(F, "key", N);
            if (!j)
              continue;
            var T = J(F, "frame", 0), C = Q.getFrame(j, T);
            if (!C) {
              console.warn('Texture "%s" not found', j);
              continue;
            }
            if (I = new K(j, T, P, C), I.duration = J(F, "duration", 0), I.isFirst = !Y, Y)
              Y.nextFrame = I, I.prevFrame = Y;
            R.push(I), Y = I, P++;
          }
          if (R.length > 0) {
            I.isLast = true, I.nextFrame = R[0], R[0].prevFrame = I;
            var v = 1 / (R.length - 1);
            for (X = 0;X < R.length; X++)
              R[X].progress = X * v;
          }
          return R;
        }, getNextTick: function(Q) {
          Q.accumulator -= Q.nextTick, Q.nextTick = Q.currentFrame.duration ? Q.currentFrame.duration : Q.msPerFrame;
        }, getFrameByProgress: function(Q) {
          return Q = E(Q, 0, 1), U(Q, this.frames, "progress");
        }, nextFrame: function(Q) {
          var H = Q.currentFrame;
          if (H.isLast)
            if (Q.yoyo)
              this.handleYoyoFrame(Q, false);
            else if (Q.repeatCounter > 0)
              if (Q.inReverse && Q.forward)
                Q.forward = false;
              else
                this.repeatAnimation(Q);
            else
              Q.complete();
          else
            this.updateAndGetNextTick(Q, H.nextFrame);
        }, handleYoyoFrame: function(Q, H) {
          if (!H)
            H = false;
          if (Q.inReverse === !H && Q.repeatCounter > 0) {
            if (Q.repeatDelay === 0 || Q.pendingRepeat)
              Q.forward = H;
            this.repeatAnimation(Q);
            return;
          }
          if (Q.inReverse !== H && Q.repeatCounter === 0) {
            Q.complete();
            return;
          }
          Q.forward = H;
          var N = H ? Q.currentFrame.nextFrame : Q.currentFrame.prevFrame;
          this.updateAndGetNextTick(Q, N);
        }, getLastFrame: function() {
          return this.frames[this.frames.length - 1];
        }, previousFrame: function(Q) {
          var H = Q.currentFrame;
          if (H.isFirst)
            if (Q.yoyo)
              this.handleYoyoFrame(Q, true);
            else if (Q.repeatCounter > 0)
              if (Q.inReverse && !Q.forward)
                this.repeatAnimation(Q);
              else
                Q.forward = true, this.repeatAnimation(Q);
            else
              Q.complete();
          else
            this.updateAndGetNextTick(Q, H.prevFrame);
        }, updateAndGetNextTick: function(Q, H) {
          Q.setCurrentFrame(H), this.getNextTick(Q);
        }, removeFrame: function(Q) {
          var H = this.frames.indexOf(Q);
          if (H !== -1)
            this.removeFrameAt(H);
          return this;
        }, removeFrameAt: function(Q) {
          return this.frames.splice(Q, 1), this.updateFrameSequence(), this;
        }, repeatAnimation: function(Q) {
          if (Q._pendingStop === 2)
            if (Q._pendingStopValue === 0)
              return Q.stop();
            else
              Q._pendingStopValue--;
          if (Q.repeatDelay > 0 && !Q.pendingRepeat)
            Q.pendingRepeat = true, Q.accumulator -= Q.nextTick, Q.nextTick += Q.repeatDelay;
          else {
            if (Q.repeatCounter--, Q.forward)
              Q.setCurrentFrame(Q.currentFrame.nextFrame);
            else
              Q.setCurrentFrame(Q.currentFrame.prevFrame);
            if (Q.isPlaying)
              this.getNextTick(Q), Q.handleRepeat();
          }
        }, toJSON: function() {
          var Q = { key: this.key, type: this.type, frames: [], frameRate: this.frameRate, duration: this.duration, skipMissedFrames: this.skipMissedFrames, delay: this.delay, repeat: this.repeat, repeatDelay: this.repeatDelay, yoyo: this.yoyo, showBeforeDelay: this.showBeforeDelay, showOnStart: this.showOnStart, randomFrame: this.randomFrame, hideOnComplete: this.hideOnComplete };
          return this.frames.forEach(function(H) {
            Q.frames.push(H.toJSON());
          }), Q;
        }, updateFrameSequence: function() {
          var Q = this.frames.length, H = 1 / (Q - 1), N;
          for (var W = 0;W < Q; W++)
            if (N = this.frames[W], N.index = W + 1, N.isFirst = false, N.isLast = false, N.progress = W * H, W === 0)
              if (N.isFirst = true, Q === 1)
                N.isLast = true, N.nextFrame = N, N.prevFrame = N;
              else
                N.isLast = false, N.prevFrame = this.frames[Q - 1], N.nextFrame = this.frames[W + 1];
            else if (W === Q - 1 && Q > 1)
              N.isLast = true, N.prevFrame = this.frames[Q - 2], N.nextFrame = this.frames[0];
            else if (Q > 1)
              N.prevFrame = this.frames[W - 1], N.nextFrame = this.frames[W + 1];
          return this;
        }, pause: function() {
          return this.paused = true, this;
        }, resume: function() {
          return this.paused = false, this;
        }, destroy: function() {
          if (this.manager.off)
            this.manager.off(z.PAUSE_ALL, this.pause, this), this.manager.off(z.RESUME_ALL, this.resume, this);
          this.manager.remove(this.key);
          for (var Q = 0;Q < this.frames.length; Q++)
            this.frames[Q].destroy();
          this.frames = [], this.manager = null;
        } });
        M.exports = D;
      }, 41138: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U, K, J, Z, D) {
          if (D === undefined)
            D = false;
          this.textureKey = U, this.textureFrame = K, this.index = J, this.frame = Z, this.isFirst = false, this.isLast = false, this.prevFrame = null, this.nextFrame = null, this.duration = 0, this.progress = 0, this.isKeyFrame = D;
        }, toJSON: function() {
          return { key: this.textureKey, frame: this.textureFrame, duration: this.duration, keyframe: this.isKeyFrame };
        }, destroy: function() {
          this.frame = undefined;
        } });
        M.exports = L;
      }, 60848: (M, B, $) => {
        var E = $(42099), L = $(83419), z = $(90330), U = $(50792), K = $(74943), J = $(8443), Z = $(95540), D = $(35154), Q = $(36383), H = $(20283), N = $(41836), W = new L({ Extends: U, initialize: function R(Y) {
          U.call(this), this.game = Y, this.textureManager = null, this.globalTimeScale = 1, this.anims = new z, this.mixes = new z, this.paused = false, this.name = "AnimationManager", Y.events.once(J.BOOT, this.boot, this);
        }, boot: function() {
          this.textureManager = this.game.textures, this.game.events.once(J.DESTROY, this.destroy, this);
        }, addMix: function(R, Y, I) {
          var P = this.anims, X = this.mixes, G = typeof R === "string" ? R : R.key, V = typeof Y === "string" ? Y : Y.key;
          if (P.has(G) && P.has(V)) {
            var A = X.get(G);
            if (!A)
              A = {};
            A[V] = I, X.set(G, A);
          }
          return this;
        }, removeMix: function(R, Y) {
          var I = this.mixes, P = typeof R === "string" ? R : R.key, X = I.get(P);
          if (X) {
            if (Y) {
              var G = typeof Y === "string" ? Y : Y.key;
              if (X.hasOwnProperty(G))
                delete X[G];
            } else if (!Y)
              I.delete(P);
          }
          return this;
        }, getMix: function(R, Y) {
          var I = this.mixes, P = typeof R === "string" ? R : R.key, X = typeof Y === "string" ? Y : Y.key, G = I.get(P);
          if (G && G.hasOwnProperty(X))
            return G[X];
          else
            return 0;
        }, add: function(R, Y) {
          if (this.anims.has(R))
            return console.warn("Animation key exists: " + R), this;
          return Y.key = R, this.anims.set(R, Y), this.emit(K.ADD_ANIMATION, R, Y), this;
        }, exists: function(R) {
          return this.anims.has(R);
        }, createFromAseprite: function(R, Y, I) {
          var P = [], X = this.game.cache.json.get(R);
          if (!X)
            return console.warn("No Aseprite data found for: " + R), P;
          var G = this, V = D(X, "meta", null), A = D(X, "frames", null);
          if (V && A) {
            var F = D(V, "frameTags", []);
            F.forEach(function(j) {
              var T = [], C = Z(j, "name", null), v = Z(j, "from", 0), O = Z(j, "to", 0), q = Z(j, "direction", "forward");
              if (!C)
                return;
              if (!Y || Y && Y.indexOf(C) > -1) {
                var w = 0;
                for (var g = v;g <= O; g++) {
                  var b = g.toString(), x = A[b];
                  if (x) {
                    var k = Z(x, "duration", Q.MAX_SAFE_INTEGER);
                    T.push({ key: R, frame: b, duration: k }), w += k;
                  }
                }
                if (q === "reverse")
                  T = T.reverse();
                var S = { key: C, frames: T, duration: w, yoyo: q === "pingpong" }, f;
                if (I) {
                  if (I.anims)
                    f = I.anims.create(S);
                } else
                  f = G.create(S);
                if (f)
                  P.push(f);
              }
            });
          }
          return P;
        }, create: function(R) {
          var Y = R.key, I = false;
          if (Y)
            if (I = this.get(Y), !I)
              I = new E(this, Y, R), this.anims.set(Y, I), this.emit(K.ADD_ANIMATION, Y, I);
            else
              console.warn("AnimationManager key already exists: " + Y);
          return I;
        }, fromJSON: function(R, Y) {
          if (Y === undefined)
            Y = false;
          if (Y)
            this.anims.clear();
          if (typeof R === "string")
            R = JSON.parse(R);
          var I = [];
          if (R.hasOwnProperty("anims") && Array.isArray(R.anims)) {
            for (var P = 0;P < R.anims.length; P++)
              I.push(this.create(R.anims[P]));
            if (R.hasOwnProperty("globalTimeScale"))
              this.globalTimeScale = R.globalTimeScale;
          } else if (R.hasOwnProperty("key") && R.type === "frame")
            I.push(this.create(R));
          return I;
        }, generateFrameNames: function(R, Y) {
          var I = D(Y, "prefix", ""), P = D(Y, "start", 0), X = D(Y, "end", 0), G = D(Y, "suffix", ""), V = D(Y, "zeroPad", 0), A = D(Y, "outputArray", []), F = D(Y, "frames", false);
          if (!this.textureManager.exists(R))
            return console.warn('Texture "%s" not found', R), A;
          var j = this.textureManager.get(R);
          if (!j)
            return A;
          var T;
          if (!Y) {
            F = j.getFrameNames();
            for (T = 0;T < F.length; T++)
              A.push({ key: R, frame: F[T] });
          } else {
            if (!F)
              F = H(P, X);
            for (T = 0;T < F.length; T++) {
              var C = I + N(F[T], V, "0", 1) + G;
              if (j.has(C))
                A.push({ key: R, frame: C });
              else
                console.warn('Frame "%s" not found in texture "%s"', C, R);
            }
          }
          return A;
        }, generateFrameNumbers: function(R, Y) {
          var I = D(Y, "start", 0), P = D(Y, "end", -1), X = D(Y, "first", false), G = D(Y, "outputArray", []), V = D(Y, "frames", false);
          if (!this.textureManager.exists(R))
            return console.warn('Texture "%s" not found', R), G;
          var A = this.textureManager.get(R);
          if (!A)
            return G;
          if (X && A.has(X))
            G.push({ key: R, frame: X });
          if (!V) {
            if (P === -1)
              P = A.frameTotal - 2;
            V = H(I, P);
          }
          for (var F = 0;F < V.length; F++) {
            var j = V[F];
            if (A.has(j))
              G.push({ key: R, frame: j });
            else
              console.warn('Frame "%s" not found in texture "%s"', j, R);
          }
          return G;
        }, get: function(R) {
          return this.anims.get(R);
        }, getAnimsFromTexture: function(R) {
          var Y = this.textureManager.get(R), I = Y.key, P = this.anims.getArray(), X = [];
          for (var G = 0;G < P.length; G++) {
            var V = P[G], A = V.frames;
            for (var F = 0;F < A.length; F++)
              if (A[F].textureKey === I) {
                X.push(V.key);
                break;
              }
          }
          return X;
        }, pauseAll: function() {
          if (!this.paused)
            this.paused = true, this.emit(K.PAUSE_ALL);
          return this;
        }, play: function(R, Y) {
          if (!Array.isArray(Y))
            Y = [Y];
          for (var I = 0;I < Y.length; I++)
            Y[I].anims.play(R);
          return this;
        }, staggerPlay: function(R, Y, I, P) {
          if (I === undefined)
            I = 0;
          if (P === undefined)
            P = true;
          if (!Array.isArray(Y))
            Y = [Y];
          var X = Y.length;
          if (!P)
            X--;
          for (var G = 0;G < Y.length; G++) {
            var V = I < 0 ? Math.abs(I) * (X - G) : I * G;
            Y[G].anims.playAfterDelay(R, V);
          }
          return this;
        }, remove: function(R) {
          var Y = this.get(R);
          if (Y)
            this.emit(K.REMOVE_ANIMATION, R, Y), this.anims.delete(R), this.removeMix(R);
          return Y;
        }, resumeAll: function() {
          if (this.paused)
            this.paused = false, this.emit(K.RESUME_ALL);
          return this;
        }, toJSON: function(R) {
          var Y = { anims: [], globalTimeScale: this.globalTimeScale };
          if (R !== undefined && R !== "")
            Y.anims.push(this.anims.get(R).toJSON());
          else
            this.anims.each(function(I, P) {
              Y.anims.push(P.toJSON());
            });
          return Y;
        }, destroy: function() {
          this.anims.clear(), this.mixes.clear(), this.textureManager = null, this.game = null;
        } });
        M.exports = W;
      }, 9674: (M, B, $) => {
        var E = $(42099), L = $(30976), z = $(83419), U = $(90330), K = $(74943), J = $(95540), Z = new z({ initialize: function D(Q) {
          this.parent = Q, this.animationManager = Q.scene.sys.anims, this.animationManager.on(K.REMOVE_ANIMATION, this.globalRemove, this), this.textureManager = this.animationManager.textureManager, this.anims = null, this.isPlaying = false, this.hasStarted = false, this.currentAnim = null, this.currentFrame = null, this.nextAnim = null, this.nextAnimsQueue = [], this.timeScale = 1, this.frameRate = 0, this.duration = 0, this.msPerFrame = 0, this.skipMissedFrames = true, this.randomFrame = false, this.delay = 0, this.repeat = 0, this.repeatDelay = 0, this.yoyo = false, this.showBeforeDelay = false, this.showOnStart = false, this.hideOnComplete = false, this.forward = true, this.inReverse = false, this.accumulator = 0, this.nextTick = 0, this.delayCounter = 0, this.repeatCounter = 0, this.pendingRepeat = false, this._paused = false, this._wasPlaying = false, this._pendingStop = 0, this._pendingStopValue;
        }, chain: function(D) {
          var Q = this.parent;
          if (D === undefined)
            return this.nextAnimsQueue.length = 0, this.nextAnim = null, Q;
          if (!Array.isArray(D))
            D = [D];
          for (var H = 0;H < D.length; H++) {
            var N = D[H];
            if (!this.nextAnim)
              this.nextAnim = N;
            else
              this.nextAnimsQueue.push(N);
          }
          return this.parent;
        }, getName: function() {
          return this.currentAnim ? this.currentAnim.key : "";
        }, getFrameName: function() {
          return this.currentFrame ? this.currentFrame.textureFrame : "";
        }, load: function(D) {
          if (this.isPlaying)
            this.stop();
          var Q = this.animationManager, H = typeof D === "string" ? D : J(D, "key", null), N = this.exists(H) ? this.get(H) : Q.get(H);
          if (!N)
            console.warn("Missing animation: " + H);
          else {
            this.currentAnim = N;
            var W = N.getTotalFrames(), R = J(D, "frameRate", N.frameRate), Y = J(D, "duration", N.duration);
            N.calculateDuration(this, W, Y, R), this.delay = J(D, "delay", N.delay), this.repeat = J(D, "repeat", N.repeat), this.repeatDelay = J(D, "repeatDelay", N.repeatDelay), this.yoyo = J(D, "yoyo", N.yoyo), this.showBeforeDelay = J(D, "showBeforeDelay", N.showBeforeDelay), this.showOnStart = J(D, "showOnStart", N.showOnStart), this.hideOnComplete = J(D, "hideOnComplete", N.hideOnComplete), this.skipMissedFrames = J(D, "skipMissedFrames", N.skipMissedFrames), this.randomFrame = J(D, "randomFrame", N.randomFrame), this.timeScale = J(D, "timeScale", this.timeScale);
            var I = J(D, "startFrame", 0);
            if (I > W)
              I = 0;
            if (this.randomFrame)
              I = L(0, W - 1);
            var P = N.frames[I];
            if (I === 0 && !this.forward)
              P = N.getLastFrame();
            this.currentFrame = P;
          }
          return this.parent;
        }, pause: function(D) {
          if (!this._paused)
            this._paused = true, this._wasPlaying = this.isPlaying, this.isPlaying = false;
          if (D !== undefined)
            this.setCurrentFrame(D);
          return this.parent;
        }, resume: function(D) {
          if (this._paused)
            this._paused = false, this.isPlaying = this._wasPlaying;
          if (D !== undefined)
            this.setCurrentFrame(D);
          return this.parent;
        }, playAfterDelay: function(D, Q) {
          if (!this.isPlaying)
            this.delayCounter = Q, this.play(D, true);
          else {
            var H = this.nextAnim, N = this.nextAnimsQueue;
            if (H)
              N.unshift(H);
            this.nextAnim = D, this._pendingStop = 1, this._pendingStopValue = Q;
          }
          return this.parent;
        }, playAfterRepeat: function(D, Q) {
          if (Q === undefined)
            Q = 1;
          if (!this.isPlaying)
            this.play(D);
          else {
            var H = this.nextAnim, N = this.nextAnimsQueue;
            if (H)
              N.unshift(H);
            if (this.repeatCounter !== -1 && Q > this.repeatCounter)
              Q = this.repeatCounter;
            this.nextAnim = D, this._pendingStop = 2, this._pendingStopValue = Q;
          }
          return this.parent;
        }, play: function(D, Q) {
          if (Q === undefined)
            Q = false;
          var H = this.currentAnim, N = this.parent, W = typeof D === "string" ? D : D.key;
          if (Q && this.isPlaying && H.key === W)
            return N;
          if (H && this.isPlaying) {
            var R = this.animationManager.getMix(H.key, D);
            if (R > 0)
              return this.playAfterDelay(D, R);
          }
          return this.forward = true, this.inReverse = false, this._paused = false, this._wasPlaying = true, this.startAnimation(D);
        }, playReverse: function(D, Q) {
          if (Q === undefined)
            Q = false;
          var H = typeof D === "string" ? D : D.key;
          if (Q && this.isPlaying && this.currentAnim.key === H)
            return this.parent;
          return this.forward = false, this.inReverse = true, this._paused = false, this._wasPlaying = true, this.startAnimation(D);
        }, startAnimation: function(D) {
          this.load(D);
          var Q = this.currentAnim, H = this.parent;
          if (!Q)
            return H;
          if (this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat, Q.getFirstTick(this), this.isPlaying = true, this.pendingRepeat = false, this.hasStarted = false, this._pendingStop = 0, this._pendingStopValue = 0, this._paused = false, this.delayCounter += this.delay, this.delayCounter === 0)
            this.handleStart();
          else if (this.showBeforeDelay)
            this.setCurrentFrame(this.currentFrame);
          return H;
        }, handleStart: function() {
          if (this.showOnStart)
            this.parent.setVisible(true);
          this.setCurrentFrame(this.currentFrame), this.hasStarted = true, this.emitEvents(K.ANIMATION_START);
        }, handleRepeat: function() {
          this.pendingRepeat = false, this.emitEvents(K.ANIMATION_REPEAT);
        }, handleStop: function() {
          this._pendingStop = 0, this.isPlaying = false, this.emitEvents(K.ANIMATION_STOP);
        }, handleComplete: function() {
          if (this._pendingStop = 0, this.isPlaying = false, this.hideOnComplete)
            this.parent.setVisible(false);
          this.emitEvents(K.ANIMATION_COMPLETE, K.ANIMATION_COMPLETE_KEY);
        }, emitEvents: function(D, Q) {
          var H = this.currentAnim;
          if (H) {
            var N = this.currentFrame, W = this.parent, R = N.textureFrame;
            if (W.emit(D, H, N, W, R), Q)
              W.emit(Q + H.key, H, N, W, R);
          }
        }, reverse: function() {
          if (this.isPlaying)
            this.inReverse = !this.inReverse, this.forward = !this.forward;
          return this.parent;
        }, getProgress: function() {
          var D = this.currentFrame;
          if (!D)
            return 0;
          var Q = D.progress;
          if (this.inReverse)
            Q *= -1;
          return Q;
        }, setProgress: function(D) {
          if (!this.forward)
            D = 1 - D;
          return this.setCurrentFrame(this.currentAnim.getFrameByProgress(D)), this.parent;
        }, setRepeat: function(D) {
          return this.repeatCounter = D === -1 ? Number.MAX_VALUE : D, this.parent;
        }, globalRemove: function(D, Q) {
          if (Q === undefined)
            Q = this.currentAnim;
          if (this.isPlaying && Q.key === this.currentAnim.key)
            this.stop(), this.setCurrentFrame(this.currentAnim.frames[0]);
        }, restart: function(D, Q) {
          if (D === undefined)
            D = false;
          if (Q === undefined)
            Q = false;
          var H = this.currentAnim, N = this.parent;
          if (!H)
            return N;
          if (Q)
            this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat;
          return H.getFirstTick(this), this.emitEvents(K.ANIMATION_RESTART), this.isPlaying = true, this.pendingRepeat = false, this.hasStarted = !D, this._pendingStop = 0, this._pendingStopValue = 0, this._paused = false, this.setCurrentFrame(H.frames[0]), this.parent;
        }, complete: function() {
          if (this._pendingStop = 0, this.isPlaying = false, this.currentAnim)
            this.handleComplete();
          if (this.nextAnim) {
            var D = this.nextAnim;
            this.nextAnim = this.nextAnimsQueue.length > 0 ? this.nextAnimsQueue.shift() : null, this.play(D);
          }
          return this.parent;
        }, stop: function() {
          if (this._pendingStop = 0, this.isPlaying = false, this.delayCounter = 0, this.currentAnim)
            this.handleStop();
          if (this.nextAnim) {
            var D = this.nextAnim;
            this.nextAnim = this.nextAnimsQueue.shift(), this.play(D);
          }
          return this.parent;
        }, stopAfterDelay: function(D) {
          return this._pendingStop = 1, this._pendingStopValue = D, this.parent;
        }, stopAfterRepeat: function(D) {
          if (D === undefined)
            D = 1;
          if (this.repeatCounter !== -1 && D > this.repeatCounter)
            D = this.repeatCounter;
          return this._pendingStop = 2, this._pendingStopValue = D, this.parent;
        }, stopOnFrame: function(D) {
          return this._pendingStop = 3, this._pendingStopValue = D, this.parent;
        }, getTotalFrames: function() {
          return this.currentAnim ? this.currentAnim.getTotalFrames() : 0;
        }, update: function(D, Q) {
          var H = this.currentAnim;
          if (!this.isPlaying || !H || H.paused)
            return;
          if (this.accumulator += Q * this.timeScale * this.animationManager.globalTimeScale, this._pendingStop === 1) {
            if (this._pendingStopValue -= Q, this._pendingStopValue <= 0)
              return this.stop();
          }
          if (!this.hasStarted) {
            if (this.accumulator >= this.delayCounter)
              this.accumulator -= this.delayCounter, this.handleStart();
          } else if (this.accumulator >= this.nextTick) {
            if (this.forward)
              H.nextFrame(this);
            else
              H.previousFrame(this);
            if (this.isPlaying && this._pendingStop === 0 && this.skipMissedFrames && this.accumulator > this.nextTick) {
              var N = 0;
              do {
                if (this.forward)
                  H.nextFrame(this);
                else
                  H.previousFrame(this);
                N++;
              } while (this.isPlaying && this.accumulator > this.nextTick && N < 60);
            }
          }
        }, setCurrentFrame: function(D) {
          var Q = this.parent;
          if (this.currentFrame = D, Q.texture = D.frame.texture, Q.frame = D.frame, Q.isCropped)
            Q.frame.updateCropUVs(Q._crop, Q.flipX, Q.flipY);
          if (D.setAlpha)
            Q.alpha = D.alpha;
          if (Q.setSizeToFrame(), Q._originComponent)
            if (D.frame.customPivot)
              Q.setOrigin(D.frame.pivotX, D.frame.pivotY);
            else
              Q.updateDisplayOrigin();
          if (this.isPlaying && this.hasStarted) {
            if (this.emitEvents(K.ANIMATION_UPDATE), this._pendingStop === 3 && this._pendingStopValue === D)
              this.stop();
          }
          return Q;
        }, nextFrame: function() {
          if (this.currentAnim)
            this.currentAnim.nextFrame(this);
          return this.parent;
        }, previousFrame: function() {
          if (this.currentAnim)
            this.currentAnim.previousFrame(this);
          return this.parent;
        }, get: function(D) {
          return this.anims ? this.anims.get(D) : null;
        }, exists: function(D) {
          return this.anims ? this.anims.has(D) : false;
        }, create: function(D) {
          var Q = D.key, H = false;
          if (Q)
            if (H = this.get(Q), !H) {
              if (H = new E(this, Q, D), !this.anims)
                this.anims = new U;
              this.anims.set(Q, H);
            } else
              console.warn("Animation key already exists: " + Q);
          return H;
        }, createFromAseprite: function(D, Q) {
          return this.animationManager.createFromAseprite(D, Q, this.parent);
        }, generateFrameNames: function(D, Q) {
          return this.animationManager.generateFrameNames(D, Q);
        }, generateFrameNumbers: function(D, Q) {
          return this.animationManager.generateFrameNumbers(D, Q);
        }, remove: function(D) {
          var Q = this.get(D);
          if (Q) {
            if (this.currentAnim === Q)
              this.stop();
            this.anims.delete(D);
          }
          return Q;
        }, destroy: function() {
          if (this.animationManager.off(K.REMOVE_ANIMATION, this.globalRemove, this), this.anims)
            this.anims.clear();
          this.animationManager = null, this.parent = null, this.nextAnim = null, this.nextAnimsQueue.length = 0, this.currentAnim = null, this.currentFrame = null;
        }, isPaused: { get: function() {
          return this._paused;
        } } });
        M.exports = Z;
      }, 57090: (M) => {
        M.exports = "add";
      }, 25312: (M) => {
        M.exports = "animationcomplete";
      }, 89580: (M) => {
        M.exports = "animationcomplete-";
      }, 52860: (M) => {
        M.exports = "animationrepeat";
      }, 63850: (M) => {
        M.exports = "animationrestart";
      }, 99085: (M) => {
        M.exports = "animationstart";
      }, 28087: (M) => {
        M.exports = "animationstop";
      }, 1794: (M) => {
        M.exports = "animationupdate";
      }, 52562: (M) => {
        M.exports = "pauseall";
      }, 57953: (M) => {
        M.exports = "remove";
      }, 68339: (M) => {
        M.exports = "resumeall";
      }, 74943: (M, B, $) => {
        M.exports = { ADD_ANIMATION: $(57090), ANIMATION_COMPLETE: $(25312), ANIMATION_COMPLETE_KEY: $(89580), ANIMATION_REPEAT: $(52860), ANIMATION_RESTART: $(63850), ANIMATION_START: $(99085), ANIMATION_STOP: $(28087), ANIMATION_UPDATE: $(1794), PAUSE_ALL: $(52562), REMOVE_ANIMATION: $(57953), RESUME_ALL: $(68339) };
      }, 60421: (M, B, $) => {
        M.exports = { Animation: $(42099), AnimationFrame: $(41138), AnimationManager: $(60848), AnimationState: $(9674), Events: $(74943) };
      }, 2161: (M, B, $) => {
        var E = $(83419), L = $(90330), z = $(50792), U = $(24736), K = new E({ initialize: function J() {
          this.entries = new L, this.events = new z;
        }, add: function(J, Z) {
          return this.entries.set(J, Z), this.events.emit(U.ADD, this, J, Z), this;
        }, has: function(J) {
          return this.entries.has(J);
        }, exists: function(J) {
          return this.entries.has(J);
        }, get: function(J) {
          return this.entries.get(J);
        }, remove: function(J) {
          var Z = this.get(J);
          if (Z)
            this.entries.delete(J), this.events.emit(U.REMOVE, this, J, Z.data);
          return this;
        }, getKeys: function() {
          return this.entries.keys();
        }, destroy: function() {
          this.entries.clear(), this.events.removeAllListeners(), this.entries = null, this.events = null;
        } });
        M.exports = K;
      }, 24047: (M, B, $) => {
        var E = $(2161), L = $(83419), z = $(8443), U = new L({ initialize: function K(J) {
          this.game = J, this.binary = new E, this.bitmapFont = new E, this.json = new E, this.physics = new E, this.shader = new E, this.audio = new E, this.video = new E, this.text = new E, this.html = new E, this.obj = new E, this.tilemap = new E, this.xml = new E, this.custom = {}, this.game.events.once(z.DESTROY, this.destroy, this);
        }, addCustom: function(K) {
          if (!this.custom.hasOwnProperty(K))
            this.custom[K] = new E;
          return this.custom[K];
        }, destroy: function() {
          var K = ["binary", "bitmapFont", "json", "physics", "shader", "audio", "video", "text", "html", "obj", "tilemap", "xml"];
          for (var J = 0;J < K.length; J++)
            this[K[J]].destroy(), this[K[J]] = null;
          for (var Z in this.custom)
            this.custom[Z].destroy();
          this.custom = null, this.game = null;
        } });
        M.exports = U;
      }, 51464: (M) => {
        M.exports = "add";
      }, 59261: (M) => {
        M.exports = "remove";
      }, 24736: (M, B, $) => {
        M.exports = { ADD: $(51464), REMOVE: $(59261) };
      }, 83388: (M, B, $) => {
        M.exports = { BaseCache: $(2161), CacheManager: $(24047), Events: $(24736) };
      }, 71911: (M, B, $) => {
        var E = $(83419), L = $(31401), z = $(39506), U = $(50792), K = $(19715), J = $(87841), Z = $(61340), D = $(80333), Q = $(26099), H = new E({ Extends: U, Mixins: [L.AlphaSingle, L.Visible], initialize: function N(W, R, Y, I) {
          if (W === undefined)
            W = 0;
          if (R === undefined)
            R = 0;
          if (Y === undefined)
            Y = 0;
          if (I === undefined)
            I = 0;
          U.call(this), this.scene, this.sceneManager, this.scaleManager, this.cameraManager, this.id = 0, this.name = "", this.roundPixels = false, this.useBounds = false, this.worldView = new J, this.dirty = true, this._x = W, this._y = R, this._width = Y, this._height = I, this._bounds = new J, this._scrollX = 0, this._scrollY = 0, this._zoomX = 1, this._zoomY = 1, this._rotation = 0, this.matrix = new Z, this.transparent = true, this.backgroundColor = D("rgba(0,0,0,0)"), this.disableCull = false, this.culledObjects = [], this.midPoint = new Q(Y / 2, I / 2), this.originX = 0.5, this.originY = 0.5, this._customViewport = false, this.mask = null, this._maskCamera = null, this.renderList = [], this.isSceneCamera = true;
        }, addToRenderList: function(N) {
          this.renderList.push(N);
        }, setOrigin: function(N, W) {
          if (N === undefined)
            N = 0.5;
          if (W === undefined)
            W = N;
          return this.originX = N, this.originY = W, this;
        }, getScroll: function(N, W, R) {
          if (R === undefined)
            R = new Q;
          var Y = this.width * 0.5, I = this.height * 0.5;
          if (R.x = N - Y, R.y = W - I, this.useBounds)
            R.x = this.clampX(R.x), R.y = this.clampY(R.y);
          return R;
        }, centerOnX: function(N) {
          var W = this.width * 0.5;
          if (this.midPoint.x = N, this.scrollX = N - W, this.useBounds)
            this.scrollX = this.clampX(this.scrollX);
          return this;
        }, centerOnY: function(N) {
          var W = this.height * 0.5;
          if (this.midPoint.y = N, this.scrollY = N - W, this.useBounds)
            this.scrollY = this.clampY(this.scrollY);
          return this;
        }, centerOn: function(N, W) {
          return this.centerOnX(N), this.centerOnY(W), this;
        }, centerToBounds: function() {
          if (this.useBounds) {
            var N = this._bounds, W = this.width * 0.5, R = this.height * 0.5;
            this.midPoint.set(N.centerX, N.centerY), this.scrollX = N.centerX - W, this.scrollY = N.centerY - R;
          }
          return this;
        }, centerToSize: function() {
          return this.scrollX = this.width * 0.5, this.scrollY = this.height * 0.5, this;
        }, cull: function(N) {
          if (this.disableCull)
            return N;
          var W = this.matrix.matrix, R = W[0], Y = W[1], I = W[2], P = W[3], X = R * P - Y * I;
          if (!X)
            return N;
          var G = W[4], V = W[5], A = this.scrollX, F = this.scrollY, j = this.width, T = this.height, C = this.y, v = C + T, O = this.x, q = O + j, w = this.culledObjects, g = N.length;
          X = 1 / X, w.length = 0;
          for (var b = 0;b < g; ++b) {
            var x = N[b];
            if (!x.hasOwnProperty("width") || x.parentContainer) {
              w.push(x);
              continue;
            }
            var { width: k, height: S } = x, f = x.x - A * x.scrollFactorX - k * x.originX, h = x.y - F * x.scrollFactorY - S * x.originY, m = f * R + h * I + G, y = f * Y + h * P + V, d = (f + k) * R + (h + S) * I + G, p = (f + k) * Y + (h + S) * P + V;
            if (d > O && m < q && (p > C && y < v))
              w.push(x);
          }
          return w;
        }, getWorldPoint: function(N, W, R) {
          if (R === undefined)
            R = new Q;
          var Y = this.matrix.matrix, I = Y[0], P = Y[1], X = Y[2], G = Y[3], V = Y[4], A = Y[5], F = I * G - P * X;
          if (!F)
            return R.x = N, R.y = W, R;
          F = 1 / F;
          var j = G * F, T = -P * F, C = -X * F, v = I * F, O = (X * A - G * V) * F, q = (P * V - I * A) * F, w = Math.cos(this.rotation), g = Math.sin(this.rotation), b = this.zoomX, x = this.zoomY, k = this.scrollX, S = this.scrollY, f = N + (k * w - S * g) * b, h = W + (k * g + S * w) * x;
          return R.x = f * j + h * C + O, R.y = f * T + h * v + q, R;
        }, ignore: function(N) {
          var W = this.id;
          if (!Array.isArray(N))
            N = [N];
          for (var R = 0;R < N.length; R++) {
            var Y = N[R];
            if (Array.isArray(Y))
              this.ignore(Y);
            else if (Y.isParent)
              this.ignore(Y.getChildren());
            else
              Y.cameraFilter |= W;
          }
          return this;
        }, preRender: function() {
          this.renderList.length = 0;
          var N = this.width, W = this.height, R = N * 0.5, Y = W * 0.5, I = this.zoomX, P = this.zoomY, X = this.matrix, G = N * this.originX, V = W * this.originY, A = this.scrollX, F = this.scrollY;
          if (this.useBounds)
            A = this.clampX(A), F = this.clampY(F);
          this.scrollX = A, this.scrollY = F;
          var j = A + R, T = F + Y;
          this.midPoint.set(j, T);
          var C = N / I, v = W / P;
          this.worldView.setTo(j - C / 2, T - v / 2, C, v), X.applyITRS(this.x + G, this.y + V, this.rotation, I, P), X.translate(-G, -V);
        }, clampX: function(N) {
          var W = this._bounds, R = this.displayWidth, Y = W.x + (R - this.width) / 2, I = Math.max(Y, Y + W.width - R);
          if (N < Y)
            N = Y;
          else if (N > I)
            N = I;
          return N;
        }, clampY: function(N) {
          var W = this._bounds, R = this.displayHeight, Y = W.y + (R - this.height) / 2, I = Math.max(Y, Y + W.height - R);
          if (N < Y)
            N = Y;
          else if (N > I)
            N = I;
          return N;
        }, removeBounds: function() {
          return this.useBounds = false, this.dirty = true, this._bounds.setEmpty(), this;
        }, setAngle: function(N) {
          if (N === undefined)
            N = 0;
          return this.rotation = z(N), this;
        }, setBackgroundColor: function(N) {
          if (N === undefined)
            N = "rgba(0,0,0,0)";
          return this.backgroundColor = D(N), this.transparent = this.backgroundColor.alpha === 0, this;
        }, setBounds: function(N, W, R, Y, I) {
          if (I === undefined)
            I = false;
          if (this._bounds.setTo(N, W, R, Y), this.dirty = true, this.useBounds = true, I)
            this.centerToBounds();
          else
            this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY);
          return this;
        }, getBounds: function(N) {
          if (N === undefined)
            N = new J;
          var W = this._bounds;
          return N.setTo(W.x, W.y, W.width, W.height), N;
        }, setName: function(N) {
          if (N === undefined)
            N = "";
          return this.name = N, this;
        }, setPosition: function(N, W) {
          if (W === undefined)
            W = N;
          return this.x = N, this.y = W, this;
        }, setRotation: function(N) {
          if (N === undefined)
            N = 0;
          return this.rotation = N, this;
        }, setRoundPixels: function(N) {
          return this.roundPixels = N, this;
        }, setScene: function(N, W) {
          if (W === undefined)
            W = true;
          if (this.scene && this._customViewport)
            this.sceneManager.customViewports--;
          this.scene = N, this.isSceneCamera = W;
          var R = N.sys;
          return this.sceneManager = R.game.scene, this.scaleManager = R.scale, this.cameraManager = R.cameras, this.updateSystem(), this;
        }, setScroll: function(N, W) {
          if (W === undefined)
            W = N;
          return this.scrollX = N, this.scrollY = W, this;
        }, setSize: function(N, W) {
          if (W === undefined)
            W = N;
          return this.width = N, this.height = W, this;
        }, setViewport: function(N, W, R, Y) {
          return this.x = N, this.y = W, this.width = R, this.height = Y, this;
        }, setZoom: function(N, W) {
          if (N === undefined)
            N = 1;
          if (W === undefined)
            W = N;
          if (N === 0)
            N = 0.001;
          if (W === 0)
            W = 0.001;
          return this.zoomX = N, this.zoomY = W, this;
        }, setMask: function(N, W) {
          if (W === undefined)
            W = true;
          return this.mask = N, this._maskCamera = W ? this.cameraManager.default : this, this;
        }, clearMask: function(N) {
          if (N === undefined)
            N = false;
          if (N && this.mask)
            this.mask.destroy();
          return this.mask = null, this;
        }, toJSON: function() {
          var N = { name: this.name, x: this.x, y: this.y, width: this.width, height: this.height, zoom: this.zoom, rotation: this.rotation, roundPixels: this.roundPixels, scrollX: this.scrollX, scrollY: this.scrollY, backgroundColor: this.backgroundColor.rgba };
          if (this.useBounds)
            N.bounds = { x: this._bounds.x, y: this._bounds.y, width: this._bounds.width, height: this._bounds.height };
          return N;
        }, update: function() {
        }, setIsSceneCamera: function(N) {
          return this.isSceneCamera = N, this;
        }, updateSystem: function() {
          if (!this.scaleManager || !this.isSceneCamera)
            return;
          var N = this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height, W = this.sceneManager;
          if (N && !this._customViewport)
            W.customViewports++;
          else if (!N && this._customViewport)
            W.customViewports--;
          this.dirty = true, this._customViewport = N;
        }, destroy: function() {
          if (this.emit(K.DESTROY, this), this.removeAllListeners(), this.matrix.destroy(), this.culledObjects = [], this._customViewport)
            this.sceneManager.customViewports--;
          this.renderList = [], this._bounds = null, this.scene = null, this.scaleManager = null, this.sceneManager = null, this.cameraManager = null;
        }, x: { get: function() {
          return this._x;
        }, set: function(N) {
          this._x = N, this.updateSystem();
        } }, y: { get: function() {
          return this._y;
        }, set: function(N) {
          this._y = N, this.updateSystem();
        } }, width: { get: function() {
          return this._width;
        }, set: function(N) {
          this._width = N, this.updateSystem();
        } }, height: { get: function() {
          return this._height;
        }, set: function(N) {
          this._height = N, this.updateSystem();
        } }, scrollX: { get: function() {
          return this._scrollX;
        }, set: function(N) {
          if (N !== this._scrollX)
            this._scrollX = N, this.dirty = true;
        } }, scrollY: { get: function() {
          return this._scrollY;
        }, set: function(N) {
          if (N !== this._scrollY)
            this._scrollY = N, this.dirty = true;
        } }, zoom: { get: function() {
          return (this._zoomX + this._zoomY) / 2;
        }, set: function(N) {
          this._zoomX = N, this._zoomY = N, this.dirty = true;
        } }, zoomX: { get: function() {
          return this._zoomX;
        }, set: function(N) {
          this._zoomX = N, this.dirty = true;
        } }, zoomY: { get: function() {
          return this._zoomY;
        }, set: function(N) {
          this._zoomY = N, this.dirty = true;
        } }, rotation: { get: function() {
          return this._rotation;
        }, set: function(N) {
          this._rotation = N, this.dirty = true;
        } }, centerX: { get: function() {
          return this.x + 0.5 * this.width;
        } }, centerY: { get: function() {
          return this.y + 0.5 * this.height;
        } }, displayWidth: { get: function() {
          return this.width / this.zoomX;
        } }, displayHeight: { get: function() {
          return this.height / this.zoomY;
        } } });
        M.exports = H;
      }, 38058: (M, B, $) => {
        var E = $(71911), L = $(67502), z = $(45319), U = $(83419), K = $(31401), J = $(20052), Z = $(19715), D = $(28915), Q = $(87841), H = $(26099), N = new U({ Extends: E, Mixins: [K.PostPipeline], initialize: function W(R, Y, I, P) {
          E.call(this, R, Y, I, P), this.initPostPipeline(), this.inputEnabled = true, this.fadeEffect = new J.Fade(this), this.flashEffect = new J.Flash(this), this.shakeEffect = new J.Shake(this), this.panEffect = new J.Pan(this), this.rotateToEffect = new J.RotateTo(this), this.zoomEffect = new J.Zoom(this), this.lerp = new H(1, 1), this.followOffset = new H, this.deadzone = null, this._follow = null;
        }, setDeadzone: function(W, R) {
          if (W === undefined)
            this.deadzone = null;
          else {
            if (this.deadzone)
              this.deadzone.width = W, this.deadzone.height = R;
            else
              this.deadzone = new Q(0, 0, W, R);
            if (this._follow) {
              var Y = this.width / 2, I = this.height / 2, P = this._follow.x - this.followOffset.x, X = this._follow.y - this.followOffset.y;
              this.midPoint.set(P, X), this.scrollX = P - Y, this.scrollY = X - I;
            }
            L(this.deadzone, this.midPoint.x, this.midPoint.y);
          }
          return this;
        }, fadeIn: function(W, R, Y, I, P, X) {
          return this.fadeEffect.start(false, W, R, Y, I, true, P, X);
        }, fadeOut: function(W, R, Y, I, P, X) {
          return this.fadeEffect.start(true, W, R, Y, I, true, P, X);
        }, fadeFrom: function(W, R, Y, I, P, X, G) {
          return this.fadeEffect.start(false, W, R, Y, I, P, X, G);
        }, fade: function(W, R, Y, I, P, X, G) {
          return this.fadeEffect.start(true, W, R, Y, I, P, X, G);
        }, flash: function(W, R, Y, I, P, X, G) {
          return this.flashEffect.start(W, R, Y, I, P, X, G);
        }, shake: function(W, R, Y, I, P) {
          return this.shakeEffect.start(W, R, Y, I, P);
        }, pan: function(W, R, Y, I, P, X, G) {
          return this.panEffect.start(W, R, Y, I, P, X, G);
        }, rotateTo: function(W, R, Y, I, P, X, G) {
          return this.rotateToEffect.start(W, R, Y, I, P, X, G);
        }, zoomTo: function(W, R, Y, I, P, X) {
          return this.zoomEffect.start(W, R, Y, I, P, X);
        }, preRender: function() {
          this.renderList.length = 0;
          var W = this.width, R = this.height, Y = W * 0.5, I = R * 0.5, P = this.zoom, X = this.matrix, G = W * this.originX, V = R * this.originY, A = this._follow, F = this.deadzone, j = this.scrollX, T = this.scrollY;
          if (F)
            L(F, this.midPoint.x, this.midPoint.y);
          var C = false;
          if (A && !this.panEffect.isRunning) {
            var v = this.lerp, O = A.x - this.followOffset.x, q = A.y - this.followOffset.y;
            if (F) {
              if (O < F.x)
                j = D(j, j - (F.x - O), v.x);
              else if (O > F.right)
                j = D(j, j + (O - F.right), v.x);
              if (q < F.y)
                T = D(T, T - (F.y - q), v.y);
              else if (q > F.bottom)
                T = D(T, T + (q - F.bottom), v.y);
            } else
              j = D(j, O - G, v.x), T = D(T, q - V, v.y);
            C = true;
          }
          if (this.useBounds)
            j = this.clampX(j), T = this.clampY(T);
          this.scrollX = j, this.scrollY = T;
          var w = j + Y, g = T + I;
          this.midPoint.set(w, g);
          var b = W / P, x = R / P, k = Math.floor(w - b / 2), S = Math.floor(g - x / 2);
          if (this.worldView.setTo(k, S, b, x), X.applyITRS(Math.floor(this.x + G), Math.floor(this.y + V), this.rotation, P, P), X.translate(-G, -V), this.shakeEffect.preRender(), C)
            this.emit(Z.FOLLOW_UPDATE, this, A);
        }, setLerp: function(W, R) {
          if (W === undefined)
            W = 1;
          if (R === undefined)
            R = W;
          return this.lerp.set(W, R), this;
        }, setFollowOffset: function(W, R) {
          if (W === undefined)
            W = 0;
          if (R === undefined)
            R = 0;
          return this.followOffset.set(W, R), this;
        }, startFollow: function(W, R, Y, I, P, X) {
          if (R === undefined)
            R = false;
          if (Y === undefined)
            Y = 1;
          if (I === undefined)
            I = Y;
          if (P === undefined)
            P = 0;
          if (X === undefined)
            X = P;
          this._follow = W, this.roundPixels = R, Y = z(Y, 0, 1), I = z(I, 0, 1), this.lerp.set(Y, I), this.followOffset.set(P, X);
          var G = this.width / 2, V = this.height / 2, A = W.x - P, F = W.y - X;
          if (this.midPoint.set(A, F), this.scrollX = A - G, this.scrollY = F - V, this.useBounds)
            this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY);
          return this;
        }, stopFollow: function() {
          return this._follow = null, this;
        }, resetFX: function() {
          return this.rotateToEffect.reset(), this.panEffect.reset(), this.shakeEffect.reset(), this.flashEffect.reset(), this.fadeEffect.reset(), this;
        }, update: function(W, R) {
          if (this.visible)
            this.rotateToEffect.update(W, R), this.panEffect.update(W, R), this.zoomEffect.update(W, R), this.shakeEffect.update(W, R), this.flashEffect.update(W, R), this.fadeEffect.update(W, R);
        }, destroy: function() {
          this.resetFX(), E.prototype.destroy.call(this), this._follow = null, this.deadzone = null;
        } });
        M.exports = N;
      }, 32743: (M, B, $) => {
        var E = $(38058), L = $(83419), z = $(95540), U = $(37277), K = $(37303), J = $(97480), Z = $(44594), D = new L({ initialize: function Q(H) {
          this.scene = H, this.systems = H.sys, this.roundPixels = H.sys.game.config.roundPixels, this.cameras = [], this.main, this.default, H.sys.events.once(Z.BOOT, this.boot, this), H.sys.events.on(Z.START, this.start, this);
        }, boot: function() {
          var Q = this.systems;
          if (Q.settings.cameras)
            this.fromJSON(Q.settings.cameras);
          else
            this.add();
          this.main = this.cameras[0], this.default = new E(0, 0, Q.scale.width, Q.scale.height).setScene(this.scene), Q.game.scale.on(J.RESIZE, this.onResize, this), this.systems.events.once(Z.DESTROY, this.destroy, this);
        }, start: function() {
          if (!this.main) {
            var Q = this.systems;
            if (Q.settings.cameras)
              this.fromJSON(Q.settings.cameras);
            else
              this.add();
            this.main = this.cameras[0];
          }
          var H = this.systems.events;
          H.on(Z.UPDATE, this.update, this), H.once(Z.SHUTDOWN, this.shutdown, this);
        }, add: function(Q, H, N, W, R, Y) {
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = this.scene.sys.scale.width;
          if (W === undefined)
            W = this.scene.sys.scale.height;
          if (R === undefined)
            R = false;
          if (Y === undefined)
            Y = "";
          var I = new E(Q, H, N, W);
          if (I.setName(Y), I.setScene(this.scene), I.setRoundPixels(this.roundPixels), I.id = this.getNextID(), this.cameras.push(I), R)
            this.main = I;
          return I;
        }, addExisting: function(Q, H) {
          if (H === undefined)
            H = false;
          var N = this.cameras.indexOf(Q);
          if (N === -1) {
            if (Q.id = this.getNextID(), Q.setRoundPixels(this.roundPixels), this.cameras.push(Q), H)
              this.main = Q;
            return Q;
          }
          return null;
        }, getNextID: function() {
          var Q = this.cameras, H = 1;
          for (var N = 0;N < 32; N++) {
            var W = false;
            for (var R = 0;R < Q.length; R++) {
              var Y = Q[R];
              if (Y && Y.id === H) {
                W = true;
                continue;
              }
            }
            if (W)
              H = H << 1;
            else
              return H;
          }
          return 0;
        }, getTotal: function(Q) {
          if (Q === undefined)
            Q = false;
          var H = 0, N = this.cameras;
          for (var W = 0;W < N.length; W++) {
            var R = N[W];
            if (!Q || Q && R.visible)
              H++;
          }
          return H;
        }, fromJSON: function(Q) {
          if (!Array.isArray(Q))
            Q = [Q];
          var H = this.scene.sys.scale.width, N = this.scene.sys.scale.height;
          for (var W = 0;W < Q.length; W++) {
            var R = Q[W], Y = z(R, "x", 0), I = z(R, "y", 0), P = z(R, "width", H), X = z(R, "height", N), G = this.add(Y, I, P, X);
            G.name = z(R, "name", ""), G.zoom = z(R, "zoom", 1), G.rotation = z(R, "rotation", 0), G.scrollX = z(R, "scrollX", 0), G.scrollY = z(R, "scrollY", 0), G.roundPixels = z(R, "roundPixels", false), G.visible = z(R, "visible", true);
            var V = z(R, "backgroundColor", false);
            if (V)
              G.setBackgroundColor(V);
            var A = z(R, "bounds", null);
            if (A) {
              var F = z(A, "x", 0), j = z(A, "y", 0), T = z(A, "width", H), C = z(A, "height", N);
              G.setBounds(F, j, T, C);
            }
          }
          return this;
        }, getCamera: function(Q) {
          var H = this.cameras;
          for (var N = 0;N < H.length; N++)
            if (H[N].name === Q)
              return H[N];
          return null;
        }, getCamerasBelowPointer: function(Q) {
          var H = this.cameras, N = Q.x, W = Q.y, R = [];
          for (var Y = 0;Y < H.length; Y++) {
            var I = H[Y];
            if (I.visible && I.inputEnabled && K(I, N, W))
              R.unshift(I);
          }
          return R;
        }, remove: function(Q, H) {
          if (H === undefined)
            H = true;
          if (!Array.isArray(Q))
            Q = [Q];
          var N = 0, W = this.cameras;
          for (var R = 0;R < Q.length; R++) {
            var Y = W.indexOf(Q[R]);
            if (Y !== -1) {
              if (H)
                W[Y].destroy();
              else
                W[Y].renderList = [];
              W.splice(Y, 1), N++;
            }
          }
          if (!this.main && W[0])
            this.main = W[0];
          return N;
        }, render: function(Q, H) {
          var N = this.scene, W = this.cameras;
          for (var R = 0;R < W.length; R++) {
            var Y = W[R];
            if (Y.visible && Y.alpha > 0) {
              Y.preRender();
              var I = this.getVisibleChildren(H.getChildren(), Y);
              Q.render(N, I, Y);
            }
          }
        }, getVisibleChildren: function(Q, H) {
          return Q.filter(function(N) {
            return N.willRender(H);
          });
        }, resetAll: function() {
          for (var Q = 0;Q < this.cameras.length; Q++)
            this.cameras[Q].destroy();
          return this.cameras = [], this.main = this.add(), this.main;
        }, update: function(Q, H) {
          for (var N = 0;N < this.cameras.length; N++)
            this.cameras[N].update(Q, H);
        }, onResize: function(Q, H, N, W, R) {
          for (var Y = 0;Y < this.cameras.length; Y++) {
            var I = this.cameras[Y];
            if (I._x === 0 && I._y === 0 && I._width === W && I._height === R)
              I.setSize(H.width, H.height);
          }
        }, resize: function(Q, H) {
          for (var N = 0;N < this.cameras.length; N++)
            this.cameras[N].setSize(Q, H);
        }, shutdown: function() {
          this.main = undefined;
          for (var Q = 0;Q < this.cameras.length; Q++)
            this.cameras[Q].destroy();
          this.cameras = [];
          var H = this.systems.events;
          H.off(Z.UPDATE, this.update, this), H.off(Z.SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          this.shutdown(), this.default.destroy(), this.systems.events.off(Z.START, this.start, this), this.systems.events.off(Z.DESTROY, this.destroy, this), this.systems.game.scale.off(J.RESIZE, this.onResize, this), this.scene = null, this.systems = null;
        } });
        U.register("CameraManager", D, "cameras"), M.exports = D;
      }, 5020: (M, B, $) => {
        var E = $(45319), L = $(83419), z = $(19715), U = new L({ initialize: function K(J) {
          this.camera = J, this.isRunning = false, this.isComplete = false, this.direction = true, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope;
        }, start: function(K, J, Z, D, Q, H, N, W) {
          if (K === undefined)
            K = true;
          if (J === undefined)
            J = 1000;
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = false;
          if (N === undefined)
            N = null;
          if (W === undefined)
            W = this.camera.scene;
          if (!H && this.isRunning)
            return this.camera;
          this.isRunning = true, this.isComplete = false, this.duration = J, this.direction = K, this.progress = 0, this.red = Z, this.green = D, this.blue = Q, this.alpha = K ? Number.MIN_VALUE : 1, this._elapsed = 0, this._onUpdate = N, this._onUpdateScope = W;
          var R = K ? z.FADE_OUT_START : z.FADE_IN_START;
          return this.camera.emit(R, this.camera, this, J, Z, D, Q), this.camera;
        }, update: function(K, J) {
          if (!this.isRunning)
            return;
          if (this._elapsed += J, this.progress = E(this._elapsed / this.duration, 0, 1), this._onUpdate)
            this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
          if (this._elapsed < this.duration)
            this.alpha = this.direction ? this.progress : 1 - this.progress;
          else
            this.alpha = this.direction ? 1 : 0, this.effectComplete();
        }, postRenderCanvas: function(K) {
          if (!this.isRunning && !this.isComplete)
            return false;
          var J = this.camera;
          return K.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")", K.fillRect(J.x, J.y, J.width, J.height), true;
        }, postRenderWebGL: function(K, J) {
          if (!this.isRunning && !this.isComplete)
            return false;
          var Z = this.camera, D = this.red / 255, Q = this.green / 255, H = this.blue / 255;
          return K.drawFillRect(Z.x, Z.y, Z.width, Z.height, J(H, Q, D, 1), this.alpha), true;
        }, effectComplete: function() {
          this._onUpdate = null, this._onUpdateScope = null, this.isRunning = false, this.isComplete = true;
          var K = this.direction ? z.FADE_OUT_COMPLETE : z.FADE_IN_COMPLETE;
          this.camera.emit(K, this.camera, this);
        }, reset: function() {
          this.isRunning = false, this.isComplete = false, this._onUpdate = null, this._onUpdateScope = null;
        }, destroy: function() {
          this.reset(), this.camera = null;
        } });
        M.exports = U;
      }, 10662: (M, B, $) => {
        var E = $(45319), L = $(83419), z = $(19715), U = new L({ initialize: function K(J) {
          this.camera = J, this.isRunning = false, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 1, this.progress = 0, this._elapsed = 0, this._alpha, this._onUpdate, this._onUpdateScope;
        }, start: function(K, J, Z, D, Q, H, N) {
          if (K === undefined)
            K = 250;
          if (J === undefined)
            J = 255;
          if (Z === undefined)
            Z = 255;
          if (D === undefined)
            D = 255;
          if (Q === undefined)
            Q = false;
          if (H === undefined)
            H = null;
          if (N === undefined)
            N = this.camera.scene;
          if (!Q && this.isRunning)
            return this.camera;
          return this.isRunning = true, this.duration = K, this.progress = 0, this.red = J, this.green = Z, this.blue = D, this._alpha = this.alpha, this._elapsed = 0, this._onUpdate = H, this._onUpdateScope = N, this.camera.emit(z.FLASH_START, this.camera, this, K, J, Z, D), this.camera;
        }, update: function(K, J) {
          if (!this.isRunning)
            return;
          if (this._elapsed += J, this.progress = E(this._elapsed / this.duration, 0, 1), this._onUpdate)
            this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
          if (this._elapsed < this.duration)
            this.alpha = this._alpha * (1 - this.progress);
          else
            this.effectComplete();
        }, postRenderCanvas: function(K) {
          if (!this.isRunning)
            return false;
          var J = this.camera;
          return K.fillStyle = "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")", K.fillRect(J.x, J.y, J.width, J.height), true;
        }, postRenderWebGL: function(K, J) {
          if (!this.isRunning)
            return false;
          var Z = this.camera, D = this.red / 255, Q = this.green / 255, H = this.blue / 255;
          return K.drawFillRect(Z.x, Z.y, Z.width, Z.height, J(H, Q, D, 1), this.alpha), true;
        }, effectComplete: function() {
          this.alpha = this._alpha, this._onUpdate = null, this._onUpdateScope = null, this.isRunning = false, this.camera.emit(z.FLASH_COMPLETE, this.camera, this);
        }, reset: function() {
          this.isRunning = false, this._onUpdate = null, this._onUpdateScope = null;
        }, destroy: function() {
          this.reset(), this.camera = null;
        } });
        M.exports = U;
      }, 20359: (M, B, $) => {
        var E = $(45319), L = $(83419), z = $(62640), U = $(19715), K = $(26099), J = new L({ initialize: function Z(D) {
          this.camera = D, this.isRunning = false, this.duration = 0, this.source = new K, this.current = new K, this.destination = new K, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope;
        }, start: function(Z, D, Q, H, N, W, R) {
          if (Q === undefined)
            Q = 1000;
          if (H === undefined)
            H = z.Linear;
          if (N === undefined)
            N = false;
          if (W === undefined)
            W = null;
          if (R === undefined)
            R = this.camera.scene;
          var Y = this.camera;
          if (!N && this.isRunning)
            return Y;
          if (this.isRunning = true, this.duration = Q, this.progress = 0, this.source.set(Y.scrollX, Y.scrollY), this.destination.set(Z, D), Y.getScroll(Z, D, this.current), typeof H === "string" && z.hasOwnProperty(H))
            this.ease = z[H];
          else if (typeof H === "function")
            this.ease = H;
          return this._elapsed = 0, this._onUpdate = W, this._onUpdateScope = R, this.camera.emit(U.PAN_START, this.camera, this, Q, Z, D), Y;
        }, update: function(Z, D) {
          if (!this.isRunning)
            return;
          this._elapsed += D;
          var Q = E(this._elapsed / this.duration, 0, 1);
          this.progress = Q;
          var H = this.camera;
          if (this._elapsed < this.duration) {
            var N = this.ease(Q);
            H.getScroll(this.destination.x, this.destination.y, this.current);
            var W = this.source.x + (this.current.x - this.source.x) * N, R = this.source.y + (this.current.y - this.source.y) * N;
            if (H.setScroll(W, R), this._onUpdate)
              this._onUpdate.call(this._onUpdateScope, H, Q, W, R);
          } else {
            if (H.centerOn(this.destination.x, this.destination.y), this._onUpdate)
              this._onUpdate.call(this._onUpdateScope, H, Q, H.scrollX, H.scrollY);
            this.effectComplete();
          }
        }, effectComplete: function() {
          this._onUpdate = null, this._onUpdateScope = null, this.isRunning = false, this.camera.emit(U.PAN_COMPLETE, this.camera, this);
        }, reset: function() {
          this.isRunning = false, this._onUpdate = null, this._onUpdateScope = null;
        }, destroy: function() {
          this.reset(), this.camera = null, this.source = null, this.destination = null;
        } });
        M.exports = J;
      }, 34208: (M, B, $) => {
        var E = $(45319), L = $(83419), z = $(19715), U = $(62640), K = new L({ initialize: function J(Z) {
          this.camera = Z, this.isRunning = false, this.duration = 0, this.source = 0, this.current = 0, this.destination = 0, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope, this.clockwise = true, this.shortestPath = false;
        }, start: function(J, Z, D, Q, H, N, W) {
          if (D === undefined)
            D = 1000;
          if (Q === undefined)
            Q = U.Linear;
          if (H === undefined)
            H = false;
          if (N === undefined)
            N = null;
          if (W === undefined)
            W = this.camera.scene;
          if (Z === undefined)
            Z = false;
          this.shortestPath = Z;
          var R = J;
          if (J < 0)
            R = -1 * J, this.clockwise = false;
          else
            this.clockwise = true;
          var Y = 360 * Math.PI / 180;
          R = R - Math.floor(R / Y) * Y;
          var I = this.camera;
          if (!H && this.isRunning)
            return I;
          if (this.isRunning = true, this.duration = D, this.progress = 0, this.source = I.rotation, this.destination = R, typeof Q === "string" && U.hasOwnProperty(Q))
            this.ease = U[Q];
          else if (typeof Q === "function")
            this.ease = Q;
          if (this._elapsed = 0, this._onUpdate = N, this._onUpdateScope = W, this.shortestPath) {
            var P = 0, X = 0;
            if (this.destination > this.source)
              P = Math.abs(this.destination - this.source);
            else
              P = Math.abs(this.destination + Y) - this.source;
            if (this.source > this.destination)
              X = Math.abs(this.source - this.destination);
            else
              X = Math.abs(this.source + Y) - this.destination;
            if (P < X)
              this.clockwise = true;
            else if (P > X)
              this.clockwise = false;
          }
          return this.camera.emit(z.ROTATE_START, this.camera, this, D, R), I;
        }, update: function(J, Z) {
          if (!this.isRunning)
            return;
          this._elapsed += Z;
          var D = E(this._elapsed / this.duration, 0, 1);
          this.progress = D;
          var Q = this.camera;
          if (this._elapsed < this.duration) {
            var H = this.ease(D);
            this.current = Q.rotation;
            var N = 0, W = 360 * Math.PI / 180, R = this.destination, Y = this.current;
            if (this.clockwise === false)
              R = this.current, Y = this.destination;
            if (R >= Y)
              N = Math.abs(R - Y);
            else
              N = Math.abs(R + W) - Y;
            var I = 0;
            if (this.clockwise)
              I = Q.rotation + N * H;
            else
              I = Q.rotation - N * H;
            if (Q.rotation = I, this._onUpdate)
              this._onUpdate.call(this._onUpdateScope, Q, D, I);
          } else {
            if (Q.rotation = this.destination, this._onUpdate)
              this._onUpdate.call(this._onUpdateScope, Q, D, this.destination);
            this.effectComplete();
          }
        }, effectComplete: function() {
          this._onUpdate = null, this._onUpdateScope = null, this.isRunning = false, this.camera.emit(z.ROTATE_COMPLETE, this.camera, this);
        }, reset: function() {
          this.isRunning = false, this._onUpdate = null, this._onUpdateScope = null;
        }, destroy: function() {
          this.reset(), this.camera = null, this.source = null, this.destination = null;
        } });
        M.exports = K;
      }, 30330: (M, B, $) => {
        var E = $(45319), L = $(83419), z = $(19715), U = $(26099), K = new L({ initialize: function J(Z) {
          this.camera = Z, this.isRunning = false, this.duration = 0, this.intensity = new U, this.progress = 0, this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate, this._onUpdateScope;
        }, start: function(J, Z, D, Q, H) {
          if (J === undefined)
            J = 100;
          if (Z === undefined)
            Z = 0.05;
          if (D === undefined)
            D = false;
          if (Q === undefined)
            Q = null;
          if (H === undefined)
            H = this.camera.scene;
          if (!D && this.isRunning)
            return this.camera;
          if (this.isRunning = true, this.duration = J, this.progress = 0, typeof Z === "number")
            this.intensity.set(Z);
          else
            this.intensity.set(Z.x, Z.y);
          return this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate = Q, this._onUpdateScope = H, this.camera.emit(z.SHAKE_START, this.camera, this, J, Z), this.camera;
        }, preRender: function() {
          if (this.isRunning)
            this.camera.matrix.translate(this._offsetX, this._offsetY);
        }, update: function(J, Z) {
          if (!this.isRunning)
            return;
          if (this._elapsed += Z, this.progress = E(this._elapsed / this.duration, 0, 1), this._onUpdate)
            this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);
          if (this._elapsed < this.duration) {
            var D = this.intensity, Q = this.camera.width, H = this.camera.height, N = this.camera.zoom;
            if (this._offsetX = (Math.random() * D.x * Q * 2 - D.x * Q) * N, this._offsetY = (Math.random() * D.y * H * 2 - D.y * H) * N, this.camera.roundPixels)
              this._offsetX = Math.round(this._offsetX), this._offsetY = Math.round(this._offsetY);
          } else
            this.effectComplete();
        }, effectComplete: function() {
          this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null, this.isRunning = false, this.camera.emit(z.SHAKE_COMPLETE, this.camera, this);
        }, reset: function() {
          this.isRunning = false, this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null;
        }, destroy: function() {
          this.reset(), this.camera = null, this.intensity = null;
        } });
        M.exports = K;
      }, 45641: (M, B, $) => {
        var E = $(45319), L = $(83419), z = $(62640), U = $(19715), K = new L({ initialize: function J(Z) {
          this.camera = Z, this.isRunning = false, this.duration = 0, this.source = 1, this.destination = 1, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope;
        }, start: function(J, Z, D, Q, H, N) {
          if (Z === undefined)
            Z = 1000;
          if (D === undefined)
            D = z.Linear;
          if (Q === undefined)
            Q = false;
          if (H === undefined)
            H = null;
          if (N === undefined)
            N = this.camera.scene;
          var W = this.camera;
          if (!Q && this.isRunning)
            return W;
          if (this.isRunning = true, this.duration = Z, this.progress = 0, this.source = W.zoom, this.destination = J, typeof D === "string" && z.hasOwnProperty(D))
            this.ease = z[D];
          else if (typeof D === "function")
            this.ease = D;
          return this._elapsed = 0, this._onUpdate = H, this._onUpdateScope = N, this.camera.emit(U.ZOOM_START, this.camera, this, Z, J), W;
        }, update: function(J, Z) {
          if (!this.isRunning)
            return;
          if (this._elapsed += Z, this.progress = E(this._elapsed / this.duration, 0, 1), this._elapsed < this.duration) {
            if (this.camera.zoom = this.source + (this.destination - this.source) * this.ease(this.progress), this._onUpdate)
              this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom);
          } else {
            if (this.camera.zoom = this.destination, this._onUpdate)
              this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination);
            this.effectComplete();
          }
        }, effectComplete: function() {
          this._onUpdate = null, this._onUpdateScope = null, this.isRunning = false, this.camera.emit(U.ZOOM_COMPLETE, this.camera, this);
        }, reset: function() {
          this.isRunning = false, this._onUpdate = null, this._onUpdateScope = null;
        }, destroy: function() {
          this.reset(), this.camera = null;
        } });
        M.exports = K;
      }, 20052: (M, B, $) => {
        M.exports = { Fade: $(5020), Flash: $(10662), Pan: $(20359), Shake: $(30330), RotateTo: $(34208), Zoom: $(45641) };
      }, 16438: (M) => {
        M.exports = "cameradestroy";
      }, 32726: (M) => {
        M.exports = "camerafadeincomplete";
      }, 87807: (M) => {
        M.exports = "camerafadeinstart";
      }, 45917: (M) => {
        M.exports = "camerafadeoutcomplete";
      }, 95666: (M) => {
        M.exports = "camerafadeoutstart";
      }, 47056: (M) => {
        M.exports = "cameraflashcomplete";
      }, 91261: (M) => {
        M.exports = "cameraflashstart";
      }, 45047: (M) => {
        M.exports = "followupdate";
      }, 81927: (M) => {
        M.exports = "camerapancomplete";
      }, 74264: (M) => {
        M.exports = "camerapanstart";
      }, 54419: (M) => {
        M.exports = "postrender";
      }, 79330: (M) => {
        M.exports = "prerender";
      }, 93183: (M) => {
        M.exports = "camerarotatecomplete";
      }, 80112: (M) => {
        M.exports = "camerarotatestart";
      }, 62252: (M) => {
        M.exports = "camerashakecomplete";
      }, 86017: (M) => {
        M.exports = "camerashakestart";
      }, 539: (M) => {
        M.exports = "camerazoomcomplete";
      }, 51892: (M) => {
        M.exports = "camerazoomstart";
      }, 19715: (M, B, $) => {
        M.exports = { DESTROY: $(16438), FADE_IN_COMPLETE: $(32726), FADE_IN_START: $(87807), FADE_OUT_COMPLETE: $(45917), FADE_OUT_START: $(95666), FLASH_COMPLETE: $(47056), FLASH_START: $(91261), FOLLOW_UPDATE: $(45047), PAN_COMPLETE: $(81927), PAN_START: $(74264), POST_RENDER: $(54419), PRE_RENDER: $(79330), ROTATE_COMPLETE: $(93183), ROTATE_START: $(80112), SHAKE_COMPLETE: $(62252), SHAKE_START: $(86017), ZOOM_COMPLETE: $(539), ZOOM_START: $(51892) };
      }, 87969: (M, B, $) => {
        M.exports = { Camera: $(38058), BaseCamera: $(71911), CameraManager: $(32743), Effects: $(20052), Events: $(19715) };
      }, 63091: (M, B, $) => {
        var E = $(83419), L = $(35154), z = new E({ initialize: function U(K) {
          this.camera = L(K, "camera", null), this.left = L(K, "left", null), this.right = L(K, "right", null), this.up = L(K, "up", null), this.down = L(K, "down", null), this.zoomIn = L(K, "zoomIn", null), this.zoomOut = L(K, "zoomOut", null), this.zoomSpeed = L(K, "zoomSpeed", 0.01), this.minZoom = L(K, "minZoom", 0.001), this.maxZoom = L(K, "maxZoom", 1000), this.speedX = 0, this.speedY = 0;
          var J = L(K, "speed", null);
          if (typeof J === "number")
            this.speedX = J, this.speedY = J;
          else
            this.speedX = L(K, "speed.x", 0), this.speedY = L(K, "speed.y", 0);
          this._zoom = 0, this.active = this.camera !== null;
        }, start: function() {
          return this.active = this.camera !== null, this;
        }, stop: function() {
          return this.active = false, this;
        }, setCamera: function(U) {
          return this.camera = U, this;
        }, update: function(U) {
          if (!this.active)
            return;
          if (U === undefined)
            U = 1;
          var K = this.camera;
          if (this.up && this.up.isDown)
            K.scrollY -= this.speedY * U | 0;
          else if (this.down && this.down.isDown)
            K.scrollY += this.speedY * U | 0;
          if (this.left && this.left.isDown)
            K.scrollX -= this.speedX * U | 0;
          else if (this.right && this.right.isDown)
            K.scrollX += this.speedX * U | 0;
          if (this.zoomIn && this.zoomIn.isDown) {
            if (K.zoom -= this.zoomSpeed, K.zoom < this.minZoom)
              K.zoom = this.minZoom;
          } else if (this.zoomOut && this.zoomOut.isDown) {
            if (K.zoom += this.zoomSpeed, K.zoom > this.maxZoom)
              K.zoom = this.maxZoom;
          }
        }, destroy: function() {
          this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null;
        } });
        M.exports = z;
      }, 58818: (M, B, $) => {
        var E = $(83419), L = $(35154), z = new E({ initialize: function U(K) {
          this.camera = L(K, "camera", null), this.left = L(K, "left", null), this.right = L(K, "right", null), this.up = L(K, "up", null), this.down = L(K, "down", null), this.zoomIn = L(K, "zoomIn", null), this.zoomOut = L(K, "zoomOut", null), this.zoomSpeed = L(K, "zoomSpeed", 0.01), this.minZoom = L(K, "minZoom", 0.001), this.maxZoom = L(K, "maxZoom", 1000), this.accelX = 0, this.accelY = 0;
          var J = L(K, "acceleration", null);
          if (typeof J === "number")
            this.accelX = J, this.accelY = J;
          else
            this.accelX = L(K, "acceleration.x", 0), this.accelY = L(K, "acceleration.y", 0);
          this.dragX = 0, this.dragY = 0;
          var Z = L(K, "drag", null);
          if (typeof Z === "number")
            this.dragX = Z, this.dragY = Z;
          else
            this.dragX = L(K, "drag.x", 0), this.dragY = L(K, "drag.y", 0);
          this.maxSpeedX = 0, this.maxSpeedY = 0;
          var D = L(K, "maxSpeed", null);
          if (typeof D === "number")
            this.maxSpeedX = D, this.maxSpeedY = D;
          else
            this.maxSpeedX = L(K, "maxSpeed.x", 0), this.maxSpeedY = L(K, "maxSpeed.y", 0);
          this._speedX = 0, this._speedY = 0, this._zoom = 0, this.active = this.camera !== null;
        }, start: function() {
          return this.active = this.camera !== null, this;
        }, stop: function() {
          return this.active = false, this;
        }, setCamera: function(U) {
          return this.camera = U, this;
        }, update: function(U) {
          if (!this.active)
            return;
          if (U === undefined)
            U = 1;
          var K = this.camera;
          if (this._speedX > 0) {
            if (this._speedX -= this.dragX * U, this._speedX < 0)
              this._speedX = 0;
          } else if (this._speedX < 0) {
            if (this._speedX += this.dragX * U, this._speedX > 0)
              this._speedX = 0;
          }
          if (this._speedY > 0) {
            if (this._speedY -= this.dragY * U, this._speedY < 0)
              this._speedY = 0;
          } else if (this._speedY < 0) {
            if (this._speedY += this.dragY * U, this._speedY > 0)
              this._speedY = 0;
          }
          if (this.up && this.up.isDown) {
            if (this._speedY += this.accelY, this._speedY > this.maxSpeedY)
              this._speedY = this.maxSpeedY;
          } else if (this.down && this.down.isDown) {
            if (this._speedY -= this.accelY, this._speedY < -this.maxSpeedY)
              this._speedY = -this.maxSpeedY;
          }
          if (this.left && this.left.isDown) {
            if (this._speedX += this.accelX, this._speedX > this.maxSpeedX)
              this._speedX = this.maxSpeedX;
          } else if (this.right && this.right.isDown) {
            if (this._speedX -= this.accelX, this._speedX < -this.maxSpeedX)
              this._speedX = -this.maxSpeedX;
          }
          if (this.zoomIn && this.zoomIn.isDown)
            this._zoom = -this.zoomSpeed;
          else if (this.zoomOut && this.zoomOut.isDown)
            this._zoom = this.zoomSpeed;
          else
            this._zoom = 0;
          if (this._speedX !== 0)
            K.scrollX -= this._speedX * U | 0;
          if (this._speedY !== 0)
            K.scrollY -= this._speedY * U | 0;
          if (this._zoom !== 0) {
            if (K.zoom += this._zoom, K.zoom < this.minZoom)
              K.zoom = this.minZoom;
            else if (K.zoom > this.maxZoom)
              K.zoom = this.maxZoom;
          }
        }, destroy: function() {
          this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null;
        } });
        M.exports = z;
      }, 38865: (M, B, $) => {
        M.exports = { FixedKeyControl: $(63091), SmoothedKeyControl: $(58818) };
      }, 26638: (M, B, $) => {
        M.exports = { Controls: $(38865), Scene2D: $(87969) };
      }, 8054: (M, B, $) => {
        var E = { VERSION: "3.80.1", BlendModes: $(10312), ScaleModes: $(29795), AUTO: 0, CANVAS: 1, WEBGL: 2, HEADLESS: 3, FOREVER: -1, NONE: 4, UP: 5, DOWN: 6, LEFT: 7, RIGHT: 8 };
        M.exports = E;
      }, 69547: (M, B, $) => {
        var E = $(83419), L = $(8054), z = $(42363), U = $(82264), K = $(95540), J = $(35154), Z = $(41212), D = $(29747), Q = $(75508), H = $(36060), N = $(80333), W = new E({ initialize: function R(Y) {
          if (Y === undefined)
            Y = {};
          var I = ["#ff0000", "#ffff00", "#00ff00", "#00ffff", "#000000"], P = "#ffffff", X = J(Y, "scale", null);
          if (this.width = J(X, "width", 1024, Y), this.height = J(X, "height", 768, Y), this.zoom = J(X, "zoom", 1, Y), this.parent = J(X, "parent", undefined, Y), this.scaleMode = J(X, X ? "mode" : "scaleMode", 0, Y), this.expandParent = J(X, "expandParent", true, Y), this.autoRound = J(X, "autoRound", false, Y), this.autoCenter = J(X, "autoCenter", 0, Y), this.resizeInterval = J(X, "resizeInterval", 500, Y), this.fullscreenTarget = J(X, "fullscreenTarget", null, Y), this.minWidth = J(X, "min.width", 0, Y), this.maxWidth = J(X, "max.width", 0, Y), this.minHeight = J(X, "min.height", 0, Y), this.maxHeight = J(X, "max.height", 0, Y), this.snapWidth = J(X, "snap.width", 0, Y), this.snapHeight = J(X, "snap.height", 0, Y), this.renderType = J(Y, "type", L.AUTO), this.canvas = J(Y, "canvas", null), this.context = J(Y, "context", null), this.canvasStyle = J(Y, "canvasStyle", null), this.customEnvironment = J(Y, "customEnvironment", false), this.sceneConfig = J(Y, "scene", null), this.seed = J(Y, "seed", [(Date.now() * Math.random()).toString()]), Q.RND = new Q.RandomDataGenerator(this.seed), this.gameTitle = J(Y, "title", ""), this.gameURL = J(Y, "url", "https://phaser.io"), this.gameVersion = J(Y, "version", ""), this.autoFocus = J(Y, "autoFocus", true), this.stableSort = J(Y, "stableSort", -1), this.stableSort === -1)
            this.stableSort = U.browser.es2019 ? 1 : 0;
          if (U.features.stableSort = this.stableSort, this.domCreateContainer = J(Y, "dom.createContainer", false), this.domPointerEvents = J(Y, "dom.pointerEvents", "none"), this.inputKeyboard = J(Y, "input.keyboard", true), this.inputKeyboardEventTarget = J(Y, "input.keyboard.target", window), this.inputKeyboardCapture = J(Y, "input.keyboard.capture", []), this.inputMouse = J(Y, "input.mouse", true), this.inputMouseEventTarget = J(Y, "input.mouse.target", null), this.inputMousePreventDefaultDown = J(Y, "input.mouse.preventDefaultDown", true), this.inputMousePreventDefaultUp = J(Y, "input.mouse.preventDefaultUp", true), this.inputMousePreventDefaultMove = J(Y, "input.mouse.preventDefaultMove", true), this.inputMousePreventDefaultWheel = J(Y, "input.mouse.preventDefaultWheel", true), this.inputTouch = J(Y, "input.touch", U.input.touch), this.inputTouchEventTarget = J(Y, "input.touch.target", null), this.inputTouchCapture = J(Y, "input.touch.capture", true), this.inputActivePointers = J(Y, "input.activePointers", 1), this.inputSmoothFactor = J(Y, "input.smoothFactor", 0), this.inputWindowEvents = J(Y, "input.windowEvents", true), this.inputGamepad = J(Y, "input.gamepad", false), this.inputGamepadEventTarget = J(Y, "input.gamepad.target", window), this.disableContextMenu = J(Y, "disableContextMenu", false), this.audio = J(Y, "audio", {}), this.hideBanner = J(Y, "banner", null) === false, this.hidePhaser = J(Y, "banner.hidePhaser", false), this.bannerTextColor = J(Y, "banner.text", P), this.bannerBackgroundColor = J(Y, "banner.background", I), this.gameTitle === "" && this.hidePhaser)
            this.hideBanner = true;
          this.fps = J(Y, "fps", null), this.disablePreFX = J(Y, "disablePreFX", false), this.disablePostFX = J(Y, "disablePostFX", false);
          var G = J(Y, "render", null);
          if (this.pipeline = J(G, "pipeline", null, Y), this.autoMobilePipeline = J(G, "autoMobilePipeline", true, Y), this.defaultPipeline = J(G, "defaultPipeline", H.MULTI_PIPELINE, Y), this.antialias = J(G, "antialias", true, Y), this.antialiasGL = J(G, "antialiasGL", true, Y), this.mipmapFilter = J(G, "mipmapFilter", "", Y), this.desynchronized = J(G, "desynchronized", false, Y), this.roundPixels = J(G, "roundPixels", true, Y), this.pixelArt = J(G, "pixelArt", this.zoom !== 1, Y), this.pixelArt)
            this.antialias = false, this.antialiasGL = false, this.roundPixels = true;
          this.transparent = J(G, "transparent", false, Y), this.clearBeforeRender = J(G, "clearBeforeRender", true, Y), this.preserveDrawingBuffer = J(G, "preserveDrawingBuffer", false, Y), this.premultipliedAlpha = J(G, "premultipliedAlpha", true, Y), this.failIfMajorPerformanceCaveat = J(G, "failIfMajorPerformanceCaveat", false, Y), this.powerPreference = J(G, "powerPreference", "default", Y), this.batchSize = J(G, "batchSize", 4096, Y), this.maxTextures = J(G, "maxTextures", -1, Y), this.maxLights = J(G, "maxLights", 10, Y);
          var V = J(Y, "backgroundColor", 0);
          if (this.backgroundColor = N(V), this.transparent)
            this.backgroundColor = N(0), this.backgroundColor.alpha = 0;
          this.preBoot = J(Y, "callbacks.preBoot", D), this.postBoot = J(Y, "callbacks.postBoot", D), this.physics = J(Y, "physics", {}), this.defaultPhysicsSystem = J(this.physics, "default", false), this.loaderBaseURL = J(Y, "loader.baseURL", ""), this.loaderPath = J(Y, "loader.path", ""), this.loaderMaxParallelDownloads = J(Y, "loader.maxParallelDownloads", U.os.android ? 6 : 32), this.loaderCrossOrigin = J(Y, "loader.crossOrigin", undefined), this.loaderResponseType = J(Y, "loader.responseType", ""), this.loaderAsync = J(Y, "loader.async", true), this.loaderUser = J(Y, "loader.user", ""), this.loaderPassword = J(Y, "loader.password", ""), this.loaderTimeout = J(Y, "loader.timeout", 0), this.loaderWithCredentials = J(Y, "loader.withCredentials", false), this.loaderImageLoadType = J(Y, "loader.imageLoadType", "XHR"), this.loaderLocalScheme = J(Y, "loader.localScheme", ["file://", "capacitor://"]), this.glowFXQuality = J(Y, "fx.glow.quality", 0.1), this.glowFXDistance = J(Y, "fx.glow.distance", 10), this.installGlobalPlugins = [], this.installScenePlugins = [];
          var A = J(Y, "plugins", null), F = z.DefaultScene;
          if (A) {
            if (Array.isArray(A))
              this.defaultPlugins = A;
            else if (Z(A)) {
              if (this.installGlobalPlugins = K(A, "global", []), this.installScenePlugins = K(A, "scene", []), Array.isArray(A.default))
                F = A.default;
              else if (Array.isArray(A.defaultMerge))
                F = F.concat(A.defaultMerge);
            }
          }
          this.defaultPlugins = F;
          var j = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg";
          if (this.defaultImage = J(Y, "images.default", j + "AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg=="), this.missingImage = J(Y, "images.missing", j + "CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg=="), this.whiteImage = J(Y, "images.white", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABdJREFUeNpi/P//PwMMMDEgAdwcgAADAJZuAwXJYZOzAAAAAElFTkSuQmCC"), window) {
            if (window.FORCE_WEBGL)
              this.renderType = L.WEBGL;
            else if (window.FORCE_CANVAS)
              this.renderType = L.CANVAS;
          }
        } });
        M.exports = W;
      }, 86054: (M, B, $) => {
        var E = $(20623), L = $(27919), z = $(8054), U = $(89357), K = function(J) {
          var Z = J.config;
          if ((Z.customEnvironment || Z.canvas) && Z.renderType === z.AUTO)
            throw new Error("Must set explicit renderType in custom environment");
          if (!Z.customEnvironment && !Z.canvas && Z.renderType !== z.HEADLESS) {
            if (Z.renderType === z.AUTO)
              Z.renderType = U.webGL ? z.WEBGL : z.CANVAS;
            if (Z.renderType === z.WEBGL) {
              if (!U.webGL)
                throw new Error("Cannot create WebGL context, aborting.");
            } else if (Z.renderType === z.CANVAS) {
              if (!U.canvas)
                throw new Error("Cannot create Canvas context, aborting.");
            } else
              throw new Error("Unknown value for renderer type: " + Z.renderType);
          }
          if (!Z.antialias)
            L.disableSmoothing();
          var D = J.scale.baseSize, Q = D.width, H = D.height;
          if (Z.canvas)
            J.canvas = Z.canvas, J.canvas.width = Q, J.canvas.height = H;
          else
            J.canvas = L.create(J, Q, H, Z.renderType);
          if (Z.canvasStyle)
            J.canvas.style = Z.canvasStyle;
          if (!Z.antialias)
            E.setCrisp(J.canvas);
          if (Z.renderType === z.HEADLESS)
            return;
          var N, W;
          if (N = $(68627), W = $(74797), Z.renderType === z.WEBGL)
            J.renderer = new W(J);
          else
            J.renderer = new N(J), J.context = J.renderer.gameContext;
        };
        M.exports = K;
      }, 96391: (M, B, $) => {
        var E = $(8054), L = function(z) {
          var U = z.config;
          if (U.hideBanner)
            return;
          var K = "WebGL";
          if (U.renderType === E.CANVAS)
            K = "Canvas";
          else if (U.renderType === E.HEADLESS)
            K = "Headless";
          var J = U.audio, Z = z.device.audio, D;
          if (Z.webAudio && !J.disableWebAudio)
            D = "Web Audio";
          else if (J.noAudio || !Z.webAudio && !Z.audioData)
            D = "No Audio";
          else
            D = "HTML5 Audio";
          if (!z.device.browser.ie) {
            var Q = "", H = [Q];
            if (Array.isArray(U.bannerBackgroundColor)) {
              var N;
              U.bannerBackgroundColor.forEach(function(R) {
                Q = Q.concat("%c "), H.push("background: " + R), N = R;
              }), H[H.length - 1] = "color: " + U.bannerTextColor + "; background: " + N;
            } else
              Q = Q.concat("%c "), H.push("color: " + U.bannerTextColor + "; background: " + U.bannerBackgroundColor);
            if (H.push("background: transparent"), U.gameTitle) {
              if (Q = Q.concat(U.gameTitle), U.gameVersion)
                Q = Q.concat(" v" + U.gameVersion);
              if (!U.hidePhaser)
                Q = Q.concat(" / ");
            }
            var W = "";
            if (!U.hidePhaser)
              Q = Q.concat("Phaser v" + E.VERSION + W + " (" + K + " | " + D + ")");
            Q = Q.concat(" %c " + U.gameURL), H[0] = Q, console.log.apply(console, H);
          } else if (window.console)
            console.log("Phaser v" + E.VERSION + " / https://phaser.io");
        };
        M.exports = L;
      }, 50127: (M, B, $) => {
        var E = $(40366), L = $(60848), z = $(24047), U = $(27919), K = $(83419), J = $(69547), Z = $(83719), D = $(86054), Q = $(45893), H = $(96391), N = $(82264), W = $(57264), R = $(50792), Y = $(8443), I = $(7003), P = $(37277), X = $(77332), G = $(76531), V = $(60903), A = $(69442), F = $(17130), j = $(65898), T = $(51085), C = $(14747);
        if (false)
          var v;
        var O = new K({ initialize: function q(w) {
          this.config = new J(w), this.renderer = null, this.domContainer = null, this.canvas = null, this.context = null, this.isBooted = false, this.isRunning = false, this.events = new R, this.anims = new L(this), this.textures = new F(this), this.cache = new z(this), this.registry = new Q(this, new R), this.input = new I(this, this.config), this.scene = new V(this, this.config.sceneConfig), this.device = N, this.scale = new G(this, this.config), this.sound = null, this.sound = C.create(this), this.loop = new j(this, this.config.fps), this.plugins = new X(this, this.config), this.pendingDestroy = false, this.removeCanvas = false, this.noReturn = false, this.hasFocus = false, this.isPaused = false, W(this.boot.bind(this));
        }, boot: function() {
          if (!P.hasCore("EventEmitter")) {
            console.warn("Aborting. Core Plugins missing.");
            return;
          }
          this.isBooted = true, this.config.preBoot(this), this.scale.preBoot(), D(this), Z(this), H(this), E(this.canvas, this.config.parent), this.textures.once(A.READY, this.texturesReady, this), this.events.emit(Y.BOOT);
        }, texturesReady: function() {
          this.events.emit(Y.READY), this.start();
        }, start: function() {
          if (this.isRunning = true, this.config.postBoot(this), this.renderer)
            this.loop.start(this.step.bind(this));
          else
            this.loop.start(this.headlessStep.bind(this));
          T(this);
          var q = this.events;
          q.on(Y.HIDDEN, this.onHidden, this), q.on(Y.VISIBLE, this.onVisible, this), q.on(Y.BLUR, this.onBlur, this), q.on(Y.FOCUS, this.onFocus, this);
        }, step: function(q, w) {
          if (this.pendingDestroy)
            return this.runDestroy();
          if (this.isPaused)
            return;
          var g = this.events;
          g.emit(Y.PRE_STEP, q, w), g.emit(Y.STEP, q, w), this.scene.update(q, w), g.emit(Y.POST_STEP, q, w);
          var b = this.renderer;
          b.preRender(), g.emit(Y.PRE_RENDER, b, q, w), this.scene.render(b), b.postRender(), g.emit(Y.POST_RENDER, b, q, w);
        }, headlessStep: function(q, w) {
          if (this.pendingDestroy)
            return this.runDestroy();
          if (this.isPaused)
            return;
          var g = this.events;
          g.emit(Y.PRE_STEP, q, w), g.emit(Y.STEP, q, w), this.scene.update(q, w), g.emit(Y.POST_STEP, q, w), this.scene.isProcessing = false, g.emit(Y.PRE_RENDER, null, q, w), g.emit(Y.POST_RENDER, null, q, w);
        }, onHidden: function() {
          this.loop.pause(), this.events.emit(Y.PAUSE);
        }, pause: function() {
          var q = this.isPaused;
          if (this.isPaused = true, !q)
            this.events.emit(Y.PAUSE);
        }, onVisible: function() {
          this.loop.resume(), this.events.emit(Y.RESUME);
        }, resume: function() {
          var q = this.isPaused;
          if (this.isPaused = false, q)
            this.events.emit(Y.RESUME);
        }, onBlur: function() {
          this.hasFocus = false, this.loop.blur();
        }, onFocus: function() {
          this.hasFocus = true, this.loop.focus();
        }, getFrame: function() {
          return this.loop.frame;
        }, getTime: function() {
          return this.loop.now;
        }, destroy: function(q, w) {
          if (w === undefined)
            w = false;
          this.pendingDestroy = true, this.removeCanvas = q, this.noReturn = w;
        }, runDestroy: function() {
          if (this.scene.destroy(), this.events.emit(Y.DESTROY), this.events.removeAllListeners(), this.renderer)
            this.renderer.destroy();
          if (this.removeCanvas && this.canvas) {
            if (U.remove(this.canvas), this.canvas.parentNode)
              this.canvas.parentNode.removeChild(this.canvas);
          }
          if (this.domContainer && this.domContainer.parentNode)
            this.domContainer.parentNode.removeChild(this.domContainer);
          this.loop.destroy(), this.pendingDestroy = false;
        } });
        M.exports = O;
      }, 65898: (M, B, $) => {
        var E = $(83419), L = $(35154), z = $(29747), U = $(43092), K = new E({ initialize: function J(Z, D) {
          this.game = Z, this.raf = new U, this.started = false, this.running = false, this.minFps = L(D, "min", 5), this.targetFps = L(D, "target", 60), this.fpsLimit = L(D, "limit", 0), this.hasFpsLimit = this.fpsLimit > 0, this._limitRate = this.hasFpsLimit ? 1000 / this.fpsLimit : 0, this._min = 1000 / this.minFps, this._target = 1000 / this.targetFps, this.actualFps = this.targetFps, this.nextFpsUpdate = 0, this.framesThisSecond = 0, this.callback = z, this.forceSetTimeOut = L(D, "forceSetTimeOut", false), this.time = 0, this.startTime = 0, this.lastTime = 0, this.frame = 0, this.inFocus = true, this._pauseTime = 0, this._coolDown = 0, this.delta = 0, this.deltaIndex = 0, this.deltaHistory = [], this.deltaSmoothingMax = L(D, "deltaHistory", 10), this.panicMax = L(D, "panicMax", 120), this.rawDelta = 0, this.now = 0, this.smoothStep = L(D, "smoothStep", true);
        }, blur: function() {
          this.inFocus = false;
        }, focus: function() {
          this.inFocus = true, this.resetDelta();
        }, pause: function() {
          this._pauseTime = window.performance.now();
        }, resume: function() {
          this.resetDelta(), this.startTime += this.time - this._pauseTime;
        }, resetDelta: function() {
          var J = window.performance.now();
          this.time = J, this.lastTime = J, this.nextFpsUpdate = J + 1000, this.framesThisSecond = 0;
          for (var Z = 0;Z < this.deltaSmoothingMax; Z++)
            this.deltaHistory[Z] = Math.min(this._target, this.deltaHistory[Z]);
          this.delta = 0, this.deltaIndex = 0, this._coolDown = this.panicMax;
        }, start: function(J) {
          if (this.started)
            return this;
          this.started = true, this.running = true;
          for (var Z = 0;Z < this.deltaSmoothingMax; Z++)
            this.deltaHistory[Z] = this._target;
          this.resetDelta(), this.startTime = window.performance.now(), this.callback = J;
          var D = this.hasFpsLimit ? this.stepLimitFPS.bind(this) : this.step.bind(this);
          this.raf.start(D, this.forceSetTimeOut, this._target);
        }, smoothDelta: function(J) {
          var Z = this.deltaIndex, D = this.deltaHistory, Q = this.deltaSmoothingMax;
          if (this._coolDown > 0 || !this.inFocus)
            this._coolDown--, J = Math.min(J, this._target);
          if (J > this._min)
            J = D[Z], J = Math.min(J, this._min);
          if (D[Z] = J, this.deltaIndex++, this.deltaIndex >= Q)
            this.deltaIndex = 0;
          var H = 0;
          for (var N = 0;N < Q; N++)
            H += D[N];
          return H /= Q, H;
        }, updateFPS: function(J) {
          this.actualFps = 0.25 * this.framesThisSecond + 0.75 * this.actualFps, this.nextFpsUpdate = J + 1000, this.framesThisSecond = 0;
        }, stepLimitFPS: function(J) {
          this.now = J;
          var Z = Math.max(0, J - this.lastTime);
          if (this.rawDelta = Z, this.time += this.rawDelta, this.smoothStep)
            Z = this.smoothDelta(Z);
          if (this.delta += Z, J >= this.nextFpsUpdate)
            this.updateFPS(J);
          if (this.framesThisSecond++, this.delta >= this._limitRate)
            this.callback(J, this.delta), this.delta = 0;
          this.lastTime = J, this.frame++;
        }, step: function(J) {
          this.now = J;
          var Z = Math.max(0, J - this.lastTime);
          if (this.rawDelta = Z, this.time += this.rawDelta, this.smoothStep)
            Z = this.smoothDelta(Z);
          if (this.delta = Z, J >= this.nextFpsUpdate)
            this.updateFPS(J);
          this.framesThisSecond++, this.callback(J, Z), this.lastTime = J, this.frame++;
        }, tick: function() {
          var J = window.performance.now();
          if (this.hasFpsLimit)
            this.stepLimitFPS(J);
          else
            this.step(J);
        }, sleep: function() {
          if (this.running)
            this.raf.stop(), this.running = false;
        }, wake: function(J) {
          if (J === undefined)
            J = false;
          var Z = window.performance.now();
          if (this.running)
            return;
          else if (J)
            this.startTime += -this.lastTime + (this.lastTime + Z);
          var D = this.hasFpsLimit ? this.stepLimitFPS.bind(this) : this.step.bind(this);
          this.raf.start(D, this.forceSetTimeOut, this._target), this.running = true, this.nextFpsUpdate = Z + 1000, this.framesThisSecond = 0, this.fpsLimitTriggered = false, this.tick();
        }, getDuration: function() {
          return Math.round(this.lastTime - this.startTime) / 1000;
        }, getDurationMS: function() {
          return Math.round(this.lastTime - this.startTime);
        }, stop: function() {
          return this.running = false, this.started = false, this.raf.stop(), this;
        }, destroy: function() {
          this.stop(), this.raf.destroy(), this.raf = null, this.game = null, this.callback = null;
        } });
        M.exports = K;
      }, 51085: (M, B, $) => {
        var E = $(8443), L = function(z) {
          var U, K = z.events;
          if (document.hidden !== undefined)
            U = "visibilitychange";
          else {
            var J = ["webkit", "moz", "ms"];
            J.forEach(function(D) {
              if (document[D + "Hidden"] !== undefined)
                document.hidden = function() {
                  return document[D + "Hidden"];
                }, U = D + "visibilitychange";
            });
          }
          var Z = function(D) {
            if (document.hidden || D.type === "pause")
              K.emit(E.HIDDEN);
            else
              K.emit(E.VISIBLE);
          };
          if (U)
            document.addEventListener(U, Z, false);
          if (window.onblur = function() {
            K.emit(E.BLUR);
          }, window.onfocus = function() {
            K.emit(E.FOCUS);
          }, window.focus && z.config.autoFocus)
            window.focus();
        };
        M.exports = L;
      }, 97217: (M) => {
        M.exports = "blur";
      }, 47548: (M) => {
        M.exports = "boot";
      }, 19814: (M) => {
        M.exports = "contextlost";
      }, 68446: (M) => {
        M.exports = "destroy";
      }, 41700: (M) => {
        M.exports = "focus";
      }, 25432: (M) => {
        M.exports = "hidden";
      }, 65942: (M) => {
        M.exports = "pause";
      }, 59211: (M) => {
        M.exports = "postrender";
      }, 47789: (M) => {
        M.exports = "poststep";
      }, 39066: (M) => {
        M.exports = "prerender";
      }, 460: (M) => {
        M.exports = "prestep";
      }, 16175: (M) => {
        M.exports = "ready";
      }, 42331: (M) => {
        M.exports = "resume";
      }, 11966: (M) => {
        M.exports = "step";
      }, 32969: (M) => {
        M.exports = "systemready";
      }, 94830: (M) => {
        M.exports = "visible";
      }, 8443: (M, B, $) => {
        M.exports = { BLUR: $(97217), BOOT: $(47548), CONTEXT_LOST: $(19814), DESTROY: $(68446), FOCUS: $(41700), HIDDEN: $(25432), PAUSE: $(65942), POST_RENDER: $(59211), POST_STEP: $(47789), PRE_RENDER: $(39066), PRE_STEP: $(460), READY: $(16175), RESUME: $(42331), STEP: $(11966), SYSTEM_READY: $(32969), VISIBLE: $(94830) };
      }, 42857: (M, B, $) => {
        M.exports = { Config: $(69547), CreateRenderer: $(86054), DebugHeader: $(96391), Events: $(8443), TimeStep: $(65898), VisibilityHandler: $(51085) };
      }, 99584: (M, B, $) => {
        var E = $(5290), L = $(27919), z = $(35154), U = function(K) {
          var J = z(K, "data", []), Z = z(K, "canvas", null), D = z(K, "palette", E), Q = z(K, "pixelWidth", 1), H = z(K, "pixelHeight", Q), N = z(K, "resizeCanvas", true), W = z(K, "clearCanvas", true), R = z(K, "preRender", null), Y = z(K, "postRender", null), I = Math.floor(Math.abs(J[0].length * Q)), P = Math.floor(Math.abs(J.length * H));
          if (!Z)
            Z = L.create2D(this, I, P), N = false, W = false;
          if (N)
            Z.width = I, Z.height = P;
          var X = Z.getContext("2d", { willReadFrequently: true });
          if (W)
            X.clearRect(0, 0, I, P);
          if (R)
            R(Z, X);
          for (var G = 0;G < J.length; G++) {
            var V = J[G];
            for (var A = 0;A < V.length; A++) {
              var F = V[A];
              if (F !== "." && F !== " ")
                X.fillStyle = D[F], X.fillRect(A * Q, G * H, Q, H);
            }
          }
          if (Y)
            Y(Z, X);
          return Z;
        };
        M.exports = U;
      }, 15822: (M, B, $) => {
        M.exports = { GenerateTexture: $(99584), Palettes: $(57763) };
      }, 5290: (M) => {
        M.exports = { 0: "#000", 1: "#9D9D9D", 2: "#FFF", 3: "#BE2633", 4: "#E06F8B", 5: "#493C2B", 6: "#A46422", 7: "#EB8931", 8: "#F7E26B", 9: "#2F484E", A: "#44891A", B: "#A3CE27", C: "#1B2632", D: "#005784", E: "#31A2F2", F: "#B2DCEF" };
      }, 23816: (M) => {
        M.exports = { 0: "#000", 1: "#fff", 2: "#8b4131", 3: "#7bbdc5", 4: "#8b41ac", 5: "#6aac41", 6: "#3931a4", 7: "#d5de73", 8: "#945a20", 9: "#5a4100", A: "#bd736a", B: "#525252", C: "#838383", D: "#acee8b", E: "#7b73de", F: "#acacac" };
      }, 9866: (M) => {
        M.exports = { 0: "#000", 1: "#2234d1", 2: "#0c7e45", 3: "#44aacc", 4: "#8a3622", 5: "#5c2e78", 6: "#aa5c3d", 7: "#b5b5b5", 8: "#5e606e", 9: "#4c81fb", A: "#6cd947", B: "#7be2f9", C: "#eb8a60", D: "#e23d69", E: "#ffd93f", F: "#fff" };
      }, 77552: (M) => {
        M.exports = { 0: "#000", 1: "#191028", 2: "#46af45", 3: "#a1d685", 4: "#453e78", 5: "#7664fe", 6: "#833129", 7: "#9ec2e8", 8: "#dc534b", 9: "#e18d79", A: "#d6b97b", B: "#e9d8a1", C: "#216c4b", D: "#d365c8", E: "#afaab9", F: "#f5f4eb" };
      }, 92259: (M) => {
        M.exports = { 0: "#000", 1: "#191028", 2: "#46af45", 3: "#a1d685", 4: "#453e78", 5: "#7664fe", 6: "#833129", 7: "#9ec2e8", 8: "#dc534b", 9: "#e18d79", A: "#d6b97b", B: "#e9d8a1", C: "#216c4b", D: "#d365c8", E: "#afaab9", F: "#fff" };
      }, 57763: (M, B, $) => {
        M.exports = { ARNE16: $(5290), C64: $(23816), CGA: $(9866), JMP: $(77552), MSX: $(92259) };
      }, 46728: (M, B, $) => {
        var E = $(83419), L = $(36316), z = $(80021), U = $(26099), K = new E({ Extends: z, initialize: function J(Z, D, Q, H) {
          if (z.call(this, "CubicBezierCurve"), Array.isArray(Z))
            H = new U(Z[6], Z[7]), Q = new U(Z[4], Z[5]), D = new U(Z[2], Z[3]), Z = new U(Z[0], Z[1]);
          this.p0 = Z, this.p1 = D, this.p2 = Q, this.p3 = H;
        }, getStartPoint: function(J) {
          if (J === undefined)
            J = new U;
          return J.copy(this.p0);
        }, getResolution: function(J) {
          return J;
        }, getPoint: function(J, Z) {
          if (Z === undefined)
            Z = new U;
          var D = this.p0, Q = this.p1, H = this.p2, N = this.p3;
          return Z.set(L(J, D.x, Q.x, H.x, N.x), L(J, D.y, Q.y, H.y, N.y));
        }, draw: function(J, Z) {
          if (Z === undefined)
            Z = 32;
          var D = this.getPoints(Z);
          J.beginPath(), J.moveTo(this.p0.x, this.p0.y);
          for (var Q = 1;Q < D.length; Q++)
            J.lineTo(D[Q].x, D[Q].y);
          return J.strokePath(), J;
        }, toJSON: function() {
          return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y, this.p3.x, this.p3.y] };
        } });
        K.fromJSON = function(J) {
          var Z = J.points, D = new U(Z[0], Z[1]), Q = new U(Z[2], Z[3]), H = new U(Z[4], Z[5]), N = new U(Z[6], Z[7]);
          return new K(D, Q, H, N);
        }, M.exports = K;
      }, 80021: (M, B, $) => {
        var E = $(83419), L = $(19217), z = $(87841), U = $(26099), K = new E({ initialize: function J(Z) {
          this.type = Z, this.defaultDivisions = 5, this.arcLengthDivisions = 100, this.cacheArcLengths = [], this.needsUpdate = true, this.active = true, this._tmpVec2A = new U, this._tmpVec2B = new U;
        }, draw: function(J, Z) {
          if (Z === undefined)
            Z = 32;
          return J.strokePoints(this.getPoints(Z));
        }, getBounds: function(J, Z) {
          if (!J)
            J = new z;
          if (Z === undefined)
            Z = 16;
          var D = this.getLength();
          if (Z > D)
            Z = D / 2;
          var Q = Math.max(1, Math.round(D / Z));
          return L(this.getSpacedPoints(Q), J);
        }, getDistancePoints: function(J) {
          var Z = this.getLength(), D = Math.max(1, Z / J);
          return this.getSpacedPoints(D);
        }, getEndPoint: function(J) {
          if (J === undefined)
            J = new U;
          return this.getPointAt(1, J);
        }, getLength: function() {
          var J = this.getLengths();
          return J[J.length - 1];
        }, getLengths: function(J) {
          if (J === undefined)
            J = this.arcLengthDivisions;
          if (this.cacheArcLengths.length === J + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
          this.needsUpdate = false;
          var Z = [], D, Q = this.getPoint(0, this._tmpVec2A), H = 0;
          Z.push(0);
          for (var N = 1;N <= J; N++)
            D = this.getPoint(N / J, this._tmpVec2B), H += D.distance(Q), Z.push(H), Q.copy(D);
          return this.cacheArcLengths = Z, Z;
        }, getPointAt: function(J, Z) {
          var D = this.getUtoTmapping(J);
          return this.getPoint(D, Z);
        }, getPoints: function(J, Z, D) {
          if (D === undefined)
            D = [];
          if (!J)
            if (!Z)
              J = this.defaultDivisions;
            else
              J = this.getLength() / Z;
          for (var Q = 0;Q <= J; Q++)
            D.push(this.getPoint(Q / J));
          return D;
        }, getRandomPoint: function(J) {
          if (J === undefined)
            J = new U;
          return this.getPoint(Math.random(), J);
        }, getSpacedPoints: function(J, Z, D) {
          if (D === undefined)
            D = [];
          if (!J)
            if (!Z)
              J = this.defaultDivisions;
            else
              J = this.getLength() / Z;
          for (var Q = 0;Q <= J; Q++) {
            var H = this.getUtoTmapping(Q / J, null, J);
            D.push(this.getPoint(H));
          }
          return D;
        }, getStartPoint: function(J) {
          if (J === undefined)
            J = new U;
          return this.getPointAt(0, J);
        }, getTangent: function(J, Z) {
          if (Z === undefined)
            Z = new U;
          var D = 0.0001, Q = J - D, H = J + D;
          if (Q < 0)
            Q = 0;
          if (H > 1)
            H = 1;
          return this.getPoint(Q, this._tmpVec2A), this.getPoint(H, Z), Z.subtract(this._tmpVec2A).normalize();
        }, getTangentAt: function(J, Z) {
          var D = this.getUtoTmapping(J);
          return this.getTangent(D, Z);
        }, getTFromDistance: function(J, Z) {
          if (J <= 0)
            return 0;
          return this.getUtoTmapping(0, J, Z);
        }, getUtoTmapping: function(J, Z, D) {
          var Q = this.getLengths(D), H = 0, N = Q.length, W;
          if (Z)
            W = Math.min(Z, Q[N - 1]);
          else
            W = J * Q[N - 1];
          var R = 0, Y = N - 1, I;
          while (R <= Y)
            if (H = Math.floor(R + (Y - R) / 2), I = Q[H] - W, I < 0)
              R = H + 1;
            else if (I > 0)
              Y = H - 1;
            else {
              Y = H;
              break;
            }
          if (H = Y, Q[H] === W)
            return H / (N - 1);
          var P = Q[H], X = Q[H + 1], G = X - P, V = (W - P) / G;
          return (H + V) / (N - 1);
        }, updateArcLengths: function() {
          this.needsUpdate = true, this.getLengths();
        } });
        M.exports = K;
      }, 73825: (M, B, $) => {
        var E = $(83419), L = $(80021), z = $(39506), U = $(35154), K = $(43396), J = $(26099), Z = new E({ Extends: L, initialize: function D(Q, H, N, W, R, Y, I, P) {
          if (typeof Q === "object") {
            var X = Q;
            Q = U(X, "x", 0), H = U(X, "y", 0), N = U(X, "xRadius", 0), W = U(X, "yRadius", N), R = U(X, "startAngle", 0), Y = U(X, "endAngle", 360), I = U(X, "clockwise", false), P = U(X, "rotation", 0);
          } else {
            if (W === undefined)
              W = N;
            if (R === undefined)
              R = 0;
            if (Y === undefined)
              Y = 360;
            if (I === undefined)
              I = false;
            if (P === undefined)
              P = 0;
          }
          L.call(this, "EllipseCurve"), this.p0 = new J(Q, H), this._xRadius = N, this._yRadius = W, this._startAngle = z(R), this._endAngle = z(Y), this._clockwise = I, this._rotation = z(P);
        }, getStartPoint: function(D) {
          if (D === undefined)
            D = new J;
          return this.getPoint(0, D);
        }, getResolution: function(D) {
          return D * 2;
        }, getPoint: function(D, Q) {
          if (Q === undefined)
            Q = new J;
          var H = Math.PI * 2, N = this._endAngle - this._startAngle, W = Math.abs(N) < Number.EPSILON;
          while (N < 0)
            N += H;
          while (N > H)
            N -= H;
          if (N < Number.EPSILON)
            if (W)
              N = 0;
            else
              N = H;
          if (this._clockwise && !W)
            if (N === H)
              N = -H;
            else
              N = N - H;
          var R = this._startAngle + D * N, Y = this.p0.x + this._xRadius * Math.cos(R), I = this.p0.y + this._yRadius * Math.sin(R);
          if (this._rotation !== 0) {
            var P = Math.cos(this._rotation), X = Math.sin(this._rotation), G = Y - this.p0.x, V = I - this.p0.y;
            Y = G * P - V * X + this.p0.x, I = G * X + V * P + this.p0.y;
          }
          return Q.set(Y, I);
        }, setXRadius: function(D) {
          return this.xRadius = D, this;
        }, setYRadius: function(D) {
          return this.yRadius = D, this;
        }, setWidth: function(D) {
          return this.xRadius = D / 2, this;
        }, setHeight: function(D) {
          return this.yRadius = D / 2, this;
        }, setStartAngle: function(D) {
          return this.startAngle = D, this;
        }, setEndAngle: function(D) {
          return this.endAngle = D, this;
        }, setClockwise: function(D) {
          return this.clockwise = D, this;
        }, setRotation: function(D) {
          return this.rotation = D, this;
        }, x: { get: function() {
          return this.p0.x;
        }, set: function(D) {
          this.p0.x = D;
        } }, y: { get: function() {
          return this.p0.y;
        }, set: function(D) {
          this.p0.y = D;
        } }, xRadius: { get: function() {
          return this._xRadius;
        }, set: function(D) {
          this._xRadius = D;
        } }, yRadius: { get: function() {
          return this._yRadius;
        }, set: function(D) {
          this._yRadius = D;
        } }, startAngle: { get: function() {
          return K(this._startAngle);
        }, set: function(D) {
          this._startAngle = z(D);
        } }, endAngle: { get: function() {
          return K(this._endAngle);
        }, set: function(D) {
          this._endAngle = z(D);
        } }, clockwise: { get: function() {
          return this._clockwise;
        }, set: function(D) {
          this._clockwise = D;
        } }, angle: { get: function() {
          return K(this._rotation);
        }, set: function(D) {
          this._rotation = z(D);
        } }, rotation: { get: function() {
          return this._rotation;
        }, set: function(D) {
          this._rotation = D;
        } }, toJSON: function() {
          return { type: this.type, x: this.p0.x, y: this.p0.y, xRadius: this._xRadius, yRadius: this._yRadius, startAngle: K(this._startAngle), endAngle: K(this._endAngle), clockwise: this._clockwise, rotation: K(this._rotation) };
        } });
        Z.fromJSON = function(D) {
          return new Z(D);
        }, M.exports = Z;
      }, 33951: (M, B, $) => {
        var E = $(83419), L = $(80021), z = $(19217), U = $(87841), K = $(26099), J = new E({ Extends: L, initialize: function Z(D, Q) {
          if (L.call(this, "LineCurve"), Array.isArray(D))
            Q = new K(D[2], D[3]), D = new K(D[0], D[1]);
          this.p0 = D, this.p1 = Q, this.arcLengthDivisions = 1;
        }, getBounds: function(Z) {
          if (Z === undefined)
            Z = new U;
          return z([this.p0, this.p1], Z);
        }, getStartPoint: function(Z) {
          if (Z === undefined)
            Z = new K;
          return Z.copy(this.p0);
        }, getResolution: function(Z) {
          if (Z === undefined)
            Z = 1;
          return Z;
        }, getPoint: function(Z, D) {
          if (D === undefined)
            D = new K;
          if (Z === 1)
            return D.copy(this.p1);
          return D.copy(this.p1).subtract(this.p0).scale(Z).add(this.p0), D;
        }, getPointAt: function(Z, D) {
          return this.getPoint(Z, D);
        }, getTangent: function(Z, D) {
          if (D === undefined)
            D = new K;
          return D.copy(this.p1).subtract(this.p0).normalize(), D;
        }, getUtoTmapping: function(Z, D, Q) {
          var H;
          if (D) {
            var N = this.getLengths(Q), W = N[N.length - 1], R = Math.min(D, W);
            H = R / W;
          } else
            H = Z;
          return H;
        }, draw: function(Z) {
          return Z.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y), Z;
        }, toJSON: function() {
          return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y] };
        } });
        J.fromJSON = function(Z) {
          var D = Z.points, Q = new K(D[0], D[1]), H = new K(D[2], D[3]);
          return new J(Q, H);
        }, M.exports = J;
      }, 14744: (M, B, $) => {
        var E = $(83419), L = $(80021), z = $(32112), U = $(26099), K = new E({ Extends: L, initialize: function J(Z, D, Q) {
          if (L.call(this, "QuadraticBezierCurve"), Array.isArray(Z))
            Q = new U(Z[4], Z[5]), D = new U(Z[2], Z[3]), Z = new U(Z[0], Z[1]);
          this.p0 = Z, this.p1 = D, this.p2 = Q;
        }, getStartPoint: function(J) {
          if (J === undefined)
            J = new U;
          return J.copy(this.p0);
        }, getResolution: function(J) {
          return J;
        }, getPoint: function(J, Z) {
          if (Z === undefined)
            Z = new U;
          var D = this.p0, Q = this.p1, H = this.p2;
          return Z.set(z(J, D.x, Q.x, H.x), z(J, D.y, Q.y, H.y));
        }, draw: function(J, Z) {
          if (Z === undefined)
            Z = 32;
          var D = this.getPoints(Z);
          J.beginPath(), J.moveTo(this.p0.x, this.p0.y);
          for (var Q = 1;Q < D.length; Q++)
            J.lineTo(D[Q].x, D[Q].y);
          return J.strokePath(), J;
        }, toJSON: function() {
          return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y] };
        } });
        K.fromJSON = function(J) {
          var Z = J.points, D = new U(Z[0], Z[1]), Q = new U(Z[2], Z[3]), H = new U(Z[4], Z[5]);
          return new K(D, Q, H);
        }, M.exports = K;
      }, 42534: (M, B, $) => {
        var E = $(87842), L = $(83419), z = $(80021), U = $(26099), K = new L({ Extends: z, initialize: function J(Z) {
          if (Z === undefined)
            Z = [];
          z.call(this, "SplineCurve"), this.points = [], this.addPoints(Z);
        }, addPoints: function(J) {
          for (var Z = 0;Z < J.length; Z++) {
            var D = new U;
            if (typeof J[Z] === "number")
              D.x = J[Z], D.y = J[Z + 1], Z++;
            else if (Array.isArray(J[Z]))
              D.x = J[Z][0], D.y = J[Z][1];
            else
              D.x = J[Z].x, D.y = J[Z].y;
            this.points.push(D);
          }
          return this;
        }, addPoint: function(J, Z) {
          var D = new U(J, Z);
          return this.points.push(D), D;
        }, getStartPoint: function(J) {
          if (J === undefined)
            J = new U;
          return J.copy(this.points[0]);
        }, getResolution: function(J) {
          return J * this.points.length;
        }, getPoint: function(J, Z) {
          if (Z === undefined)
            Z = new U;
          var D = this.points, Q = (D.length - 1) * J, H = Math.floor(Q), N = Q - H, W = D[H === 0 ? H : H - 1], R = D[H], Y = D[H > D.length - 2 ? D.length - 1 : H + 1], I = D[H > D.length - 3 ? D.length - 1 : H + 2];
          return Z.set(E(N, W.x, R.x, Y.x, I.x), E(N, W.y, R.y, Y.y, I.y));
        }, toJSON: function() {
          var J = [];
          for (var Z = 0;Z < this.points.length; Z++)
            J.push(this.points[Z].x), J.push(this.points[Z].y);
          return { type: this.type, points: J };
        } });
        K.fromJSON = function(J) {
          return new K(J.points);
        }, M.exports = K;
      }, 25410: (M, B, $) => {
        M.exports = { Path: $(46669), MoveTo: $(68618), CubicBezier: $(46728), Curve: $(80021), Ellipse: $(73825), Line: $(33951), QuadraticBezier: $(14744), Spline: $(42534) };
      }, 68618: (M, B, $) => {
        var E = $(83419), L = $(26099), z = new E({ initialize: function U(K, J) {
          this.active = false, this.p0 = new L(K, J);
        }, getPoint: function(U, K) {
          if (K === undefined)
            K = new L;
          return K.copy(this.p0);
        }, getPointAt: function(U, K) {
          return this.getPoint(U, K);
        }, getResolution: function() {
          return 1;
        }, getLength: function() {
          return 0;
        }, toJSON: function() {
          return { type: "MoveTo", points: [this.p0.x, this.p0.y] };
        } });
        M.exports = z;
      }, 46669: (M, B, $) => {
        var E = $(83419), L = $(46728), z = $(73825), U = $(39429), K = $(33951), J = $(68618), Z = $(14744), D = $(87841), Q = $(42534), H = $(26099), N = $(36383), W = new E({ initialize: function R(Y, I) {
          if (Y === undefined)
            Y = 0;
          if (I === undefined)
            I = 0;
          if (this.name = "", this.defaultDivisions = 12, this.curves = [], this.cacheLengths = [], this.autoClose = false, this.startPoint = new H, this._tmpVec2A = new H, this._tmpVec2B = new H, typeof Y === "object")
            this.fromJSON(Y);
          else
            this.startPoint.set(Y, I);
        }, add: function(R) {
          return this.curves.push(R), this;
        }, circleTo: function(R, Y, I) {
          if (Y === undefined)
            Y = false;
          return this.ellipseTo(R, R, 0, 360, Y, I);
        }, closePath: function() {
          var R = this.curves[0].getPoint(0), Y = this.curves[this.curves.length - 1].getPoint(1);
          if (!R.equals(Y))
            this.curves.push(new K(Y, R));
          return this;
        }, cubicBezierTo: function(R, Y, I, P, X, G) {
          var V = this.getEndPoint(), A, F, j;
          if (R instanceof H)
            A = R, F = Y, j = I;
          else
            A = new H(I, P), F = new H(X, G), j = new H(R, Y);
          return this.add(new L(V, A, F, j));
        }, quadraticBezierTo: function(R, Y, I, P) {
          var X = this.getEndPoint(), G, V;
          if (R instanceof H)
            G = R, V = Y;
          else
            G = new H(I, P), V = new H(R, Y);
          return this.add(new Z(X, G, V));
        }, draw: function(R, Y) {
          for (var I = 0;I < this.curves.length; I++) {
            var P = this.curves[I];
            if (!P.active)
              continue;
            P.draw(R, Y);
          }
          return R;
        }, ellipseTo: function(R, Y, I, P, X, G) {
          var V = new z(0, 0, R, Y, I, P, X, G), A = this.getEndPoint(this._tmpVec2A), F = V.getStartPoint(this._tmpVec2B);
          return A.subtract(F), V.x = A.x, V.y = A.y, this.add(V);
        }, fromJSON: function(R) {
          this.curves = [], this.cacheLengths = [], this.startPoint.set(R.x, R.y), this.autoClose = R.autoClose;
          for (var Y = 0;Y < R.curves.length; Y++) {
            var I = R.curves[Y];
            switch (I.type) {
              case "LineCurve":
                this.add(K.fromJSON(I));
                break;
              case "EllipseCurve":
                this.add(z.fromJSON(I));
                break;
              case "SplineCurve":
                this.add(Q.fromJSON(I));
                break;
              case "CubicBezierCurve":
                this.add(L.fromJSON(I));
                break;
              case "QuadraticBezierCurve":
                this.add(Z.fromJSON(I));
                break;
            }
          }
          return this;
        }, getBounds: function(R, Y) {
          if (R === undefined)
            R = new D;
          if (Y === undefined)
            Y = 16;
          R.x = Number.MAX_VALUE, R.y = Number.MAX_VALUE;
          var I = new D, P = N.MIN_SAFE_INTEGER, X = N.MIN_SAFE_INTEGER;
          for (var G = 0;G < this.curves.length; G++) {
            var V = this.curves[G];
            if (!V.active)
              continue;
            V.getBounds(I, Y), R.x = Math.min(R.x, I.x), R.y = Math.min(R.y, I.y), P = Math.max(P, I.right), X = Math.max(X, I.bottom);
          }
          return R.right = P, R.bottom = X, R;
        }, getCurveLengths: function() {
          if (this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
          var R = [], Y = 0;
          for (var I = 0;I < this.curves.length; I++)
            Y += this.curves[I].getLength(), R.push(Y);
          return this.cacheLengths = R, R;
        }, getCurveAt: function(R) {
          var Y = R * this.getLength(), I = this.getCurveLengths(), P = 0;
          while (P < I.length) {
            if (I[P] >= Y)
              return this.curves[P];
            P++;
          }
          return null;
        }, getEndPoint: function(R) {
          if (R === undefined)
            R = new H;
          if (this.curves.length > 0)
            this.curves[this.curves.length - 1].getPoint(1, R);
          else
            R.copy(this.startPoint);
          return R;
        }, getLength: function() {
          var R = this.getCurveLengths();
          return R[R.length - 1];
        }, getPoint: function(R, Y) {
          if (Y === undefined)
            Y = new H;
          var I = R * this.getLength(), P = this.getCurveLengths(), X = 0;
          while (X < P.length) {
            if (P[X] >= I) {
              var G = P[X] - I, V = this.curves[X], A = V.getLength(), F = A === 0 ? 0 : 1 - G / A;
              return V.getPointAt(F, Y);
            }
            X++;
          }
          return null;
        }, getPoints: function(R, Y) {
          if (!R && !Y)
            R = this.defaultDivisions;
          var I = [], P;
          for (var X = 0;X < this.curves.length; X++) {
            var G = this.curves[X];
            if (!G.active)
              continue;
            var V = G.getResolution(R), A = G.getPoints(V, Y);
            for (var F = 0;F < A.length; F++) {
              var j = A[F];
              if (P && P.equals(j))
                continue;
              I.push(j), P = j;
            }
          }
          if (this.autoClose && I.length > 1 && !I[I.length - 1].equals(I[0]))
            I.push(I[0]);
          return I;
        }, getRandomPoint: function(R) {
          if (R === undefined)
            R = new H;
          return this.getPoint(Math.random(), R);
        }, getSpacedPoints: function(R) {
          if (R === undefined)
            R = 40;
          var Y = [];
          for (var I = 0;I <= R; I++)
            Y.push(this.getPoint(I / R));
          if (this.autoClose)
            Y.push(Y[0]);
          return Y;
        }, getStartPoint: function(R) {
          if (R === undefined)
            R = new H;
          return R.copy(this.startPoint);
        }, getTangent: function(R, Y) {
          if (Y === undefined)
            Y = new H;
          var I = R * this.getLength(), P = this.getCurveLengths(), X = 0;
          while (X < P.length) {
            if (P[X] >= I) {
              var G = P[X] - I, V = this.curves[X], A = V.getLength(), F = A === 0 ? 0 : 1 - G / A;
              return V.getTangentAt(F, Y);
            }
            X++;
          }
          return null;
        }, lineTo: function(R, Y) {
          if (R instanceof H)
            this._tmpVec2B.copy(R);
          else if (typeof R === "object")
            this._tmpVec2B.setFromObject(R);
          else
            this._tmpVec2B.set(R, Y);
          var I = this.getEndPoint(this._tmpVec2A);
          return this.add(new K([I.x, I.y, this._tmpVec2B.x, this._tmpVec2B.y]));
        }, splineTo: function(R) {
          return R.unshift(this.getEndPoint()), this.add(new Q(R));
        }, moveTo: function(R, Y) {
          if (R instanceof H)
            return this.add(new J(R.x, R.y));
          else
            return this.add(new J(R, Y));
        }, toJSON: function() {
          var R = [];
          for (var Y = 0;Y < this.curves.length; Y++)
            R.push(this.curves[Y].toJSON());
          return { type: "Path", x: this.startPoint.x, y: this.startPoint.y, autoClose: this.autoClose, curves: R };
        }, updateArcLengths: function() {
          this.cacheLengths = [], this.getCurveLengths();
        }, destroy: function() {
          this.curves.length = 0, this.cacheLengths.length = 0, this.startPoint = undefined;
        } });
        U.register("path", function(R, Y) {
          return new W(R, Y);
        }), M.exports = W;
      }, 45893: (M, B, $) => {
        var E = $(83419), L = $(24882), z = new E({ initialize: function U(K, J) {
          if (this.parent = K, this.events = J, !J)
            this.events = K.events ? K.events : K;
          if (this.list = {}, this.values = {}, this._frozen = false, !K.hasOwnProperty("sys") && this.events)
            this.events.once(L.DESTROY, this.destroy, this);
        }, get: function(U) {
          var K = this.list;
          if (Array.isArray(U)) {
            var J = [];
            for (var Z = 0;Z < U.length; Z++)
              J.push(K[U[Z]]);
            return J;
          } else
            return K[U];
        }, getAll: function() {
          var U = {};
          for (var K in this.list)
            if (this.list.hasOwnProperty(K))
              U[K] = this.list[K];
          return U;
        }, query: function(U) {
          var K = {};
          for (var J in this.list)
            if (this.list.hasOwnProperty(J) && J.match(U))
              K[J] = this.list[J];
          return K;
        }, set: function(U, K) {
          if (this._frozen)
            return this;
          if (typeof U === "string")
            return this.setValue(U, K);
          else
            for (var J in U)
              this.setValue(J, U[J]);
          return this;
        }, inc: function(U, K) {
          if (this._frozen)
            return this;
          if (K === undefined)
            K = 1;
          var J = this.get(U);
          if (J === undefined)
            J = 0;
          return this.set(U, J + K), this;
        }, toggle: function(U) {
          if (this._frozen)
            return this;
          return this.set(U, !this.get(U)), this;
        }, setValue: function(U, K) {
          if (this._frozen)
            return this;
          if (this.has(U))
            this.values[U] = K;
          else {
            var J = this, Z = this.list, D = this.events, Q = this.parent;
            Object.defineProperty(this.values, U, { enumerable: true, configurable: true, get: function() {
              return Z[U];
            }, set: function(H) {
              if (!J._frozen) {
                var N = Z[U];
                Z[U] = H, D.emit(L.CHANGE_DATA, Q, U, H, N), D.emit(L.CHANGE_DATA_KEY + U, Q, H, N);
              }
            } }), Z[U] = K, D.emit(L.SET_DATA, Q, U, K);
          }
          return this;
        }, each: function(U, K) {
          var J = [this.parent, null, undefined];
          for (var Z = 1;Z < arguments.length; Z++)
            J.push(arguments[Z]);
          for (var D in this.list)
            J[1] = D, J[2] = this.list[D], U.apply(K, J);
          return this;
        }, merge: function(U, K) {
          if (K === undefined)
            K = true;
          for (var J in U)
            if (U.hasOwnProperty(J) && (K || !K && !this.has(J)))
              this.setValue(J, U[J]);
          return this;
        }, remove: function(U) {
          if (this._frozen)
            return this;
          if (Array.isArray(U))
            for (var K = 0;K < U.length; K++)
              this.removeValue(U[K]);
          else
            return this.removeValue(U);
          return this;
        }, removeValue: function(U) {
          if (this.has(U)) {
            var K = this.list[U];
            delete this.list[U], delete this.values[U], this.events.emit(L.REMOVE_DATA, this.parent, U, K);
          }
          return this;
        }, pop: function(U) {
          var K = undefined;
          if (!this._frozen && this.has(U))
            K = this.list[U], delete this.list[U], delete this.values[U], this.events.emit(L.REMOVE_DATA, this.parent, U, K);
          return K;
        }, has: function(U) {
          return this.list.hasOwnProperty(U);
        }, setFreeze: function(U) {
          return this._frozen = U, this;
        }, reset: function() {
          for (var U in this.list)
            delete this.list[U], delete this.values[U];
          return this._frozen = false, this;
        }, destroy: function() {
          this.reset(), this.events.off(L.CHANGE_DATA), this.events.off(L.SET_DATA), this.events.off(L.REMOVE_DATA), this.parent = null;
        }, freeze: { get: function() {
          return this._frozen;
        }, set: function(U) {
          this._frozen = U ? true : false;
        } }, count: { get: function() {
          var U = 0;
          for (var K in this.list)
            if (this.list[K] !== undefined)
              U++;
          return U;
        } } });
        M.exports = z;
      }, 63646: (M, B, $) => {
        var E = $(83419), L = $(45893), z = $(37277), U = $(44594), K = new E({ Extends: L, initialize: function J(Z) {
          L.call(this, Z, Z.sys.events), this.scene = Z, this.systems = Z.sys, Z.sys.events.once(U.BOOT, this.boot, this), Z.sys.events.on(U.START, this.start, this);
        }, boot: function() {
          this.events = this.systems.events, this.events.once(U.DESTROY, this.destroy, this);
        }, start: function() {
          this.events.once(U.SHUTDOWN, this.shutdown, this);
        }, shutdown: function() {
          this.systems.events.off(U.SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          L.prototype.destroy.call(this), this.events.off(U.START, this.start, this), this.scene = null, this.systems = null;
        } });
        z.register("DataManagerPlugin", K, "data"), M.exports = K;
      }, 10700: (M) => {
        M.exports = "changedata";
      }, 93608: (M) => {
        M.exports = "changedata-";
      }, 60883: (M) => {
        M.exports = "destroy";
      }, 69780: (M) => {
        M.exports = "removedata";
      }, 22166: (M) => {
        M.exports = "setdata";
      }, 24882: (M, B, $) => {
        M.exports = { CHANGE_DATA: $(10700), CHANGE_DATA_KEY: $(93608), DESTROY: $(60883), REMOVE_DATA: $(69780), SET_DATA: $(22166) };
      }, 44965: (M, B, $) => {
        M.exports = { DataManager: $(45893), DataManagerPlugin: $(63646), Events: $(24882) };
      }, 7098: (M, B, $) => {
        var E = $(84148), L = { flac: false, aac: false, audioData: false, dolby: false, m4a: false, mp3: false, ogg: false, opus: false, wav: false, webAudio: false, webm: false };
        function z() {
          if (typeof importScripts === "function")
            return L;
          L.audioData = !!window.Audio, L.webAudio = !!(window.AudioContext || window.webkitAudioContext);
          var U = document.createElement("audio"), K = !!U.canPlayType;
          try {
            if (K) {
              var J = function(Q, H) {
                var N = U.canPlayType("audio/" + Q).replace(/^no$/, "");
                if (H)
                  return Boolean(N || U.canPlayType("audio/" + H).replace(/^no$/, ""));
                else
                  return Boolean(N);
              };
              if (L.ogg = J('ogg; codecs="vorbis"'), L.opus = J('ogg; codecs="opus"', "opus"), L.mp3 = J("mpeg"), L.wav = J("wav"), L.m4a = J("x-m4a"), L.aac = J("aac"), L.flac = J("flac", "x-flac"), L.webm = J('webm; codecs="vorbis"'), U.canPlayType('audio/mp4; codecs="ec-3"') !== "") {
                if (E.edge)
                  L.dolby = true;
                else if (E.safari && E.safariVersion >= 9) {
                  if (/Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                    var Z = parseInt(RegExp.$1, 10), D = parseInt(RegExp.$2, 10);
                    if (Z === 10 && D >= 11 || Z > 10)
                      L.dolby = true;
                  }
                }
              }
            }
          } catch (Q) {
          }
          return L;
        }
        M.exports = z();
      }, 84148: (M, B, $) => {
        var E = $(25892), L = { chrome: false, chromeVersion: 0, edge: false, firefox: false, firefoxVersion: 0, ie: false, ieVersion: 0, mobileSafari: false, opera: false, safari: false, safariVersion: 0, silk: false, trident: false, tridentVersion: 0, es2019: false };
        function z() {
          var U = navigator.userAgent;
          if (/Edg\/\d+/.test(U))
            L.edge = true, L.es2019 = true;
          else if (/OPR/.test(U))
            L.opera = true, L.es2019 = true;
          else if (/Chrome\/(\d+)/.test(U) && !E.windowsPhone)
            L.chrome = true, L.chromeVersion = parseInt(RegExp.$1, 10), L.es2019 = L.chromeVersion > 69;
          else if (/Firefox\D+(\d+)/.test(U))
            L.firefox = true, L.firefoxVersion = parseInt(RegExp.$1, 10), L.es2019 = L.firefoxVersion > 10;
          else if (/AppleWebKit\/(?!.*CriOS)/.test(U) && E.iOS)
            L.mobileSafari = true, L.es2019 = true;
          else if (/MSIE (\d+\.\d+);/.test(U))
            L.ie = true, L.ieVersion = parseInt(RegExp.$1, 10);
          else if (/Version\/(\d+\.\d+(\.\d+)?) Safari/.test(U) && !E.windowsPhone)
            L.safari = true, L.safariVersion = parseInt(RegExp.$1, 10), L.es2019 = L.safariVersion > 10;
          else if (/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(U))
            L.ie = true, L.trident = true, L.tridentVersion = parseInt(RegExp.$1, 10), L.ieVersion = parseInt(RegExp.$3, 10);
          if (/Silk/.test(U))
            L.silk = true;
          return L;
        }
        M.exports = z();
      }, 89289: (M, B, $) => {
        var E = $(27919), L = { supportInverseAlpha: false, supportNewBlendModes: false };
        function z() {
          var J = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/", Z = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==", D = new Image;
          return D.onload = function() {
            var Q = new Image;
            Q.onload = function() {
              var H = E.create2D(Q, 6), N = H.getContext("2d", { willReadFrequently: true });
              if (N.globalCompositeOperation = "multiply", N.drawImage(D, 0, 0), N.drawImage(Q, 2, 0), !N.getImageData(2, 0, 1, 1))
                return false;
              var W = N.getImageData(2, 0, 1, 1).data;
              E.remove(Q), L.supportNewBlendModes = W[0] === 255 && W[1] === 0 && W[2] === 0;
            }, Q.src = J + "/wCKxvRF" + Z;
          }, D.src = J + "AP804Oa6" + Z, false;
        }
        function U() {
          var J = E.create2D(this, 2), Z = J.getContext("2d", { willReadFrequently: true });
          Z.fillStyle = "rgba(10, 20, 30, 0.5)", Z.fillRect(0, 0, 1, 1);
          var D = Z.getImageData(0, 0, 1, 1);
          if (D === null)
            return false;
          Z.putImageData(D, 1, 0);
          var Q = Z.getImageData(1, 0, 1, 1), H = Q.data[0] === D.data[0] && Q.data[1] === D.data[1] && Q.data[2] === D.data[2] && Q.data[3] === D.data[3];
          return E.remove(this), H;
        }
        function K() {
          if (typeof importScripts !== "function" && document !== undefined)
            L.supportNewBlendModes = z(), L.supportInverseAlpha = U();
          return L;
        }
        M.exports = K();
      }, 89357: (M, B, $) => {
        var E = $(25892), L = $(84148), z = $(27919), U = { canvas: false, canvasBitBltShift: null, file: false, fileSystem: false, getUserMedia: true, littleEndian: false, localStorage: false, pointerLock: false, stableSort: false, support32bit: false, vibration: false, webGL: false, worker: false };
        function K() {
          var Z = new ArrayBuffer(4), D = new Uint8Array(Z), Q = new Uint32Array(Z);
          if (D[0] = 161, D[1] = 178, D[2] = 195, D[3] = 212, Q[0] === 3569595041)
            return true;
          if (Q[0] === 2712847316)
            return false;
          else
            return null;
        }
        function J() {
          if (typeof importScripts === "function")
            return U;
          U.canvas = !!window.CanvasRenderingContext2D;
          try {
            U.localStorage = !!localStorage.getItem;
          } catch (Q) {
            U.localStorage = false;
          }
          U.file = !!window.File && !!window.FileReader && !!window.FileList && !!window.Blob, U.fileSystem = !!window.requestFileSystem;
          var Z = false, D = function() {
            if (window.WebGLRenderingContext)
              try {
                var Q = z.createWebGL(this), H = Q.getContext("webgl") || Q.getContext("experimental-webgl"), N = z.create2D(this), W = N.getContext("2d", { willReadFrequently: true }), R = W.createImageData(1, 1);
                return Z = R.data instanceof Uint8ClampedArray, z.remove(Q), z.remove(N), !!H;
              } catch (Y) {
                return false;
              }
            return false;
          };
          if (U.webGL = D(), U.worker = !!window.Worker, U.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, U.getUserMedia = U.getUserMedia && !!navigator.getUserMedia && !!window.URL, L.firefox && L.firefoxVersion < 21)
            U.getUserMedia = false;
          if (!E.iOS && (L.ie || L.firefox || L.chrome))
            U.canvasBitBltShift = true;
          if (L.safari || L.mobileSafari)
            U.canvasBitBltShift = false;
          if (navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate)
            U.vibration = true;
          if (typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint32Array !== "undefined")
            U.littleEndian = K();
          return U.support32bit = typeof ArrayBuffer !== "undefined" && typeof Uint8ClampedArray !== "undefined" && typeof Int32Array !== "undefined" && U.littleEndian !== null && Z, U;
        }
        M.exports = J();
      }, 91639: (M) => {
        var B = { available: false, cancel: "", keyboard: false, request: "" };
        function $() {
          if (typeof importScripts === "function")
            return B;
          var E, L = "Fullscreen", z = "FullScreen", U = ["request" + L, "request" + z, "webkitRequest" + L, "webkitRequest" + z, "msRequest" + L, "msRequest" + z, "mozRequest" + z, "mozRequest" + L];
          for (E = 0;E < U.length; E++)
            if (document.documentElement[U[E]]) {
              B.available = true, B.request = U[E];
              break;
            }
          var K = ["cancel" + z, "exit" + L, "webkitCancel" + z, "webkitExit" + L, "msCancel" + z, "msExit" + L, "mozCancel" + z, "mozExit" + L];
          if (B.available) {
            for (E = 0;E < K.length; E++)
              if (document[K[E]]) {
                B.cancel = K[E];
                break;
              }
          }
          if (window.Element && Element.ALLOW_KEYBOARD_INPUT && !/ Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent))
            B.keyboard = true;
          return Object.defineProperty(B, "active", { get: function() {
            return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
          } }), B;
        }
        M.exports = $();
      }, 31784: (M, B, $) => {
        var E = $(84148), L = { gamepads: false, mspointer: false, touch: false, wheelEvent: null };
        function z() {
          if (typeof importScripts === "function")
            return L;
          if ("ontouchstart" in document.documentElement || navigator.maxTouchPoints && navigator.maxTouchPoints >= 1)
            L.touch = true;
          if (navigator.msPointerEnabled || navigator.pointerEnabled)
            L.mspointer = true;
          if (navigator.getGamepads)
            L.gamepads = true;
          if ("onwheel" in window || E.ie && "WheelEvent" in window)
            L.wheelEvent = "wheel";
          else if ("onmousewheel" in window)
            L.wheelEvent = "mousewheel";
          else if (E.firefox && "MouseScrollEvent" in window)
            L.wheelEvent = "DOMMouseScroll";
          return L;
        }
        M.exports = z();
      }, 25892: (M) => {
        var B = { android: false, chromeOS: false, cordova: false, crosswalk: false, desktop: false, ejecta: false, electron: false, iOS: false, iOSVersion: 0, iPad: false, iPhone: false, kindle: false, linux: false, macOS: false, node: false, nodeWebkit: false, pixelRatio: 1, webApp: false, windows: false, windowsPhone: false };
        function $() {
          if (typeof importScripts === "function")
            return B;
          var E = navigator.userAgent;
          if (/Windows/.test(E))
            B.windows = true;
          else if (/Mac OS/.test(E) && !/like Mac OS/.test(E))
            if (navigator.maxTouchPoints && navigator.maxTouchPoints > 2)
              B.iOS = true, B.iPad = true, navigator.appVersion.match(/Version\/(\d+)/), B.iOSVersion = parseInt(RegExp.$1, 10);
            else
              B.macOS = true;
          else if (/Android/.test(E))
            B.android = true;
          else if (/Linux/.test(E))
            B.linux = true;
          else if (/iP[ao]d|iPhone/i.test(E))
            B.iOS = true, navigator.appVersion.match(/OS (\d+)/), B.iOSVersion = parseInt(RegExp.$1, 10), B.iPhone = E.toLowerCase().indexOf("iphone") !== -1, B.iPad = E.toLowerCase().indexOf("ipad") !== -1;
          else if (/Kindle/.test(E) || /\bKF[A-Z][A-Z]+/.test(E) || /Silk.*Mobile Safari/.test(E))
            B.kindle = true;
          else if (/CrOS/.test(E))
            B.chromeOS = true;
          if (/Windows Phone/i.test(E) || /IEMobile/i.test(E))
            B.android = false, B.iOS = false, B.macOS = false, B.windows = true, B.windowsPhone = true;
          var L = /Silk/.test(E);
          if (B.windows || B.macOS || B.linux && !L || B.chromeOS)
            B.desktop = true;
          if (B.windowsPhone || /Windows NT/i.test(E) && /Touch/i.test(E))
            B.desktop = false;
          if (navigator.standalone)
            B.webApp = true;
          if (typeof importScripts !== "function") {
            if (window.cordova !== undefined)
              B.cordova = true;
            if (window.ejecta !== undefined)
              B.ejecta = true;
          }
          if (typeof process !== "undefined" && process.versions && process.versions.node)
            B.node = true;
          if (B.node && typeof process.versions === "object")
            B.nodeWebkit = !!process.versions["node-webkit"], B.electron = !!process.versions.electron;
          if (/Crosswalk/.test(E))
            B.crosswalk = true;
          return B.pixelRatio = window.devicePixelRatio || 1, B;
        }
        M.exports = $();
      }, 43267: (M, B, $) => {
        var E = $(95540), L = { h264: false, hls: false, mp4: false, m4v: false, ogg: false, vp9: false, webm: false, hasRequestVideoFrame: false };
        function z() {
          if (typeof importScripts === "function")
            return L;
          var U = document.createElement("video"), K = !!U.canPlayType, J = /^no$/;
          try {
            if (K) {
              if (U.canPlayType('video/ogg; codecs="theora"').replace(J, ""))
                L.ogg = true;
              if (U.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(J, ""))
                L.h264 = true, L.mp4 = true;
              if (U.canPlayType("video/x-m4v").replace(J, ""))
                L.m4v = true;
              if (U.canPlayType('video/webm; codecs="vp8, vorbis"').replace(J, ""))
                L.webm = true;
              if (U.canPlayType('video/webm; codecs="vp9"').replace(J, ""))
                L.vp9 = true;
              if (U.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(J, ""))
                L.hls = true;
            }
          } catch (Z) {
          }
          if (U.parentNode)
            U.parentNode.removeChild(U);
          return L.getVideoURL = function(Z) {
            if (!Array.isArray(Z))
              Z = [Z];
            for (var D = 0;D < Z.length; D++) {
              var Q = E(Z[D], "url", Z[D]);
              if (Q.indexOf("blob:") === 0)
                return { url: Q, type: "" };
              var H;
              if (Q.indexOf("data:") === 0)
                H = Q.split(",")[0].match(/\/(.*?);/);
              else
                H = Q.match(/\.([a-zA-Z0-9]+)($|\?)/);
              if (H = E(Z[D], "type", H ? H[1] : "").toLowerCase(), L[H])
                return { url: Q, type: H };
            }
            return null;
          }, L;
        }
        M.exports = z();
      }, 82264: (M, B, $) => {
        M.exports = { os: $(25892), browser: $(84148), features: $(89357), input: $(31784), audio: $(7098), video: $(43267), fullscreen: $(91639), canvasFeatures: $(89289) };
      }, 89422: (M, B, $) => {
        var E = $(83419), L = new Float32Array(20), z = new E({ initialize: function U() {
          this._matrix = new Float32Array(20), this.alpha = 1, this._dirty = true, this._data = new Float32Array(20), this.reset();
        }, set: function(U) {
          return this._matrix.set(U), this._dirty = true, this;
        }, reset: function() {
          var U = this._matrix;
          return U.fill(0), U[0] = 1, U[6] = 1, U[12] = 1, U[18] = 1, this.alpha = 1, this._dirty = true, this;
        }, getData: function() {
          var U = this._data;
          if (this._dirty)
            U.set(this._matrix), U[4] /= 255, U[9] /= 255, U[14] /= 255, U[19] /= 255, this._dirty = false;
          return U;
        }, brightness: function(U, K) {
          if (U === undefined)
            U = 0;
          if (K === undefined)
            K = false;
          var J = U;
          return this.multiply([J, 0, 0, 0, 0, 0, J, 0, 0, 0, 0, 0, J, 0, 0, 0, 0, 0, 1, 0], K);
        }, saturate: function(U, K) {
          if (U === undefined)
            U = 0;
          if (K === undefined)
            K = false;
          var J = U * 2 / 3 + 1, Z = (J - 1) * -0.5;
          return this.multiply([J, Z, Z, 0, 0, Z, J, Z, 0, 0, Z, Z, J, 0, 0, 0, 0, 0, 1, 0], K);
        }, desaturate: function(U) {
          if (U === undefined)
            U = false;
          return this.saturate(-1, U);
        }, hue: function(U, K) {
          if (U === undefined)
            U = 0;
          if (K === undefined)
            K = false;
          U = U / 180 * Math.PI;
          var J = Math.cos(U), Z = Math.sin(U), D = 0.213, Q = 0.715, H = 0.072;
          return this.multiply([D + J * (1 - D) + Z * -D, Q + J * -Q + Z * -Q, H + J * -H + Z * (1 - H), 0, 0, D + J * -D + Z * 0.143, Q + J * (1 - Q) + Z * 0.14, H + J * -H + Z * -0.283, 0, 0, D + J * -D + Z * -(1 - D), Q + J * -Q + Z * Q, H + J * (1 - H) + Z * H, 0, 0, 0, 0, 0, 1, 0], K);
        }, grayscale: function(U, K) {
          if (U === undefined)
            U = 1;
          if (K === undefined)
            K = false;
          return this.saturate(-U, K);
        }, blackWhite: function(U) {
          if (U === undefined)
            U = false;
          return this.multiply(z.BLACK_WHITE, U);
        }, contrast: function(U, K) {
          if (U === undefined)
            U = 0;
          if (K === undefined)
            K = false;
          var J = U + 1, Z = -0.5 * (J - 1);
          return this.multiply([J, 0, 0, 0, Z, 0, J, 0, 0, Z, 0, 0, J, 0, Z, 0, 0, 0, 1, 0], K);
        }, negative: function(U) {
          if (U === undefined)
            U = false;
          return this.multiply(z.NEGATIVE, U);
        }, desaturateLuminance: function(U) {
          if (U === undefined)
            U = false;
          return this.multiply(z.DESATURATE_LUMINANCE, U);
        }, sepia: function(U) {
          if (U === undefined)
            U = false;
          return this.multiply(z.SEPIA, U);
        }, night: function(U, K) {
          if (U === undefined)
            U = 0.1;
          if (K === undefined)
            K = false;
          return this.multiply([U * -2, -U, 0, 0, 0, -U, 0, U, 0, 0, 0, U, U * 2, 0, 0, 0, 0, 0, 1, 0], K);
        }, lsd: function(U) {
          if (U === undefined)
            U = false;
          return this.multiply(z.LSD, U);
        }, brown: function(U) {
          if (U === undefined)
            U = false;
          return this.multiply(z.BROWN, U);
        }, vintagePinhole: function(U) {
          if (U === undefined)
            U = false;
          return this.multiply(z.VINTAGE, U);
        }, kodachrome: function(U) {
          if (U === undefined)
            U = false;
          return this.multiply(z.KODACHROME, U);
        }, technicolor: function(U) {
          if (U === undefined)
            U = false;
          return this.multiply(z.TECHNICOLOR, U);
        }, polaroid: function(U) {
          if (U === undefined)
            U = false;
          return this.multiply(z.POLAROID, U);
        }, shiftToBGR: function(U) {
          if (U === undefined)
            U = false;
          return this.multiply(z.SHIFT_BGR, U);
        }, multiply: function(U, K) {
          if (K === undefined)
            K = false;
          if (!K)
            this.reset();
          var J = this._matrix, Z = L;
          return Z.set(J), J.set([Z[0] * U[0] + Z[1] * U[5] + Z[2] * U[10] + Z[3] * U[15], Z[0] * U[1] + Z[1] * U[6] + Z[2] * U[11] + Z[3] * U[16], Z[0] * U[2] + Z[1] * U[7] + Z[2] * U[12] + Z[3] * U[17], Z[0] * U[3] + Z[1] * U[8] + Z[2] * U[13] + Z[3] * U[18], Z[0] * U[4] + Z[1] * U[9] + Z[2] * U[14] + Z[3] * U[19] + Z[4], Z[5] * U[0] + Z[6] * U[5] + Z[7] * U[10] + Z[8] * U[15], Z[5] * U[1] + Z[6] * U[6] + Z[7] * U[11] + Z[8] * U[16], Z[5] * U[2] + Z[6] * U[7] + Z[7] * U[12] + Z[8] * U[17], Z[5] * U[3] + Z[6] * U[8] + Z[7] * U[13] + Z[8] * U[18], Z[5] * U[4] + Z[6] * U[9] + Z[7] * U[14] + Z[8] * U[19] + Z[9], Z[10] * U[0] + Z[11] * U[5] + Z[12] * U[10] + Z[13] * U[15], Z[10] * U[1] + Z[11] * U[6] + Z[12] * U[11] + Z[13] * U[16], Z[10] * U[2] + Z[11] * U[7] + Z[12] * U[12] + Z[13] * U[17], Z[10] * U[3] + Z[11] * U[8] + Z[12] * U[13] + Z[13] * U[18], Z[10] * U[4] + Z[11] * U[9] + Z[12] * U[14] + Z[13] * U[19] + Z[14], Z[15] * U[0] + Z[16] * U[5] + Z[17] * U[10] + Z[18] * U[15], Z[15] * U[1] + Z[16] * U[6] + Z[17] * U[11] + Z[18] * U[16], Z[15] * U[2] + Z[16] * U[7] + Z[17] * U[12] + Z[18] * U[17], Z[15] * U[3] + Z[16] * U[8] + Z[17] * U[13] + Z[18] * U[18], Z[15] * U[4] + Z[16] * U[9] + Z[17] * U[14] + Z[18] * U[19] + Z[19]]), this._dirty = true, this;
        } });
        z.BLACK_WHITE = [0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0], z.NEGATIVE = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], z.DESATURATE_LUMINANCE = [0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0, 0, 0, 1, 0], z.SEPIA = [0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0], z.LSD = [2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0], z.BROWN = [0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], z.VINTAGE = [0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], z.KODACHROME = [1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], z.TECHNICOLOR = [1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], z.POLAROID = [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0], z.SHIFT_BGR = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], M.exports = z;
      }, 51767: (M, B, $) => {
        var E = $(83419), L = $(29747), z = new E({ initialize: function U(K, J, Z) {
          this._rgb = [0, 0, 0], this.onChangeCallback = L, this.dirty = false, this.set(K, J, Z);
        }, set: function(U, K, J) {
          if (U === undefined)
            U = 0;
          if (K === undefined)
            K = 0;
          if (J === undefined)
            J = 0;
          return this._rgb = [U, K, J], this.onChange(), this;
        }, equals: function(U, K, J) {
          var Z = this._rgb;
          return Z[0] === U && Z[1] === K && Z[2] === J;
        }, onChange: function() {
          this.dirty = true;
          var U = this._rgb;
          this.onChangeCallback.call(this, U[0], U[1], U[2]);
        }, r: { get: function() {
          return this._rgb[0];
        }, set: function(U) {
          this._rgb[0] = U, this.onChange();
        } }, g: { get: function() {
          return this._rgb[1];
        }, set: function(U) {
          this._rgb[1] = U, this.onChange();
        } }, b: { get: function() {
          return this._rgb[2];
        }, set: function(U) {
          this._rgb[2] = U, this.onChange();
        } }, destroy: function() {
          this.onChangeCallback = null;
        } });
        M.exports = z;
      }, 60461: (M) => {
        var B = { TOP_LEFT: 0, TOP_CENTER: 1, TOP_RIGHT: 2, LEFT_TOP: 3, LEFT_CENTER: 4, LEFT_BOTTOM: 5, CENTER: 6, RIGHT_TOP: 7, RIGHT_CENTER: 8, RIGHT_BOTTOM: 9, BOTTOM_LEFT: 10, BOTTOM_CENTER: 11, BOTTOM_RIGHT: 12 };
        M.exports = B;
      }, 54312: (M, B, $) => {
        var E = $(62235), L = $(35893), z = $(86327), U = $(88417), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return U(J, L(Z) + D), z(J, E(Z) + Q), J;
        };
        M.exports = K;
      }, 46768: (M, B, $) => {
        var E = $(62235), L = $(26541), z = $(86327), U = $(385), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return U(J, L(Z) - D), z(J, E(Z) + Q), J;
        };
        M.exports = K;
      }, 35827: (M, B, $) => {
        var E = $(62235), L = $(54380), z = $(86327), U = $(40136), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return U(J, L(Z) + D), z(J, E(Z) + Q), J;
        };
        M.exports = K;
      }, 46871: (M, B, $) => {
        var E = $(66786), L = $(35893), z = $(7702), U = function(K, J, Z, D) {
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = 0;
          return E(K, L(J) + Z, z(J) + D), K;
        };
        M.exports = U;
      }, 5198: (M, B, $) => {
        var E = $(7702), L = $(26541), z = $(20786), U = $(385), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return U(J, L(Z) - D), z(J, E(Z) + Q), J;
        };
        M.exports = K;
      }, 11879: (M, B, $) => {
        var E = $(60461), L = [];
        L[E.BOTTOM_CENTER] = $(54312), L[E.BOTTOM_LEFT] = $(46768), L[E.BOTTOM_RIGHT] = $(35827), L[E.CENTER] = $(46871), L[E.LEFT_CENTER] = $(5198), L[E.RIGHT_CENTER] = $(80503), L[E.TOP_CENTER] = $(89698), L[E.TOP_LEFT] = $(922), L[E.TOP_RIGHT] = $(21373), L[E.LEFT_BOTTOM] = L[E.BOTTOM_LEFT], L[E.LEFT_TOP] = L[E.TOP_LEFT], L[E.RIGHT_BOTTOM] = L[E.BOTTOM_RIGHT], L[E.RIGHT_TOP] = L[E.TOP_RIGHT];
        var z = function(U, K, J, Z, D) {
          return L[J](U, K, Z, D);
        };
        M.exports = z;
      }, 80503: (M, B, $) => {
        var E = $(7702), L = $(54380), z = $(20786), U = $(40136), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return U(J, L(Z) + D), z(J, E(Z) + Q), J;
        };
        M.exports = K;
      }, 89698: (M, B, $) => {
        var E = $(35893), L = $(17717), z = $(88417), U = $(66737), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return z(J, E(Z) + D), U(J, L(Z) - Q), J;
        };
        M.exports = K;
      }, 922: (M, B, $) => {
        var E = $(26541), L = $(17717), z = $(385), U = $(66737), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return z(J, E(Z) - D), U(J, L(Z) - Q), J;
        };
        M.exports = K;
      }, 21373: (M, B, $) => {
        var E = $(54380), L = $(17717), z = $(40136), U = $(66737), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return z(J, E(Z) + D), U(J, L(Z) - Q), J;
        };
        M.exports = K;
      }, 91660: (M, B, $) => {
        M.exports = { BottomCenter: $(54312), BottomLeft: $(46768), BottomRight: $(35827), Center: $(46871), LeftCenter: $(5198), QuickSet: $(11879), RightCenter: $(80503), TopCenter: $(89698), TopLeft: $(922), TopRight: $(21373) };
      }, 71926: (M, B, $) => {
        var E = $(60461), L = $(79291), z = { In: $(91660), To: $(16694) };
        z = L(false, z, E), M.exports = z;
      }, 21578: (M, B, $) => {
        var E = $(62235), L = $(35893), z = $(88417), U = $(66737), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return z(J, L(Z) + D), U(J, E(Z) + Q), J;
        };
        M.exports = K;
      }, 10210: (M, B, $) => {
        var E = $(62235), L = $(26541), z = $(385), U = $(66737), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return z(J, L(Z) - D), U(J, E(Z) + Q), J;
        };
        M.exports = K;
      }, 82341: (M, B, $) => {
        var E = $(62235), L = $(54380), z = $(40136), U = $(66737), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return z(J, L(Z) + D), U(J, E(Z) + Q), J;
        };
        M.exports = K;
      }, 87958: (M, B, $) => {
        var E = $(62235), L = $(26541), z = $(86327), U = $(40136), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return U(J, L(Z) - D), z(J, E(Z) + Q), J;
        };
        M.exports = K;
      }, 40080: (M, B, $) => {
        var E = $(7702), L = $(26541), z = $(20786), U = $(40136), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return U(J, L(Z) - D), z(J, E(Z) + Q), J;
        };
        M.exports = K;
      }, 88466: (M, B, $) => {
        var E = $(26541), L = $(17717), z = $(40136), U = $(66737), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return z(J, E(Z) - D), U(J, L(Z) - Q), J;
        };
        M.exports = K;
      }, 38829: (M, B, $) => {
        var E = $(60461), L = [];
        L[E.BOTTOM_CENTER] = $(21578), L[E.BOTTOM_LEFT] = $(10210), L[E.BOTTOM_RIGHT] = $(82341), L[E.LEFT_BOTTOM] = $(87958), L[E.LEFT_CENTER] = $(40080), L[E.LEFT_TOP] = $(88466), L[E.RIGHT_BOTTOM] = $(19211), L[E.RIGHT_CENTER] = $(34609), L[E.RIGHT_TOP] = $(48741), L[E.TOP_CENTER] = $(49440), L[E.TOP_LEFT] = $(81288), L[E.TOP_RIGHT] = $(61323);
        var z = function(U, K, J, Z, D) {
          return L[J](U, K, Z, D);
        };
        M.exports = z;
      }, 19211: (M, B, $) => {
        var E = $(62235), L = $(54380), z = $(86327), U = $(385), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return U(J, L(Z) + D), z(J, E(Z) + Q), J;
        };
        M.exports = K;
      }, 34609: (M, B, $) => {
        var E = $(7702), L = $(54380), z = $(20786), U = $(385), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return U(J, L(Z) + D), z(J, E(Z) + Q), J;
        };
        M.exports = K;
      }, 48741: (M, B, $) => {
        var E = $(54380), L = $(17717), z = $(385), U = $(66737), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return z(J, E(Z) + D), U(J, L(Z) - Q), J;
        };
        M.exports = K;
      }, 49440: (M, B, $) => {
        var E = $(35893), L = $(17717), z = $(86327), U = $(88417), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return U(J, E(Z) + D), z(J, L(Z) - Q), J;
        };
        M.exports = K;
      }, 81288: (M, B, $) => {
        var E = $(26541), L = $(17717), z = $(86327), U = $(385), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return U(J, E(Z) - D), z(J, L(Z) - Q), J;
        };
        M.exports = K;
      }, 61323: (M, B, $) => {
        var E = $(54380), L = $(17717), z = $(86327), U = $(40136), K = function(J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          return U(J, E(Z) + D), z(J, L(Z) - Q), J;
        };
        M.exports = K;
      }, 16694: (M, B, $) => {
        M.exports = { BottomCenter: $(21578), BottomLeft: $(10210), BottomRight: $(82341), LeftBottom: $(87958), LeftCenter: $(40080), LeftTop: $(88466), QuickSet: $(38829), RightBottom: $(19211), RightCenter: $(34609), RightTop: $(48741), TopCenter: $(49440), TopLeft: $(81288), TopRight: $(61323) };
      }, 66786: (M, B, $) => {
        var E = $(88417), L = $(20786), z = function(U, K, J) {
          return E(U, K), L(U, J);
        };
        M.exports = z;
      }, 62235: (M) => {
        var B = function($) {
          return $.y + $.height - $.height * $.originY;
        };
        M.exports = B;
      }, 72873: (M, B, $) => {
        var E = $(62235), L = $(26541), z = $(54380), U = $(17717), K = $(87841), J = function(Z, D) {
          if (D === undefined)
            D = new K;
          var Q = L(Z), H = U(Z);
          return D.x = Q, D.y = H, D.width = z(Z) - Q, D.height = E(Z) - H, D;
        };
        M.exports = J;
      }, 35893: (M) => {
        var B = function($) {
          return $.x - $.width * $.originX + $.width * 0.5;
        };
        M.exports = B;
      }, 7702: (M) => {
        var B = function($) {
          return $.y - $.height * $.originY + $.height * 0.5;
        };
        M.exports = B;
      }, 26541: (M) => {
        var B = function($) {
          return $.x - $.width * $.originX;
        };
        M.exports = B;
      }, 87431: (M) => {
        var B = function($) {
          return $.width * $.originX;
        };
        M.exports = B;
      }, 46928: (M) => {
        var B = function($) {
          return $.height * $.originY;
        };
        M.exports = B;
      }, 54380: (M) => {
        var B = function($) {
          return $.x + $.width - $.width * $.originX;
        };
        M.exports = B;
      }, 17717: (M) => {
        var B = function($) {
          return $.y - $.height * $.originY;
        };
        M.exports = B;
      }, 86327: (M) => {
        var B = function($, E) {
          return $.y = E - $.height + $.height * $.originY, $;
        };
        M.exports = B;
      }, 88417: (M) => {
        var B = function($, E) {
          var L = $.width * $.originX;
          return $.x = E + L - $.width * 0.5, $;
        };
        M.exports = B;
      }, 20786: (M) => {
        var B = function($, E) {
          var L = $.height * $.originY;
          return $.y = E + L - $.height * 0.5, $;
        };
        M.exports = B;
      }, 385: (M) => {
        var B = function($, E) {
          return $.x = E + $.width * $.originX, $;
        };
        M.exports = B;
      }, 40136: (M) => {
        var B = function($, E) {
          return $.x = E - $.width + $.width * $.originX, $;
        };
        M.exports = B;
      }, 66737: (M) => {
        var B = function($, E) {
          return $.y = E + $.height * $.originY, $;
        };
        M.exports = B;
      }, 58724: (M, B, $) => {
        M.exports = { CenterOn: $(66786), GetBottom: $(62235), GetBounds: $(72873), GetCenterX: $(35893), GetCenterY: $(7702), GetLeft: $(26541), GetOffsetX: $(87431), GetOffsetY: $(46928), GetRight: $(54380), GetTop: $(17717), SetBottom: $(86327), SetCenterX: $(88417), SetCenterY: $(20786), SetLeft: $(385), SetRight: $(40136), SetTop: $(66737) };
      }, 20623: (M) => {
        var B = { setCrisp: function($) {
          var E = ["optimizeSpeed", "-moz-crisp-edges", "-o-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "crisp-edges", "pixelated"];
          return E.forEach(function(L) {
            $.style["image-rendering"] = L;
          }), $.style.msInterpolationMode = "nearest-neighbor", $;
        }, setBicubic: function($) {
          return $.style["image-rendering"] = "auto", $.style.msInterpolationMode = "bicubic", $;
        } };
        M.exports = B;
      }, 27919: (M, B, $) => {
        var E = $(8054), L = $(68703), z = [], U = false, K = function() {
          var J = function(I, P, X, G, V) {
            if (P === undefined)
              P = 1;
            if (X === undefined)
              X = 1;
            if (G === undefined)
              G = E.CANVAS;
            if (V === undefined)
              V = false;
            var A, F = Q(G);
            if (F === null) {
              if (F = { parent: I, canvas: document.createElement("canvas"), type: G }, G === E.CANVAS)
                z.push(F);
              A = F.canvas;
            } else
              F.parent = I, A = F.canvas;
            if (V)
              F.parent = A;
            if (A.width = P, A.height = X, U && G === E.CANVAS)
              L.disable(A.getContext("2d", { willReadFrequently: false }));
            return A;
          }, Z = function(I, P, X) {
            return J(I, P, X, E.CANVAS);
          }, D = function(I, P, X) {
            return J(I, P, X, E.WEBGL);
          }, Q = function(I) {
            if (I === undefined)
              I = E.CANVAS;
            if (I === E.WEBGL)
              return null;
            for (var P = 0;P < z.length; P++) {
              var X = z[P];
              if (!X.parent && X.type === I)
                return X;
            }
            return null;
          }, H = function(I) {
            var P = I instanceof HTMLCanvasElement;
            z.forEach(function(X) {
              if (P && X.canvas === I || !P && X.parent === I)
                X.parent = null, X.canvas.width = 1, X.canvas.height = 1;
            });
          }, N = function() {
            var I = 0;
            return z.forEach(function(P) {
              if (P.parent)
                I++;
            }), I;
          }, W = function() {
            return z.length - N();
          }, R = function() {
            U = true;
          }, Y = function() {
            U = false;
          };
          return { create2D: Z, create: J, createWebGL: D, disableSmoothing: R, enableSmoothing: Y, first: Q, free: W, pool: z, remove: H, total: N };
        };
        M.exports = K();
      }, 68703: (M) => {
        var B = "", $ = function() {
          var E = function(K) {
            var J = ["i", "webkitI", "msI", "mozI", "oI"];
            for (var Z = 0;Z < J.length; Z++) {
              var D = J[Z] + "mageSmoothingEnabled";
              if (D in K)
                return D;
            }
            return null;
          }, L = function(K) {
            if (B === "")
              B = E(K);
            if (B)
              K[B] = true;
            return K;
          }, z = function(K) {
            if (B === "")
              B = E(K);
            if (B)
              K[B] = false;
            return K;
          }, U = function(K) {
            return B !== null ? K[B] : null;
          };
          return { disable: z, enable: L, getPrefix: E, isEnabled: U };
        };
        M.exports = $();
      }, 65208: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = "none";
          return $.style.msTouchAction = E, $.style["ms-touch-action"] = E, $.style["touch-action"] = E, $;
        };
        M.exports = B;
      }, 91610: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = "none";
          var L = ["-webkit-", "-khtml-", "-moz-", "-ms-", ""];
          return L.forEach(function(z) {
            $.style[z + "user-select"] = E;
          }), $.style["-webkit-touch-callout"] = E, $.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", $;
        };
        M.exports = B;
      }, 26253: (M, B, $) => {
        M.exports = { CanvasInterpolation: $(20623), CanvasPool: $(27919), Smoothing: $(68703), TouchAction: $(65208), UserSelect: $(91610) };
      }, 40987: (M, B, $) => {
        var E = $(83419), L = $(37589), z = $(1000), U = $(7537), K = $(87837), J = new E({ initialize: function Z(D, Q, H, N) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = 255;
          this.r = 0, this.g = 0, this.b = 0, this.a = 255, this._h = 0, this._s = 0, this._v = 0, this._locked = false, this.gl = [0, 0, 0, 1], this._color = 0, this._color32 = 0, this._rgba = "", this.setTo(D, Q, H, N);
        }, transparent: function() {
          return this._locked = true, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this._locked = false, this.update(true);
        }, setTo: function(Z, D, Q, H, N) {
          if (H === undefined)
            H = 255;
          if (N === undefined)
            N = true;
          return this._locked = true, this.red = Z, this.green = D, this.blue = Q, this.alpha = H, this._locked = false, this.update(N);
        }, setGLTo: function(Z, D, Q, H) {
          if (H === undefined)
            H = 1;
          return this._locked = true, this.redGL = Z, this.greenGL = D, this.blueGL = Q, this.alphaGL = H, this._locked = false, this.update(true);
        }, setFromRGB: function(Z) {
          if (this._locked = true, this.red = Z.r, this.green = Z.g, this.blue = Z.b, Z.hasOwnProperty("a"))
            this.alpha = Z.a;
          return this._locked = false, this.update(true);
        }, setFromHSV: function(Z, D, Q) {
          return U(Z, D, Q, this);
        }, update: function(Z) {
          if (Z === undefined)
            Z = false;
          if (this._locked)
            return this;
          var D = this.r, Q = this.g, H = this.b, N = this.a;
          if (this._color = L(D, Q, H), this._color32 = z(D, Q, H, N), this._rgba = "rgba(" + D + "," + Q + "," + H + "," + N / 255 + ")", Z)
            K(D, Q, H, this);
          return this;
        }, updateHSV: function() {
          var Z = this.r, D = this.g, Q = this.b;
          return K(Z, D, Q, this), this;
        }, clone: function() {
          return new J(this.r, this.g, this.b, this.a);
        }, gray: function(Z) {
          return this.setTo(Z, Z, Z);
        }, random: function(Z, D) {
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = 255;
          var Q = Math.floor(Z + Math.random() * (D - Z)), H = Math.floor(Z + Math.random() * (D - Z)), N = Math.floor(Z + Math.random() * (D - Z));
          return this.setTo(Q, H, N);
        }, randomGray: function(Z, D) {
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = 255;
          var Q = Math.floor(Z + Math.random() * (D - Z));
          return this.setTo(Q, Q, Q);
        }, saturate: function(Z) {
          return this.s += Z / 100, this;
        }, desaturate: function(Z) {
          return this.s -= Z / 100, this;
        }, lighten: function(Z) {
          return this.v += Z / 100, this;
        }, darken: function(Z) {
          return this.v -= Z / 100, this;
        }, brighten: function(Z) {
          var D = this.r, Q = this.g, H = this.b;
          return D = Math.max(0, Math.min(255, D - Math.round(255 * -(Z / 100)))), Q = Math.max(0, Math.min(255, Q - Math.round(255 * -(Z / 100)))), H = Math.max(0, Math.min(255, H - Math.round(255 * -(Z / 100)))), this.setTo(D, Q, H);
        }, color: { get: function() {
          return this._color;
        } }, color32: { get: function() {
          return this._color32;
        } }, rgba: { get: function() {
          return this._rgba;
        } }, redGL: { get: function() {
          return this.gl[0];
        }, set: function(Z) {
          this.gl[0] = Math.min(Math.abs(Z), 1), this.r = Math.floor(this.gl[0] * 255), this.update(true);
        } }, greenGL: { get: function() {
          return this.gl[1];
        }, set: function(Z) {
          this.gl[1] = Math.min(Math.abs(Z), 1), this.g = Math.floor(this.gl[1] * 255), this.update(true);
        } }, blueGL: { get: function() {
          return this.gl[2];
        }, set: function(Z) {
          this.gl[2] = Math.min(Math.abs(Z), 1), this.b = Math.floor(this.gl[2] * 255), this.update(true);
        } }, alphaGL: { get: function() {
          return this.gl[3];
        }, set: function(Z) {
          this.gl[3] = Math.min(Math.abs(Z), 1), this.a = Math.floor(this.gl[3] * 255), this.update();
        } }, red: { get: function() {
          return this.r;
        }, set: function(Z) {
          Z = Math.floor(Math.abs(Z)), this.r = Math.min(Z, 255), this.gl[0] = Z / 255, this.update(true);
        } }, green: { get: function() {
          return this.g;
        }, set: function(Z) {
          Z = Math.floor(Math.abs(Z)), this.g = Math.min(Z, 255), this.gl[1] = Z / 255, this.update(true);
        } }, blue: { get: function() {
          return this.b;
        }, set: function(Z) {
          Z = Math.floor(Math.abs(Z)), this.b = Math.min(Z, 255), this.gl[2] = Z / 255, this.update(true);
        } }, alpha: { get: function() {
          return this.a;
        }, set: function(Z) {
          Z = Math.floor(Math.abs(Z)), this.a = Math.min(Z, 255), this.gl[3] = Z / 255, this.update();
        } }, h: { get: function() {
          return this._h;
        }, set: function(Z) {
          this._h = Z, U(Z, this._s, this._v, this);
        } }, s: { get: function() {
          return this._s;
        }, set: function(Z) {
          this._s = Z, U(this._h, Z, this._v, this);
        } }, v: { get: function() {
          return this._v;
        }, set: function(Z) {
          this._v = Z, U(this._h, this._s, Z, this);
        } } });
        M.exports = J;
      }, 92728: (M, B, $) => {
        var E = $(37589), L = function(z) {
          if (z === undefined)
            z = 1024;
          var U = [], K = 255, J, Z = 255, D = 0, Q = 0;
          for (J = 0;J <= K; J++)
            U.push({ r: Z, g: J, b: Q, color: E(Z, J, Q) });
          D = 255;
          for (J = K;J >= 0; J--)
            U.push({ r: J, g: D, b: Q, color: E(J, D, Q) });
          Z = 0;
          for (J = 0;J <= K; J++, D--)
            U.push({ r: Z, g: D, b: J, color: E(Z, D, J) });
          D = 0, Q = 255;
          for (J = 0;J <= K; J++, Q--, Z++)
            U.push({ r: Z, g: D, b: Q, color: E(Z, D, Q) });
          if (z === 1024)
            return U;
          else {
            var H = [], N = 0, W = 1024 / z;
            for (J = 0;J < z; J++)
              H.push(U[Math.floor(N)]), N += W;
            return H;
          }
        };
        M.exports = L;
      }, 91588: (M) => {
        var B = function($) {
          var E = { r: $ >> 16 & 255, g: $ >> 8 & 255, b: $ & 255, a: 255 };
          if ($ > 16777215)
            E.a = $ >>> 24;
          return E;
        };
        M.exports = B;
      }, 62957: (M) => {
        var B = function($) {
          var E = $.toString(16);
          return E.length === 1 ? "0" + E : E;
        };
        M.exports = B;
      }, 37589: (M) => {
        var B = function($, E, L) {
          return $ << 16 | E << 8 | L;
        };
        M.exports = B;
      }, 1000: (M) => {
        var B = function($, E, L, z) {
          return z << 24 | $ << 16 | E << 8 | L;
        };
        M.exports = B;
      }, 62183: (M, B, $) => {
        var E = $(40987), L = $(89528), z = function(U, K, J) {
          var Z = J, D = J, Q = J;
          if (K !== 0) {
            var H = J < 0.5 ? J * (1 + K) : J + K - J * K, N = 2 * J - H;
            Z = L(N, H, U + 0.3333333333333333), D = L(N, H, U), Q = L(N, H, U - 0.3333333333333333);
          }
          var W = new E;
          return W.setGLTo(Z, D, Q, 1);
        };
        M.exports = z;
      }, 27939: (M, B, $) => {
        var E = $(7537), L = function(z, U) {
          if (z === undefined)
            z = 1;
          if (U === undefined)
            U = 1;
          var K = [];
          for (var J = 0;J <= 359; J++)
            K.push(E(J / 359, z, U));
          return K;
        };
        M.exports = L;
      }, 7537: (M, B, $) => {
        var E = $(37589);
        function L(U, K, J, Z) {
          var D = (U + K * 6) % 6, Q = Math.min(D, 4 - D, 1);
          return Math.round(255 * (Z - Z * J * Math.max(0, Q)));
        }
        var z = function(U, K, J, Z) {
          if (K === undefined)
            K = 1;
          if (J === undefined)
            J = 1;
          var D = L(5, U, K, J), Q = L(3, U, K, J), H = L(1, U, K, J);
          if (!Z)
            return { r: D, g: Q, b: H, color: E(D, Q, H) };
          else if (Z.setTo)
            return Z.setTo(D, Q, H, Z.alpha, true);
          else
            return Z.r = D, Z.g = Q, Z.b = H, Z.color = E(D, Q, H), Z;
        };
        M.exports = z;
      }, 70238: (M, B, $) => {
        var E = $(40987), L = function(z) {
          var U = new E;
          z = z.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(Q, H, N, W) {
            return H + H + N + N + W + W;
          });
          var K = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(z);
          if (K) {
            var J = parseInt(K[1], 16), Z = parseInt(K[2], 16), D = parseInt(K[3], 16);
            U.setTo(J, Z, D);
          }
          return U;
        };
        M.exports = L;
      }, 89528: (M) => {
        var B = function($, E, L) {
          if (L < 0)
            L += 1;
          if (L > 1)
            L -= 1;
          if (L < 0.16666666666666666)
            return $ + (E - $) * 6 * L;
          if (L < 0.5)
            return E;
          if (L < 0.6666666666666666)
            return $ + (E - $) * (0.6666666666666666 - L) * 6;
          return $;
        };
        M.exports = B;
      }, 30100: (M, B, $) => {
        var E = $(40987), L = $(90664), z = function(U) {
          var K = L(U);
          return new E(K.r, K.g, K.b, K.a);
        };
        M.exports = z;
      }, 90664: (M) => {
        var B = function($) {
          if ($ > 16777215)
            return { a: $ >>> 24, r: $ >> 16 & 255, g: $ >> 8 & 255, b: $ & 255 };
          else
            return { a: 255, r: $ >> 16 & 255, g: $ >> 8 & 255, b: $ & 255 };
        };
        M.exports = B;
      }, 13699: (M, B, $) => {
        var E = $(28915), L = function(K, J, Z, D, Q, H, N, W) {
          if (N === undefined)
            N = 100;
          if (W === undefined)
            W = 0;
          var R = W / N;
          return { r: E(K, D, R), g: E(J, Q, R), b: E(Z, H, R) };
        }, z = function(K, J, Z, D) {
          if (Z === undefined)
            Z = 100;
          if (D === undefined)
            D = 0;
          return L(K.r, K.g, K.b, J.r, J.g, J.b, Z, D);
        }, U = function(K, J, Z, D, Q, H) {
          if (Q === undefined)
            Q = 100;
          if (H === undefined)
            H = 0;
          return L(K.r, K.g, K.b, J, Z, D, Q, H);
        };
        M.exports = { RGBWithRGB: L, ColorWithRGB: U, ColorWithColor: z };
      }, 68957: (M, B, $) => {
        var E = $(40987), L = function(z) {
          return new E(z.r, z.g, z.b, z.a);
        };
        M.exports = L;
      }, 87388: (M, B, $) => {
        var E = $(40987), L = function(z) {
          var U = new E, K = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(z.toLowerCase());
          if (K) {
            var J = parseInt(K[1], 10), Z = parseInt(K[2], 10), D = parseInt(K[3], 10), Q = K[4] !== undefined ? parseFloat(K[4]) : 1;
            U.setTo(J, Z, D, Q * 255);
          }
          return U;
        };
        M.exports = L;
      }, 87837: (M) => {
        var B = function($, E, L, z) {
          if (z === undefined)
            z = { h: 0, s: 0, v: 0 };
          $ /= 255, E /= 255, L /= 255;
          var U = Math.min($, E, L), K = Math.max($, E, L), J = K - U, Z = 0, D = K === 0 ? 0 : J / K, Q = K;
          if (K !== U) {
            if (K === $)
              Z = (E - L) / J + (E < L ? 6 : 0);
            else if (K === E)
              Z = (L - $) / J + 2;
            else if (K === L)
              Z = ($ - E) / J + 4;
            Z /= 6;
          }
          if (z.hasOwnProperty("_h"))
            z._h = Z, z._s = D, z._v = Q;
          else
            z.h = Z, z.s = D, z.v = Q;
          return z;
        };
        M.exports = B;
      }, 75723: (M, B, $) => {
        var E = $(62957), L = function(z, U, K, J, Z) {
          if (J === undefined)
            J = 255;
          if (Z === undefined)
            Z = "#";
          if (Z === "#")
            return "#" + ((1 << 24) + (z << 16) + (U << 8) + K).toString(16).slice(1, 7);
          else
            return "0x" + E(J) + E(z) + E(U) + E(K);
        };
        M.exports = L;
      }, 85386: (M, B, $) => {
        var E = $(30976), L = $(40987), z = function(U, K) {
          if (U === undefined)
            U = 0;
          if (K === undefined)
            K = 255;
          return new L(E(U, K), E(U, K), E(U, K));
        };
        M.exports = z;
      }, 80333: (M, B, $) => {
        var E = $(70238), L = $(30100), z = $(68957), U = $(87388), K = function(J) {
          var Z = typeof J;
          switch (Z) {
            case "string":
              if (J.substr(0, 3).toLowerCase() === "rgb")
                return U(J);
              else
                return E(J);
            case "number":
              return L(J);
            case "object":
              return z(J);
          }
        };
        M.exports = K;
      }, 3956: (M, B, $) => {
        var E = $(40987);
        E.ColorSpectrum = $(92728), E.ColorToRGBA = $(91588), E.ComponentToHex = $(62957), E.GetColor = $(37589), E.GetColor32 = $(1000), E.HexStringToColor = $(70238), E.HSLToColor = $(62183), E.HSVColorWheel = $(27939), E.HSVToRGB = $(7537), E.HueToComponent = $(89528), E.IntegerToColor = $(30100), E.IntegerToRGB = $(90664), E.Interpolate = $(13699), E.ObjectToColor = $(68957), E.RandomRGB = $(85386), E.RGBStringToColor = $(87388), E.RGBToHSV = $(87837), E.RGBToString = $(75723), E.ValueToColor = $(80333), M.exports = E;
      }, 27460: (M, B, $) => {
        M.exports = { Align: $(71926), BaseShader: $(73894), Bounds: $(58724), Canvas: $(26253), Color: $(3956), ColorMatrix: $(89422), Masks: $(69781), RGB: $(51767) };
      }, 6858: (M, B, $) => {
        var E = $(83419), L = $(39429), z = new E({ initialize: function U(K, J, Z, D, Q, H) {
          if (!J)
            J = K.sys.make.image({ x: Z, y: D, key: Q, frame: H, add: false });
          this.bitmapMask = J, this.invertAlpha = false, this.isStencil = false;
        }, setBitmap: function(U) {
          this.bitmapMask = U;
        }, preRenderWebGL: function(U, K, J) {
          U.pipelines.BITMAPMASK_PIPELINE.beginMask(this, K, J);
        }, postRenderWebGL: function(U, K, J) {
          U.pipelines.BITMAPMASK_PIPELINE.endMask(this, K, J);
        }, preRenderCanvas: function() {
        }, postRenderCanvas: function() {
        }, destroy: function() {
          this.bitmapMask = null;
        } });
        L.register("bitmapMask", function(U, K, J, Z, D) {
          return new z(this.scene, U, K, J, Z, D);
        }), M.exports = z;
      }, 80661: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U, K) {
          this.geometryMask = K, this.invertAlpha = false, this.isStencil = true, this.level = 0;
        }, setShape: function(z) {
          return this.geometryMask = z, this;
        }, setInvertAlpha: function(z) {
          if (z === undefined)
            z = true;
          return this.invertAlpha = z, this;
        }, preRenderWebGL: function(z, U, K) {
          var J = z.gl;
          if (z.flush(), z.maskStack.length === 0)
            J.enable(J.STENCIL_TEST), J.clear(J.STENCIL_BUFFER_BIT), z.maskCount = 0;
          if (z.currentCameraMask.mask !== this)
            z.currentMask.mask = this;
          z.maskStack.push({ mask: this, camera: K }), this.applyStencil(z, K, true), z.maskCount++;
        }, applyStencil: function(z, U, K) {
          var J = z.gl, Z = this.geometryMask, D = z.maskCount, Q = 255;
          if (J.colorMask(false, false, false, false), K)
            J.stencilFunc(J.EQUAL, D, Q), J.stencilOp(J.KEEP, J.KEEP, J.INCR), D++;
          else
            J.stencilFunc(J.EQUAL, D + 1, Q), J.stencilOp(J.KEEP, J.KEEP, J.DECR);
          if (this.level = D, Z.renderWebGL(z, Z, U), z.flush(), J.colorMask(true, true, true, true), J.stencilOp(J.KEEP, J.KEEP, J.KEEP), this.invertAlpha)
            J.stencilFunc(J.NOTEQUAL, D, Q);
          else
            J.stencilFunc(J.EQUAL, D, Q);
        }, postRenderWebGL: function(z) {
          var U = z.gl;
          z.maskStack.pop(), z.maskCount--, z.flush();
          var K = z.currentMask;
          if (z.maskStack.length === 0)
            K.mask = null, U.disable(U.STENCIL_TEST);
          else {
            var J = z.maskStack[z.maskStack.length - 1];
            if (J.mask.applyStencil(z, J.camera, false), z.currentCameraMask.mask !== J.mask)
              K.mask = J.mask, K.camera = J.camera;
            else
              K.mask = null;
          }
        }, preRenderCanvas: function(z, U, K) {
          var J = this.geometryMask;
          z.currentContext.save(), J.renderCanvas(z, J, K, null, null, true), z.currentContext.clip();
        }, postRenderCanvas: function(z) {
          z.currentContext.restore();
        }, destroy: function() {
          this.geometryMask = null;
        } });
        M.exports = L;
      }, 69781: (M, B, $) => {
        M.exports = { BitmapMask: $(6858), GeometryMask: $(80661) };
      }, 73894: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U, K, J, Z) {
          if (!K || K === "")
            K = ["precision mediump float;", "uniform vec2 resolution;", "varying vec2 fragCoord;", "void main () {", "    vec2 uv = fragCoord / resolution.xy;", "    gl_FragColor = vec4(uv.xyx, 1.0);", "}"].join("\n");
          if (!J || J === "")
            J = ["precision mediump float;", "uniform mat4 uProjectionMatrix;", "uniform mat4 uViewMatrix;", "uniform vec2 uResolution;", "attribute vec2 inPosition;", "varying vec2 fragCoord;", "varying vec2 outTexCoord;", "void main () {", "   gl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);", "   fragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);", "   outTexCoord = vec2(inPosition.x / uResolution.x, fragCoord.y / uResolution.y);", "}"].join("\n");
          if (Z === undefined)
            Z = null;
          this.key = U, this.fragmentSrc = K, this.vertexSrc = J, this.uniforms = Z;
        } });
        M.exports = L;
      }, 40366: (M) => {
        var B = function($, E) {
          var L;
          if (E) {
            if (typeof E === "string")
              L = document.getElementById(E);
            else if (typeof E === "object" && E.nodeType === 1)
              L = E;
          } else if ($.parentElement || E === null)
            return $;
          if (!L)
            L = document.body;
          return L.appendChild($), $;
        };
        M.exports = B;
      }, 83719: (M, B, $) => {
        var E = $(40366), L = function(z) {
          var U = z.config;
          if (!U.parent || !U.domCreateContainer)
            return;
          var K = document.createElement("div");
          K.style.cssText = ["display: block;", "width: " + z.scale.width + "px;", "height: " + z.scale.height + "px;", "padding: 0; margin: 0;", "position: absolute;", "overflow: hidden;", "pointer-events: " + U.domPointerEvents + ";", "transform: scale(1);", "transform-origin: left top;"].join(" "), z.domContainer = K, E(K, U.parent);
        };
        M.exports = L;
      }, 57264: (M, B, $) => {
        var E = $(25892), L = function(z) {
          if (document.readyState === "complete" || document.readyState === "interactive") {
            z();
            return;
          }
          var U = function() {
            document.removeEventListener("deviceready", U, true), document.removeEventListener("DOMContentLoaded", U, true), window.removeEventListener("load", U, true), z();
          };
          if (!document.body)
            window.setTimeout(U, 20);
          else if (E.cordova)
            document.addEventListener("deviceready", U, false);
          else
            document.addEventListener("DOMContentLoaded", U, true), window.addEventListener("load", U, true);
        };
        M.exports = L;
      }, 57811: (M) => {
        var B = function($) {
          if (!$)
            return window.innerHeight;
          var E = Math.abs(window.orientation), L = { w: 0, h: 0 }, z = document.createElement("div");
          if (z.setAttribute("style", "position: fixed; height: 100vh; width: 0; top: 0"), document.documentElement.appendChild(z), L.w = E === 90 ? z.offsetHeight : window.innerWidth, L.h = E === 90 ? window.innerWidth : z.offsetHeight, document.documentElement.removeChild(z), z = null, Math.abs(window.orientation) !== 90)
            return L.h;
          else
            return L.w;
        };
        M.exports = B;
      }, 45818: (M, B, $) => {
        var E = $(13560), L = function(z, U) {
          var K = window.screen, J = K ? K.orientation || K.mozOrientation || K.msOrientation : false;
          if (J && typeof J.type === "string")
            return J.type;
          else if (typeof J === "string")
            return J;
          if (typeof window.orientation === "number")
            return window.orientation === 0 || window.orientation === 180 ? E.ORIENTATION.PORTRAIT : E.ORIENTATION.LANDSCAPE;
          else if (window.matchMedia) {
            if (window.matchMedia("(orientation: portrait)").matches)
              return E.ORIENTATION.PORTRAIT;
            else if (window.matchMedia("(orientation: landscape)").matches)
              return E.ORIENTATION.LANDSCAPE;
          } else
            return U > z ? E.ORIENTATION.PORTRAIT : E.ORIENTATION.LANDSCAPE;
        };
        M.exports = L;
      }, 74403: (M) => {
        var B = function($) {
          var E;
          if ($ !== "") {
            if (typeof $ === "string")
              E = document.getElementById($);
            else if ($ && $.nodeType === 1)
              E = $;
          }
          if (!E)
            E = document.body;
          return E;
        };
        M.exports = B;
      }, 56836: (M) => {
        var B = function($) {
          var E = "";
          try {
            if (window.DOMParser) {
              var L = new DOMParser;
              E = L.parseFromString($, "text/xml");
            } else
              E = new ActiveXObject("Microsoft.XMLDOM"), E.loadXML($);
          } catch (z) {
            E = null;
          }
          if (!E || !E.documentElement || E.getElementsByTagName("parsererror").length)
            return null;
          else
            return E;
        };
        M.exports = B;
      }, 35846: (M) => {
        var B = function($) {
          if ($.parentNode)
            $.parentNode.removeChild($);
        };
        M.exports = B;
      }, 43092: (M, B, $) => {
        var E = $(83419), L = $(29747), z = new E({ initialize: function U() {
          this.isRunning = false, this.callback = L, this.isSetTimeOut = false, this.timeOutID = null, this.delay = 0;
          var K = this;
          this.step = function J(Z) {
            if (K.callback(Z), K.isRunning)
              K.timeOutID = window.requestAnimationFrame(J);
          }, this.stepTimeout = function J() {
            if (K.isRunning)
              K.timeOutID = window.setTimeout(J, K.delay);
            K.callback(window.performance.now());
          };
        }, start: function(U, K, J) {
          if (this.isRunning)
            return;
          this.callback = U, this.isSetTimeOut = K, this.delay = J, this.isRunning = true, this.timeOutID = K ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step);
        }, stop: function() {
          if (this.isRunning = false, this.isSetTimeOut)
            clearTimeout(this.timeOutID);
          else
            window.cancelAnimationFrame(this.timeOutID);
        }, destroy: function() {
          this.stop(), this.callback = L;
        } });
        M.exports = z;
      }, 84902: (M, B, $) => {
        var E = { AddToDOM: $(40366), DOMContentLoaded: $(57264), GetInnerHeight: $(57811), GetScreenOrientation: $(45818), GetTarget: $(74403), ParseXML: $(56836), RemoveFromDOM: $(35846), RequestAnimationFrame: $(43092) };
        M.exports = E;
      }, 47565: (M, B, $) => {
        var E = $(83419), L = $(50792), z = $(37277), U = new E({ Extends: L, initialize: function K() {
          L.call(this);
        }, shutdown: function() {
          this.removeAllListeners();
        }, destroy: function() {
          this.removeAllListeners();
        } });
        z.register("EventEmitter", U, "events"), M.exports = U;
      }, 93055: (M, B, $) => {
        M.exports = { EventEmitter: $(47565) };
      }, 20122: (M, B, $) => {
        var E = $(83419), L = $(72898), z = $(14811), U = new E({ Extends: L, initialize: function K(J, Z) {
          if (Z === undefined)
            Z = 1;
          L.call(this, z.BARREL, J), this.amount = Z;
        } });
        M.exports = U;
      }, 32251: (M, B, $) => {
        var E = $(83419), L = $(72898), z = $(14811), U = new E({ Extends: L, initialize: function K(J, Z, D, Q, H, N, W) {
          if (D === undefined)
            D = 1;
          if (Q === undefined)
            Q = 1;
          if (H === undefined)
            H = 1;
          if (N === undefined)
            N = 1;
          if (W === undefined)
            W = 4;
          if (L.call(this, z.BLOOM, J), this.steps = W, this.offsetX = D, this.offsetY = Q, this.blurStrength = H, this.strength = N, this.glcolor = [1, 1, 1], Z !== undefined && Z !== null)
            this.color = Z;
        }, color: { get: function() {
          var K = this.glcolor;
          return (K[0] * 255 << 16) + (K[1] * 255 << 8) + (K[2] * 255 | 0);
        }, set: function(K) {
          var J = this.glcolor;
          J[0] = (K >> 16 & 255) / 255, J[1] = (K >> 8 & 255) / 255, J[2] = (K & 255) / 255;
        } } });
        M.exports = U;
      }, 9047: (M, B, $) => {
        var E = $(83419), L = $(72898), z = $(14811), U = new E({ Extends: L, initialize: function K(J, Z, D, Q, H, N, W) {
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = 2;
          if (Q === undefined)
            Q = 2;
          if (H === undefined)
            H = 1;
          if (W === undefined)
            W = 4;
          if (L.call(this, z.BLUR, J), this.quality = Z, this.x = D, this.y = Q, this.steps = W, this.strength = H, this.glcolor = [1, 1, 1], N !== undefined && N !== null)
            this.color = N;
        }, color: { get: function() {
          var K = this.glcolor;
          return (K[0] * 255 << 16) + (K[1] * 255 << 8) + (K[2] * 255 | 0);
        }, set: function(K) {
          var J = this.glcolor;
          J[0] = (K >> 16 & 255) / 255, J[1] = (K >> 8 & 255) / 255, J[2] = (K & 255) / 255;
        } } });
        M.exports = U;
      }, 27885: (M, B, $) => {
        var E = $(83419), L = $(72898), z = $(14811), U = new E({ Extends: L, initialize: function K(J, Z, D, Q, H, N, W, R) {
          if (Z === undefined)
            Z = 0.5;
          if (D === undefined)
            D = 1;
          if (Q === undefined)
            Q = 0.2;
          if (H === undefined)
            H = false;
          if (N === undefined)
            N = 1;
          if (W === undefined)
            W = 1;
          if (R === undefined)
            R = 1;
          L.call(this, z.BOKEH, J), this.radius = Z, this.amount = D, this.contrast = Q, this.isTiltShift = H, this.strength = R, this.blurX = N, this.blurY = W;
        } });
        M.exports = U;
      }, 12578: (M, B, $) => {
        var E = $(83419), L = $(72898), z = $(14811), U = new E({ Extends: L, initialize: function K(J, Z, D, Q, H, N) {
          if (Z === undefined)
            Z = 8;
          if (H === undefined)
            H = 1;
          if (N === undefined)
            N = 0.005;
          if (L.call(this, z.CIRCLE, J), this.scale = H, this.feather = N, this.thickness = Z, this.glcolor = [1, 0.2, 0.7], this.glcolor2 = [1, 0, 0, 0.4], D !== undefined && D !== null)
            this.color = D;
          if (Q !== undefined && Q !== null)
            this.backgroundColor = Q;
        }, color: { get: function() {
          var K = this.glcolor;
          return (K[0] * 255 << 16) + (K[1] * 255 << 8) + (K[2] * 255 | 0);
        }, set: function(K) {
          var J = this.glcolor;
          J[0] = (K >> 16 & 255) / 255, J[1] = (K >> 8 & 255) / 255, J[2] = (K & 255) / 255;
        } }, backgroundColor: { get: function() {
          var K = this.glcolor2;
          return (K[0] * 255 << 16) + (K[1] * 255 << 8) + (K[2] * 255 | 0);
        }, set: function(K) {
          var J = this.glcolor2;
          J[0] = (K >> 16 & 255) / 255, J[1] = (K >> 8 & 255) / 255, J[2] = (K & 255) / 255;
        } }, backgroundAlpha: { get: function() {
          return this.glcolor2[3];
        }, set: function(K) {
          this.glcolor2[3] = K;
        } } });
        M.exports = U;
      }, 15802: (M, B, $) => {
        var E = $(83419), L = $(89422), z = $(14811), U = new E({ Extends: L, initialize: function K(J) {
          L.call(this), this.type = z.COLOR_MATRIX, this.gameObject = J, this.active = true;
        }, destroy: function() {
          this.gameObject = null, this._matrix = null, this._data = null;
        } });
        M.exports = U;
      }, 72898: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U, K) {
          this.type = U, this.gameObject = K, this.active = true;
        }, setActive: function(z) {
          return this.active = z, this;
        }, destroy: function() {
          this.gameObject = null, this.active = false;
        } });
        M.exports = L;
      }, 44553: (M, B, $) => {
        var E = $(83419), L = $(72898), z = $(14811), U = new E({ Extends: L, initialize: function K(J, Z, D, Q) {
          if (Z === undefined)
            Z = "__WHITE";
          if (D === undefined)
            D = 0.005;
          if (Q === undefined)
            Q = 0.005;
          L.call(this, z.DISPLACEMENT, J), this.x = D, this.y = Q, this.glTexture, this.setTexture(Z);
        }, setTexture: function(K) {
          var J = this.gameObject.scene.sys.textures.getFrame(K);
          if (J)
            this.glTexture = J.glTexture;
          return this;
        } });
        M.exports = U;
      }, 68531: (M, B, $) => {
        var E = $(83419), L = $(72898), z = $(14811), U = new E({ Extends: L, initialize: function K(J, Z, D, Q, H) {
          if (D === undefined)
            D = 4;
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = false;
          if (L.call(this, z.GLOW, J), this.outerStrength = D, this.innerStrength = Q, this.knockout = H, this.glcolor = [1, 1, 1, 1], Z !== undefined)
            this.color = Z;
        }, color: { get: function() {
          var K = this.glcolor;
          return (K[0] * 255 << 16) + (K[1] * 255 << 8) + (K[2] * 255 | 0);
        }, set: function(K) {
          var J = this.glcolor;
          J[0] = (K >> 16 & 255) / 255, J[1] = (K >> 8 & 255) / 255, J[2] = (K & 255) / 255;
        } } });
        M.exports = U;
      }, 37102: (M, B, $) => {
        var E = $(83419), L = $(72898), z = $(14811), U = new E({ Extends: L, initialize: function K(J, Z, D, Q, H, N, W, R, Y) {
          if (Q === undefined)
            Q = 0.2;
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = 0;
          if (R === undefined)
            R = 1;
          if (Y === undefined)
            Y = 0;
          if (L.call(this, z.GRADIENT, J), this.alpha = Q, this.size = Y, this.fromX = H, this.fromY = N, this.toX = W, this.toY = R, this.glcolor1 = [255, 0, 0], this.glcolor2 = [0, 255, 0], Z !== undefined && Z !== null)
            this.color1 = Z;
          if (D !== undefined && D !== null)
            this.color2 = D;
        }, color1: { get: function() {
          var K = this.glcolor1;
          return (K[0] << 16) + (K[1] << 8) + (K[2] | 0);
        }, set: function(K) {
          var J = this.glcolor1;
          J[0] = K >> 16 & 255, J[1] = K >> 8 & 255, J[2] = K & 255;
        } }, color2: { get: function() {
          var K = this.glcolor2;
          return (K[0] << 16) + (K[1] << 8) + (K[2] | 0);
        }, set: function(K) {
          var J = this.glcolor2;
          J[0] = K >> 16 & 255, J[1] = K >> 8 & 255, J[2] = K & 255;
        } } });
        M.exports = U;
      }, 86886: (M, B, $) => {
        var E = $(83419), L = $(72898), z = $(14811), U = new E({ Extends: L, initialize: function K(J, Z) {
          if (Z === undefined)
            Z = 1;
          L.call(this, z.PIXELATE, J), this.amount = Z;
        } });
        M.exports = U;
      }, 92322: (M, B, $) => {
        var E = $(83419), L = $(72898), z = $(14811), U = new E({ Extends: L, initialize: function K(J, Z, D, Q, H, N, W, R) {
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0.1;
          if (H === undefined)
            H = 1;
          if (W === undefined)
            W = 6;
          if (R === undefined)
            R = 1;
          if (L.call(this, z.SHADOW, J), this.x = Z, this.y = D, this.decay = Q, this.power = H, this.glcolor = [0, 0, 0, 1], this.samples = W, this.intensity = R, N !== undefined)
            this.color = N;
        }, color: { get: function() {
          var K = this.glcolor;
          return (K[0] * 255 << 16) + (K[1] * 255 << 8) + (K[2] * 255 | 0);
        }, set: function(K) {
          var J = this.glcolor;
          J[0] = (K >> 16 & 255) / 255, J[1] = (K >> 8 & 255) / 255, J[2] = (K & 255) / 255;
        } } });
        M.exports = U;
      }, 39563: (M, B, $) => {
        var E = $(83419), L = $(72898), z = $(14811), U = new E({ Extends: L, initialize: function K(J, Z, D, Q, H) {
          if (Z === undefined)
            Z = 0.5;
          if (D === undefined)
            D = 0.5;
          if (Q === undefined)
            Q = 3;
          if (H === undefined)
            H = false;
          L.call(this, z.SHINE, J), this.speed = Z, this.lineWidth = D, this.gradient = Q, this.reveal = H;
        } });
        M.exports = U;
      }, 56448: (M, B, $) => {
        var E = $(83419), L = $(72898), z = $(14811), U = new E({ Extends: L, initialize: function K(J, Z, D, Q, H) {
          if (Z === undefined)
            Z = 0.5;
          if (D === undefined)
            D = 0.5;
          if (Q === undefined)
            Q = 0.5;
          if (H === undefined)
            H = 0.5;
          L.call(this, z.VIGNETTE, J), this.x = Z, this.y = D, this.radius = Q, this.strength = H;
        } });
        M.exports = U;
      }, 38433: (M, B, $) => {
        var E = $(83419), L = $(72898), z = $(14811), U = new E({ Extends: L, initialize: function K(J, Z, D, Q, H) {
          if (Z === undefined)
            Z = 0.1;
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = false;
          L.call(this, z.WIPE, J), this.progress = 0, this.wipeWidth = Z, this.direction = D, this.axis = Q, this.reveal = H;
        } });
        M.exports = U;
      }, 14811: (M) => {
        var B = { GLOW: 4, SHADOW: 5, PIXELATE: 6, VIGNETTE: 7, SHINE: 8, BLUR: 9, GRADIENT: 12, BLOOM: 13, COLOR_MATRIX: 14, CIRCLE: 15, BARREL: 16, DISPLACEMENT: 17, WIPE: 18, BOKEH: 19 };
        M.exports = B;
      }, 66064: (M, B, $) => {
        var E = $(79291), L = $(14811), z = { Barrel: $(20122), Controller: $(72898), Bloom: $(32251), Blur: $(9047), Bokeh: $(27885), Circle: $(12578), ColorMatrix: $(15802), Displacement: $(44553), Glow: $(68531), Gradient: $(37102), Pixelate: $(86886), Shadow: $(92322), Shine: $(39563), Vignette: $(56448), Wipe: $(38433) };
        z = E(false, z, L), M.exports = z;
      }, 25305: (M, B, $) => {
        var E = $(10312), L = $(23568), z = function(U, K, J) {
          K.x = L(J, "x", 0), K.y = L(J, "y", 0), K.depth = L(J, "depth", 0), K.flipX = L(J, "flipX", false), K.flipY = L(J, "flipY", false);
          var Z = L(J, "scale", null);
          if (typeof Z === "number")
            K.setScale(Z);
          else if (Z !== null)
            K.scaleX = L(Z, "x", 1), K.scaleY = L(Z, "y", 1);
          var D = L(J, "scrollFactor", null);
          if (typeof D === "number")
            K.setScrollFactor(D);
          else if (D !== null)
            K.scrollFactorX = L(D, "x", 1), K.scrollFactorY = L(D, "y", 1);
          K.rotation = L(J, "rotation", 0);
          var Q = L(J, "angle", null);
          if (Q !== null)
            K.angle = Q;
          K.alpha = L(J, "alpha", 1);
          var H = L(J, "origin", null);
          if (typeof H === "number")
            K.setOrigin(H);
          else if (H !== null) {
            var N = L(H, "x", 0.5), W = L(H, "y", 0.5);
            K.setOrigin(N, W);
          }
          K.blendMode = L(J, "blendMode", E.NORMAL), K.visible = L(J, "visible", true);
          var R = L(J, "add", true);
          if (R)
            U.sys.displayList.add(K);
          if (K.preUpdate)
            U.sys.updateList.add(K);
          return K;
        };
        M.exports = z;
      }, 13059: (M, B, $) => {
        var E = $(23568), L = function(z, U) {
          var K = E(U, "anims", null);
          if (K === null)
            return z;
          if (typeof K === "string")
            z.anims.play(K);
          else if (typeof K === "object") {
            var J = z.anims, Z = E(K, "key", undefined);
            if (Z) {
              var D = E(K, "startFrame", undefined), Q = E(K, "delay", 0), H = E(K, "repeat", 0), N = E(K, "repeatDelay", 0), W = E(K, "yoyo", false), R = E(K, "play", false), Y = E(K, "delayedPlay", 0), I = { key: Z, delay: Q, repeat: H, repeatDelay: N, yoyo: W, startFrame: D };
              if (R)
                J.play(I);
              else if (Y > 0)
                J.playAfterDelay(I, Y);
              else
                J.load(I);
            }
          }
          return z;
        };
        M.exports = L;
      }, 8050: (M, B, $) => {
        var E = $(83419), L = $(73162), z = $(37277), U = $(51708), K = $(44594), J = $(19186), Z = new E({ Extends: L, initialize: function D(Q) {
          L.call(this, Q), this.sortChildrenFlag = false, this.scene = Q, this.systems = Q.sys, this.events = Q.sys.events, this.addCallback = this.addChildCallback, this.removeCallback = this.removeChildCallback, this.events.once(K.BOOT, this.boot, this), this.events.on(K.START, this.start, this);
        }, boot: function() {
          this.events.once(K.DESTROY, this.destroy, this);
        }, addChildCallback: function(D) {
          if (D.displayList && D.displayList !== this)
            D.removeFromDisplayList();
          if (D.parentContainer)
            D.parentContainer.remove(D);
          if (!D.displayList)
            this.queueDepthSort(), D.displayList = this, D.emit(U.ADDED_TO_SCENE, D, this.scene), this.events.emit(K.ADDED_TO_SCENE, D, this.scene);
        }, removeChildCallback: function(D) {
          this.queueDepthSort(), D.displayList = null, D.emit(U.REMOVED_FROM_SCENE, D, this.scene), this.events.emit(K.REMOVED_FROM_SCENE, D, this.scene);
        }, start: function() {
          this.events.once(K.SHUTDOWN, this.shutdown, this);
        }, queueDepthSort: function() {
          this.sortChildrenFlag = true;
        }, depthSort: function() {
          if (this.sortChildrenFlag)
            J(this.list, this.sortByDepth), this.sortChildrenFlag = false;
        }, sortByDepth: function(D, Q) {
          return D._depth - Q._depth;
        }, getChildren: function() {
          return this.list;
        }, shutdown: function() {
          var D = this.list;
          while (D.length)
            D[0].destroy(true);
          this.events.off(K.SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          this.shutdown(), this.events.off(K.START, this.start, this), this.scene = null, this.systems = null, this.events = null;
        } });
        z.register("DisplayList", Z, "displayList"), M.exports = Z;
      }, 95643: (M, B, $) => {
        var E = $(83419), L = $(53774), z = $(45893), U = $(50792), K = $(51708), J = $(44594), Z = new E({ Extends: U, initialize: function D(Q, H) {
          U.call(this), this.scene = Q, this.displayList = null, this.type = H, this.state = 0, this.parentContainer = null, this.name = "", this.active = true, this.tabIndex = -1, this.data = null, this.renderFlags = 15, this.cameraFilter = 0, this.input = null, this.body = null, this.ignoreDestroy = false, this.on(K.ADDED_TO_SCENE, this.addedToScene, this), this.on(K.REMOVED_FROM_SCENE, this.removedFromScene, this), Q.sys.queueDepthSort();
        }, setActive: function(D) {
          return this.active = D, this;
        }, setName: function(D) {
          return this.name = D, this;
        }, setState: function(D) {
          return this.state = D, this;
        }, setDataEnabled: function() {
          if (!this.data)
            this.data = new z(this);
          return this;
        }, setData: function(D, Q) {
          if (!this.data)
            this.data = new z(this);
          return this.data.set(D, Q), this;
        }, incData: function(D, Q) {
          if (!this.data)
            this.data = new z(this);
          return this.data.inc(D, Q), this;
        }, toggleData: function(D) {
          if (!this.data)
            this.data = new z(this);
          return this.data.toggle(D), this;
        }, getData: function(D) {
          if (!this.data)
            this.data = new z(this);
          return this.data.get(D);
        }, setInteractive: function(D, Q, H) {
          return this.scene.sys.input.enable(this, D, Q, H), this;
        }, disableInteractive: function() {
          return this.scene.sys.input.disable(this), this;
        }, removeInteractive: function() {
          return this.scene.sys.input.clear(this), this.input = undefined, this;
        }, addedToScene: function() {
        }, removedFromScene: function() {
        }, update: function() {
        }, toJSON: function() {
          return L(this);
        }, willRender: function(D) {
          var Q = this.displayList && this.displayList.active ? this.displayList.willRender(D) : true;
          return !(!Q || Z.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & D.id);
        }, getIndexList: function() {
          var D = this, Q = this.parentContainer, H = [];
          while (Q)
            if (H.unshift(Q.getIndex(D)), D = Q, !Q.parentContainer)
              break;
            else
              Q = Q.parentContainer;
          if (this.displayList)
            H.unshift(this.displayList.getIndex(D));
          else
            H.unshift(this.scene.sys.displayList.getIndex(D));
          return H;
        }, addToDisplayList: function(D) {
          if (D === undefined)
            D = this.scene.sys.displayList;
          if (this.displayList && this.displayList !== D)
            this.removeFromDisplayList();
          if (!D.exists(this))
            this.displayList = D, D.add(this, true), D.queueDepthSort(), this.emit(K.ADDED_TO_SCENE, this, this.scene), D.events.emit(J.ADDED_TO_SCENE, this, this.scene);
          return this;
        }, addToUpdateList: function() {
          if (this.scene && this.preUpdate)
            this.scene.sys.updateList.add(this);
          return this;
        }, removeFromDisplayList: function() {
          var D = this.displayList || this.scene.sys.displayList;
          if (D && D.exists(this))
            D.remove(this, true), D.queueDepthSort(), this.displayList = null, this.emit(K.REMOVED_FROM_SCENE, this, this.scene), D.events.emit(J.REMOVED_FROM_SCENE, this, this.scene);
          return this;
        }, removeFromUpdateList: function() {
          if (this.scene && this.preUpdate)
            this.scene.sys.updateList.remove(this);
          return this;
        }, destroy: function(D) {
          if (!this.scene || this.ignoreDestroy)
            return;
          if (D === undefined)
            D = false;
          if (this.preDestroy)
            this.preDestroy.call(this);
          if (this.emit(K.DESTROY, this, D), this.removeAllListeners(), this.postPipelines)
            this.resetPostPipeline(true);
          if (this.removeFromDisplayList(), this.removeFromUpdateList(), this.input)
            this.scene.sys.input.clear(this), this.input = undefined;
          if (this.data)
            this.data.destroy(), this.data = undefined;
          if (this.body)
            this.body.destroy(), this.body = undefined;
          if (this.preFX)
            this.preFX.destroy(), this.preFX = undefined;
          if (this.postFX)
            this.postFX.destroy(), this.postFX = undefined;
          this.active = false, this.visible = false, this.scene = undefined, this.parentContainer = undefined;
        } });
        Z.RENDER_MASK = 15, M.exports = Z;
      }, 44603: (M, B, $) => {
        var E = $(83419), L = $(37277), z = $(44594), U = new E({ initialize: function K(J) {
          this.scene = J, this.systems = J.sys, this.events = J.sys.events, this.displayList, this.updateList, this.events.once(z.BOOT, this.boot, this), this.events.on(z.START, this.start, this);
        }, boot: function() {
          this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.events.once(z.DESTROY, this.destroy, this);
        }, start: function() {
          this.events.once(z.SHUTDOWN, this.shutdown, this);
        }, shutdown: function() {
          this.events.off(z.SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          this.shutdown(), this.events.off(z.START, this.start, this), this.scene = null, this.systems = null, this.events = null, this.displayList = null, this.updateList = null;
        } });
        U.register = function(K, J) {
          if (!U.prototype.hasOwnProperty(K))
            U.prototype[K] = J;
        }, U.remove = function(K) {
          if (U.prototype.hasOwnProperty(K))
            delete U.prototype[K];
        }, L.register("GameObjectCreator", U, "make"), M.exports = U;
      }, 39429: (M, B, $) => {
        var E = $(83419), L = $(37277), z = $(44594), U = new E({ initialize: function K(J) {
          this.scene = J, this.systems = J.sys, this.events = J.sys.events, this.displayList, this.updateList, this.events.once(z.BOOT, this.boot, this), this.events.on(z.START, this.start, this);
        }, boot: function() {
          this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.events.once(z.DESTROY, this.destroy, this);
        }, start: function() {
          this.events.once(z.SHUTDOWN, this.shutdown, this);
        }, existing: function(K) {
          if (K.renderCanvas || K.renderWebGL)
            this.displayList.add(K);
          if (K.preUpdate)
            this.updateList.add(K);
          return K;
        }, shutdown: function() {
          this.events.off(z.SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          this.shutdown(), this.events.off(z.START, this.start, this), this.scene = null, this.systems = null, this.events = null, this.displayList = null, this.updateList = null;
        } });
        U.register = function(K, J) {
          if (!U.prototype.hasOwnProperty(K))
            U.prototype[K] = J;
        }, U.remove = function(K) {
          if (U.prototype.hasOwnProperty(K))
            delete U.prototype[K];
        }, L.register("GameObjectFactory", U, "add"), M.exports = U;
      }, 91296: (M, B, $) => {
        var E = $(61340), L = new E, z = new E, U = new E, K = { camera: L, sprite: z, calc: U }, J = function(Z, D, Q) {
          var H = L, N = z, W = U;
          if (N.applyITRS(Z.x, Z.y, Z.rotation, Z.scaleX, Z.scaleY), H.copyFrom(D.matrix), Q)
            H.multiplyWithOffset(Q, -D.scrollX * Z.scrollFactorX, -D.scrollY * Z.scrollFactorY), N.e = Z.x, N.f = Z.y;
          else
            N.e -= D.scrollX * Z.scrollFactorX, N.f -= D.scrollY * Z.scrollFactorY;
          return H.multiply(N, W), K;
        };
        M.exports = J;
      }, 45027: (M, B, $) => {
        var E = $(83419), L = $(25774), z = $(37277), U = $(44594), K = new E({ Extends: L, initialize: function J(Z) {
          L.call(this), this.checkQueue = true, this.scene = Z, this.systems = Z.sys, Z.sys.events.once(U.BOOT, this.boot, this), Z.sys.events.on(U.START, this.start, this);
        }, boot: function() {
          this.systems.events.once(U.DESTROY, this.destroy, this);
        }, start: function() {
          var J = this.systems.events;
          J.on(U.PRE_UPDATE, this.update, this), J.on(U.UPDATE, this.sceneUpdate, this), J.once(U.SHUTDOWN, this.shutdown, this);
        }, sceneUpdate: function(J, Z) {
          var D = this._active, Q = D.length;
          for (var H = 0;H < Q; H++) {
            var N = D[H];
            if (N.active)
              N.preUpdate.call(N, J, Z);
          }
        }, shutdown: function() {
          var J = this._active.length;
          while (J--)
            this._active[J].destroy(true);
          J = this._pending.length;
          while (J--)
            this._pending[J].destroy(true);
          J = this._destroy.length;
          while (J--)
            this._destroy[J].destroy(true);
          this._toProcess = 0, this._pending = [], this._active = [], this._destroy = [], this.removeAllListeners();
          var Z = this.systems.events;
          Z.off(U.PRE_UPDATE, this.update, this), Z.off(U.UPDATE, this.sceneUpdate, this), Z.off(U.SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          this.shutdown(), this.systems.events.off(U.START, this.start, this), this.scene = null, this.systems = null;
        } });
        z.register("UpdateList", K, "updateList"), M.exports = K;
      }, 3217: (M) => {
        var B = function($, E, L, z, U, K, J, Z, D, Q, H, N, W, R, Y) {
          var I = L.x - E.displayOriginX + U, P = L.y - E.displayOriginY + K, X = I + L.w, G = P + L.h, V = J.getXRound(I, P, Z), A = J.getYRound(I, P, Z), F = J.getXRound(I, G, Z), j = J.getYRound(I, G, Z), T = J.getXRound(X, G, Z), C = J.getYRound(X, G, Z), v = J.getXRound(X, P, Z), O = J.getYRound(X, P, Z);
          $.batchQuad(E, V, A, F, j, T, C, v, O, z.u0, z.v0, z.u1, z.v1, D, Q, H, N, W, R, Y);
        };
        M.exports = B;
      }, 53048: (M) => {
        var B = function($, E, L, z) {
          if (L === undefined)
            L = false;
          if (z === undefined)
            return z = { local: { x: 0, y: 0, width: 0, height: 0 }, global: { x: 0, y: 0, width: 0, height: 0 }, lines: { shortest: 0, longest: 0, lengths: null, height: 0 }, wrappedText: "", words: [], characters: [], scaleX: 0, scaleY: 0 }, z;
          var U = $.text, K = U.length, J = $.maxWidth, Z = $.wordWrapCharCode, D = Number.MAX_VALUE, Q = Number.MAX_VALUE, H = 0, N = 0, W = $.fontData.chars, R = $.fontData.lineHeight, Y = $.letterSpacing, I = $.lineSpacing, P = 0, X = 0, G = 0, V = null, A = $._align, F = 0, j = 0, T = $.fontSize / $.fontData.size, C = T * $.scaleX, v = T * $.scaleY, O = null, q = 0, w = [], g = Number.MAX_VALUE, b = 0, x = 0, k = 0, S, f = [], h = [], m = null;
          if (J > 0) {
            for (S = 0;S < K; S++) {
              if (G = U.charCodeAt(S), G === 10) {
                if (m !== null)
                  f.push({ word: m.word, i: m.i, x: m.x * C, y: m.y * v, w: m.w * C, h: m.h * v, cr: true }), m = null;
                P = 0, X += R + I, O = null;
                continue;
              }
              if (V = W[G], !V)
                continue;
              if (O !== null)
                var y = V.kerning[q];
              if (G === Z) {
                if (m !== null)
                  f.push({ word: m.word, i: m.i, x: m.x * C, y: m.y * v, w: m.w * C, h: m.h * v, cr: false }), m = null;
              } else {
                if (m === null)
                  m = { word: "", i: S, x: P, y: X, w: 0, h: R, cr: false };
                m.word = m.word.concat(U[S]), m.w += V.xOffset + V.xAdvance + (y !== undefined ? y : 0);
              }
              P += V.xAdvance + Y, O = V, q = G;
            }
            if (m !== null)
              f.push({ word: m.word, i: m.i, x: m.x * C, y: m.y * v, w: m.w * C, h: m.h * v, cr: false });
            P = 0, X = 0, O = null, q = 0;
            var d, p = 0, u = [];
            for (S = 0;S < f.length; S++) {
              var s = f[S], c = s.x, n = s.x + s.w;
              if (d) {
                var _ = c - (d.x + d.w);
                p = c - (_ + d.w), d = null;
              }
              var l = c - p, i = n - p;
              if (l > J || i > J)
                if (u.push(s.i - 1), s.cr)
                  u.push(s.i + s.word.length), p = 0, d = null;
                else
                  d = s;
              else if (s.cr)
                u.push(s.i + s.word.length), p = 0, d = null;
            }
            var t = function(U0, N0, E0) {
              return U0.substr(0, N0) + E0 + U0.substr(N0 + 1);
            };
            for (S = u.length - 1;S >= 0; S--)
              U = t(U, u[S], "\n");
            z.wrappedText = U, K = U.length, f = [], m = null;
          }
          var $0 = 0;
          for (S = 0;S < K; S++) {
            if (G = U.charCodeAt(S), G === 10) {
              if (m !== null)
                f.push({ word: m.word, i: m.i, x: m.x * C, y: m.y * v, w: m.w * C, h: m.h * v }), m = null;
              if (P = 0, X += R + I, O = null, w[x] = k, k > b)
                b = k;
              if (k < g)
                g = k;
              x++, k = 0;
              continue;
            }
            if (V = W[G], !V)
              continue;
            if (F = P, j = X, O !== null) {
              var e = V.kerning[q];
              F += e !== undefined ? e : 0;
            }
            if (D > F)
              D = F;
            if (Q > j)
              Q = j;
            var o = F + V.xAdvance, r = j + R;
            if (H < o)
              H = o;
            if (N < r)
              N = r;
            var a = V.xOffset + V.xAdvance + (e !== undefined ? e : 0);
            if (G === Z) {
              if (m !== null)
                f.push({ word: m.word, i: m.i, x: m.x * C, y: m.y * v, w: m.w * C, h: m.h * v }), m = null;
            } else {
              if (m === null)
                m = { word: "", i: $0, x: P, y: X, w: 0, h: R };
              m.word = m.word.concat(U[S]), m.w += a;
            }
            h.push({ i: $0, idx: S, char: U[S], code: G, x: (V.xOffset + F) * T, y: (V.yOffset + X) * T, w: V.width * T, h: V.height * T, t: X * T, r: o * T, b: R * T, line: x, glyph: V }), P += V.xAdvance + Y + (e !== undefined ? e : 0), O = V, q = G, k = o * T, $0++;
          }
          if (m !== null)
            f.push({ word: m.word, i: m.i, x: m.x * C, y: m.y * v, w: m.w * C, h: m.h * v });
          if (w[x] = k, k > b)
            b = k;
          if (k < g)
            g = k;
          if (A > 0)
            for (var J0 = 0;J0 < h.length; J0++) {
              var Q0 = h[J0];
              if (A === 1) {
                var D0 = (b - w[Q0.line]) / 2;
                Q0.x += D0, Q0.r += D0;
              } else if (A === 2) {
                var z0 = b - w[Q0.line];
                Q0.x += z0, Q0.r += z0;
              }
            }
          var { local: K0, global: Z0, lines: W0 } = z;
          if (K0.x = D * T, K0.y = Q * T, K0.width = H * T, K0.height = N * T, Z0.x = $.x - $._displayOriginX + D * C, Z0.y = $.y - $._displayOriginY + Q * v, Z0.width = H * C, Z0.height = N * v, W0.shortest = g, W0.longest = b, W0.lengths = w, E)
            K0.x = Math.ceil(K0.x), K0.y = Math.ceil(K0.y), K0.width = Math.ceil(K0.width), K0.height = Math.ceil(K0.height), Z0.x = Math.ceil(Z0.x), Z0.y = Math.ceil(Z0.y), Z0.width = Math.ceil(Z0.width), Z0.height = Math.ceil(Z0.height), W0.shortest = Math.ceil(g), W0.longest = Math.ceil(b);
          if (L) {
            if ($._displayOriginX = $.originX * K0.width, $._displayOriginY = $.originY * K0.height, Z0.x = $.x - $._displayOriginX * $.scaleX, Z0.y = $.y - $._displayOriginY * $.scaleY, E)
              Z0.x = Math.ceil(Z0.x), Z0.y = Math.ceil(Z0.y);
          }
          return z.words = f, z.characters = h, z.lines.height = R, z.scale = T, z.scaleX = $.scaleX, z.scaleY = $.scaleY, z;
        };
        M.exports = B;
      }, 61327: (M, B, $) => {
        var E = $(21859), L = function(z, U, K, J, Z, D, Q) {
          var H = z.sys.textures.get(K), N = H.get(J), W = z.sys.cache.xml.get(Z);
          if (N && W) {
            var R = E(W, N, D, Q, H);
            return z.sys.cache.bitmapFont.add(U, { data: R, texture: K, frame: J, fromAtlas: true }), true;
          } else
            return false;
        };
        M.exports = L;
      }, 6925: (M, B, $) => {
        var E = $(35154), L = function(z, U) {
          var { width: K, height: J } = U, Z = Math.floor(K / 2), D = Math.floor(J / 2), Q = E(U, "chars", "");
          if (Q === "")
            return;
          var H = E(U, "image", ""), N = z.sys.textures.getFrame(H), W = N.cutX, R = N.cutY, Y = N.source.width, I = N.source.height, P = E(U, "offset.x", 0), X = E(U, "offset.y", 0), G = E(U, "spacing.x", 0), V = E(U, "spacing.y", 0), A = E(U, "lineSpacing", 0), F = E(U, "charsPerRow", null);
          if (F === null) {
            if (F = Y / K, F > Q.length)
              F = Q.length;
          }
          var j = P, T = X, C = { retroFont: true, font: H, size: K, lineHeight: J + A, chars: {} }, v = 0;
          for (var O = 0;O < Q.length; O++) {
            var q = Q.charCodeAt(O), w = (W + j) / Y, g = (R + T) / I, b = (W + j + K) / Y, x = (R + T + J) / I;
            if (C.chars[q] = { x: j, y: T, width: K, height: J, centerX: Z, centerY: D, xOffset: 0, yOffset: 0, xAdvance: K, data: {}, kerning: {}, u0: w, v0: g, u1: b, v1: x }, v++, v === F)
              v = 0, j = P, T += J + V;
            else
              j += K + G;
          }
          var k = { data: C, frame: null, texture: H };
          return k;
        };
        M.exports = L;
      }, 21859: (M) => {
        function B(E, L) {
          return parseInt(E.getAttribute(L), 10);
        }
        var $ = function(E, L, z, U, K) {
          if (z === undefined)
            z = 0;
          if (U === undefined)
            U = 0;
          var { cutX: J, cutY: Z } = L, D = L.source.width, Q = L.source.height, H = L.sourceIndex, N = {}, W = E.getElementsByTagName("info")[0], R = E.getElementsByTagName("common")[0];
          N.font = W.getAttribute("face"), N.size = B(W, "size"), N.lineHeight = B(R, "lineHeight") + U, N.chars = {};
          var Y = E.getElementsByTagName("char"), I = L !== undefined && L.trimmed;
          if (I)
            var { height: P, width: X } = L;
          for (var G = 0;G < Y.length; G++) {
            var V = Y[G], A = B(V, "id"), F = String.fromCharCode(A), j = B(V, "x"), T = B(V, "y"), C = B(V, "width"), v = B(V, "height");
            if (I) {
              if (j < X)
                X = j;
              if (T < P)
                P = T;
            }
            if (I && P !== 0 && X !== 0)
              j -= L.x, T -= L.y;
            var O = (J + j) / D, q = (Z + T) / Q, w = (J + j + C) / D, g = (Z + T + v) / Q;
            if (N.chars[A] = { x: j, y: T, width: C, height: v, centerX: Math.floor(C / 2), centerY: Math.floor(v / 2), xOffset: B(V, "xoffset"), yOffset: B(V, "yoffset"), xAdvance: B(V, "xadvance") + z, data: {}, kerning: {}, u0: O, v0: q, u1: w, v1: g }, K && C !== 0 && v !== 0) {
              var b = K.add(F, H, j, T, C, v);
              if (b)
                b.setUVs(C, v, O, q, w, g);
            }
          }
          var x = E.getElementsByTagName("kerning");
          for (G = 0;G < x.length; G++) {
            var k = x[G], S = B(k, "first"), f = B(k, "second"), h = B(k, "amount");
            N.chars[f].kerning[S] = h;
          }
          return N;
        };
        M.exports = $;
      }, 196: (M, B, $) => {
        var E = $(87662), L = $(79291), z = { Parse: $(6925) };
        z = L(false, z, E), M.exports = z;
      }, 87662: (M) => {
        var B = { TEXT_SET1: ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~', TEXT_SET2: ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ', TEXT_SET3: "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", TEXT_SET4: "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789", TEXT_SET5: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() \'!?-*:0123456789", TEXT_SET6: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.\' ', TEXT_SET7: 'AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-\'39', TEXT_SET8: "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ", TEXT_SET9: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,\'"?!', TEXT_SET10: "ABCDEFGHIJKLMNOPQRSTUVWXYZ", TEXT_SET11: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()\':;0123456789' };
        M.exports = B;
      }, 2638: (M, B, $) => {
        var E = $(22186), L = $(83419), z = $(12310), U = new L({ Extends: E, Mixins: [z], initialize: function K(J, Z, D, Q, H, N, W) {
          E.call(this, J, Z, D, Q, H, N, W), this.type = "DynamicBitmapText", this.scrollX = 0, this.scrollY = 0, this.cropWidth = 0, this.cropHeight = 0, this.displayCallback, this.callbackData = { parent: this, color: 0, tint: { topLeft: 0, topRight: 0, bottomLeft: 0, bottomRight: 0 }, index: 0, charCode: 0, x: 0, y: 0, scale: 0, rotation: 0, data: 0 };
        }, setSize: function(K, J) {
          return this.cropWidth = K, this.cropHeight = J, this;
        }, setDisplayCallback: function(K) {
          return this.displayCallback = K, this;
        }, setScrollX: function(K) {
          return this.scrollX = K, this;
        }, setScrollY: function(K) {
          return this.scrollY = K, this;
        } });
        M.exports = U;
      }, 86741: (M, B, $) => {
        var E = $(20926), L = function(z, U, K, J) {
          var Z = U._text, D = Z.length, Q = z.currentContext;
          if (D === 0 || !E(z, Q, U, K, J))
            return;
          K.addToRenderList(U);
          var H = U.fromAtlas ? U.frame : U.texture.frames.__BASE, N = U.displayCallback, W = U.callbackData, R = U.fontData.chars, Y = U.fontData.lineHeight, I = U._letterSpacing, P = 0, X = 0, G = 0, V = null, A = 0, F = 0, j = 0, T = 0, C = 0, v = 0, O = null, q = 0, w = U.frame.source.image, g = H.cutX, b = H.cutY, x = 0, k = 0, S = U._fontSize / U.fontData.size, f = U._align, h = 0, m = 0;
          U.getTextBounds(false);
          var y = U._bounds.lines;
          if (f === 1)
            m = (y.longest - y.lengths[0]) / 2;
          else if (f === 2)
            m = y.longest - y.lengths[0];
          Q.translate(-U.displayOriginX, -U.displayOriginY);
          var d = K.roundPixels;
          if (U.cropWidth > 0 && U.cropHeight > 0)
            Q.beginPath(), Q.rect(0, 0, U.cropWidth, U.cropHeight), Q.clip();
          for (var p = 0;p < D; p++) {
            if (k = S, x = 0, G = Z.charCodeAt(p), G === 10) {
              if (h++, f === 1)
                m = (y.longest - y.lengths[h]) / 2;
              else if (f === 2)
                m = y.longest - y.lengths[h];
              P = 0, X += Y, O = null;
              continue;
            }
            if (V = R[G], !V)
              continue;
            if (A = g + V.x, F = b + V.y, j = V.width, T = V.height, C = V.xOffset + P - U.scrollX, v = V.yOffset + X - U.scrollY, O !== null) {
              var u = V.kerning[q];
              C += u !== undefined ? u : 0;
            }
            if (N) {
              W.index = p, W.charCode = G, W.x = C, W.y = v, W.scale = k, W.rotation = x, W.data = V.data;
              var s = N(W);
              C = s.x, v = s.y, k = s.scale, x = s.rotation;
            }
            if (C *= k, v *= k, C += m, P += V.xAdvance + I + (u !== undefined ? u : 0), O = V, q = G, j === 0 || T === 0 || G === 32)
              continue;
            if (d)
              C = Math.round(C), v = Math.round(v);
            Q.save(), Q.translate(C, v), Q.rotate(x), Q.scale(k, k), Q.drawImage(w, A, F, j, T, 0, 0, j, T), Q.restore();
          }
          Q.restore();
        };
        M.exports = L;
      }, 11164: (M, B, $) => {
        var E = $(2638), L = $(25305), z = $(44603), U = $(23568);
        z.register("dynamicBitmapText", function(K, J) {
          if (K === undefined)
            K = {};
          var Z = U(K, "font", ""), D = U(K, "text", ""), Q = U(K, "size", false), H = new E(this.scene, 0, 0, Z, D, Q);
          if (J !== undefined)
            K.add = J;
          return L(this.scene, H, K), H;
        });
      }, 72566: (M, B, $) => {
        var E = $(2638), L = $(39429);
        L.register("dynamicBitmapText", function(z, U, K, J, Z) {
          return this.displayList.add(new E(this.scene, z, U, K, J, Z));
        });
      }, 12310: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(73482), z = $(86741), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 73482: (M, B, $) => {
        var E = $(91296), L = $(61340), z = $(70554), U = new L, K = function(J, Z, D, Q) {
          var H = Z.text, N = H.length;
          if (N === 0)
            return;
          D.addToRenderList(Z);
          var W = J.pipelines.set(Z.pipeline, Z), R = E(Z, D, Q);
          J.pipelines.preBatch(Z);
          var { sprite: Y, calc: I } = R, P = U, X = Z.cropWidth > 0 || Z.cropHeight > 0;
          if (X)
            W.flush(), J.pushScissor(I.tx, I.ty, Z.cropWidth * I.scaleX, Z.cropHeight * I.scaleY);
          var G = Z.frame, V = G.glTexture, A = Z.tintFill, F = z.getTintAppendFloatAlpha(Z.tintTopLeft, D.alpha * Z._alphaTL), j = z.getTintAppendFloatAlpha(Z.tintTopRight, D.alpha * Z._alphaTR), T = z.getTintAppendFloatAlpha(Z.tintBottomLeft, D.alpha * Z._alphaBL), C = z.getTintAppendFloatAlpha(Z.tintBottomRight, D.alpha * Z._alphaBR), v = W.setGameObject(Z), O = 0, q = 0, w = 0, g = 0, b = Z.letterSpacing, x, k = 0, S = 0, f, h = Z.scrollX, m = Z.scrollY, y = Z.fontData, d = y.chars, p = y.lineHeight, u = Z.fontSize / y.size, s = 0, c = Z._align, n = 0, _ = 0, l = Z.getTextBounds(false);
          if (Z.maxWidth > 0)
            H = l.wrappedText, N = H.length;
          var i = Z._bounds.lines;
          if (c === 1)
            _ = (i.longest - i.lengths[0]) / 2;
          else if (c === 2)
            _ = i.longest - i.lengths[0];
          var t = D.roundPixels, $0 = Z.displayCallback, e = Z.callbackData;
          for (var o = 0;o < N; o++) {
            if (w = H.charCodeAt(o), w === 10) {
              if (n++, c === 1)
                _ = (i.longest - i.lengths[n]) / 2;
              else if (c === 2)
                _ = i.longest - i.lengths[n];
              O = 0, q += p, f = null;
              continue;
            }
            if (x = d[w], !x)
              continue;
            k = x.width, S = x.height;
            var r = x.xOffset + O - h, a = x.yOffset + q - m;
            if (f !== null) {
              var J0 = x.kerning[g];
              r += J0 !== undefined ? J0 : 0;
            }
            if (O += x.xAdvance + b, f = x, g = w, k === 0 || S === 0 || w === 32)
              continue;
            if (u = Z.fontSize / Z.fontData.size, s = 0, $0) {
              e.color = 0, e.tint.topLeft = F, e.tint.topRight = j, e.tint.bottomLeft = T, e.tint.bottomRight = C, e.index = o, e.charCode = w, e.x = r, e.y = a, e.scale = u, e.rotation = s, e.data = x.data;
              var Q0 = $0(e);
              if (r = Q0.x, a = Q0.y, u = Q0.scale, s = Q0.rotation, Q0.color)
                F = Q0.color, j = Q0.color, T = Q0.color, C = Q0.color;
              else
                F = Q0.tint.topLeft, j = Q0.tint.topRight, T = Q0.tint.bottomLeft, C = Q0.tint.bottomRight;
              F = z.getTintAppendFloatAlpha(F, D.alpha * Z._alphaTL), j = z.getTintAppendFloatAlpha(j, D.alpha * Z._alphaTR), T = z.getTintAppendFloatAlpha(T, D.alpha * Z._alphaBL), C = z.getTintAppendFloatAlpha(C, D.alpha * Z._alphaBR);
            }
            r *= u, a *= u, r -= Z.displayOriginX, a -= Z.displayOriginY, r += _, P.applyITRS(r, a, s, u, u), I.multiply(P, Y);
            var { u0: D0, v0: z0, u1: K0, v1: Z0 } = x, W0 = k, U0 = S, N0 = Y.e, E0 = Y.f, L0 = U0 * Y.c + Y.e, I0 = U0 * Y.d + Y.f, X0 = W0 * Y.a + U0 * Y.c + Y.e, P0 = W0 * Y.b + U0 * Y.d + Y.f, G0 = W0 * Y.a + Y.e, V0 = W0 * Y.b + Y.f;
            if (t)
              N0 = Math.round(N0), E0 = Math.round(E0), L0 = Math.round(L0), I0 = Math.round(I0), X0 = Math.round(X0), P0 = Math.round(P0), G0 = Math.round(G0), V0 = Math.round(V0);
            if (W.shouldFlush(6))
              W.flush(), v = W.setGameObject(Z);
            W.batchQuad(Z, N0, E0, L0, I0, X0, P0, G0, V0, D0, z0, K0, Z0, F, j, T, C, A, V, v);
          }
          if (X)
            W.flush(), J.popScissor();
          J.pipelines.postBatch(Z);
        };
        M.exports = K;
      }, 22186: (M, B, $) => {
        var E = $(83419), L = $(45319), z = $(31401), U = $(95643), K = $(53048), J = $(61327), Z = $(21859), D = $(87841), Q = $(18658), H = new E({ Extends: U, Mixins: [z.Alpha, z.BlendMode, z.Depth, z.GetBounds, z.Mask, z.Origin, z.Pipeline, z.PostPipeline, z.ScrollFactor, z.Texture, z.Tint, z.Transform, z.Visible, Q], initialize: function N(W, R, Y, I, P, X, G) {
          if (P === undefined)
            P = "";
          if (G === undefined)
            G = 0;
          U.call(this, W, "BitmapText"), this.font = I;
          var V = this.scene.sys.cache.bitmapFont.get(I);
          if (!V)
            console.warn("Invalid BitmapText key: " + I);
          this.fontData = V.data, this._text = "", this._fontSize = X || this.fontData.size, this._letterSpacing = 0, this._lineSpacing = 0, this._align = G, this._bounds = K(), this._dirty = true, this._maxWidth = 0, this.wordWrapCharCode = 32, this.charColors = [], this.dropShadowX = 0, this.dropShadowY = 0, this.dropShadowColor = 0, this.dropShadowAlpha = 0.5, this.fromAtlas = V.fromAtlas, this.setTexture(V.texture, V.frame), this.setPosition(R, Y), this.setOrigin(0, 0), this.initPipeline(), this.initPostPipeline(), this.setText(P);
        }, setLeftAlign: function() {
          return this._align = H.ALIGN_LEFT, this._dirty = true, this;
        }, setCenterAlign: function() {
          return this._align = H.ALIGN_CENTER, this._dirty = true, this;
        }, setRightAlign: function() {
          return this._align = H.ALIGN_RIGHT, this._dirty = true, this;
        }, setFontSize: function(N) {
          return this._fontSize = N, this._dirty = true, this;
        }, setLetterSpacing: function(N) {
          if (N === undefined)
            N = 0;
          return this._letterSpacing = N, this._dirty = true, this;
        }, setLineSpacing: function(N) {
          if (N === undefined)
            N = 0;
          return this.lineSpacing = N, this;
        }, setText: function(N) {
          if (!N && N !== 0)
            N = "";
          if (Array.isArray(N))
            N = N.join("\n");
          if (N !== this.text)
            this._text = N.toString(), this._dirty = true, this.updateDisplayOrigin();
          return this;
        }, setDropShadow: function(N, W, R, Y) {
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = 0;
          if (R === undefined)
            R = 0;
          if (Y === undefined)
            Y = 0.5;
          return this.dropShadowX = N, this.dropShadowY = W, this.dropShadowColor = R, this.dropShadowAlpha = Y, this;
        }, setCharacterTint: function(N, W, R, Y, I, P, X) {
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = 1;
          if (R === undefined)
            R = false;
          if (Y === undefined)
            Y = -1;
          if (I === undefined)
            I = Y, P = Y, X = Y;
          var G = this.text.length;
          if (W === -1)
            W = G;
          if (N < 0)
            N = G + N;
          N = L(N, 0, G - 1);
          var V = L(N + W, N, G), A = this.charColors;
          for (var F = N;F < V; F++) {
            var j = A[F];
            if (Y === -1)
              A[F] = null;
            else {
              var T = R ? 1 : 0;
              if (j)
                j.tintEffect = T, j.tintTL = Y, j.tintTR = I, j.tintBL = P, j.tintBR = X;
              else
                A[F] = { tintEffect: T, tintTL: Y, tintTR: I, tintBL: P, tintBR: X };
            }
          }
          return this;
        }, setWordTint: function(N, W, R, Y, I, P, X) {
          if (W === undefined)
            W = 1;
          var G = this.getTextBounds(), V = G.words, A = typeof N === "number", F = 0;
          for (var j = 0;j < V.length; j++) {
            var T = V[j];
            if (A && j === N || !A && T.word === N) {
              if (this.setCharacterTint(T.i, T.word.length, R, Y, I, P, X), F++, F === W)
                return this;
            }
          }
          return this;
        }, getTextBounds: function(N) {
          var W = this._bounds;
          if (this._dirty || N || this.scaleX !== W.scaleX || this.scaleY !== W.scaleY)
            K(this, N, true, W), this._dirty = false;
          return W;
        }, getCharacterAt: function(N, W, R) {
          var Y = this.getLocalPoint(N, W, null, R), I = this.getTextBounds(), P = I.characters, X = new D;
          for (var G = 0;G < P.length; G++) {
            var V = P[G];
            if (X.setTo(V.x, V.t, V.r - V.x, V.b), X.contains(Y.x, Y.y))
              return V;
          }
          return null;
        }, updateDisplayOrigin: function() {
          return this._dirty = true, this.getTextBounds(false), this;
        }, setFont: function(N, W, R) {
          if (W === undefined)
            W = this._fontSize;
          if (R === undefined)
            R = this._align;
          var Y = this.scene.sys.cache.bitmapFont.get(N);
          if (Y)
            this.font = N, this.fontData = Y.data, this._fontSize = W, this._align = R, this.fromAtlas = Y.fromAtlas === true, this.setTexture(Y.texture, Y.frame), K(this, false, true, this._bounds);
          return this;
        }, setMaxWidth: function(N, W) {
          if (this._maxWidth = N, this._dirty = true, W !== undefined)
            this.wordWrapCharCode = W;
          return this;
        }, align: { set: function(N) {
          this._align = N, this._dirty = true;
        }, get: function() {
          return this._align;
        } }, text: { set: function(N) {
          this.setText(N);
        }, get: function() {
          return this._text;
        } }, fontSize: { set: function(N) {
          this._fontSize = N, this._dirty = true;
        }, get: function() {
          return this._fontSize;
        } }, letterSpacing: { set: function(N) {
          this._letterSpacing = N, this._dirty = true;
        }, get: function() {
          return this._letterSpacing;
        } }, lineSpacing: { set: function(N) {
          this._lineSpacing = N, this._dirty = true;
        }, get: function() {
          return this._lineSpacing;
        } }, maxWidth: { set: function(N) {
          this._maxWidth = N, this._dirty = true;
        }, get: function() {
          return this._maxWidth;
        } }, width: { get: function() {
          return this.getTextBounds(false), this._bounds.global.width;
        } }, height: { get: function() {
          return this.getTextBounds(false), this._bounds.global.height;
        } }, displayWidth: { get: function() {
          return this.width;
        } }, displayHeight: { get: function() {
          return this.height;
        } }, toJSON: function() {
          var N = z.ToJSON(this), W = { font: this.font, text: this.text, fontSize: this.fontSize, letterSpacing: this.letterSpacing, lineSpacing: this.lineSpacing, align: this.align };
          return N.data = W, N;
        }, preDestroy: function() {
          this.charColors.length = 0, this._bounds = null, this.fontData = null;
        } });
        H.ALIGN_LEFT = 0, H.ALIGN_CENTER = 1, H.ALIGN_RIGHT = 2, H.ParseFromAtlas = J, H.ParseXMLBitmapFont = Z, M.exports = H;
      }, 37289: (M, B, $) => {
        var E = $(20926), L = function(z, U, K, J) {
          var Z = U._text, D = Z.length, Q = z.currentContext;
          if (D === 0 || !E(z, Q, U, K, J))
            return;
          K.addToRenderList(U);
          var H = U.fromAtlas ? U.frame : U.texture.frames.__BASE, N = U.fontData.chars, W = U.fontData.lineHeight, R = U._letterSpacing, Y = U._lineSpacing, I = 0, P = 0, X = 0, G = null, V = 0, A = 0, F = 0, j = 0, T = 0, C = 0, v = null, O = 0, q = H.source.image, w = H.cutX, g = H.cutY, b = U._fontSize / U.fontData.size, x = U._align, k = 0, S = 0, f = U.getTextBounds(false);
          if (U.maxWidth > 0)
            Z = f.wrappedText, D = Z.length;
          var h = U._bounds.lines;
          if (x === 1)
            S = (h.longest - h.lengths[0]) / 2;
          else if (x === 2)
            S = h.longest - h.lengths[0];
          Q.translate(-U.displayOriginX, -U.displayOriginY);
          var m = K.roundPixels;
          for (var y = 0;y < D; y++) {
            if (X = Z.charCodeAt(y), X === 10) {
              if (k++, x === 1)
                S = (h.longest - h.lengths[k]) / 2;
              else if (x === 2)
                S = h.longest - h.lengths[k];
              I = 0, P += W + Y, v = null;
              continue;
            }
            if (G = N[X], !G)
              continue;
            if (V = w + G.x, A = g + G.y, F = G.width, j = G.height, T = G.xOffset + I, C = G.yOffset + P, v !== null) {
              var d = G.kerning[O];
              T += d !== undefined ? d : 0;
            }
            if (T *= b, C *= b, T += S, I += G.xAdvance + R + (d !== undefined ? d : 0), v = G, O = X, F === 0 || j === 0 || X === 32)
              continue;
            if (m)
              T = Math.round(T), C = Math.round(C);
            Q.save(), Q.translate(T, C), Q.scale(b, b), Q.drawImage(q, V, A, F, j, 0, 0, F, j), Q.restore();
          }
          Q.restore();
        };
        M.exports = L;
      }, 57336: (M, B, $) => {
        var E = $(22186), L = $(25305), z = $(44603), U = $(23568), K = $(35154);
        z.register("bitmapText", function(J, Z) {
          if (J === undefined)
            J = {};
          var D = K(J, "font", ""), Q = U(J, "text", ""), H = U(J, "size", false), N = K(J, "align", 0), W = new E(this.scene, 0, 0, D, Q, H, N);
          if (Z !== undefined)
            J.add = Z;
          return L(this.scene, W, J), W;
        });
      }, 34914: (M, B, $) => {
        var E = $(22186), L = $(39429);
        L.register("bitmapText", function(z, U, K, J, Z, D) {
          return this.displayList.add(new E(this.scene, z, U, K, J, Z, D));
        });
      }, 18658: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(33590), z = $(37289), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 33590: (M, B, $) => {
        var E = $(3217), L = $(91296), z = $(70554), U = function(K, J, Z, D) {
          var Q = J._text, H = Q.length;
          if (H === 0)
            return;
          Z.addToRenderList(J);
          var N = K.pipelines.set(J.pipeline, J), W = L(J, Z, D).calc;
          K.pipelines.preBatch(J);
          var { roundPixels: R, alpha: Y } = Z, I = J.charColors, P = J.tintFill, X = z.getTintAppendFloatAlpha, G = X(J.tintTopLeft, Y * J._alphaTL), V = X(J.tintTopRight, Y * J._alphaTR), A = X(J.tintBottomLeft, Y * J._alphaBL), F = X(J.tintBottomRight, Y * J._alphaBR), j = J.frame.glTexture, T = N.setGameObject(J), C = J.getTextBounds(false), v, O, q, w = C.characters, g = J.dropShadowX, b = J.dropShadowY, x = g !== 0 || b !== 0;
          if (x) {
            var { dropShadowColor: k, dropShadowAlpha: S } = J, f = X(k, Y * S * J._alphaTL), h = X(k, Y * S * J._alphaTR), m = X(k, Y * S * J._alphaBL), y = X(k, Y * S * J._alphaBR);
            for (v = 0;v < w.length; v++) {
              if (O = w[v], q = O.glyph, O.code === 32 || q.width === 0 || q.height === 0)
                continue;
              E(N, J, O, q, g, b, W, R, f, h, m, y, 1, j, T);
            }
          }
          for (v = 0;v < w.length; v++) {
            if (O = w[v], q = O.glyph, O.code === 32 || q.width === 0 || q.height === 0)
              continue;
            if (N.shouldFlush(6))
              N.flush(), T = N.setGameObject(J);
            if (I[O.i]) {
              var d = I[O.i], p = d.tintEffect, u = X(d.tintTL, Y * J._alphaTL), s = X(d.tintTR, Y * J._alphaTR), c = X(d.tintBL, Y * J._alphaBL), n = X(d.tintBR, Y * J._alphaBR);
              E(N, J, O, q, 0, 0, W, R, u, s, c, n, p, j, T);
            } else
              E(N, J, O, q, 0, 0, W, R, G, V, A, F, P, j, T);
          }
          K.pipelines.postBatch(J);
        };
        M.exports = U;
      }, 6107: (M, B, $) => {
        var E = $(48011), L = $(46590), z = $(83419), U = $(31401), K = $(4327), J = $(95643), Z = $(73162), D = new z({ Extends: J, Mixins: [U.Alpha, U.BlendMode, U.Depth, U.Mask, U.Pipeline, U.PostPipeline, U.ScrollFactor, U.Size, U.Texture, U.Transform, U.Visible, E], initialize: function Q(H, N, W, R, Y) {
          J.call(this, H, "Blitter"), this.setTexture(R, Y), this.setPosition(N, W), this.initPipeline(), this.initPostPipeline(), this.children = new Z, this.renderList = [], this.dirty = false;
        }, create: function(Q, H, N, W, R) {
          if (W === undefined)
            W = true;
          if (R === undefined)
            R = this.children.length;
          if (N === undefined)
            N = this.frame;
          else if (!(N instanceof K))
            N = this.texture.get(N);
          var Y = new L(this, Q, H, N, W);
          return this.children.addAt(Y, R, false), this.dirty = true, Y;
        }, createFromCallback: function(Q, H, N, W) {
          var R = this.createMultiple(H, N, W);
          for (var Y = 0;Y < R.length; Y++) {
            var I = R[Y];
            Q.call(this, I, Y);
          }
          return R;
        }, createMultiple: function(Q, H, N) {
          if (H === undefined)
            H = this.frame.name;
          if (N === undefined)
            N = true;
          if (!Array.isArray(H))
            H = [H];
          var W = [], R = this;
          return H.forEach(function(Y) {
            for (var I = 0;I < Q; I++)
              W.push(R.create(0, 0, Y, N));
          }), W;
        }, childCanRender: function(Q) {
          return Q.visible && Q.alpha > 0;
        }, getRenderList: function() {
          if (this.dirty)
            this.renderList = this.children.list.filter(this.childCanRender, this), this.dirty = false;
          return this.renderList;
        }, clear: function() {
          this.children.removeAll(), this.dirty = true;
        }, preDestroy: function() {
          this.children.destroy(), this.renderList = [];
        } });
        M.exports = D;
      }, 72396: (M) => {
        var B = function($, E, L, z) {
          var U = E.getRenderList();
          if (U.length === 0)
            return;
          var K = $.currentContext, J = L.alpha * E.alpha;
          if (J === 0)
            return;
          L.addToRenderList(E), K.globalCompositeOperation = $.blendModes[E.blendMode], K.imageSmoothingEnabled = !E.frame.source.scaleMode;
          var Z = E.x - L.scrollX * E.scrollFactorX, D = E.y - L.scrollY * E.scrollFactorY;
          if (K.save(), z)
            z.copyToContext(K);
          var Q = L.roundPixels;
          for (var H = 0;H < U.length; H++) {
            var N = U[H], W = N.flipX || N.flipY, R = N.frame, Y = R.canvasData, I = R.x, P = R.y, X = 1, G = 1, V = N.alpha * J;
            if (V === 0)
              continue;
            if (K.globalAlpha = V, !W) {
              if (Q)
                I = Math.round(I), P = Math.round(P);
              if (Y.width > 0 && Y.height > 0)
                K.drawImage(R.source.image, Y.x, Y.y, Y.width, Y.height, I + N.x + Z, P + N.y + D, Y.width, Y.height);
            } else {
              if (N.flipX)
                X = -1, I -= Y.width;
              if (N.flipY)
                G = -1, P -= Y.height;
              if (Y.width > 0 && Y.height > 0)
                K.save(), K.translate(N.x + Z, N.y + D), K.scale(X, G), K.drawImage(R.source.image, Y.x, Y.y, Y.width, Y.height, I, P, Y.width, Y.height), K.restore();
            }
          }
          K.restore();
        };
        M.exports = B;
      }, 9403: (M, B, $) => {
        var E = $(6107), L = $(25305), z = $(44603), U = $(23568);
        z.register("blitter", function(K, J) {
          if (K === undefined)
            K = {};
          var Z = U(K, "key", null), D = U(K, "frame", null), Q = new E(this.scene, 0, 0, Z, D);
          if (J !== undefined)
            K.add = J;
          return L(this.scene, Q, K), Q;
        });
      }, 12709: (M, B, $) => {
        var E = $(6107), L = $(39429);
        L.register("blitter", function(z, U, K, J) {
          return this.displayList.add(new E(this.scene, z, U, K, J));
        });
      }, 48011: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(99485), z = $(72396), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 99485: (M, B, $) => {
        var E = $(61340), L = $(70554), z = new E, U = function(K, J, Z, D) {
          var Q = J.getRenderList(), H = Z.alpha * J.alpha;
          if (Q.length === 0 || H === 0)
            return;
          Z.addToRenderList(J);
          var N = K.pipelines.set(this.pipeline, J), W = Z.scrollX * J.scrollFactorX, R = Z.scrollY * J.scrollFactorY, Y = z.copyFrom(Z.matrix);
          if (D)
            Y.multiplyWithOffset(D, -W, -R), W = 0, R = 0;
          var I = J.x - W, P = J.y - R, X = -1, G = false;
          K.pipelines.preBatch(J);
          for (var V = 0;V < Q.length; V++) {
            var A = Q[V], F = A.frame, j = A.alpha * H;
            if (j === 0)
              continue;
            var { width: T, height: C } = F, v = I + A.x + F.x, O = P + A.y + F.y;
            if (A.flipX)
              T *= -1, v += F.width;
            if (A.flipY)
              C *= -1, O += F.height;
            var q = Y.setQuad(v, O, v + T, O + C), w = L.getTintAppendFloatAlpha(A.tint, j);
            if (F.sourceIndex !== X) {
              var g = N.setGameObject(J, F);
              X = F.sourceIndex;
            }
            if (N.batchQuad(J, q[0], q[1], q[2], q[3], q[4], q[5], q[6], q[7], F.u0, F.v0, F.u1, F.v1, w, w, w, w, G, F.glTexture, g))
              X = -1;
          }
          K.pipelines.postBatch(J);
        };
        M.exports = U;
      }, 46590: (M, B, $) => {
        var E = $(83419), L = $(4327), z = new E({ initialize: function U(K, J, Z, D, Q) {
          this.parent = K, this.x = J, this.y = Z, this.frame = D, this.data = {}, this.tint = 16777215, this._visible = Q, this._alpha = 1, this.flipX = false, this.flipY = false, this.hasTransformComponent = true;
        }, setFrame: function(U) {
          if (U === undefined)
            this.frame = this.parent.frame;
          else if (U instanceof L && U.texture === this.parent.texture)
            this.frame = U;
          else
            this.frame = this.parent.texture.get(U);
          return this;
        }, resetFlip: function() {
          return this.flipX = false, this.flipY = false, this;
        }, reset: function(U, K, J) {
          if (this.x = U, this.y = K, this.flipX = false, this.flipY = false, this._alpha = 1, this._visible = true, this.parent.dirty = true, J)
            this.setFrame(J);
          return this;
        }, setPosition: function(U, K) {
          return this.x = U, this.y = K, this;
        }, setFlipX: function(U) {
          return this.flipX = U, this;
        }, setFlipY: function(U) {
          return this.flipY = U, this;
        }, setFlip: function(U, K) {
          return this.flipX = U, this.flipY = K, this;
        }, setVisible: function(U) {
          return this.visible = U, this;
        }, setAlpha: function(U) {
          return this.alpha = U, this;
        }, setTint: function(U) {
          return this.tint = U, this;
        }, destroy: function() {
          this.parent.dirty = true, this.parent.children.remove(this), this.parent = undefined, this.frame = undefined, this.data = undefined;
        }, visible: { get: function() {
          return this._visible;
        }, set: function(U) {
          this.parent.dirty |= this._visible !== U, this._visible = U;
        } }, alpha: { get: function() {
          return this._alpha;
        }, set: function(U) {
          this.parent.dirty |= this._alpha > 0 !== U > 0, this._alpha = U;
        } } });
        M.exports = z;
      }, 16005: (M, B, $) => {
        var E = $(45319), L = 2, z = { _alpha: 1, _alphaTL: 1, _alphaTR: 1, _alphaBL: 1, _alphaBR: 1, clearAlpha: function() {
          return this.setAlpha(1);
        }, setAlpha: function(U, K, J, Z) {
          if (U === undefined)
            U = 1;
          if (K === undefined)
            this.alpha = U;
          else
            this._alphaTL = E(U, 0, 1), this._alphaTR = E(K, 0, 1), this._alphaBL = E(J, 0, 1), this._alphaBR = E(Z, 0, 1);
          return this;
        }, alpha: { get: function() {
          return this._alpha;
        }, set: function(U) {
          var K = E(U, 0, 1);
          if (this._alpha = K, this._alphaTL = K, this._alphaTR = K, this._alphaBL = K, this._alphaBR = K, K === 0)
            this.renderFlags &= ~L;
          else
            this.renderFlags |= L;
        } }, alphaTopLeft: { get: function() {
          return this._alphaTL;
        }, set: function(U) {
          var K = E(U, 0, 1);
          if (this._alphaTL = K, K !== 0)
            this.renderFlags |= L;
        } }, alphaTopRight: { get: function() {
          return this._alphaTR;
        }, set: function(U) {
          var K = E(U, 0, 1);
          if (this._alphaTR = K, K !== 0)
            this.renderFlags |= L;
        } }, alphaBottomLeft: { get: function() {
          return this._alphaBL;
        }, set: function(U) {
          var K = E(U, 0, 1);
          if (this._alphaBL = K, K !== 0)
            this.renderFlags |= L;
        } }, alphaBottomRight: { get: function() {
          return this._alphaBR;
        }, set: function(U) {
          var K = E(U, 0, 1);
          if (this._alphaBR = K, K !== 0)
            this.renderFlags |= L;
        } } };
        M.exports = z;
      }, 88509: (M, B, $) => {
        var E = $(45319), L = 2, z = { _alpha: 1, clearAlpha: function() {
          return this.setAlpha(1);
        }, setAlpha: function(U) {
          if (U === undefined)
            U = 1;
          return this.alpha = U, this;
        }, alpha: { get: function() {
          return this._alpha;
        }, set: function(U) {
          var K = E(U, 0, 1);
          if (this._alpha = K, K === 0)
            this.renderFlags &= ~L;
          else
            this.renderFlags |= L;
        } } };
        M.exports = z;
      }, 90065: (M, B, $) => {
        var E = $(10312), L = { _blendMode: E.NORMAL, blendMode: { get: function() {
          return this._blendMode;
        }, set: function(z) {
          if (typeof z === "string")
            z = E[z];
          if (z |= 0, z >= -1)
            this._blendMode = z;
        } }, setBlendMode: function(z) {
          return this.blendMode = z, this;
        } };
        M.exports = L;
      }, 94215: (M) => {
        var B = { width: 0, height: 0, displayWidth: { get: function() {
          return this.scaleX * this.width;
        }, set: function($) {
          this.scaleX = $ / this.width;
        } }, displayHeight: { get: function() {
          return this.scaleY * this.height;
        }, set: function($) {
          this.scaleY = $ / this.height;
        } }, setSize: function($, E) {
          return this.width = $, this.height = E, this;
        }, setDisplaySize: function($, E) {
          return this.displayWidth = $, this.displayHeight = E, this;
        } };
        M.exports = B;
      }, 61683: (M) => {
        var B = { texture: null, frame: null, isCropped: false, setCrop: function($, E, L, z) {
          if ($ === undefined)
            this.isCropped = false;
          else if (this.frame) {
            if (typeof $ === "number")
              this.frame.setCropUVs(this._crop, $, E, L, z, this.flipX, this.flipY);
            else {
              var U = $;
              this.frame.setCropUVs(this._crop, U.x, U.y, U.width, U.height, this.flipX, this.flipY);
            }
            this.isCropped = true;
          }
          return this;
        }, resetCropObject: function() {
          return { u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false, cx: 0, cy: 0, cw: 0, ch: 0 };
        } };
        M.exports = B;
      }, 89272: (M) => {
        var B = { _depth: 0, depth: { get: function() {
          return this._depth;
        }, set: function($) {
          if (this.displayList)
            this.displayList.queueDepthSort();
          this._depth = $;
        } }, setDepth: function($) {
          if ($ === undefined)
            $ = 0;
          return this.depth = $, this;
        } };
        M.exports = B;
      }, 47059: (M, B, $) => {
        var E = $(83419), L = $(66064), z = $(19133), U = new E({ initialize: function K(J, Z) {
          this.gameObject = J, this.isPost = Z, this.enabled = false, this.list = [], this.padding = 0;
        }, setPadding: function(K) {
          if (K === undefined)
            K = 0;
          return this.padding = K, this.gameObject;
        }, onFXCopy: function() {
        }, onFX: function() {
        }, enable: function(K) {
          if (this.isPost)
            return;
          var J = this.gameObject.scene.sys.renderer;
          if (J && J.pipelines) {
            if (this.gameObject.pipeline = J.pipelines.FX_PIPELINE, K !== undefined)
              this.padding = K;
            this.enabled = true;
          } else
            this.enabled = false;
        }, clear: function() {
          if (this.isPost)
            this.gameObject.resetPostPipeline(true);
          else {
            var K = this.list;
            for (var J = 0;J < K.length; J++)
              K[J].destroy();
            this.list = [];
          }
          return this.enabled = false, this.gameObject;
        }, remove: function(K) {
          var J;
          if (this.isPost) {
            var Z = this.gameObject.getPostPipeline(String(K.type));
            if (!Array.isArray(Z))
              Z = [Z];
            for (J = 0;J < Z.length; J++) {
              var D = Z[J];
              if (D.controller === K) {
                this.gameObject.removePostPipeline(D), K.destroy();
                break;
              }
            }
          } else {
            var Q = this.list;
            for (J = 0;J < Q.length; J++)
              if (Q[J] === K)
                z(Q, J), K.destroy();
          }
          return this.gameObject;
        }, disable: function(K) {
          if (K === undefined)
            K = false;
          if (!this.isPost)
            this.gameObject.resetPipeline();
          if (this.enabled = false, K)
            this.clear();
          return this.gameObject;
        }, add: function(K, J) {
          if (this.isPost) {
            var Z = String(K.type);
            this.gameObject.setPostPipeline(Z, J);
            var D = this.gameObject.getPostPipeline(Z);
            if (D) {
              if (Array.isArray(D))
                D = D.pop();
              return D.controller = K, K;
            }
          } else {
            if (!this.enabled)
              this.enable();
            return this.list.push(K), K;
          }
        }, addGlow: function(K, J, Z, D, Q, H) {
          return this.add(new L.Glow(this.gameObject, K, J, Z, D), { quality: Q, distance: H });
        }, addShadow: function(K, J, Z, D, Q, H, N) {
          return this.add(new L.Shadow(this.gameObject, K, J, Z, D, Q, H, N));
        }, addPixelate: function(K) {
          return this.add(new L.Pixelate(this.gameObject, K));
        }, addVignette: function(K, J, Z, D) {
          return this.add(new L.Vignette(this.gameObject, K, J, Z, D));
        }, addShine: function(K, J, Z, D) {
          return this.add(new L.Shine(this.gameObject, K, J, Z, D));
        }, addBlur: function(K, J, Z, D, Q, H) {
          return this.add(new L.Blur(this.gameObject, K, J, Z, D, Q, H));
        }, addGradient: function(K, J, Z, D, Q, H, N, W) {
          return this.add(new L.Gradient(this.gameObject, K, J, Z, D, Q, H, N, W));
        }, addBloom: function(K, J, Z, D, Q, H) {
          return this.add(new L.Bloom(this.gameObject, K, J, Z, D, Q, H));
        }, addColorMatrix: function() {
          return this.add(new L.ColorMatrix(this.gameObject));
        }, addCircle: function(K, J, Z, D, Q) {
          return this.add(new L.Circle(this.gameObject, K, J, Z, D, Q));
        }, addBarrel: function(K) {
          return this.add(new L.Barrel(this.gameObject, K));
        }, addDisplacement: function(K, J, Z) {
          return this.add(new L.Displacement(this.gameObject, K, J, Z));
        }, addWipe: function(K, J, Z) {
          return this.add(new L.Wipe(this.gameObject, K, J, Z));
        }, addReveal: function(K, J, Z) {
          return this.add(new L.Wipe(this.gameObject, K, J, Z, true));
        }, addBokeh: function(K, J, Z) {
          return this.add(new L.Bokeh(this.gameObject, K, J, Z));
        }, addTiltShift: function(K, J, Z, D, Q, H) {
          return this.add(new L.Bokeh(this.gameObject, K, J, Z, true, D, Q, H));
        }, destroy: function() {
          this.clear(), this.gameObject = null;
        } });
        M.exports = U;
      }, 54434: (M) => {
        var B = { flipX: false, flipY: false, toggleFlipX: function() {
          return this.flipX = !this.flipX, this;
        }, toggleFlipY: function() {
          return this.flipY = !this.flipY, this;
        }, setFlipX: function($) {
          return this.flipX = $, this;
        }, setFlipY: function($) {
          return this.flipY = $, this;
        }, setFlip: function($, E) {
          return this.flipX = $, this.flipY = E, this;
        }, resetFlip: function() {
          return this.flipX = false, this.flipY = false, this;
        } };
        M.exports = B;
      }, 8004: (M, B, $) => {
        var E = $(87841), L = $(11520), z = $(26099), U = { prepareBoundsOutput: function(K, J) {
          if (J === undefined)
            J = false;
          if (this.rotation !== 0)
            L(K, this.x, this.y, this.rotation);
          if (J && this.parentContainer) {
            var Z = this.parentContainer.getBoundsTransformMatrix();
            Z.transformPoint(K.x, K.y, K);
          }
          return K;
        }, getCenter: function(K, J) {
          if (K === undefined)
            K = new z;
          return K.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, K.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(K, J);
        }, getTopLeft: function(K, J) {
          if (!K)
            K = new z;
          return K.x = this.x - this.displayWidth * this.originX, K.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(K, J);
        }, getTopCenter: function(K, J) {
          if (!K)
            K = new z;
          return K.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, K.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(K, J);
        }, getTopRight: function(K, J) {
          if (!K)
            K = new z;
          return K.x = this.x - this.displayWidth * this.originX + this.displayWidth, K.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(K, J);
        }, getLeftCenter: function(K, J) {
          if (!K)
            K = new z;
          return K.x = this.x - this.displayWidth * this.originX, K.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(K, J);
        }, getRightCenter: function(K, J) {
          if (!K)
            K = new z;
          return K.x = this.x - this.displayWidth * this.originX + this.displayWidth, K.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(K, J);
        }, getBottomLeft: function(K, J) {
          if (!K)
            K = new z;
          return K.x = this.x - this.displayWidth * this.originX, K.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(K, J);
        }, getBottomCenter: function(K, J) {
          if (!K)
            K = new z;
          return K.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, K.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(K, J);
        }, getBottomRight: function(K, J) {
          if (!K)
            K = new z;
          return K.x = this.x - this.displayWidth * this.originX + this.displayWidth, K.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(K, J);
        }, getBounds: function(K) {
          if (K === undefined)
            K = new E;
          var J, Z, D, Q, H, N, W, R;
          if (this.parentContainer) {
            var Y = this.parentContainer.getBoundsTransformMatrix();
            this.getTopLeft(K), Y.transformPoint(K.x, K.y, K), J = K.x, Z = K.y, this.getTopRight(K), Y.transformPoint(K.x, K.y, K), D = K.x, Q = K.y, this.getBottomLeft(K), Y.transformPoint(K.x, K.y, K), H = K.x, N = K.y, this.getBottomRight(K), Y.transformPoint(K.x, K.y, K), W = K.x, R = K.y;
          } else
            this.getTopLeft(K), J = K.x, Z = K.y, this.getTopRight(K), D = K.x, Q = K.y, this.getBottomLeft(K), H = K.x, N = K.y, this.getBottomRight(K), W = K.x, R = K.y;
          return K.x = Math.min(J, D, H, W), K.y = Math.min(Z, Q, N, R), K.width = Math.max(J, D, H, W) - K.x, K.height = Math.max(Z, Q, N, R) - K.y, K;
        } };
        M.exports = U;
      }, 8573: (M, B, $) => {
        var E = $(6858), L = $(80661), z = { mask: null, setMask: function(U) {
          return this.mask = U, this;
        }, clearMask: function(U) {
          if (U === undefined)
            U = false;
          if (U && this.mask)
            this.mask.destroy();
          return this.mask = null, this;
        }, createBitmapMask: function(U, K, J, Z, D) {
          if (U === undefined && (this.texture || this.shader || this.geom))
            U = this;
          return new E(this.scene, U, K, J, Z, D);
        }, createGeometryMask: function(U) {
          if (U === undefined && (this.type === "Graphics" || this.geom))
            U = this;
          return new L(this.scene, U);
        } };
        M.exports = z;
      }, 27387: (M) => {
        var B = { _originComponent: true, originX: 0.5, originY: 0.5, _displayOriginX: 0, _displayOriginY: 0, displayOriginX: { get: function() {
          return this._displayOriginX;
        }, set: function($) {
          this._displayOriginX = $, this.originX = $ / this.width;
        } }, displayOriginY: { get: function() {
          return this._displayOriginY;
        }, set: function($) {
          this._displayOriginY = $, this.originY = $ / this.height;
        } }, setOrigin: function($, E) {
          if ($ === undefined)
            $ = 0.5;
          if (E === undefined)
            E = $;
          return this.originX = $, this.originY = E, this.updateDisplayOrigin();
        }, setOriginFromFrame: function() {
          if (!this.frame || !this.frame.customPivot)
            return this.setOrigin();
          else
            this.originX = this.frame.pivotX, this.originY = this.frame.pivotY;
          return this.updateDisplayOrigin();
        }, setDisplayOrigin: function($, E) {
          if ($ === undefined)
            $ = 0;
          if (E === undefined)
            E = $;
          return this.displayOriginX = $, this.displayOriginY = E, this;
        }, updateDisplayOrigin: function() {
          return this._displayOriginX = this.originX * this.width, this._displayOriginY = this.originY * this.height, this;
        } };
        M.exports = B;
      }, 37640: (M, B, $) => {
        var E = $(39506), L = $(57355), z = $(35154), U = $(86353), K = $(26099), J = { path: null, rotateToPath: false, pathRotationOffset: 0, pathOffset: null, pathVector: null, pathDelta: null, pathTween: null, pathConfig: null, _prevDirection: U.PLAYING_FORWARD, setPath: function(Z, D) {
          if (D === undefined)
            D = this.pathConfig;
          var Q = this.pathTween;
          if (Q && Q.isPlaying())
            Q.stop();
          if (this.path = Z, D)
            this.startFollow(D);
          return this;
        }, setRotateToPath: function(Z, D) {
          if (D === undefined)
            D = 0;
          return this.rotateToPath = Z, this.pathRotationOffset = D, this;
        }, isFollowing: function() {
          var Z = this.pathTween;
          return Z && Z.isPlaying();
        }, startFollow: function(Z, D) {
          if (Z === undefined)
            Z = {};
          if (D === undefined)
            D = 0;
          var Q = this.pathTween;
          if (Q && Q.isPlaying())
            Q.stop();
          if (typeof Z === "number")
            Z = { duration: Z };
          Z.from = z(Z, "from", 0), Z.to = z(Z, "to", 1);
          var H = L(Z, "positionOnPath", false);
          this.rotateToPath = L(Z, "rotateToPath", false), this.pathRotationOffset = z(Z, "rotationOffset", 0);
          var N = z(Z, "startAt", D);
          if (N)
            Z.onStart = function(R) {
              var Y = R.data[0];
              Y.progress = N, Y.elapsed = Y.duration * N;
              var I = Y.ease(Y.progress);
              Y.current = Y.start + (Y.end - Y.start) * I, Y.setTargetValue();
            };
          if (!this.pathOffset)
            this.pathOffset = new K(this.x, this.y);
          if (!this.pathVector)
            this.pathVector = new K;
          if (!this.pathDelta)
            this.pathDelta = new K;
          if (this.pathDelta.reset(), Z.persist = true, this.pathTween = this.scene.sys.tweens.addCounter(Z), this.path.getStartPoint(this.pathOffset), H)
            this.x = this.pathOffset.x, this.y = this.pathOffset.y;
          if (this.pathOffset.x = this.x - this.pathOffset.x, this.pathOffset.y = this.y - this.pathOffset.y, this._prevDirection = U.PLAYING_FORWARD, this.rotateToPath) {
            var W = this.path.getPoint(0.1);
            this.rotation = Math.atan2(W.y - this.y, W.x - this.x) + E(this.pathRotationOffset);
          }
          return this.pathConfig = Z, this;
        }, pauseFollow: function() {
          var Z = this.pathTween;
          if (Z && Z.isPlaying())
            Z.pause();
          return this;
        }, resumeFollow: function() {
          var Z = this.pathTween;
          if (Z && Z.isPaused())
            Z.resume();
          return this;
        }, stopFollow: function() {
          var Z = this.pathTween;
          if (Z && Z.isPlaying())
            Z.stop();
          return this;
        }, pathUpdate: function() {
          var Z = this.pathTween;
          if (Z && Z.data) {
            var D = Z.data[0], Q = this.pathDelta, H = this.pathVector;
            if (Q.copy(H).negate(), D.state === U.COMPLETE) {
              this.path.getPoint(D.end, H), Q.add(H), H.add(this.pathOffset), this.setPosition(H.x, H.y);
              return;
            } else if (D.state !== U.PLAYING_FORWARD && D.state !== U.PLAYING_BACKWARD)
              return;
            this.path.getPoint(Z.getValue(), H), Q.add(H), H.add(this.pathOffset);
            var N = this.x, W = this.y;
            this.setPosition(H.x, H.y);
            var R = this.x - N, Y = this.y - W;
            if (R === 0 && Y === 0)
              return;
            if (D.state !== this._prevDirection) {
              this._prevDirection = D.state;
              return;
            }
            if (this.rotateToPath)
              this.rotation = Math.atan2(Y, R) + E(this.pathRotationOffset);
          }
        } };
        M.exports = J;
      }, 72699: (M, B, $) => {
        var E = $(62644), L = { defaultPipeline: null, pipeline: null, pipelineData: null, initPipeline: function(z) {
          this.pipelineData = {};
          var U = this.scene.sys.renderer;
          if (!U)
            return false;
          var K = U.pipelines;
          if (K) {
            if (z === undefined)
              z = K.default;
            var J = K.get(z);
            if (J)
              return this.defaultPipeline = J, this.pipeline = J, true;
          }
          return false;
        }, setPipeline: function(z, U, K) {
          var J = this.scene.sys.renderer;
          if (!J)
            return this;
          var Z = J.pipelines;
          if (Z) {
            var D = Z.get(z);
            if (D)
              this.pipeline = D;
            if (U)
              this.pipelineData = K ? E(U) : U;
          }
          return this;
        }, setPipelineData: function(z, U) {
          var K = this.pipelineData;
          if (U === undefined)
            delete K[z];
          else
            K[z] = U;
          return this;
        }, resetPipeline: function(z) {
          if (z === undefined)
            z = false;
          if (this.pipeline = this.defaultPipeline, z)
            this.pipelineData = {};
          return this.pipeline !== null;
        }, getPipelineName: function() {
          return this.pipeline.name;
        } };
        M.exports = L;
      }, 17581: (M, B, $) => {
        var E = $(62644), L = $(47059), z = $(19133), U = { hasPostPipeline: false, postPipelines: null, postPipelineData: null, preFX: null, postFX: null, initPostPipeline: function(K) {
          if (this.postPipelines = [], this.postPipelineData = {}, this.postFX = new L(this, true), K)
            this.preFX = new L(this, false);
        }, setPostPipeline: function(K, J, Z) {
          var D = this.scene.sys.renderer;
          if (!D)
            return this;
          var Q = D.pipelines;
          if (Q) {
            if (!Array.isArray(K))
              K = [K];
            for (var H = 0;H < K.length; H++) {
              var N = Q.getPostPipeline(K[H], this, J);
              if (N)
                this.postPipelines.push(N);
            }
            if (J)
              this.postPipelineData = Z ? E(J) : J;
          }
          return this.hasPostPipeline = this.postPipelines.length > 0, this;
        }, setPostPipelineData: function(K, J) {
          var Z = this.postPipelineData;
          if (J === undefined)
            delete Z[K];
          else
            Z[K] = J;
          return this;
        }, getPostPipeline: function(K) {
          var J = typeof K === "string", Z = this.postPipelines, D = [];
          for (var Q = 0;Q < Z.length; Q++) {
            var H = Z[Q];
            if (J && H.name === K || !J && H instanceof K)
              D.push(H);
          }
          return D.length === 1 ? D[0] : D;
        }, resetPostPipeline: function(K) {
          if (K === undefined)
            K = false;
          var J = this.postPipelines;
          for (var Z = 0;Z < J.length; Z++)
            J[Z].destroy();
          if (this.postPipelines = [], this.hasPostPipeline = false, K)
            this.postPipelineData = {};
        }, removePostPipeline: function(K) {
          var J = typeof K === "string", Z = this.postPipelines;
          for (var D = Z.length - 1;D >= 0; D--) {
            var Q = Z[D];
            if (J && Q.name === K || !J && Q === K)
              Q.destroy(), z(Z, D);
          }
          return this.hasPostPipeline = this.postPipelines.length > 0, this;
        }, clearFX: function() {
          if (this.preFX)
            this.preFX.clear();
          if (this.postFX)
            this.postFX.clear();
          return this;
        } };
        M.exports = U;
      }, 80227: (M) => {
        var B = { scrollFactorX: 1, scrollFactorY: 1, setScrollFactor: function($, E) {
          if (E === undefined)
            E = $;
          return this.scrollFactorX = $, this.scrollFactorY = E, this;
        } };
        M.exports = B;
      }, 16736: (M) => {
        var B = { _sizeComponent: true, width: 0, height: 0, displayWidth: { get: function() {
          return Math.abs(this.scaleX * this.frame.realWidth);
        }, set: function($) {
          this.scaleX = $ / this.frame.realWidth;
        } }, displayHeight: { get: function() {
          return Math.abs(this.scaleY * this.frame.realHeight);
        }, set: function($) {
          this.scaleY = $ / this.frame.realHeight;
        } }, setSizeToFrame: function($) {
          if (!$)
            $ = this.frame;
          this.width = $.realWidth, this.height = $.realHeight;
          var E = this.input;
          if (E && !E.customHitArea)
            E.hitArea.width = this.width, E.hitArea.height = this.height;
          return this;
        }, setSize: function($, E) {
          return this.width = $, this.height = E, this;
        }, setDisplaySize: function($, E) {
          return this.displayWidth = $, this.displayHeight = E, this;
        } };
        M.exports = B;
      }, 37726: (M, B, $) => {
        var E = $(4327), L = 8, z = { texture: null, frame: null, isCropped: false, setTexture: function(U, K, J, Z) {
          return this.texture = this.scene.sys.textures.get(U), this.setFrame(K, J, Z);
        }, setFrame: function(U, K, J) {
          if (K === undefined)
            K = true;
          if (J === undefined)
            J = true;
          if (U instanceof E)
            this.texture = this.scene.sys.textures.get(U.texture.key), this.frame = U;
          else
            this.frame = this.texture.get(U);
          if (!this.frame.cutWidth || !this.frame.cutHeight)
            this.renderFlags &= ~L;
          else
            this.renderFlags |= L;
          if (this._sizeComponent && K)
            this.setSizeToFrame();
          if (this._originComponent && J)
            if (this.frame.customPivot)
              this.setOrigin(this.frame.pivotX, this.frame.pivotY);
            else
              this.updateDisplayOrigin();
          return this;
        } };
        M.exports = z;
      }, 79812: (M, B, $) => {
        var E = $(4327), L = 8, z = { texture: null, frame: null, isCropped: false, setCrop: function(U, K, J, Z) {
          if (U === undefined)
            this.isCropped = false;
          else if (this.frame) {
            if (typeof U === "number")
              this.frame.setCropUVs(this._crop, U, K, J, Z, this.flipX, this.flipY);
            else {
              var D = U;
              this.frame.setCropUVs(this._crop, D.x, D.y, D.width, D.height, this.flipX, this.flipY);
            }
            this.isCropped = true;
          }
          return this;
        }, setTexture: function(U, K) {
          return this.texture = this.scene.sys.textures.get(U), this.setFrame(K);
        }, setFrame: function(U, K, J) {
          if (K === undefined)
            K = true;
          if (J === undefined)
            J = true;
          if (U instanceof E)
            this.texture = this.scene.sys.textures.get(U.texture.key), this.frame = U;
          else
            this.frame = this.texture.get(U);
          if (!this.frame.cutWidth || !this.frame.cutHeight)
            this.renderFlags &= ~L;
          else
            this.renderFlags |= L;
          if (this._sizeComponent && K)
            this.setSizeToFrame();
          if (this._originComponent && J)
            if (this.frame.customPivot)
              this.setOrigin(this.frame.pivotX, this.frame.pivotY);
            else
              this.updateDisplayOrigin();
          if (this.isCropped)
            this.frame.updateCropUVs(this._crop, this.flipX, this.flipY);
          return this;
        }, resetCropObject: function() {
          return { u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false, cx: 0, cy: 0, cw: 0, ch: 0 };
        } };
        M.exports = z;
      }, 27472: (M) => {
        var B = { tintTopLeft: 16777215, tintTopRight: 16777215, tintBottomLeft: 16777215, tintBottomRight: 16777215, tintFill: false, clearTint: function() {
          return this.setTint(16777215), this;
        }, setTint: function($, E, L, z) {
          if ($ === undefined)
            $ = 16777215;
          if (E === undefined)
            E = $, L = $, z = $;
          return this.tintTopLeft = $, this.tintTopRight = E, this.tintBottomLeft = L, this.tintBottomRight = z, this.tintFill = false, this;
        }, setTintFill: function($, E, L, z) {
          return this.setTint($, E, L, z), this.tintFill = true, this;
        }, tint: { get: function() {
          return this.tintTopLeft;
        }, set: function($) {
          this.setTint($, $, $, $);
        } }, isTinted: { get: function() {
          var $ = 16777215;
          return this.tintFill || this.tintTopLeft !== $ || this.tintTopRight !== $ || this.tintBottomLeft !== $ || this.tintBottomRight !== $;
        } } };
        M.exports = B;
      }, 53774: (M) => {
        var B = function($) {
          var E = { name: $.name, type: $.type, x: $.x, y: $.y, depth: $.depth, scale: { x: $.scaleX, y: $.scaleY }, origin: { x: $.originX, y: $.originY }, flipX: $.flipX, flipY: $.flipY, rotation: $.rotation, alpha: $.alpha, visible: $.visible, blendMode: $.blendMode, textureKey: "", frameKey: "", data: {} };
          if ($.texture)
            E.textureKey = $.texture.key, E.frameKey = $.frame.name;
          return E;
        };
        M.exports = B;
      }, 16901: (M, B, $) => {
        var E = $(36383), L = $(61340), z = $(85955), U = $(86554), K = $(30954), J = $(26099), Z = 4, D = { hasTransformComponent: true, _scaleX: 1, _scaleY: 1, _rotation: 0, x: 0, y: 0, z: 0, w: 0, scale: { get: function() {
          return (this._scaleX + this._scaleY) / 2;
        }, set: function(Q) {
          if (this._scaleX = Q, this._scaleY = Q, Q === 0)
            this.renderFlags &= ~Z;
          else
            this.renderFlags |= Z;
        } }, scaleX: { get: function() {
          return this._scaleX;
        }, set: function(Q) {
          if (this._scaleX = Q, Q === 0)
            this.renderFlags &= ~Z;
          else if (this._scaleY !== 0)
            this.renderFlags |= Z;
        } }, scaleY: { get: function() {
          return this._scaleY;
        }, set: function(Q) {
          if (this._scaleY = Q, Q === 0)
            this.renderFlags &= ~Z;
          else if (this._scaleX !== 0)
            this.renderFlags |= Z;
        } }, angle: { get: function() {
          return K(this._rotation * E.RAD_TO_DEG);
        }, set: function(Q) {
          this.rotation = K(Q) * E.DEG_TO_RAD;
        } }, rotation: { get: function() {
          return this._rotation;
        }, set: function(Q) {
          this._rotation = U(Q);
        } }, setPosition: function(Q, H, N, W) {
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = Q;
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = 0;
          return this.x = Q, this.y = H, this.z = N, this.w = W, this;
        }, copyPosition: function(Q) {
          if (Q.x !== undefined)
            this.x = Q.x;
          if (Q.y !== undefined)
            this.y = Q.y;
          if (Q.z !== undefined)
            this.z = Q.z;
          if (Q.w !== undefined)
            this.w = Q.w;
          return this;
        }, setRandomPosition: function(Q, H, N, W) {
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = this.scene.sys.scale.width;
          if (W === undefined)
            W = this.scene.sys.scale.height;
          return this.x = Q + Math.random() * N, this.y = H + Math.random() * W, this;
        }, setRotation: function(Q) {
          if (Q === undefined)
            Q = 0;
          return this.rotation = Q, this;
        }, setAngle: function(Q) {
          if (Q === undefined)
            Q = 0;
          return this.angle = Q, this;
        }, setScale: function(Q, H) {
          if (Q === undefined)
            Q = 1;
          if (H === undefined)
            H = Q;
          return this.scaleX = Q, this.scaleY = H, this;
        }, setX: function(Q) {
          if (Q === undefined)
            Q = 0;
          return this.x = Q, this;
        }, setY: function(Q) {
          if (Q === undefined)
            Q = 0;
          return this.y = Q, this;
        }, setZ: function(Q) {
          if (Q === undefined)
            Q = 0;
          return this.z = Q, this;
        }, setW: function(Q) {
          if (Q === undefined)
            Q = 0;
          return this.w = Q, this;
        }, getLocalTransformMatrix: function(Q) {
          if (Q === undefined)
            Q = new L;
          return Q.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);
        }, getWorldTransformMatrix: function(Q, H) {
          if (Q === undefined)
            Q = new L;
          var N = this.parentContainer;
          if (!N)
            return this.getLocalTransformMatrix(Q);
          if (!H)
            H = new L;
          Q.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);
          while (N)
            H.applyITRS(N.x, N.y, N._rotation, N._scaleX, N._scaleY), H.multiply(Q, Q), N = N.parentContainer;
          return Q;
        }, getLocalPoint: function(Q, H, N, W) {
          if (!N)
            N = new J;
          if (!W)
            W = this.scene.sys.cameras.main;
          var { scrollX: R, scrollY: Y } = W, I = Q + R * this.scrollFactorX - R, P = H + Y * this.scrollFactorY - Y;
          if (this.parentContainer)
            this.getWorldTransformMatrix().applyInverse(I, P, N);
          else
            z(I, P, this.x, this.y, this.rotation, this.scaleX, this.scaleY, N);
          if (this._originComponent)
            N.x += this._displayOriginX, N.y += this._displayOriginY;
          return N;
        }, getParentRotation: function() {
          var Q = 0, H = this.parentContainer;
          while (H)
            Q += H.rotation, H = H.parentContainer;
          return Q;
        } };
        M.exports = D;
      }, 61340: (M, B, $) => {
        var E = $(83419), L = $(36383), z = $(26099), U = new E({ initialize: function K(J, Z, D, Q, H, N) {
          if (J === undefined)
            J = 1;
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 1;
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = 0;
          this.matrix = new Float32Array([J, Z, D, Q, H, N, 0, 0, 1]), this.decomposedMatrix = { translateX: 0, translateY: 0, scaleX: 1, scaleY: 1, rotation: 0 }, this.quad = new Float32Array(8);
        }, a: { get: function() {
          return this.matrix[0];
        }, set: function(K) {
          this.matrix[0] = K;
        } }, b: { get: function() {
          return this.matrix[1];
        }, set: function(K) {
          this.matrix[1] = K;
        } }, c: { get: function() {
          return this.matrix[2];
        }, set: function(K) {
          this.matrix[2] = K;
        } }, d: { get: function() {
          return this.matrix[3];
        }, set: function(K) {
          this.matrix[3] = K;
        } }, e: { get: function() {
          return this.matrix[4];
        }, set: function(K) {
          this.matrix[4] = K;
        } }, f: { get: function() {
          return this.matrix[5];
        }, set: function(K) {
          this.matrix[5] = K;
        } }, tx: { get: function() {
          return this.matrix[4];
        }, set: function(K) {
          this.matrix[4] = K;
        } }, ty: { get: function() {
          return this.matrix[5];
        }, set: function(K) {
          this.matrix[5] = K;
        } }, rotation: { get: function() {
          return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1);
        } }, rotationNormalized: { get: function() {
          var K = this.matrix, J = K[0], Z = K[1], D = K[2], Q = K[3];
          if (J || Z)
            return Z > 0 ? Math.acos(J / this.scaleX) : -Math.acos(J / this.scaleX);
          else if (D || Q)
            return L.TAU - (Q > 0 ? Math.acos(-D / this.scaleY) : -Math.acos(D / this.scaleY));
          else
            return 0;
        } }, scaleX: { get: function() {
          return Math.sqrt(this.a * this.a + this.b * this.b);
        } }, scaleY: { get: function() {
          return Math.sqrt(this.c * this.c + this.d * this.d);
        } }, loadIdentity: function() {
          var K = this.matrix;
          return K[0] = 1, K[1] = 0, K[2] = 0, K[3] = 1, K[4] = 0, K[5] = 0, this;
        }, translate: function(K, J) {
          var Z = this.matrix;
          return Z[4] = Z[0] * K + Z[2] * J + Z[4], Z[5] = Z[1] * K + Z[3] * J + Z[5], this;
        }, scale: function(K, J) {
          var Z = this.matrix;
          return Z[0] *= K, Z[1] *= K, Z[2] *= J, Z[3] *= J, this;
        }, rotate: function(K) {
          var J = Math.sin(K), Z = Math.cos(K), D = this.matrix, Q = D[0], H = D[1], N = D[2], W = D[3];
          return D[0] = Q * Z + N * J, D[1] = H * Z + W * J, D[2] = Q * -J + N * Z, D[3] = H * -J + W * Z, this;
        }, multiply: function(K, J) {
          var Z = this.matrix, D = K.matrix, Q = Z[0], H = Z[1], N = Z[2], W = Z[3], R = Z[4], Y = Z[5], I = D[0], P = D[1], X = D[2], G = D[3], V = D[4], A = D[5], F = J === undefined ? Z : J.matrix;
          return F[0] = I * Q + P * N, F[1] = I * H + P * W, F[2] = X * Q + G * N, F[3] = X * H + G * W, F[4] = V * Q + A * N + R, F[5] = V * H + A * W + Y, F;
        }, multiplyWithOffset: function(K, J, Z) {
          var D = this.matrix, Q = K.matrix, H = D[0], N = D[1], W = D[2], R = D[3], Y = D[4], I = D[5], P = J * H + Z * W + Y, X = J * N + Z * R + I, G = Q[0], V = Q[1], A = Q[2], F = Q[3], j = Q[4], T = Q[5];
          return D[0] = G * H + V * W, D[1] = G * N + V * R, D[2] = A * H + F * W, D[3] = A * N + F * R, D[4] = j * H + T * W + P, D[5] = j * N + T * R + X, this;
        }, transform: function(K, J, Z, D, Q, H) {
          var N = this.matrix, W = N[0], R = N[1], Y = N[2], I = N[3], P = N[4], X = N[5];
          return N[0] = K * W + J * Y, N[1] = K * R + J * I, N[2] = Z * W + D * Y, N[3] = Z * R + D * I, N[4] = Q * W + H * Y + P, N[5] = Q * R + H * I + X, this;
        }, transformPoint: function(K, J, Z) {
          if (Z === undefined)
            Z = { x: 0, y: 0 };
          var D = this.matrix, Q = D[0], H = D[1], N = D[2], W = D[3], R = D[4], Y = D[5];
          return Z.x = K * Q + J * N + R, Z.y = K * H + J * W + Y, Z;
        }, invert: function() {
          var K = this.matrix, J = K[0], Z = K[1], D = K[2], Q = K[3], H = K[4], N = K[5], W = J * Q - Z * D;
          return K[0] = Q / W, K[1] = -Z / W, K[2] = -D / W, K[3] = J / W, K[4] = (D * N - Q * H) / W, K[5] = -(J * N - Z * H) / W, this;
        }, copyFrom: function(K) {
          var J = this.matrix;
          return J[0] = K.a, J[1] = K.b, J[2] = K.c, J[3] = K.d, J[4] = K.e, J[5] = K.f, this;
        }, copyFromArray: function(K) {
          var J = this.matrix;
          return J[0] = K[0], J[1] = K[1], J[2] = K[2], J[3] = K[3], J[4] = K[4], J[5] = K[5], this;
        }, copyToContext: function(K) {
          var J = this.matrix;
          return K.transform(J[0], J[1], J[2], J[3], J[4], J[5]), K;
        }, setToContext: function(K) {
          return K.setTransform(this), K;
        }, copyToArray: function(K) {
          var J = this.matrix;
          if (K === undefined)
            K = [J[0], J[1], J[2], J[3], J[4], J[5]];
          else
            K[0] = J[0], K[1] = J[1], K[2] = J[2], K[3] = J[3], K[4] = J[4], K[5] = J[5];
          return K;
        }, setTransform: function(K, J, Z, D, Q, H) {
          var N = this.matrix;
          return N[0] = K, N[1] = J, N[2] = Z, N[3] = D, N[4] = Q, N[5] = H, this;
        }, decomposeMatrix: function() {
          var K = this.decomposedMatrix, J = this.matrix, Z = J[0], D = J[1], Q = J[2], H = J[3], N = Z * H - D * Q;
          if (K.translateX = J[4], K.translateY = J[5], Z || D) {
            var W = Math.sqrt(Z * Z + D * D);
            K.rotation = D > 0 ? Math.acos(Z / W) : -Math.acos(Z / W), K.scaleX = W, K.scaleY = N / W;
          } else if (Q || H) {
            var R = Math.sqrt(Q * Q + H * H);
            K.rotation = Math.PI * 0.5 - (H > 0 ? Math.acos(-Q / R) : -Math.acos(Q / R)), K.scaleX = N / R, K.scaleY = R;
          } else
            K.rotation = 0, K.scaleX = 0, K.scaleY = 0;
          return K;
        }, applyITRS: function(K, J, Z, D, Q) {
          var H = this.matrix, N = Math.sin(Z), W = Math.cos(Z);
          return H[4] = K, H[5] = J, H[0] = W * D, H[1] = N * D, H[2] = -N * Q, H[3] = W * Q, this;
        }, applyInverse: function(K, J, Z) {
          if (Z === undefined)
            Z = new z;
          var D = this.matrix, Q = D[0], H = D[1], N = D[2], W = D[3], R = D[4], Y = D[5], I = 1 / (Q * W + N * -H);
          return Z.x = W * I * K + -N * I * J + (Y * N - R * W) * I, Z.y = Q * I * J + -H * I * K + (-Y * Q + R * H) * I, Z;
        }, setQuad: function(K, J, Z, D, Q, H) {
          if (Q === undefined)
            Q = false;
          if (H === undefined)
            H = this.quad;
          var N = this.matrix, W = N[0], R = N[1], Y = N[2], I = N[3], P = N[4], X = N[5];
          if (Q)
            H[0] = Math.round(K * W + J * Y + P), H[1] = Math.round(K * R + J * I + X), H[2] = Math.round(K * W + D * Y + P), H[3] = Math.round(K * R + D * I + X), H[4] = Math.round(Z * W + D * Y + P), H[5] = Math.round(Z * R + D * I + X), H[6] = Math.round(Z * W + J * Y + P), H[7] = Math.round(Z * R + J * I + X);
          else
            H[0] = K * W + J * Y + P, H[1] = K * R + J * I + X, H[2] = K * W + D * Y + P, H[3] = K * R + D * I + X, H[4] = Z * W + D * Y + P, H[5] = Z * R + D * I + X, H[6] = Z * W + J * Y + P, H[7] = Z * R + J * I + X;
          return H;
        }, getX: function(K, J) {
          return K * this.a + J * this.c + this.e;
        }, getY: function(K, J) {
          return K * this.b + J * this.d + this.f;
        }, getXRound: function(K, J, Z) {
          var D = this.getX(K, J);
          if (Z)
            D = Math.round(D);
          return D;
        }, getYRound: function(K, J, Z) {
          var D = this.getY(K, J);
          if (Z)
            D = Math.round(D);
          return D;
        }, getCSSMatrix: function() {
          var K = this.matrix;
          return "matrix(" + K[0] + "," + K[1] + "," + K[2] + "," + K[3] + "," + K[4] + "," + K[5] + ")";
        }, destroy: function() {
          this.matrix = null, this.quad = null, this.decomposedMatrix = null;
        } });
        M.exports = U;
      }, 59715: (M) => {
        var B = 1, $ = { _visible: true, visible: { get: function() {
          return this._visible;
        }, set: function(E) {
          if (E)
            this._visible = true, this.renderFlags |= B;
          else
            this._visible = false, this.renderFlags &= ~B;
        } }, setVisible: function(E) {
          return this.visible = E, this;
        } };
        M.exports = $;
      }, 31401: (M, B, $) => {
        M.exports = { Alpha: $(16005), AlphaSingle: $(88509), BlendMode: $(90065), ComputedSize: $(94215), Crop: $(61683), Depth: $(89272), Flip: $(54434), FX: $(47059), GetBounds: $(8004), Mask: $(8573), Origin: $(27387), PathFollower: $(37640), Pipeline: $(72699), PostPipeline: $(17581), ScrollFactor: $(80227), Size: $(16736), Texture: $(37726), TextureCrop: $(79812), Tint: $(27472), ToJSON: $(53774), Transform: $(16901), TransformMatrix: $(61340), Visible: $(59715) };
      }, 31559: (M, B, $) => {
        var E = $(37105), L = $(10312), z = $(83419), U = $(31401), K = $(51708), J = $(95643), Z = $(87841), D = $(29959), Q = $(36899), H = $(26099), N = new z({ Extends: J, Mixins: [U.AlphaSingle, U.BlendMode, U.ComputedSize, U.Depth, U.Mask, U.PostPipeline, U.Transform, U.Visible, D], initialize: function W(R, Y, I, P) {
          if (J.call(this, R, "Container"), this.list = [], this.exclusive = true, this.maxSize = -1, this.position = 0, this.localTransform = new U.TransformMatrix, this.tempTransformMatrix = new U.TransformMatrix, this._sortKey = "", this._sysEvents = R.sys.events, this.scrollFactorX = 1, this.scrollFactorY = 1, this.initPostPipeline(), this.setPosition(Y, I), this.setBlendMode(L.SKIP_CHECK), P)
            this.add(P);
        }, originX: { get: function() {
          return 0.5;
        } }, originY: { get: function() {
          return 0.5;
        } }, displayOriginX: { get: function() {
          return this.width * 0.5;
        } }, displayOriginY: { get: function() {
          return this.height * 0.5;
        } }, setExclusive: function(W) {
          if (W === undefined)
            W = true;
          return this.exclusive = W, this;
        }, getBounds: function(W) {
          if (W === undefined)
            W = new Z;
          if (W.setTo(this.x, this.y, 0, 0), this.parentContainer) {
            var R = this.parentContainer.getBoundsTransformMatrix(), Y = R.transformPoint(this.x, this.y);
            W.setTo(Y.x, Y.y, 0, 0);
          }
          if (this.list.length > 0) {
            var I = this.list, P = new Z, X = false;
            W.setEmpty();
            for (var G = 0;G < I.length; G++) {
              var V = I[G];
              if (V.getBounds)
                if (V.getBounds(P), !X)
                  W.setTo(P.x, P.y, P.width, P.height), X = true;
                else
                  Q(P, W, W);
            }
          }
          return W;
        }, addHandler: function(W) {
          if (W.once(K.DESTROY, this.onChildDestroyed, this), this.exclusive) {
            if (W.parentContainer)
              W.parentContainer.remove(W);
            W.parentContainer = this, W.removeFromDisplayList(), W.addedToScene();
          }
        }, removeHandler: function(W) {
          if (W.off(K.DESTROY, this.remove, this), this.exclusive)
            W.parentContainer = null, W.removedFromScene(), W.addToDisplayList();
        }, pointToContainer: function(W, R) {
          if (R === undefined)
            R = new H;
          if (this.parentContainer)
            this.parentContainer.pointToContainer(W, R);
          else
            R.x = W.x, R.y = W.y;
          var Y = this.tempTransformMatrix;
          return Y.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY), Y.invert(), Y.transformPoint(W.x, W.y, R), R;
        }, getBoundsTransformMatrix: function() {
          return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform);
        }, add: function(W) {
          return E.Add(this.list, W, this.maxSize, this.addHandler, this), this;
        }, addAt: function(W, R) {
          return E.AddAt(this.list, W, R, this.maxSize, this.addHandler, this), this;
        }, getAt: function(W) {
          return this.list[W];
        }, getIndex: function(W) {
          return this.list.indexOf(W);
        }, sort: function(W, R) {
          if (!W)
            return this;
          if (R === undefined)
            R = function(Y, I) {
              return Y[W] - I[W];
            };
          return E.StableSort(this.list, R), this;
        }, getByName: function(W) {
          return E.GetFirst(this.list, "name", W);
        }, getRandom: function(W, R) {
          return E.GetRandom(this.list, W, R);
        }, getFirst: function(W, R, Y, I) {
          return E.GetFirst(this.list, W, R, Y, I);
        }, getAll: function(W, R, Y, I) {
          return E.GetAll(this.list, W, R, Y, I);
        }, count: function(W, R, Y, I) {
          return E.CountAllMatching(this.list, W, R, Y, I);
        }, swap: function(W, R) {
          return E.Swap(this.list, W, R), this;
        }, moveTo: function(W, R) {
          return E.MoveTo(this.list, W, R), this;
        }, moveAbove: function(W, R) {
          return E.MoveAbove(this.list, W, R), this;
        }, moveBelow: function(W, R) {
          return E.MoveBelow(this.list, W, R), this;
        }, remove: function(W, R) {
          var Y = E.Remove(this.list, W, this.removeHandler, this);
          if (R && Y) {
            if (!Array.isArray(Y))
              Y = [Y];
            for (var I = 0;I < Y.length; I++)
              Y[I].destroy();
          }
          return this;
        }, removeAt: function(W, R) {
          var Y = E.RemoveAt(this.list, W, this.removeHandler, this);
          if (R && Y)
            Y.destroy();
          return this;
        }, removeBetween: function(W, R, Y) {
          var I = E.RemoveBetween(this.list, W, R, this.removeHandler, this);
          if (Y)
            for (var P = 0;P < I.length; P++)
              I[P].destroy();
          return this;
        }, removeAll: function(W) {
          var R = this.list;
          if (W) {
            for (var Y = 0;Y < R.length; Y++)
              if (R[Y] && R[Y].scene)
                R[Y].off(K.DESTROY, this.onChildDestroyed, this), R[Y].destroy();
            this.list = [];
          } else
            E.RemoveBetween(R, 0, R.length, this.removeHandler, this);
          return this;
        }, bringToTop: function(W) {
          return E.BringToTop(this.list, W), this;
        }, sendToBack: function(W) {
          return E.SendToBack(this.list, W), this;
        }, moveUp: function(W) {
          return E.MoveUp(this.list, W), this;
        }, moveDown: function(W) {
          return E.MoveDown(this.list, W), this;
        }, reverse: function() {
          return this.list.reverse(), this;
        }, shuffle: function() {
          return E.Shuffle(this.list), this;
        }, replace: function(W, R, Y) {
          var I = E.Replace(this.list, W, R);
          if (I) {
            if (this.addHandler(R), this.removeHandler(W), Y)
              W.destroy();
          }
          return this;
        }, exists: function(W) {
          return this.list.indexOf(W) > -1;
        }, setAll: function(W, R, Y, I) {
          return E.SetAll(this.list, W, R, Y, I), this;
        }, each: function(W, R) {
          var Y = [null], I, P = this.list.slice(), X = P.length;
          for (I = 2;I < arguments.length; I++)
            Y.push(arguments[I]);
          for (I = 0;I < X; I++)
            Y[0] = P[I], W.apply(R, Y);
          return this;
        }, iterate: function(W, R) {
          var Y = [null], I;
          for (I = 2;I < arguments.length; I++)
            Y.push(arguments[I]);
          for (I = 0;I < this.list.length; I++)
            Y[0] = this.list[I], W.apply(R, Y);
          return this;
        }, setScrollFactor: function(W, R, Y) {
          if (R === undefined)
            R = W;
          if (Y === undefined)
            Y = false;
          if (this.scrollFactorX = W, this.scrollFactorY = R, Y)
            E.SetAll(this.list, "scrollFactorX", W), E.SetAll(this.list, "scrollFactorY", R);
          return this;
        }, length: { get: function() {
          return this.list.length;
        } }, first: { get: function() {
          if (this.position = 0, this.list.length > 0)
            return this.list[0];
          else
            return null;
        } }, last: { get: function() {
          if (this.list.length > 0)
            return this.position = this.list.length - 1, this.list[this.position];
          else
            return null;
        } }, next: { get: function() {
          if (this.position < this.list.length)
            return this.position++, this.list[this.position];
          else
            return null;
        } }, previous: { get: function() {
          if (this.position > 0)
            return this.position--, this.list[this.position];
          else
            return null;
        } }, preDestroy: function() {
          this.removeAll(!!this.exclusive), this.localTransform.destroy(), this.tempTransformMatrix.destroy(), this.list = [];
        }, onChildDestroyed: function(W) {
          if (E.Remove(this.list, W), this.exclusive)
            W.parentContainer = null, W.removedFromScene();
        } });
        M.exports = N;
      }, 53584: (M) => {
        var B = function($, E, L, z) {
          L.addToRenderList(E);
          var U = E.list;
          if (U.length === 0)
            return;
          var K = E.localTransform;
          if (z)
            K.loadIdentity(), K.multiply(z), K.translate(E.x, E.y), K.rotate(E.rotation), K.scale(E.scaleX, E.scaleY);
          else
            K.applyITRS(E.x, E.y, E.rotation, E.scaleX, E.scaleY);
          var J = E.blendMode !== -1;
          if (!J)
            $.setBlendMode(0);
          var { _alpha: Z, scrollFactorX: D, scrollFactorY: Q } = E;
          if (E.mask)
            E.mask.preRenderCanvas($, null, L);
          for (var H = 0;H < U.length; H++) {
            var N = U[H];
            if (!N.willRender(L))
              continue;
            var { alpha: W, scrollFactorX: R, scrollFactorY: Y } = N;
            if (!J && N.blendMode !== $.currentBlendMode)
              $.setBlendMode(N.blendMode);
            N.setScrollFactor(R * D, Y * Q), N.setAlpha(W * Z), N.renderCanvas($, N, L, K), N.setAlpha(W), N.setScrollFactor(R, Y);
          }
          if (E.mask)
            E.mask.postRenderCanvas($);
        };
        M.exports = B;
      }, 77143: (M, B, $) => {
        var E = $(25305), L = $(31559), z = $(44603), U = $(23568), K = $(95540);
        z.register("container", function(J, Z) {
          if (J === undefined)
            J = {};
          var D = U(J, "x", 0), Q = U(J, "y", 0), H = K(J, "children", null), N = new L(this.scene, D, Q, H);
          if (Z !== undefined)
            J.add = Z;
          return E(this.scene, N, J), N;
        });
      }, 24961: (M, B, $) => {
        var E = $(31559), L = $(39429);
        L.register("container", function(z, U, K) {
          return this.displayList.add(new E(this.scene, z, U, K));
        });
      }, 29959: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(72249), z = $(53584), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 72249: (M) => {
        var B = function($, E, L, z) {
          L.addToRenderList(E);
          var U = E.list, K = U.length;
          if (K === 0)
            return;
          var J = E.localTransform;
          if (z)
            J.loadIdentity(), J.multiply(z), J.translate(E.x, E.y), J.rotate(E.rotation), J.scale(E.scaleX, E.scaleY);
          else
            J.applyITRS(E.x, E.y, E.rotation, E.scaleX, E.scaleY);
          $.pipelines.preBatch(E);
          var Z = E.blendMode !== -1;
          if (!Z)
            $.setBlendMode(0);
          var { alpha: D, scrollFactorX: Q, scrollFactorY: H } = E;
          for (var N = 0;N < K; N++) {
            var W = U[N];
            if (!W.willRender(L))
              continue;
            var R, Y, I, P;
            if (W.alphaTopLeft !== undefined)
              R = W.alphaTopLeft, Y = W.alphaTopRight, I = W.alphaBottomLeft, P = W.alphaBottomRight;
            else {
              var X = W.alpha;
              R = X, Y = X, I = X, P = X;
            }
            var { scrollFactorX: G, scrollFactorY: V } = W;
            if (!Z && W.blendMode !== $.currentBlendMode)
              $.setBlendMode(W.blendMode);
            var A = W.mask;
            if (A)
              A.preRenderWebGL($, W, L);
            var F = W.type;
            if (F !== $.currentType)
              $.newType = true, $.currentType = F;
            if ($.nextTypeMatch = N < K - 1 ? U[N + 1].type === $.currentType : false, W.setScrollFactor(G * Q, V * H), W.setAlpha(R * D, Y * D, I * D, P * D), W.renderWebGL($, W, L, J, E), W.setAlpha(R, Y, I, P), W.setScrollFactor(G, V), A)
              A.postRenderWebGL($, L);
            $.newType = false;
          }
          $.pipelines.postBatch(E);
        };
        M.exports = B;
      }, 47407: (M) => {
        M.exports = ["normal", "multiply", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
      }, 3069: (M, B, $) => {
        var E = $(83419), L = $(31401), z = $(441), U = $(95643), K = $(41212), J = $(35846), Z = $(44594), D = $(61369), Q = new E({ Extends: U, Mixins: [L.AlphaSingle, L.BlendMode, L.Depth, L.Origin, L.ScrollFactor, L.Transform, L.Visible, z], initialize: function H(N, W, R, Y, I, P) {
          if (U.call(this, N, "DOMElement"), this.parent = N.sys.game.domContainer, this.cache = N.sys.cache.html, this.node, this.transformOnly = false, this.skewX = 0, this.skewY = 0, this.rotate3d = new D, this.rotate3dAngle = "deg", this.pointerEvents = "auto", this.width = 0, this.height = 0, this.displayWidth = 0, this.displayHeight = 0, this.handler = this.dispatchNativeEvent.bind(this), this.setPosition(W, R), typeof Y === "string")
            if (Y[0] === "#")
              this.setElement(Y.substr(1), I, P);
            else
              this.createElement(Y, I, P);
          else if (Y)
            this.setElement(Y, I, P);
          N.sys.events.on(Z.SLEEP, this.handleSceneEvent, this), N.sys.events.on(Z.WAKE, this.handleSceneEvent, this), N.sys.events.on(Z.PRE_RENDER, this.preRender, this);
        }, handleSceneEvent: function(H) {
          var N = this.node, W = N.style;
          if (N)
            W.display = H.settings.visible ? "block" : "none";
        }, setSkew: function(H, N) {
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = H;
          return this.skewX = H, this.skewY = N, this;
        }, setPerspective: function(H) {
          return this.parent.style.perspective = H + "px", this;
        }, perspective: { get: function() {
          return parseFloat(this.parent.style.perspective);
        }, set: function(H) {
          this.parent.style.perspective = H + "px";
        } }, addListener: function(H) {
          if (this.node) {
            H = H.split(" ");
            for (var N = 0;N < H.length; N++)
              this.node.addEventListener(H[N], this.handler, false);
          }
          return this;
        }, removeListener: function(H) {
          if (this.node) {
            H = H.split(" ");
            for (var N = 0;N < H.length; N++)
              this.node.removeEventListener(H[N], this.handler);
          }
          return this;
        }, dispatchNativeEvent: function(H) {
          this.emit(H.type, H);
        }, createElement: function(H, N, W) {
          return this.setElement(document.createElement(H), N, W);
        }, setElement: function(H, N, W) {
          this.removeElement();
          var R;
          if (typeof H === "string") {
            if (H[0] === "#")
              H = H.substr(1);
            R = document.getElementById(H);
          } else if (typeof H === "object" && H.nodeType === 1)
            R = H;
          if (!R)
            return this;
          if (this.node = R, N && K(N))
            for (var Y in N)
              R.style[Y] = N[Y];
          else if (typeof N === "string")
            R.style = N;
          if (R.style.zIndex = "0", R.style.display = "inline", R.style.position = "absolute", R.phaser = this, this.parent)
            this.parent.appendChild(R);
          if (W)
            R.innerText = W;
          return this.updateSize();
        }, createFromCache: function(H, N) {
          var W = this.cache.get(H);
          if (W)
            this.createFromHTML(W, N);
          return this;
        }, createFromHTML: function(H, N) {
          if (N === undefined)
            N = "div";
          this.removeElement();
          var W = document.createElement(N);
          if (this.node = W, W.style.zIndex = "0", W.style.display = "inline", W.style.position = "absolute", W.phaser = this, this.parent)
            this.parent.appendChild(W);
          return W.innerHTML = H, this.updateSize();
        }, removeElement: function() {
          if (this.node)
            J(this.node), this.node = null;
          return this;
        }, updateSize: function() {
          var H = this.node, N = H.getBoundingClientRect();
          return this.width = H.clientWidth, this.height = H.clientHeight, this.displayWidth = N.width || 0, this.displayHeight = N.height || 0, this;
        }, getChildByProperty: function(H, N) {
          if (this.node) {
            var W = this.node.querySelectorAll("*");
            for (var R = 0;R < W.length; R++)
              if (W[R][H] === N)
                return W[R];
          }
          return null;
        }, getChildByID: function(H) {
          return this.getChildByProperty("id", H);
        }, getChildByName: function(H) {
          return this.getChildByProperty("name", H);
        }, setClassName: function(H) {
          if (this.node)
            this.node.className = H, this.updateSize();
          return this;
        }, setText: function(H) {
          if (this.node)
            this.node.innerText = H, this.updateSize();
          return this;
        }, setHTML: function(H) {
          if (this.node)
            this.node.innerHTML = H, this.updateSize();
          return this;
        }, preRender: function() {
          var H = this.parentContainer, N = this.node;
          if (N && H && !H.willRender())
            N.style.display = "none";
        }, willRender: function() {
          return true;
        }, preDestroy: function() {
          this.removeElement(), this.scene.sys.events.off(Z.SLEEP, this.handleSceneEvent, this), this.scene.sys.events.off(Z.WAKE, this.handleSceneEvent, this), this.scene.sys.events.off(Z.PRE_RENDER, this.preRender, this);
        } });
        M.exports = Q;
      }, 49381: (M, B, $) => {
        var E = $(47407), L = $(95643), z = $(61340), U = new z, K = new z, J = new z, Z = function(D, Q, H, N) {
          if (!Q.node)
            return;
          var W = Q.node.style, R = Q.scene.sys.settings;
          if (!W || !R.visible || L.RENDER_MASK !== Q.renderFlags || Q.cameraFilter !== 0 && Q.cameraFilter & H.id || Q.parentContainer && !Q.parentContainer.willRender()) {
            W.display = "none";
            return;
          }
          var Y = Q.parentContainer, I = H.alpha * Q.alpha;
          if (Y)
            I *= Y.alpha;
          var P = U, X = K, G = J, V = 0, A = 0, F = "0%", j = "0%";
          if (N)
            V = Q.width * Q.scaleX * Q.originX, A = Q.height * Q.scaleY * Q.originY, X.applyITRS(Q.x - V, Q.y - A, Q.rotation, Q.scaleX, Q.scaleY), P.copyFrom(H.matrix), P.multiplyWithOffset(N, -H.scrollX * Q.scrollFactorX, -H.scrollY * Q.scrollFactorY), X.e = Q.x - V, X.f = Q.y - A, P.multiply(X, G);
          else
            V = Q.width * Q.originX, A = Q.height * Q.originY, X.applyITRS(Q.x - V, Q.y - A, Q.rotation, Q.scaleX, Q.scaleY), P.copyFrom(H.matrix), F = 100 * Q.originX + "%", j = 100 * Q.originY + "%", X.e -= H.scrollX * Q.scrollFactorX, X.f -= H.scrollY * Q.scrollFactorY, P.multiply(X, G);
          if (!Q.transformOnly)
            W.display = "block", W.opacity = I, W.zIndex = Q._depth, W.pointerEvents = Q.pointerEvents, W.mixBlendMode = E[Q._blendMode];
          W.transform = G.getCSSMatrix() + " skew(" + Q.skewX + "rad, " + Q.skewY + "rad) rotate3d(" + Q.rotate3d.x + "," + Q.rotate3d.y + "," + Q.rotate3d.z + "," + Q.rotate3d.w + Q.rotate3dAngle + ")", W.transformOrigin = F + " " + j;
        };
        M.exports = Z;
      }, 2611: (M, B, $) => {
        var E = $(3069), L = $(39429);
        L.register("dom", function(z, U, K, J, Z) {
          var D = new E(this.scene, z, U, K, J, Z);
          return this.displayList.add(D), D;
        });
      }, 441: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(49381), z = $(49381), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 62980: (M) => {
        M.exports = "addedtoscene";
      }, 41337: (M) => {
        M.exports = "destroy";
      }, 44947: (M) => {
        M.exports = "removedfromscene";
      }, 49358: (M) => {
        M.exports = "complete";
      }, 35163: (M) => {
        M.exports = "created";
      }, 97249: (M) => {
        M.exports = "error";
      }, 19483: (M) => {
        M.exports = "locked";
      }, 56059: (M) => {
        M.exports = "loop";
      }, 26772: (M) => {
        M.exports = "metadata";
      }, 64437: (M) => {
        M.exports = "playing";
      }, 83411: (M) => {
        M.exports = "play";
      }, 75780: (M) => {
        M.exports = "seeked";
      }, 67799: (M) => {
        M.exports = "seeking";
      }, 63500: (M) => {
        M.exports = "stalled";
      }, 55541: (M) => {
        M.exports = "stop";
      }, 53208: (M) => {
        M.exports = "textureready";
      }, 4992: (M) => {
        M.exports = "unlocked";
      }, 12: (M) => {
        M.exports = "unsupported";
      }, 51708: (M, B, $) => {
        M.exports = { ADDED_TO_SCENE: $(62980), DESTROY: $(41337), REMOVED_FROM_SCENE: $(44947), VIDEO_COMPLETE: $(49358), VIDEO_CREATED: $(35163), VIDEO_ERROR: $(97249), VIDEO_LOCKED: $(19483), VIDEO_LOOP: $(56059), VIDEO_METADATA: $(26772), VIDEO_PLAY: $(83411), VIDEO_PLAYING: $(64437), VIDEO_SEEKED: $(75780), VIDEO_SEEKING: $(67799), VIDEO_STALLED: $(63500), VIDEO_STOP: $(55541), VIDEO_TEXTURE: $(53208), VIDEO_UNLOCKED: $(4992), VIDEO_UNSUPPORTED: $(12) };
      }, 42421: (M, B, $) => {
        var E = $(83419), L = $(31401), z = $(95643), U = $(64993), K = new E({ Extends: z, Mixins: [L.Alpha, L.BlendMode, L.Depth, L.Flip, L.Origin, L.ScrollFactor, L.Size, L.Texture, L.Tint, L.Transform, L.Visible, U], initialize: function J(Z) {
          z.call(this, Z, "Extern");
        }, addedToScene: function() {
          this.scene.sys.updateList.add(this);
        }, removedFromScene: function() {
          this.scene.sys.updateList.remove(this);
        }, preUpdate: function() {
        }, render: function() {
        } });
        M.exports = K;
      }, 70217: () => {
      }, 56315: (M, B, $) => {
        var E = $(42421), L = $(39429);
        L.register("extern", function() {
          var z = new E(this.scene);
          return this.displayList.add(z), z;
        });
      }, 64993: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(80287), z = $(70217), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 80287: (M, B, $) => {
        var E = $(91296), L = function(z, U, K, J) {
          z.pipelines.clear();
          var Z = E(U, K, J).calc;
          U.render.call(U, z, K, Z), z.pipelines.rebind();
        };
        M.exports = L;
      }, 85592: (M) => {
        M.exports = { ARC: 0, BEGIN_PATH: 1, CLOSE_PATH: 2, FILL_RECT: 3, LINE_TO: 4, MOVE_TO: 5, LINE_STYLE: 6, FILL_STYLE: 7, FILL_PATH: 8, STROKE_PATH: 9, FILL_TRIANGLE: 10, STROKE_TRIANGLE: 11, SAVE: 14, RESTORE: 15, TRANSLATE: 16, SCALE: 17, ROTATE: 18, GRADIENT_FILL_STYLE: 21, GRADIENT_LINE_STYLE: 22 };
      }, 43831: (M, B, $) => {
        var E = $(71911), L = $(83419), z = $(85592), U = $(31401), K = $(8497), J = $(95643), Z = $(95540), D = $(35154), Q = $(36383), H = $(84503), N = new L({ Extends: J, Mixins: [U.AlphaSingle, U.BlendMode, U.Depth, U.Mask, U.Pipeline, U.PostPipeline, U.Transform, U.Visible, U.ScrollFactor, H], initialize: function W(R, Y) {
          var I = D(Y, "x", 0), P = D(Y, "y", 0);
          J.call(this, R, "Graphics"), this.setPosition(I, P), this.initPipeline(), this.initPostPipeline(), this.displayOriginX = 0, this.displayOriginY = 0, this.commandBuffer = [], this.defaultFillColor = -1, this.defaultFillAlpha = 1, this.defaultStrokeWidth = 1, this.defaultStrokeColor = -1, this.defaultStrokeAlpha = 1, this._lineWidth = 1, this.lineStyle(1, 0, 0), this.fillStyle(0, 0), this.setDefaultStyles(Y);
        }, setDefaultStyles: function(W) {
          if (D(W, "lineStyle", null))
            this.defaultStrokeWidth = D(W, "lineStyle.width", 1), this.defaultStrokeColor = D(W, "lineStyle.color", 16777215), this.defaultStrokeAlpha = D(W, "lineStyle.alpha", 1), this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
          if (D(W, "fillStyle", null))
            this.defaultFillColor = D(W, "fillStyle.color", 16777215), this.defaultFillAlpha = D(W, "fillStyle.alpha", 1), this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
          return this;
        }, lineStyle: function(W, R, Y) {
          if (Y === undefined)
            Y = 1;
          return this.commandBuffer.push(z.LINE_STYLE, W, R, Y), this._lineWidth = W, this;
        }, fillStyle: function(W, R) {
          if (R === undefined)
            R = 1;
          return this.commandBuffer.push(z.FILL_STYLE, W, R), this;
        }, fillGradientStyle: function(W, R, Y, I, P, X, G, V) {
          if (P === undefined)
            P = 1;
          if (X === undefined)
            X = P;
          if (G === undefined)
            G = P;
          if (V === undefined)
            V = P;
          return this.commandBuffer.push(z.GRADIENT_FILL_STYLE, P, X, G, V, W, R, Y, I), this;
        }, lineGradientStyle: function(W, R, Y, I, P, X) {
          if (X === undefined)
            X = 1;
          return this.commandBuffer.push(z.GRADIENT_LINE_STYLE, W, X, R, Y, I, P), this;
        }, beginPath: function() {
          return this.commandBuffer.push(z.BEGIN_PATH), this;
        }, closePath: function() {
          return this.commandBuffer.push(z.CLOSE_PATH), this;
        }, fillPath: function() {
          return this.commandBuffer.push(z.FILL_PATH), this;
        }, fill: function() {
          return this.commandBuffer.push(z.FILL_PATH), this;
        }, strokePath: function() {
          return this.commandBuffer.push(z.STROKE_PATH), this;
        }, stroke: function() {
          return this.commandBuffer.push(z.STROKE_PATH), this;
        }, fillCircleShape: function(W) {
          return this.fillCircle(W.x, W.y, W.radius);
        }, strokeCircleShape: function(W) {
          return this.strokeCircle(W.x, W.y, W.radius);
        }, fillCircle: function(W, R, Y) {
          return this.beginPath(), this.arc(W, R, Y, 0, Q.PI2), this.fillPath(), this;
        }, strokeCircle: function(W, R, Y) {
          return this.beginPath(), this.arc(W, R, Y, 0, Q.PI2), this.strokePath(), this;
        }, fillRectShape: function(W) {
          return this.fillRect(W.x, W.y, W.width, W.height);
        }, strokeRectShape: function(W) {
          return this.strokeRect(W.x, W.y, W.width, W.height);
        }, fillRect: function(W, R, Y, I) {
          return this.commandBuffer.push(z.FILL_RECT, W, R, Y, I), this;
        }, strokeRect: function(W, R, Y, I) {
          var P = this._lineWidth / 2, X = W - P, G = W + P;
          return this.beginPath(), this.moveTo(W, R), this.lineTo(W, R + I), this.strokePath(), this.beginPath(), this.moveTo(W + Y, R), this.lineTo(W + Y, R + I), this.strokePath(), this.beginPath(), this.moveTo(X, R), this.lineTo(G + Y, R), this.strokePath(), this.beginPath(), this.moveTo(X, R + I), this.lineTo(G + Y, R + I), this.strokePath(), this;
        }, fillRoundedRect: function(W, R, Y, I, P) {
          if (P === undefined)
            P = 20;
          var X = P, G = P, V = P, A = P;
          if (typeof P !== "number")
            X = Z(P, "tl", 20), G = Z(P, "tr", 20), V = Z(P, "bl", 20), A = Z(P, "br", 20);
          var F = X >= 0, j = G >= 0, T = V >= 0, C = A >= 0;
          if (X = Math.abs(X), G = Math.abs(G), V = Math.abs(V), A = Math.abs(A), this.beginPath(), this.moveTo(W + X, R), this.lineTo(W + Y - G, R), j)
            this.arc(W + Y - G, R + G, G, -Q.TAU, 0);
          else
            this.arc(W + Y, R, G, Math.PI, Q.TAU, true);
          if (this.lineTo(W + Y, R + I - A), C)
            this.arc(W + Y - A, R + I - A, A, 0, Q.TAU);
          else
            this.arc(W + Y, R + I, A, -Q.TAU, Math.PI, true);
          if (this.lineTo(W + V, R + I), T)
            this.arc(W + V, R + I - V, V, Q.TAU, Math.PI);
          else
            this.arc(W, R + I, V, 0, -Q.TAU, true);
          if (this.lineTo(W, R + X), F)
            this.arc(W + X, R + X, X, -Math.PI, -Q.TAU);
          else
            this.arc(W, R, X, Q.TAU, 0, true);
          return this.fillPath(), this;
        }, strokeRoundedRect: function(W, R, Y, I, P) {
          if (P === undefined)
            P = 20;
          var X = P, G = P, V = P, A = P, F = Math.min(Y, I) / 2;
          if (typeof P !== "number")
            X = Z(P, "tl", 20), G = Z(P, "tr", 20), V = Z(P, "bl", 20), A = Z(P, "br", 20);
          var j = X >= 0, T = G >= 0, C = V >= 0, v = A >= 0;
          if (X = Math.min(Math.abs(X), F), G = Math.min(Math.abs(G), F), V = Math.min(Math.abs(V), F), A = Math.min(Math.abs(A), F), this.beginPath(), this.moveTo(W + X, R), this.lineTo(W + Y - G, R), this.moveTo(W + Y - G, R), T)
            this.arc(W + Y - G, R + G, G, -Q.TAU, 0);
          else
            this.arc(W + Y, R, G, Math.PI, Q.TAU, true);
          if (this.lineTo(W + Y, R + I - A), this.moveTo(W + Y, R + I - A), v)
            this.arc(W + Y - A, R + I - A, A, 0, Q.TAU);
          else
            this.arc(W + Y, R + I, A, -Q.TAU, Math.PI, true);
          if (this.lineTo(W + V, R + I), this.moveTo(W + V, R + I), C)
            this.arc(W + V, R + I - V, V, Q.TAU, Math.PI);
          else
            this.arc(W, R + I, V, 0, -Q.TAU, true);
          if (this.lineTo(W, R + X), this.moveTo(W, R + X), j)
            this.arc(W + X, R + X, X, -Math.PI, -Q.TAU);
          else
            this.arc(W, R, X, Q.TAU, 0, true);
          return this.strokePath(), this;
        }, fillPointShape: function(W, R) {
          return this.fillPoint(W.x, W.y, R);
        }, fillPoint: function(W, R, Y) {
          if (!Y || Y < 1)
            Y = 1;
          else
            W -= Y / 2, R -= Y / 2;
          return this.commandBuffer.push(z.FILL_RECT, W, R, Y, Y), this;
        }, fillTriangleShape: function(W) {
          return this.fillTriangle(W.x1, W.y1, W.x2, W.y2, W.x3, W.y3);
        }, strokeTriangleShape: function(W) {
          return this.strokeTriangle(W.x1, W.y1, W.x2, W.y2, W.x3, W.y3);
        }, fillTriangle: function(W, R, Y, I, P, X) {
          return this.commandBuffer.push(z.FILL_TRIANGLE, W, R, Y, I, P, X), this;
        }, strokeTriangle: function(W, R, Y, I, P, X) {
          return this.commandBuffer.push(z.STROKE_TRIANGLE, W, R, Y, I, P, X), this;
        }, strokeLineShape: function(W) {
          return this.lineBetween(W.x1, W.y1, W.x2, W.y2);
        }, lineBetween: function(W, R, Y, I) {
          return this.beginPath(), this.moveTo(W, R), this.lineTo(Y, I), this.strokePath(), this;
        }, lineTo: function(W, R) {
          return this.commandBuffer.push(z.LINE_TO, W, R), this;
        }, moveTo: function(W, R) {
          return this.commandBuffer.push(z.MOVE_TO, W, R), this;
        }, strokePoints: function(W, R, Y, I) {
          if (R === undefined)
            R = false;
          if (Y === undefined)
            Y = false;
          if (I === undefined)
            I = W.length;
          this.beginPath(), this.moveTo(W[0].x, W[0].y);
          for (var P = 1;P < I; P++)
            this.lineTo(W[P].x, W[P].y);
          if (R)
            this.lineTo(W[0].x, W[0].y);
          if (Y)
            this.closePath();
          return this.strokePath(), this;
        }, fillPoints: function(W, R, Y, I) {
          if (R === undefined)
            R = false;
          if (Y === undefined)
            Y = false;
          if (I === undefined)
            I = W.length;
          this.beginPath(), this.moveTo(W[0].x, W[0].y);
          for (var P = 1;P < I; P++)
            this.lineTo(W[P].x, W[P].y);
          if (R)
            this.lineTo(W[0].x, W[0].y);
          if (Y)
            this.closePath();
          return this.fillPath(), this;
        }, strokeEllipseShape: function(W, R) {
          if (R === undefined)
            R = 32;
          var Y = W.getPoints(R);
          return this.strokePoints(Y, true);
        }, strokeEllipse: function(W, R, Y, I, P) {
          if (P === undefined)
            P = 32;
          var X = new K(W, R, Y, I), G = X.getPoints(P);
          return this.strokePoints(G, true);
        }, fillEllipseShape: function(W, R) {
          if (R === undefined)
            R = 32;
          var Y = W.getPoints(R);
          return this.fillPoints(Y, true);
        }, fillEllipse: function(W, R, Y, I, P) {
          if (P === undefined)
            P = 32;
          var X = new K(W, R, Y, I), G = X.getPoints(P);
          return this.fillPoints(G, true);
        }, arc: function(W, R, Y, I, P, X, G) {
          if (X === undefined)
            X = false;
          if (G === undefined)
            G = 0;
          return this.commandBuffer.push(z.ARC, W, R, Y, I, P, X, G), this;
        }, slice: function(W, R, Y, I, P, X, G) {
          if (X === undefined)
            X = false;
          if (G === undefined)
            G = 0;
          return this.commandBuffer.push(z.BEGIN_PATH), this.commandBuffer.push(z.MOVE_TO, W, R), this.commandBuffer.push(z.ARC, W, R, Y, I, P, X, G), this.commandBuffer.push(z.CLOSE_PATH), this;
        }, save: function() {
          return this.commandBuffer.push(z.SAVE), this;
        }, restore: function() {
          return this.commandBuffer.push(z.RESTORE), this;
        }, translateCanvas: function(W, R) {
          return this.commandBuffer.push(z.TRANSLATE, W, R), this;
        }, scaleCanvas: function(W, R) {
          return this.commandBuffer.push(z.SCALE, W, R), this;
        }, rotateCanvas: function(W) {
          return this.commandBuffer.push(z.ROTATE, W), this;
        }, clear: function() {
          if (this.commandBuffer.length = 0, this.defaultFillColor > -1)
            this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);
          if (this.defaultStrokeColor > -1)
            this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);
          return this;
        }, generateTexture: function(W, R, Y) {
          var I = this.scene.sys, P = I.game.renderer;
          if (R === undefined)
            R = I.scale.width;
          if (Y === undefined)
            Y = I.scale.height;
          N.TargetCamera.setScene(this.scene), N.TargetCamera.setViewport(0, 0, R, Y), N.TargetCamera.scrollX = this.x, N.TargetCamera.scrollY = this.y;
          var X, G, V = { willReadFrequently: true };
          if (typeof W === "string")
            if (I.textures.exists(W)) {
              X = I.textures.get(W);
              var A = X.getSourceImage();
              if (A instanceof HTMLCanvasElement)
                G = A.getContext("2d", V);
            } else
              X = I.textures.createCanvas(W, R, Y), G = X.getSourceImage().getContext("2d", V);
          else if (W instanceof HTMLCanvasElement)
            G = W.getContext("2d", V);
          if (G) {
            if (this.renderCanvas(P, this, N.TargetCamera, null, G, false), X)
              X.refresh();
          }
          return this;
        }, preDestroy: function() {
          this.commandBuffer = [];
        } });
        N.TargetCamera = new E, M.exports = N;
      }, 32768: (M, B, $) => {
        var E = $(85592), L = $(20926), z = function(U, K, J, Z, D, Q) {
          var H = K.commandBuffer, N = H.length, W = D || U.currentContext;
          if (N === 0 || !L(U, W, K, J, Z))
            return;
          J.addToRenderList(K);
          var R = 1, Y = 1, I = 0, P = 0, X = 1, G = 0, V = 0, A = 0;
          W.beginPath();
          for (var F = 0;F < N; ++F) {
            var j = H[F];
            switch (j) {
              case E.ARC:
                W.arc(H[F + 1], H[F + 2], H[F + 3], H[F + 4], H[F + 5], H[F + 6]), F += 7;
                break;
              case E.LINE_STYLE:
                X = H[F + 1], I = H[F + 2], R = H[F + 3], G = (I & 16711680) >>> 16, V = (I & 65280) >>> 8, A = I & 255, W.strokeStyle = "rgba(" + G + "," + V + "," + A + "," + R + ")", W.lineWidth = X, F += 3;
                break;
              case E.FILL_STYLE:
                P = H[F + 1], Y = H[F + 2], G = (P & 16711680) >>> 16, V = (P & 65280) >>> 8, A = P & 255, W.fillStyle = "rgba(" + G + "," + V + "," + A + "," + Y + ")", F += 2;
                break;
              case E.BEGIN_PATH:
                W.beginPath();
                break;
              case E.CLOSE_PATH:
                W.closePath();
                break;
              case E.FILL_PATH:
                if (!Q)
                  W.fill();
                break;
              case E.STROKE_PATH:
                if (!Q)
                  W.stroke();
                break;
              case E.FILL_RECT:
                if (!Q)
                  W.fillRect(H[F + 1], H[F + 2], H[F + 3], H[F + 4]);
                else
                  W.rect(H[F + 1], H[F + 2], H[F + 3], H[F + 4]);
                F += 4;
                break;
              case E.FILL_TRIANGLE:
                if (W.beginPath(), W.moveTo(H[F + 1], H[F + 2]), W.lineTo(H[F + 3], H[F + 4]), W.lineTo(H[F + 5], H[F + 6]), W.closePath(), !Q)
                  W.fill();
                F += 6;
                break;
              case E.STROKE_TRIANGLE:
                if (W.beginPath(), W.moveTo(H[F + 1], H[F + 2]), W.lineTo(H[F + 3], H[F + 4]), W.lineTo(H[F + 5], H[F + 6]), W.closePath(), !Q)
                  W.stroke();
                F += 6;
                break;
              case E.LINE_TO:
                W.lineTo(H[F + 1], H[F + 2]), F += 2;
                break;
              case E.MOVE_TO:
                W.moveTo(H[F + 1], H[F + 2]), F += 2;
                break;
              case E.LINE_FX_TO:
                W.lineTo(H[F + 1], H[F + 2]), F += 5;
                break;
              case E.MOVE_FX_TO:
                W.moveTo(H[F + 1], H[F + 2]), F += 5;
                break;
              case E.SAVE:
                W.save();
                break;
              case E.RESTORE:
                W.restore();
                break;
              case E.TRANSLATE:
                W.translate(H[F + 1], H[F + 2]), F += 2;
                break;
              case E.SCALE:
                W.scale(H[F + 1], H[F + 2]), F += 2;
                break;
              case E.ROTATE:
                W.rotate(H[F + 1]), F += 1;
                break;
              case E.GRADIENT_FILL_STYLE:
                F += 5;
                break;
              case E.GRADIENT_LINE_STYLE:
                F += 6;
                break;
            }
          }
          W.restore();
        };
        M.exports = z;
      }, 87079: (M, B, $) => {
        var E = $(44603), L = $(43831);
        E.register("graphics", function(z, U) {
          if (z === undefined)
            z = {};
          if (U !== undefined)
            z.add = U;
          var K = new L(this.scene, z);
          if (z.add)
            this.scene.sys.displayList.add(K);
          return K;
        });
      }, 1201: (M, B, $) => {
        var E = $(43831), L = $(39429);
        L.register("graphics", function(z) {
          return this.displayList.add(new E(this.scene, z));
        });
      }, 84503: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(77545), z = $(32768), z = $(32768), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 77545: (M, B, $) => {
        var E = $(85592), L = $(91296), z = $(61340), U = $(70554), K = function(H, N, W) {
          this.x = H, this.y = N, this.width = W;
        }, J = function(H, N, W) {
          this.points = [], this.pointsLength = 1, this.points[0] = new K(H, N, W);
        }, Z = [], D = new z, Q = function(H, N, W, R) {
          if (N.commandBuffer.length === 0)
            return;
          W.addToRenderList(N);
          var Y = H.pipelines.set(N.pipeline, N);
          H.pipelines.preBatch(N);
          var I = L(N, W, R).calc, P = D.loadIdentity(), X = N.commandBuffer, G = W.alpha * N.alpha, V = 1, A = Y.fillTint, F = Y.strokeTint, j = 0, T = 0, C = 0, v = 0.01, O = Math.PI * 2, q, w = [], g = 0, b = true, x = null, k = U.getTintAppendFloatAlpha;
          for (var S = 0;S < X.length; S++)
            switch (q = X[S], q) {
              case E.BEGIN_PATH: {
                w.length = 0, x = null, b = true;
                break;
              }
              case E.CLOSE_PATH: {
                if (b = false, x && x.points.length)
                  x.points.push(x.points[0]);
                break;
              }
              case E.FILL_PATH: {
                for (g = 0;g < w.length; g++)
                  Y.batchFillPath(w[g].points, P, I);
                break;
              }
              case E.STROKE_PATH: {
                for (g = 0;g < w.length; g++)
                  Y.batchStrokePath(w[g].points, V, b, P, I);
                break;
              }
              case E.LINE_STYLE: {
                V = X[++S];
                var f = X[++S], h = X[++S] * G, m = k(f, h);
                F.TL = m, F.TR = m, F.BL = m, F.BR = m;
                break;
              }
              case E.FILL_STYLE: {
                var y = X[++S], d = X[++S] * G, p = k(y, d);
                A.TL = p, A.TR = p, A.BL = p, A.BR = p;
                break;
              }
              case E.GRADIENT_FILL_STYLE: {
                var u = X[++S] * G, s = X[++S] * G, c = X[++S] * G, n = X[++S] * G;
                A.TL = k(X[++S], u), A.TR = k(X[++S], s), A.BL = k(X[++S], c), A.BR = k(X[++S], n);
                break;
              }
              case E.GRADIENT_LINE_STYLE: {
                V = X[++S];
                var _ = X[++S] * G;
                F.TL = k(X[++S], _), F.TR = k(X[++S], _), F.BL = k(X[++S], _), F.BR = k(X[++S], _);
                break;
              }
              case E.ARC: {
                var l = 0, i = X[++S], t = X[++S], $0 = X[++S], e = X[++S], o = X[++S], r = X[++S], a = X[++S];
                if (o -= e, r) {
                  if (o < -O)
                    o = -O;
                  else if (o > 0)
                    o = -O + o % O;
                } else if (o > O)
                  o = O;
                else if (o < 0)
                  o = O + o % O;
                if (x === null)
                  x = new J(i + Math.cos(e) * $0, t + Math.sin(e) * $0, V), w.push(x), l += v;
                while (l < 1 + a)
                  C = o * l + e, j = i + Math.cos(C) * $0, T = t + Math.sin(C) * $0, x.points.push(new K(j, T, V)), l += v;
                C = o + e, j = i + Math.cos(C) * $0, T = t + Math.sin(C) * $0, x.points.push(new K(j, T, V));
                break;
              }
              case E.FILL_RECT: {
                Y.batchFillRect(X[++S], X[++S], X[++S], X[++S], P, I);
                break;
              }
              case E.FILL_TRIANGLE: {
                Y.batchFillTriangle(X[++S], X[++S], X[++S], X[++S], X[++S], X[++S], P, I);
                break;
              }
              case E.STROKE_TRIANGLE: {
                Y.batchStrokeTriangle(X[++S], X[++S], X[++S], X[++S], X[++S], X[++S], V, P, I);
                break;
              }
              case E.LINE_TO: {
                if (x !== null)
                  x.points.push(new K(X[++S], X[++S], V));
                else
                  x = new J(X[++S], X[++S], V), w.push(x);
                break;
              }
              case E.MOVE_TO: {
                x = new J(X[++S], X[++S], V), w.push(x);
                break;
              }
              case E.SAVE: {
                Z.push(P.copyToArray());
                break;
              }
              case E.RESTORE: {
                P.copyFromArray(Z.pop());
                break;
              }
              case E.TRANSLATE: {
                i = X[++S], t = X[++S], P.translate(i, t);
                break;
              }
              case E.SCALE: {
                i = X[++S], t = X[++S], P.scale(i, t);
                break;
              }
              case E.ROTATE: {
                P.rotate(X[++S]);
                break;
              }
            }
          H.pipelines.postBatch(N);
        };
        M.exports = Q;
      }, 26479: (M, B, $) => {
        var E = $(61061), L = $(83419), z = $(51708), U = $(50792), K = $(46710), J = $(95540), Z = $(35154), D = $(97022), Q = $(41212), H = $(88492), N = $(35072), W = $(68287), R = new L({ Extends: U, initialize: function Y(I, P, X) {
          if (U.call(this), X) {
            if (P && !Array.isArray(P))
              P = [P];
          } else if (Array.isArray(P)) {
            if (Q(P[0]))
              X = P, P = null;
          } else if (Q(P))
            X = P, P = null;
          if (this.scene = I, this.children = new N, this.isParent = true, this.type = "Group", this.classType = J(X, "classType", W), this.name = J(X, "name", ""), this.active = J(X, "active", true), this.maxSize = J(X, "maxSize", -1), this.defaultKey = J(X, "defaultKey", null), this.defaultFrame = J(X, "defaultFrame", null), this.runChildUpdate = J(X, "runChildUpdate", false), this.createCallback = J(X, "createCallback", null), this.removeCallback = J(X, "removeCallback", null), this.createMultipleCallback = J(X, "createMultipleCallback", null), this.internalCreateCallback = J(X, "internalCreateCallback", null), this.internalRemoveCallback = J(X, "internalRemoveCallback", null), P)
            this.addMultiple(P);
          if (X)
            this.createMultiple(X);
          this.on(z.ADDED_TO_SCENE, this.addedToScene, this), this.on(z.REMOVED_FROM_SCENE, this.removedFromScene, this);
        }, addedToScene: function() {
          this.scene.sys.updateList.add(this);
        }, removedFromScene: function() {
          this.scene.sys.updateList.remove(this);
        }, create: function(Y, I, P, X, G, V) {
          if (Y === undefined)
            Y = 0;
          if (I === undefined)
            I = 0;
          if (P === undefined)
            P = this.defaultKey;
          if (X === undefined)
            X = this.defaultFrame;
          if (G === undefined)
            G = true;
          if (V === undefined)
            V = true;
          if (this.isFull())
            return null;
          var A = new this.classType(this.scene, Y, I, P, X);
          return A.addToDisplayList(this.scene.sys.displayList), A.addToUpdateList(), A.visible = G, A.setActive(V), this.add(A), A;
        }, createMultiple: function(Y) {
          if (this.isFull())
            return [];
          if (!Array.isArray(Y))
            Y = [Y];
          var I = [];
          if (Y[0].key)
            for (var P = 0;P < Y.length; P++) {
              var X = this.createFromConfig(Y[P]);
              I = I.concat(X);
            }
          return I;
        }, createFromConfig: function(Y) {
          if (this.isFull())
            return [];
          this.classType = J(Y, "classType", this.classType);
          var I = J(Y, "key", undefined), P = J(Y, "frame", null), X = J(Y, "visible", true), G = J(Y, "active", true), V = [];
          if (I === undefined)
            return V;
          else {
            if (!Array.isArray(I))
              I = [I];
            if (!Array.isArray(P))
              P = [P];
          }
          var A = J(Y, "repeat", 0), F = J(Y, "randomKey", false), j = J(Y, "randomFrame", false), T = J(Y, "yoyo", false), C = J(Y, "quantity", false), v = J(Y, "frameQuantity", 1), O = J(Y, "max", 0), q = H(I, P, { max: O, qty: C ? C : v, random: F, randomB: j, repeat: A, yoyo: T });
          if (Y.createCallback)
            this.createCallback = Y.createCallback;
          if (Y.removeCallback)
            this.removeCallback = Y.removeCallback;
          if (Y.internalCreateCallback)
            this.internalCreateCallback = Y.internalCreateCallback;
          if (Y.internalRemoveCallback)
            this.internalRemoveCallback = Y.internalRemoveCallback;
          for (var w = 0;w < q.length; w++) {
            var g = this.create(0, 0, q[w].a, q[w].b, X, G);
            if (!g)
              break;
            V.push(g);
          }
          if (D(Y, "setXY")) {
            var b = Z(Y, "setXY.x", 0), x = Z(Y, "setXY.y", 0), k = Z(Y, "setXY.stepX", 0), S = Z(Y, "setXY.stepY", 0);
            E.SetXY(V, b, x, k, S);
          }
          if (D(Y, "setRotation")) {
            var f = Z(Y, "setRotation.value", 0), h = Z(Y, "setRotation.step", 0);
            E.SetRotation(V, f, h);
          }
          if (D(Y, "setScale")) {
            var m = Z(Y, "setScale.x", 1), y = Z(Y, "setScale.y", m), d = Z(Y, "setScale.stepX", 0), p = Z(Y, "setScale.stepY", 0);
            E.SetScale(V, m, y, d, p);
          }
          if (D(Y, "setOrigin")) {
            var u = Z(Y, "setOrigin.x", 0.5), s = Z(Y, "setOrigin.y", u), c = Z(Y, "setOrigin.stepX", 0), n = Z(Y, "setOrigin.stepY", 0);
            E.SetOrigin(V, u, s, c, n);
          }
          if (D(Y, "setAlpha")) {
            var _ = Z(Y, "setAlpha.value", 1), l = Z(Y, "setAlpha.step", 0);
            E.SetAlpha(V, _, l);
          }
          if (D(Y, "setDepth")) {
            var i = Z(Y, "setDepth.value", 0), t = Z(Y, "setDepth.step", 0);
            E.SetDepth(V, i, t);
          }
          if (D(Y, "setScrollFactor")) {
            var $0 = Z(Y, "setScrollFactor.x", 1), e = Z(Y, "setScrollFactor.y", $0), o = Z(Y, "setScrollFactor.stepX", 0), r = Z(Y, "setScrollFactor.stepY", 0);
            E.SetScrollFactor(V, $0, e, o, r);
          }
          var a = J(Y, "hitArea", null), J0 = J(Y, "hitAreaCallback", null);
          if (a)
            E.SetHitArea(V, a, J0);
          var Q0 = J(Y, "gridAlign", false);
          if (Q0)
            E.GridAlign(V, Q0);
          if (this.createMultipleCallback)
            this.createMultipleCallback.call(this, V);
          return V;
        }, preUpdate: function(Y, I) {
          if (!this.runChildUpdate || this.children.size === 0)
            return;
          var P = this.children.entries.slice();
          for (var X = 0;X < P.length; X++) {
            var G = P[X];
            if (G.active)
              G.update(Y, I);
          }
        }, add: function(Y, I) {
          if (I === undefined)
            I = false;
          if (this.isFull())
            return this;
          if (this.children.set(Y), this.internalCreateCallback)
            this.internalCreateCallback.call(this, Y);
          if (this.createCallback)
            this.createCallback.call(this, Y);
          if (I)
            Y.addToDisplayList(this.scene.sys.displayList), Y.addToUpdateList();
          return Y.on(z.DESTROY, this.remove, this), this;
        }, addMultiple: function(Y, I) {
          if (I === undefined)
            I = false;
          if (Array.isArray(Y))
            for (var P = 0;P < Y.length; P++)
              this.add(Y[P], I);
          return this;
        }, remove: function(Y, I, P) {
          if (I === undefined)
            I = false;
          if (P === undefined)
            P = false;
          if (!this.children.contains(Y))
            return this;
          if (this.children.delete(Y), this.internalRemoveCallback)
            this.internalRemoveCallback.call(this, Y);
          if (this.removeCallback)
            this.removeCallback.call(this, Y);
          if (Y.off(z.DESTROY, this.remove, this), P)
            Y.destroy();
          else if (I)
            Y.removeFromDisplayList(), Y.removeFromUpdateList();
          return this;
        }, clear: function(Y, I) {
          if (Y === undefined)
            Y = false;
          if (I === undefined)
            I = false;
          var P = this.children;
          for (var X = 0;X < P.size; X++) {
            var G = P.entries[X];
            if (G.off(z.DESTROY, this.remove, this), I)
              G.destroy();
            else if (Y)
              G.removeFromDisplayList(), G.removeFromUpdateList();
          }
          return this.children.clear(), this;
        }, contains: function(Y) {
          return this.children.contains(Y);
        }, getChildren: function() {
          return this.children.entries;
        }, getLength: function() {
          return this.children.size;
        }, getMatching: function(Y, I, P, X) {
          return K(this.children.entries, Y, I, P, X);
        }, getFirst: function(Y, I, P, X, G, V, A) {
          return this.getHandler(true, 1, Y, I, P, X, G, V, A);
        }, getFirstNth: function(Y, I, P, X, G, V, A, F) {
          return this.getHandler(true, Y, I, P, X, G, V, A, F);
        }, getLast: function(Y, I, P, X, G, V, A) {
          return this.getHandler(false, 1, Y, I, P, X, G, V, A);
        }, getLastNth: function(Y, I, P, X, G, V, A, F) {
          return this.getHandler(false, Y, I, P, X, G, V, A, F);
        }, getHandler: function(Y, I, P, X, G, V, A, F, j) {
          if (P === undefined)
            P = false;
          if (X === undefined)
            X = false;
          var T, C, v = 0, O = this.children.entries;
          if (Y)
            for (C = 0;C < O.length; C++)
              if (T = O[C], T.active === P) {
                if (v++, v === I)
                  break;
              } else
                T = null;
          else
            for (C = O.length - 1;C >= 0; C--)
              if (T = O[C], T.active === P) {
                if (v++, v === I)
                  break;
              } else
                T = null;
          if (T) {
            if (typeof G === "number")
              T.x = G;
            if (typeof V === "number")
              T.y = V;
            return T;
          }
          if (X)
            return this.create(G, V, A, F, j);
          else
            return null;
        }, get: function(Y, I, P, X, G) {
          return this.getFirst(false, true, Y, I, P, X, G);
        }, getFirstAlive: function(Y, I, P, X, G, V) {
          return this.getFirst(true, Y, I, P, X, G, V);
        }, getFirstDead: function(Y, I, P, X, G, V) {
          return this.getFirst(false, Y, I, P, X, G, V);
        }, playAnimation: function(Y, I) {
          return E.PlayAnimation(this.children.entries, Y, I), this;
        }, isFull: function() {
          if (this.maxSize === -1)
            return false;
          else
            return this.children.size >= this.maxSize;
        }, countActive: function(Y) {
          if (Y === undefined)
            Y = true;
          var I = 0;
          for (var P = 0;P < this.children.size; P++)
            if (this.children.entries[P].active === Y)
              I++;
          return I;
        }, getTotalUsed: function() {
          return this.countActive();
        }, getTotalFree: function() {
          var Y = this.getTotalUsed(), I = this.maxSize === -1 ? 999999999999 : this.maxSize;
          return I - Y;
        }, setActive: function(Y) {
          return this.active = Y, this;
        }, setName: function(Y) {
          return this.name = Y, this;
        }, propertyValueSet: function(Y, I, P, X, G) {
          return E.PropertyValueSet(this.children.entries, Y, I, P, X, G), this;
        }, propertyValueInc: function(Y, I, P, X, G) {
          return E.PropertyValueInc(this.children.entries, Y, I, P, X, G), this;
        }, setX: function(Y, I) {
          return E.SetX(this.children.entries, Y, I), this;
        }, setY: function(Y, I) {
          return E.SetY(this.children.entries, Y, I), this;
        }, setXY: function(Y, I, P, X) {
          return E.SetXY(this.children.entries, Y, I, P, X), this;
        }, incX: function(Y, I) {
          return E.IncX(this.children.entries, Y, I), this;
        }, incY: function(Y, I) {
          return E.IncY(this.children.entries, Y, I), this;
        }, incXY: function(Y, I, P, X) {
          return E.IncXY(this.children.entries, Y, I, P, X), this;
        }, shiftPosition: function(Y, I, P) {
          return E.ShiftPosition(this.children.entries, Y, I, P), this;
        }, angle: function(Y, I) {
          return E.Angle(this.children.entries, Y, I), this;
        }, rotate: function(Y, I) {
          return E.Rotate(this.children.entries, Y, I), this;
        }, rotateAround: function(Y, I) {
          return E.RotateAround(this.children.entries, Y, I), this;
        }, rotateAroundDistance: function(Y, I, P) {
          return E.RotateAroundDistance(this.children.entries, Y, I, P), this;
        }, setAlpha: function(Y, I) {
          return E.SetAlpha(this.children.entries, Y, I), this;
        }, setTint: function(Y, I, P, X) {
          return E.SetTint(this.children.entries, Y, I, P, X), this;
        }, setOrigin: function(Y, I, P, X) {
          return E.SetOrigin(this.children.entries, Y, I, P, X), this;
        }, scaleX: function(Y, I) {
          return E.ScaleX(this.children.entries, Y, I), this;
        }, scaleY: function(Y, I) {
          return E.ScaleY(this.children.entries, Y, I), this;
        }, scaleXY: function(Y, I, P, X) {
          return E.ScaleXY(this.children.entries, Y, I, P, X), this;
        }, setDepth: function(Y, I) {
          return E.SetDepth(this.children.entries, Y, I), this;
        }, setBlendMode: function(Y) {
          return E.SetBlendMode(this.children.entries, Y), this;
        }, setHitArea: function(Y, I) {
          return E.SetHitArea(this.children.entries, Y, I), this;
        }, shuffle: function() {
          return E.Shuffle(this.children.entries), this;
        }, kill: function(Y) {
          if (this.children.contains(Y))
            Y.setActive(false);
        }, killAndHide: function(Y) {
          if (this.children.contains(Y))
            Y.setActive(false), Y.setVisible(false);
        }, setVisible: function(Y, I, P) {
          return E.SetVisible(this.children.entries, Y, I, P), this;
        }, toggleVisible: function() {
          return E.ToggleVisible(this.children.entries), this;
        }, destroy: function(Y, I) {
          if (Y === undefined)
            Y = false;
          if (I === undefined)
            I = false;
          if (!this.scene || this.ignoreDestroy)
            return;
          this.emit(z.DESTROY, this), this.removeAllListeners(), this.scene.sys.updateList.remove(this), this.clear(I, Y), this.scene = undefined, this.children = undefined;
        } });
        M.exports = R;
      }, 94975: (M, B, $) => {
        var E = $(44603), L = $(26479);
        E.register("group", function(z) {
          return new L(this.scene, null, z);
        });
      }, 3385: (M, B, $) => {
        var E = $(26479), L = $(39429);
        L.register("group", function(z, U) {
          return this.updateList.add(new E(this.scene, z, U));
        });
      }, 88571: (M, B, $) => {
        var E = $(83419), L = $(31401), z = $(95643), U = $(59819), K = new E({ Extends: z, Mixins: [L.Alpha, L.BlendMode, L.Depth, L.Flip, L.GetBounds, L.Mask, L.Origin, L.Pipeline, L.PostPipeline, L.ScrollFactor, L.Size, L.TextureCrop, L.Tint, L.Transform, L.Visible, U], initialize: function J(Z, D, Q, H, N) {
          z.call(this, Z, "Image"), this._crop = this.resetCropObject(), this.setTexture(H, N), this.setPosition(D, Q), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline(), this.initPostPipeline(true);
        } });
        M.exports = K;
      }, 40652: (M) => {
        var B = function($, E, L, z) {
          L.addToRenderList(E), $.batchSprite(E, E.frame, L, z);
        };
        M.exports = B;
      }, 82459: (M, B, $) => {
        var E = $(25305), L = $(44603), z = $(23568), U = $(88571);
        L.register("image", function(K, J) {
          if (K === undefined)
            K = {};
          var Z = z(K, "key", null), D = z(K, "frame", null), Q = new U(this.scene, 0, 0, Z, D);
          if (J !== undefined)
            K.add = J;
          return E(this.scene, Q, K), Q;
        });
      }, 2117: (M, B, $) => {
        var E = $(88571), L = $(39429);
        L.register("image", function(z, U, K, J) {
          return this.displayList.add(new E(this.scene, z, U, K, J));
        });
      }, 59819: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(99517), z = $(40652), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 99517: (M) => {
        var B = function($, E, L, z) {
          L.addToRenderList(E), this.pipeline.batchSprite(E, L, z);
        };
        M.exports = B;
      }, 77856: (M, B, $) => {
        var E = { Events: $(51708), DisplayList: $(8050), GameObjectCreator: $(44603), GameObjectFactory: $(39429), UpdateList: $(45027), Components: $(31401), GetCalcMatrix: $(91296), BuildGameObject: $(25305), BuildGameObjectAnimation: $(13059), GameObject: $(95643), BitmapText: $(22186), Blitter: $(6107), Bob: $(46590), Container: $(31559), DOMElement: $(3069), DynamicBitmapText: $(2638), Extern: $(42421), Graphics: $(43831), Group: $(26479), Image: $(88571), Layer: $(93595), Particles: $(18404), PathFollower: $(1159), RenderTexture: $(591), RetroFont: $(196), Rope: $(77757), Sprite: $(68287), Text: $(50171), GetTextSize: $(14220), MeasureText: $(79557), TextStyle: $(35762), TileSprite: $(20839), Zone: $(41481), Video: $(18471), Shape: $(17803), Arc: $(23629), Curve: $(89), Ellipse: $(19921), Grid: $(30479), IsoBox: $(61475), IsoTriangle: $(16933), Line: $(57847), Polygon: $(24949), Rectangle: $(74561), Star: $(55911), Triangle: $(36931), Factories: { Blitter: $(12709), Container: $(24961), DOMElement: $(2611), DynamicBitmapText: $(72566), Extern: $(56315), Graphics: $(1201), Group: $(3385), Image: $(2117), Layer: $(20005), Particles: $(676), PathFollower: $(90145), RenderTexture: $(60505), Rope: $(96819), Sprite: $(46409), StaticBitmapText: $(34914), Text: $(68005), TileSprite: $(91681), Zone: $(84175), Video: $(89025), Arc: $(42563), Curve: $(40511), Ellipse: $(1543), Grid: $(34137), IsoBox: $(3933), IsoTriangle: $(49803), Line: $(2481), Polygon: $(64827), Rectangle: $(87959), Star: $(93697), Triangle: $(45245) }, Creators: { Blitter: $(9403), Container: $(77143), DynamicBitmapText: $(11164), Graphics: $(87079), Group: $(94975), Image: $(82459), Layer: $(25179), Particles: $(92730), RenderTexture: $(34495), Rope: $(26209), Sprite: $(15567), StaticBitmapText: $(57336), Text: $(71259), TileSprite: $(14167), Zone: $(95261), Video: $(11511) } };
        E.Shader = $(20071), E.Mesh = $(4703), E.NineSlice = $(28103), E.PointLight = $(80321), E.Plane = $(33663), E.Factories.Shader = $(74177), E.Factories.Mesh = $(9225), E.Factories.NineSlice = $(47521), E.Factories.PointLight = $(71255), E.Factories.Plane = $(30985), E.Creators.Shader = $(54935), E.Creators.Mesh = $(20527), E.Creators.NineSlice = $(28279), E.Creators.PointLight = $(39829), E.Creators.Plane = $(56015), E.Light = $(41432), E.LightsManager = $(61356), E.LightsPlugin = $(88992), M.exports = E;
      }, 93595: (M, B, $) => {
        var E = $(10312), L = $(83419), z = $(31401), U = $(53774), K = $(45893), J = $(50792), Z = $(51708), D = $(73162), Q = $(33963), H = $(44594), N = $(19186), W = new L({ Extends: D, Mixins: [z.AlphaSingle, z.BlendMode, z.Depth, z.Mask, z.PostPipeline, z.Visible, J, Q], initialize: function R(Y, I) {
          if (D.call(this, Y), J.call(this), this.scene = Y, this.displayList = null, this.type = "Layer", this.state = 0, this.parentContainer = null, this.name = "", this.active = true, this.tabIndex = -1, this.data = null, this.renderFlags = 15, this.cameraFilter = 0, this.input = null, this.body = null, this.ignoreDestroy = false, this.systems = Y.sys, this.events = Y.sys.events, this.sortChildrenFlag = false, this.addCallback = this.addChildCallback, this.removeCallback = this.removeChildCallback, this.initPostPipeline(), this.clearAlpha(), this.setBlendMode(E.SKIP_CHECK), I)
            this.add(I);
          Y.sys.queueDepthSort();
        }, setActive: function(R) {
          return this.active = R, this;
        }, setName: function(R) {
          return this.name = R, this;
        }, setState: function(R) {
          return this.state = R, this;
        }, setDataEnabled: function() {
          if (!this.data)
            this.data = new K(this);
          return this;
        }, setData: function(R, Y) {
          if (!this.data)
            this.data = new K(this);
          return this.data.set(R, Y), this;
        }, incData: function(R, Y) {
          if (!this.data)
            this.data = new K(this);
          return this.data.inc(R, Y), this;
        }, toggleData: function(R) {
          if (!this.data)
            this.data = new K(this);
          return this.data.toggle(R), this;
        }, getData: function(R) {
          if (!this.data)
            this.data = new K(this);
          return this.data.get(R);
        }, setInteractive: function() {
          return this;
        }, disableInteractive: function() {
          return this;
        }, removeInteractive: function() {
          return this;
        }, addedToScene: function() {
        }, removedFromScene: function() {
        }, update: function() {
        }, toJSON: function() {
          return U(this);
        }, willRender: function(R) {
          return !(this.renderFlags !== 15 || this.list.length === 0 || this.cameraFilter !== 0 && this.cameraFilter & R.id);
        }, getIndexList: function() {
          var R = this, Y = this.parentContainer, I = [];
          while (Y)
            if (I.unshift(Y.getIndex(R)), R = Y, !Y.parentContainer)
              break;
            else
              Y = Y.parentContainer;
          return I.unshift(this.displayList.getIndex(R)), I;
        }, addChildCallback: function(R) {
          var Y = R.displayList;
          if (Y && Y !== this)
            R.removeFromDisplayList();
          if (!R.displayList)
            this.queueDepthSort(), R.displayList = this, R.emit(Z.ADDED_TO_SCENE, R, this.scene), this.events.emit(H.ADDED_TO_SCENE, R, this.scene);
        }, removeChildCallback: function(R) {
          this.queueDepthSort(), R.displayList = null, R.emit(Z.REMOVED_FROM_SCENE, R, this.scene), this.events.emit(H.REMOVED_FROM_SCENE, R, this.scene);
        }, queueDepthSort: function() {
          this.sortChildrenFlag = true;
        }, depthSort: function() {
          if (this.sortChildrenFlag)
            N(this.list, this.sortByDepth), this.sortChildrenFlag = false;
        }, sortByDepth: function(R, Y) {
          return R._depth - Y._depth;
        }, getChildren: function() {
          return this.list;
        }, addToDisplayList: function(R) {
          if (R === undefined)
            R = this.scene.sys.displayList;
          if (this.displayList && this.displayList !== R)
            this.removeFromDisplayList();
          if (!R.exists(this))
            this.displayList = R, R.add(this, true), R.queueDepthSort(), this.emit(Z.ADDED_TO_SCENE, this, this.scene), R.events.emit(H.ADDED_TO_SCENE, this, this.scene);
          return this;
        }, removeFromDisplayList: function() {
          var R = this.displayList || this.scene.sys.displayList;
          if (R.exists(this))
            R.remove(this, true), R.queueDepthSort(), this.displayList = null, this.emit(Z.REMOVED_FROM_SCENE, this, this.scene), R.events.emit(H.REMOVED_FROM_SCENE, this, this.scene);
          return this;
        }, destroy: function(R) {
          if (!this.scene || this.ignoreDestroy)
            return;
          this.emit(Z.DESTROY, this);
          var Y = this.list;
          while (Y.length)
            Y[0].destroy(R);
          if (this.removeAllListeners(), this.resetPostPipeline(true), this.displayList)
            this.displayList.remove(this, true, false), this.displayList.queueDepthSort();
          if (this.data)
            this.data.destroy(), this.data = undefined;
          this.active = false, this.visible = false, this.list = undefined, this.scene = undefined, this.displayList = undefined, this.systems = undefined, this.events = undefined;
        } });
        M.exports = W;
      }, 2956: (M) => {
        var B = function($, E, L) {
          var z = E.list;
          if (z.length === 0)
            return;
          E.depthSort();
          var U = E.blendMode !== -1;
          if (!U)
            $.setBlendMode(0);
          var K = E._alpha;
          if (E.mask)
            E.mask.preRenderCanvas($, null, L);
          for (var J = 0;J < z.length; J++) {
            var Z = z[J];
            if (!Z.willRender(L))
              continue;
            var D = Z.alpha;
            if (!U && Z.blendMode !== $.currentBlendMode)
              $.setBlendMode(Z.blendMode);
            Z.setAlpha(D * K), Z.renderCanvas($, Z, L), Z.setAlpha(D);
          }
          if (E.mask)
            E.mask.postRenderCanvas($);
        };
        M.exports = B;
      }, 25179: (M, B, $) => {
        var E = $(25305), L = $(93595), z = $(44603), U = $(23568);
        z.register("layer", function(K, J) {
          if (K === undefined)
            K = {};
          var Z = U(K, "children", null), D = new L(this.scene, Z);
          if (J !== undefined)
            K.add = J;
          return E(this.scene, D, K), D;
        });
      }, 20005: (M, B, $) => {
        var E = $(93595), L = $(39429);
        L.register("layer", function(z) {
          return this.displayList.add(new E(this.scene, z));
        });
      }, 33963: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(15869), z = $(2956), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 15869: (M) => {
        var B = function($, E, L) {
          var z = E.list, U = z.length;
          if (U === 0)
            return;
          E.depthSort(), $.pipelines.preBatch(E);
          var K = E.blendMode !== -1;
          if (!K)
            $.setBlendMode(0);
          var J = E.alpha;
          for (var Z = 0;Z < U; Z++) {
            var D = z[Z];
            if (!D.willRender(L))
              continue;
            var Q, H, N, W;
            if (D.alphaTopLeft !== undefined)
              Q = D.alphaTopLeft, H = D.alphaTopRight, N = D.alphaBottomLeft, W = D.alphaBottomRight;
            else {
              var R = D.alpha;
              Q = R, H = R, N = R, W = R;
            }
            if (!K && D.blendMode !== $.currentBlendMode)
              $.setBlendMode(D.blendMode);
            var Y = D.mask;
            if (Y)
              Y.preRenderWebGL($, D, L);
            var I = D.type;
            if (I !== $.currentType)
              $.newType = true, $.currentType = I;
            if ($.nextTypeMatch = Z < U - 1 ? z[Z + 1].type === $.currentType : false, D.setAlpha(Q * J, H * J, N * J, W * J), D.renderWebGL($, D, L), D.setAlpha(Q, H, N, W), Y)
              Y.postRenderWebGL($, L);
            $.newType = false;
          }
          $.pipelines.postBatch(E);
        };
        M.exports = B;
      }, 41432: (M, B, $) => {
        var E = $(96503), L = $(83419), z = $(31401), U = $(51767), K = $(70554), J = new L({ Extends: E, Mixins: [z.Origin, z.ScrollFactor, z.Visible], initialize: function Z(D, Q, H, N, W, R, Y) {
          E.call(this, D, Q, H), this.color = new U(N, W, R), this.intensity = Y, this.renderFlags = 15, this.cameraFilter = 0, this.setScrollFactor(1, 1), this.setOrigin(), this.setDisplayOrigin(H);
        }, displayWidth: { get: function() {
          return this.diameter;
        }, set: function(Z) {
          this.diameter = Z;
        } }, displayHeight: { get: function() {
          return this.diameter;
        }, set: function(Z) {
          this.diameter = Z;
        } }, width: { get: function() {
          return this.diameter;
        }, set: function(Z) {
          this.diameter = Z;
        } }, height: { get: function() {
          return this.diameter;
        }, set: function(Z) {
          this.diameter = Z;
        } }, willRender: function(Z) {
          return !(J.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & Z.id);
        }, setColor: function(Z) {
          var D = K.getFloatsFromUintRGB(Z);
          return this.color.set(D[0], D[1], D[2]), this;
        }, setIntensity: function(Z) {
          return this.intensity = Z, this;
        }, setRadius: function(Z) {
          return this.radius = Z, this;
        } });
        J.RENDER_MASK = 15, M.exports = J;
      }, 61356: (M, B, $) => {
        var E = $(81491), L = $(83419), z = $(20339), U = $(41432), K = $(80321), J = $(51767), Z = $(19133), D = $(19186), Q = $(70554), H = new L({ initialize: function N() {
          this.lights = [], this.ambientColor = new J(0.1, 0.1, 0.1), this.active = false, this.maxLights = -1, this.visibleLights = 0;
        }, addPointLight: function(N, W, R, Y, I, P) {
          return this.systems.displayList.add(new K(this.scene, N, W, R, Y, I, P));
        }, enable: function() {
          if (this.maxLights === -1)
            this.maxLights = this.systems.renderer.config.maxLights;
          return this.active = true, this;
        }, disable: function() {
          return this.active = false, this;
        }, getLights: function(N) {
          var W = this.lights, R = N.worldView, Y = [];
          for (var I = 0;I < W.length; I++) {
            var P = W[I];
            if (P.willRender(N) && E(P, R))
              Y.push({ light: P, distance: z(P.x, P.y, R.centerX, R.centerY) });
          }
          if (Y.length > this.maxLights)
            D(Y, this.sortByDistance), Y = Y.slice(0, this.maxLights);
          return this.visibleLights = Y.length, Y;
        }, sortByDistance: function(N, W) {
          return N.distance >= W.distance;
        }, setAmbientColor: function(N) {
          var W = Q.getFloatsFromUintRGB(N);
          return this.ambientColor.set(W[0], W[1], W[2]), this;
        }, getMaxVisibleLights: function() {
          return this.maxLights;
        }, getLightCount: function() {
          return this.lights.length;
        }, addLight: function(N, W, R, Y, I) {
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = 0;
          if (R === undefined)
            R = 128;
          if (Y === undefined)
            Y = 16777215;
          if (I === undefined)
            I = 1;
          var P = Q.getFloatsFromUintRGB(Y), X = new U(N, W, R, P[0], P[1], P[2], I);
          return this.lights.push(X), X;
        }, removeLight: function(N) {
          var W = this.lights.indexOf(N);
          if (W >= 0)
            Z(this.lights, W);
          return this;
        }, shutdown: function() {
          this.lights.length = 0;
        }, destroy: function() {
          this.shutdown();
        } });
        M.exports = H;
      }, 88992: (M, B, $) => {
        var E = $(83419), L = $(61356), z = $(37277), U = $(44594), K = new E({ Extends: L, initialize: function J(Z) {
          if (this.scene = Z, this.systems = Z.sys, !Z.sys.settings.isBooted)
            Z.sys.events.once(U.BOOT, this.boot, this);
          L.call(this);
        }, boot: function() {
          var J = this.systems.events;
          J.on(U.SHUTDOWN, this.shutdown, this), J.on(U.DESTROY, this.destroy, this);
        }, destroy: function() {
          this.shutdown(), this.scene = undefined, this.systems = undefined;
        } });
        z.register("LightsPlugin", K, "lights"), M.exports = K;
      }, 4703: (M, B, $) => {
        var E = $(83419), L = $(31401), z = $(39506), U = $(83997), K = $(95643), J = $(34684), Z = $(92515), D = $(91296), Q = $(37867), H = $(29807), N = $(43396), W = $(19186), R = $(25836), Y = $(39318), I = new E({ Extends: K, Mixins: [L.AlphaSingle, L.BlendMode, L.Depth, L.Mask, L.Pipeline, L.PostPipeline, L.ScrollFactor, L.Size, L.Texture, L.Transform, L.Visible, H], initialize: function P(X, G, V, A, F, j, T, C, v, O, q, w) {
          if (G === undefined)
            G = 0;
          if (V === undefined)
            V = 0;
          if (A === undefined)
            A = "__WHITE";
          K.call(this, X, "Mesh"), this.faces = [], this.vertices = [], this.tintFill = false, this.debugCallback = null, this.debugGraphic = null, this.hideCCW = true, this.modelPosition = new R, this.modelScale = new R(1, 1, 1), this.modelRotation = new R, this.dirtyCache = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.transformMatrix = new Q, this.viewPosition = new R, this.viewMatrix = new Q, this.projectionMatrix = new Q, this.totalRendered = 0, this.totalFrame = 0, this.ignoreDirtyCache = false, this.fov, this.displayOriginX = 0, this.displayOriginY = 0;
          var g = X.sys.renderer;
          if (this.setPosition(G, V), this.setTexture(A, F), this.setSize(g.width, g.height), this.initPipeline(), this.initPostPipeline(), this.setPerspective(g.width, g.height), j)
            this.addVertices(j, T, C, v, O, q, w);
        }, addedToScene: function() {
          this.scene.sys.updateList.add(this);
        }, removedFromScene: function() {
          this.scene.sys.updateList.remove(this);
        }, panX: function(P) {
          return this.viewPosition.addScale(R.LEFT, P), this.dirtyCache[10] = 1, this;
        }, panY: function(P) {
          return this.viewPosition.y += R.DOWN.y * P, this.dirtyCache[10] = 1, this;
        }, panZ: function(P) {
          return this.viewPosition.z += P, this.dirtyCache[10] = 1, this;
        }, setPerspective: function(P, X, G, V, A) {
          if (G === undefined)
            G = 45;
          if (V === undefined)
            V = 0.01;
          if (A === undefined)
            A = 1000;
          return this.fov = G, this.projectionMatrix.perspective(z(G), P / X, V, A), this.dirtyCache[10] = 1, this.dirtyCache[11] = 0, this;
        }, setOrtho: function(P, X, G, V) {
          if (P === undefined)
            P = this.scene.sys.renderer.getAspectRatio();
          if (X === undefined)
            X = 1;
          if (G === undefined)
            G = -1000;
          if (V === undefined)
            V = 1000;
          return this.fov = 0, this.projectionMatrix.ortho(-P, P, -X, X, G, V), this.dirtyCache[10] = 1, this.dirtyCache[11] = 1, this;
        }, clear: function() {
          return this.faces.forEach(function(P) {
            P.destroy();
          }), this.faces = [], this.vertices = [], this;
        }, addVerticesFromObj: function(P, X, G, V, A, F, j, T, C) {
          var v = this.scene.sys.cache.obj.get(P), O;
          if (v)
            O = J(v, this, X, G, V, A, F, j, T, C);
          if (!O || O.verts.length === 0)
            console.warn("Mesh.addVerticesFromObj data empty:", P);
          return this;
        }, sortByDepth: function(P, X) {
          return P.depth - X.depth;
        }, depthSort: function() {
          return W(this.faces, this.sortByDepth), this;
        }, addVertex: function(P, X, G, V, A, F, j) {
          var T = new Y(P, X, G, V, A, F, j);
          return this.vertices.push(T), T;
        }, addFace: function(P, X, G) {
          var V = new U(P, X, G);
          return this.faces.push(V), this.dirtyCache[9] = -1, V;
        }, addVertices: function(P, X, G, V, A, F, j) {
          var T = Z(P, X, G, V, A, F, j);
          if (T)
            this.faces = this.faces.concat(T.faces), this.vertices = this.vertices.concat(T.vertices);
          else
            console.warn("Mesh.addVertices data empty or invalid");
          return this.dirtyCache[9] = -1, this;
        }, getFaceCount: function() {
          return this.faces.length;
        }, getVertexCount: function() {
          return this.vertices.length;
        }, getFace: function(P) {
          return this.faces[P];
        }, hasFaceAt: function(P, X, G) {
          if (G === undefined)
            G = this.scene.sys.cameras.main;
          var V = D(this, G).calc, A = this.faces;
          for (var F = 0;F < A.length; F++) {
            var j = A[F];
            if (j.contains(P, X, V))
              return true;
          }
          return false;
        }, getFaceAt: function(P, X, G) {
          if (G === undefined)
            G = this.scene.sys.cameras.main;
          var V = D(this, G).calc, A = this.faces, F = [];
          for (var j = 0;j < A.length; j++) {
            var T = A[j];
            if (T.contains(P, X, V))
              F.push(T);
          }
          return W(F, this.sortByDepth);
        }, setDebug: function(P, X) {
          if (this.debugGraphic = P, !P && !X)
            this.debugCallback = null;
          else if (!X)
            this.debugCallback = this.renderDebug;
          else
            this.debugCallback = X;
          return this;
        }, isDirty: function() {
          var P = this.modelPosition, X = this.modelRotation, G = this.modelScale, V = this.dirtyCache, A = P.x, F = P.y, j = P.z, T = X.x, C = X.y, v = X.z, O = G.x, q = G.y, w = G.z, g = this.getFaceCount(), b = V[0], x = V[1], k = V[2], S = V[3], f = V[4], h = V[5], m = V[6], y = V[7], d = V[8], p = V[9];
          return V[0] = A, V[1] = F, V[2] = j, V[3] = T, V[4] = C, V[5] = v, V[6] = O, V[7] = q, V[8] = w, V[9] = g, b !== A || x !== F || k !== j || S !== T || f !== C || h !== v || m !== O || y !== q || d !== w || p !== g;
        }, preUpdate: function() {
          this.totalRendered = this.totalFrame, this.totalFrame = 0;
          var P = this.dirtyCache;
          if (!this.ignoreDirtyCache && !P[10] && !this.isDirty())
            return;
          var X = this.width, G = this.height, V = this.viewMatrix, A = this.viewPosition;
          if (P[10])
            V.identity(), V.translate(A), V.invert(), P[10] = 0;
          var F = this.transformMatrix;
          F.setWorldMatrix(this.modelRotation, this.modelPosition, this.modelScale, this.viewMatrix, this.projectionMatrix);
          var j = A.z, T = this.faces;
          for (var C = 0;C < T.length; C++)
            T[C].transformCoordinatesLocal(F, X, G, j);
          this.depthSort();
        }, renderDebug: function(P, X) {
          var G = P.debugGraphic;
          for (var V = 0;V < X.length; V++) {
            var A = X[V], F = A.vertex1.tx, j = A.vertex1.ty, T = A.vertex2.tx, C = A.vertex2.ty, v = A.vertex3.tx, O = A.vertex3.ty;
            G.strokeTriangle(F, j, T, C, v, O);
          }
        }, preDestroy: function() {
          this.clear(), this.debugCallback = null, this.debugGraphic = null;
        }, clearTint: function() {
          return this.setTint();
        }, setInteractive: function(P) {
          if (P === undefined)
            P = {};
          var X = function(G, V, A) {
            var F = this.faces;
            for (var j = 0;j < F.length; j++) {
              var T = F[j];
              if (T.contains(V, A))
                return true;
            }
            return false;
          }.bind(this);
          return this.scene.sys.input.enable(this, P, X), this;
        }, setTint: function(P) {
          if (P === undefined)
            P = 16777215;
          var X = this.vertices;
          for (var G = 0;G < X.length; G++)
            X[G].color = P;
          return this;
        }, uvScroll: function(P, X) {
          var G = this.faces;
          for (var V = 0;V < G.length; V++)
            G[V].scrollUV(P, X);
          return this;
        }, uvScale: function(P, X) {
          var G = this.faces;
          for (var V = 0;V < G.length; V++)
            G[V].scaleUV(P, X);
          return this;
        }, tint: { set: function(P) {
          this.setTint(P);
        } }, rotateX: { get: function() {
          return N(this.modelRotation.x);
        }, set: function(P) {
          this.modelRotation.x = z(P);
        } }, rotateY: { get: function() {
          return N(this.modelRotation.y);
        }, set: function(P) {
          this.modelRotation.y = z(P);
        } }, rotateZ: { get: function() {
          return N(this.modelRotation.z);
        }, set: function(P) {
          this.modelRotation.z = z(P);
        } } });
        M.exports = I;
      }, 36488: (M) => {
        var B = function() {
        };
        M.exports = B;
      }, 20527: (M, B, $) => {
        var E = $(25305), L = $(44603), z = $(23568), U = $(35154), K = $(4703);
        L.register("mesh", function(J, Z) {
          if (J === undefined)
            J = {};
          var D = z(J, "key", null), Q = z(J, "frame", null), H = U(J, "vertices", []), N = U(J, "uvs", []), W = U(J, "indicies", []), R = U(J, "containsZ", false), Y = U(J, "normals", []), I = U(J, "colors", 16777215), P = U(J, "alphas", 1), X = new K(this.scene, 0, 0, D, Q, H, N, W, R, Y, I, P);
          if (Z !== undefined)
            J.add = Z;
          return E(this.scene, X, J), X;
        });
      }, 9225: (M, B, $) => {
        var E = $(4703), L = $(39429);
        L.register("mesh", function(z, U, K, J, Z, D, Q, H, N, W, R) {
          return this.displayList.add(new E(this.scene, z, U, K, J, Z, D, Q, H, N, W, R));
        });
      }, 29807: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(48833), z = $(36488), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 48833: (M, B, $) => {
        var E = $(91296), L = function(z, U, K, J) {
          var Z = U.faces, D = Z.length;
          if (D === 0)
            return;
          K.addToRenderList(U);
          var Q = z.pipelines.set(U.pipeline, U), H = E(U, K, J).calc;
          z.pipelines.preBatch(U);
          var N = Q.setGameObject(U), W = Q.vertexViewF32, R = Q.vertexViewU32, Y = Q.vertexCount * Q.currentShader.vertexComponentCount - 1, I = U.tintFill, P = [], X = U.debugCallback, G = H.a, V = H.b, A = H.c, F = H.d, j = H.e, T = H.f, C = U.viewPosition.z, v = U.hideCCW, O = K.roundPixels, q = K.alpha * U.alpha, w = 0;
          for (var g = 0;g < D; g++) {
            var b = Z[g];
            if (!b.isInView(K, v, C, q, G, V, A, F, j, T, O))
              continue;
            if (Q.shouldFlush(3))
              Q.flush(), N = Q.setGameObject(U), Y = 0;
            if (Y = b.load(W, R, Y, N, I), w++, Q.vertexCount += 3, Q.currentBatch.count = Q.vertexCount - Q.currentBatch.start, X)
              P.push(b);
          }
          if (U.totalFrame += w, X)
            X.call(U, U, P);
          z.pipelines.postBatch(U);
        };
        M.exports = L;
      }, 28103: (M, B, $) => {
        var E = $(83419), L = $(31401), z = $(95643), U = $(78023), K = $(39318), J = new E({ Extends: z, Mixins: [L.AlphaSingle, L.BlendMode, L.Depth, L.GetBounds, L.Mask, L.Origin, L.Pipeline, L.PostPipeline, L.ScrollFactor, L.Texture, L.Transform, L.Visible, U], initialize: function Z(D, Q, H, N, W, R, Y, I, P, X, G) {
          z.call(this, D, "NineSlice"), this._width, this._height, this._originX = 0.5, this._originY = 0.5, this._sizeComponent = true, this.vertices = [], this.leftWidth, this.rightWidth, this.topHeight, this.bottomHeight, this.tint = 16777215, this.tintFill = false;
          var V = D.textures.getFrame(N, W);
          if (this.is3Slice = !X && !G, V.scale9)
            this.is3Slice = V.is3Slice;
          var A = this.is3Slice ? 18 : 54;
          for (var F = 0;F < A; F++)
            this.vertices.push(new K);
          this.setPosition(Q, H), this.setTexture(N, W), this.setSlices(R, Y, I, P, X, G, false), this.updateDisplayOrigin(), this.initPipeline(), this.initPostPipeline();
        }, setSlices: function(Z, D, Q, H, N, W, R) {
          if (Q === undefined)
            Q = 10;
          if (H === undefined)
            H = 10;
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = 0;
          if (R === undefined)
            R = false;
          var Y = this.frame, I = false;
          if (this.is3Slice && R && N !== 0 && W !== 0)
            I = true;
          if (I)
            console.warn("Cannot change 9 slice to 3 slice");
          else {
            if (Y.scale9 && !R) {
              var P = Y.data.scale9Borders, X = P.x, G = P.y;
              if (Q = X, H = Y.width - P.w - X, N = G, W = Y.height - P.h - G, Z === undefined)
                Z = Y.width;
              if (D === undefined)
                D = Y.height;
            } else {
              if (Z === undefined)
                Z = 256;
              if (D === undefined)
                D = 256;
            }
            if (this._width = Z, this._height = D, this.leftWidth = Q, this.rightWidth = H, this.topHeight = N, this.bottomHeight = W, this.is3Slice)
              D = Y.height, this._height = D, this.topHeight = D, this.bottomHeight = 0;
            this.updateVertices(), this.updateUVs();
          }
          return this;
        }, updateUVs: function() {
          var Z = this.leftWidth, D = this.rightWidth, Q = this.topHeight, H = this.bottomHeight, N = this.frame.width, W = this.frame.height;
          if (this.updateQuadUVs(0, 0, 0, Z / N, Q / W), this.updateQuadUVs(6, Z / N, 0, 1 - D / N, Q / W), this.updateQuadUVs(12, 1 - D / N, 0, 1, Q / W), !this.is3Slice)
            this.updateQuadUVs(18, 0, Q / W, Z / N, 1 - H / W), this.updateQuadUVs(24, Z / N, Q / W, 1 - D / N, 1 - H / W), this.updateQuadUVs(30, 1 - D / N, Q / W, 1, 1 - H / W), this.updateQuadUVs(36, 0, 1 - H / W, Z / N, 1), this.updateQuadUVs(42, Z / N, 1 - H / W, 1 - D / N, 1), this.updateQuadUVs(48, 1 - D / N, 1 - H / W, 1, 1);
        }, updateVertices: function() {
          var Z = this.leftWidth, D = this.rightWidth, Q = this.topHeight, H = this.bottomHeight, N = this.width, W = this.height;
          if (this.updateQuad(0, -0.5, 0.5, -0.5 + Z / N, 0.5 - Q / W), this.updateQuad(6, -0.5 + Z / N, 0.5, 0.5 - D / N, 0.5 - Q / W), this.updateQuad(12, 0.5 - D / N, 0.5, 0.5, 0.5 - Q / W), !this.is3Slice)
            this.updateQuad(18, -0.5, 0.5 - Q / W, -0.5 + Z / N, -0.5 + H / W), this.updateQuad(24, -0.5 + Z / N, 0.5 - Q / W, 0.5 - D / N, -0.5 + H / W), this.updateQuad(30, 0.5 - D / N, 0.5 - Q / W, 0.5, -0.5 + H / W), this.updateQuad(36, -0.5, -0.5 + H / W, -0.5 + Z / N, -0.5), this.updateQuad(42, -0.5 + Z / N, -0.5 + H / W, 0.5 - D / N, -0.5), this.updateQuad(48, 0.5 - D / N, -0.5 + H / W, 0.5, -0.5);
        }, updateQuad: function(Z, D, Q, H, N) {
          var W = this.width, R = this.height, Y = this.originX, I = this.originY, P = this.vertices;
          P[Z + 0].resize(D, Q, W, R, Y, I), P[Z + 1].resize(D, N, W, R, Y, I), P[Z + 2].resize(H, Q, W, R, Y, I), P[Z + 3].resize(D, N, W, R, Y, I), P[Z + 4].resize(H, N, W, R, Y, I), P[Z + 5].resize(H, Q, W, R, Y, I);
        }, updateQuadUVs: function(Z, D, Q, H, N) {
          var W = this.vertices, R = this.frame, Y = R.u0, I = R.v0, P = R.u1, X = R.v1;
          if (Y !== 0 || P !== 1) {
            var G = P - Y;
            D = Y + D * G, H = Y + H * G;
          }
          if (I !== 0 || X !== 1) {
            var V = X - I;
            Q = I + Q * V, N = I + N * V;
          }
          W[Z + 0].setUVs(D, Q), W[Z + 1].setUVs(D, N), W[Z + 2].setUVs(H, Q), W[Z + 3].setUVs(D, N), W[Z + 4].setUVs(H, N), W[Z + 5].setUVs(H, Q);
        }, clearTint: function() {
          return this.setTint(16777215), this;
        }, setTint: function(Z) {
          if (Z === undefined)
            Z = 16777215;
          return this.tint = Z, this.tintFill = false, this;
        }, setTintFill: function(Z) {
          return this.setTint(Z), this.tintFill = true, this;
        }, isTinted: { get: function() {
          return this.tint !== 16777215;
        } }, width: { get: function() {
          return this._width;
        }, set: function(Z) {
          this._width = Math.max(Z, this.leftWidth + this.rightWidth), this.updateVertices();
        } }, height: { get: function() {
          return this._height;
        }, set: function(Z) {
          if (!this.is3Slice)
            this._height = Math.max(Z, this.topHeight + this.bottomHeight), this.updateVertices();
        } }, displayWidth: { get: function() {
          return this.scaleX * this.width;
        }, set: function(Z) {
          this.scaleX = Z / this.width;
        } }, displayHeight: { get: function() {
          return this.scaleY * this.height;
        }, set: function(Z) {
          this.scaleY = Z / this.height;
        } }, setSize: function(Z, D) {
          this.width = Z, this.height = D, this.updateDisplayOrigin();
          var Q = this.input;
          if (Q && !Q.customHitArea)
            Q.hitArea.width = this.width, Q.hitArea.height = this.height;
          return this;
        }, setDisplaySize: function(Z, D) {
          return this.displayWidth = Z, this.displayHeight = D, this;
        }, originX: { get: function() {
          return this._originX;
        }, set: function(Z) {
          this._originX = Z, this.updateVertices();
        } }, originY: { get: function() {
          return this._originY;
        }, set: function(Z) {
          this._originY = Z, this.updateVertices();
        } }, setOrigin: function(Z, D) {
          if (Z === undefined)
            Z = 0.5;
          if (D === undefined)
            D = Z;
          return this._originX = Z, this._originY = D, this.updateVertices(), this.updateDisplayOrigin();
        }, setSizeToFrame: function() {
          if (this.is3Slice) {
            var Z = this.frame.height;
            this._height = Z, this.topHeight = Z, this.bottomHeight = 0;
          }
          return this.updateUVs(), this;
        }, preDestroy: function() {
          this.vertices = [];
        } });
        M.exports = J;
      }, 28279: (M, B, $) => {
        var E = $(25305), L = $(44603), z = $(23568), U = $(35154), K = $(28103);
        L.register("nineslice", function(J, Z) {
          if (J === undefined)
            J = {};
          var D = z(J, "key", null), Q = z(J, "frame", null), H = U(J, "width", 256), N = U(J, "height", 256), W = U(J, "leftWidth", 10), R = U(J, "rightWidth", 10), Y = U(J, "topHeight", 0), I = U(J, "bottomHeight", 0), P = new K(this.scene, 0, 0, D, Q, H, N, W, R, Y, I);
          if (Z !== undefined)
            J.add = Z;
          return E(this.scene, P, J), P;
        });
      }, 47521: (M, B, $) => {
        var E = $(28103), L = $(39429);
        L.register("nineslice", function(z, U, K, J, Z, D, Q, H, N, W) {
          return this.displayList.add(new E(this.scene, z, U, K, J, Z, D, Q, H, N, W));
        });
      }, 78023: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(52230), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 52230: (M, B, $) => {
        var E = $(91296), L = $(70554), z = function(U, K, J, Z) {
          var D = K.vertices, Q = D.length;
          if (Q === 0)
            return;
          J.addToRenderList(K);
          var H = U.pipelines.set(K.pipeline, K), N = E(K, J, Z, false).calc;
          U.pipelines.preBatch(K);
          var W = H.setGameObject(K), R = H.vertexViewF32, Y = H.vertexViewU32, I = H.vertexCount * H.currentShader.vertexComponentCount - 1, P = J.roundPixels, X = K.tintFill, G = J.alpha * K.alpha, V = L.getTintAppendFloatAlpha(K.tint, G), A = H.vertexAvailable(), F = -1;
          if (A < Q)
            F = A;
          for (var j = 0;j < Q; j++) {
            var T = D[j];
            if (j === F)
              H.flush(), W = H.setGameObject(K), I = 0;
            R[++I] = N.getXRound(T.vx, T.vy, P), R[++I] = N.getYRound(T.vx, T.vy, P), R[++I] = T.u, R[++I] = T.v, R[++I] = W, R[++I] = X, Y[++I] = V, H.vertexCount++, H.currentBatch.count = H.vertexCount - H.currentBatch.start;
          }
          U.pipelines.postBatch(K);
        };
        M.exports = z;
      }, 76472: (M, B, $) => {
        var E = $(83419), L = $(44777), z = $(37589), U = $(6113), K = $(91389), J = $(90664), Z = new E({ Extends: L, initialize: function D(Q) {
          L.call(this, Q, null, false), this.active = false, this.easeName = "Linear", this.r = [], this.g = [], this.b = [];
        }, getMethod: function() {
          return this.propertyValue === null ? 0 : 9;
        }, setMethods: function() {
          var D = this.propertyValue, Q = D, H = this.defaultEmit, N = this.defaultUpdate;
          if (this.method === 9) {
            this.start = D[0], this.ease = U("Linear"), this.interpolation = K("linear"), H = this.easedValueEmit, N = this.easeValueUpdate, Q = D[0], this.active = true;
            for (var W = 0;W < D.length; W++) {
              var R = J(D[W]);
              this.r.push(R.r), this.g.push(R.g), this.b.push(R.b);
            }
          }
          return this.onEmit = H, this.onUpdate = N, this.current = Q, this;
        }, setEase: function(D) {
          this.easeName = D, this.ease = U(D);
        }, easedValueEmit: function() {
          return this.current = this.start, this.start;
        }, easeValueUpdate: function(D, Q, H) {
          var N = this.ease(H), W = this.interpolation(this.r, N), R = this.interpolation(this.g, N), Y = this.interpolation(this.b, N), I = z(W, R, Y);
          return this.current = I, I;
        } });
        M.exports = Z;
      }, 44777: (M, B, $) => {
        var E = $(30976), L = $(45319), z = $(83419), U = $(99472), K = $(6113), J = $(95540), Z = $(91389), D = $(77720), Q = $(15994), H = new z({ initialize: function N(W, R, Y) {
          if (Y === undefined)
            Y = false;
          this.propertyKey = W, this.propertyValue = R, this.defaultValue = R, this.steps = 0, this.counter = 0, this.yoyo = false, this.direction = 0, this.start = 0, this.current = 0, this.end = 0, this.ease = null, this.interpolation = null, this.emitOnly = Y, this.onEmit = this.defaultEmit, this.onUpdate = this.defaultUpdate, this.active = true, this.method = 0, this._onEmit, this._onUpdate;
        }, loadConfig: function(N, W) {
          if (N === undefined)
            N = {};
          if (W)
            this.propertyKey = W;
          if (this.propertyValue = J(N, this.propertyKey, this.defaultValue), this.method = this.getMethod(), this.setMethods(), this.emitOnly)
            this.onUpdate = this.defaultUpdate;
        }, toJSON: function() {
          return JSON.stringify(this.propertyValue);
        }, onChange: function(N) {
          var W;
          switch (this.method) {
            case 1:
            case 3:
            case 8:
              W = N;
              break;
            case 2:
              if (this.propertyValue.indexOf(N) >= 0)
                W = N;
              break;
            case 4:
              var R = (this.end - this.start) / this.steps;
              W = D(N, R), this.counter = W;
              break;
            case 5:
            case 6:
            case 7:
              W = L(N, this.start, this.end);
              break;
            case 9:
              W = this.start[0];
              break;
          }
          return this.current = W, this;
        }, getMethod: function() {
          var N = this.propertyValue;
          if (N === null)
            return 0;
          var W = typeof N;
          if (W === "number")
            return 1;
          else if (Array.isArray(N))
            return 2;
          else if (W === "function")
            return 3;
          else if (W === "object") {
            if (this.hasBoth(N, "start", "end"))
              if (this.has(N, "steps"))
                return 4;
              else
                return 5;
            else if (this.hasBoth(N, "min", "max"))
              return 6;
            else if (this.has(N, "random"))
              return 7;
            else if (this.hasEither(N, "onEmit", "onUpdate"))
              return 8;
            else if (this.hasEither(N, "values", "interpolation"))
              return 9;
          }
          return 0;
        }, setMethods: function() {
          var N = this.propertyValue, W = N, R = this.defaultEmit, Y = this.defaultUpdate;
          switch (this.method) {
            case 1:
              R = this.staticValueEmit;
              break;
            case 2:
              R = this.randomStaticValueEmit, W = N[0];
              break;
            case 3:
              this._onEmit = N, R = this.proxyEmit;
              break;
            case 4:
              this.start = N.start, this.end = N.end, this.steps = N.steps, this.counter = this.start, this.yoyo = this.has(N, "yoyo") ? N.yoyo : false, this.direction = 0, R = this.steppedEmit, W = this.start;
              break;
            case 5:
              this.start = N.start, this.end = N.end;
              var I = this.has(N, "ease") ? N.ease : "Linear";
              this.ease = K(I, N.easeParams), R = this.has(N, "random") && N.random ? this.randomRangedValueEmit : this.easedValueEmit, Y = this.easeValueUpdate, W = this.start;
              break;
            case 6:
              this.start = N.min, this.end = N.max, R = this.has(N, "int") && N.int ? this.randomRangedIntEmit : this.randomRangedValueEmit, W = this.start;
              break;
            case 7:
              var P = N.random;
              if (Array.isArray(P))
                this.start = P[0], this.end = P[1];
              R = this.randomRangedIntEmit, W = this.start;
              break;
            case 8:
              this._onEmit = this.has(N, "onEmit") ? N.onEmit : this.defaultEmit, this._onUpdate = this.has(N, "onUpdate") ? N.onUpdate : this.defaultUpdate, R = this.proxyEmit, Y = this.proxyUpdate;
              break;
            case 9:
              this.start = N.values;
              var X = this.has(N, "ease") ? N.ease : "Linear";
              this.ease = K(X, N.easeParams), this.interpolation = Z(N.interpolation), R = this.easedValueEmit, Y = this.easeValueUpdate, W = this.start[0];
              break;
          }
          return this.onEmit = R, this.onUpdate = Y, this.current = W, this;
        }, has: function(N, W) {
          return N.hasOwnProperty(W);
        }, hasBoth: function(N, W, R) {
          return N.hasOwnProperty(W) && N.hasOwnProperty(R);
        }, hasEither: function(N, W, R) {
          return N.hasOwnProperty(W) || N.hasOwnProperty(R);
        }, defaultEmit: function(N, W, R) {
          return R;
        }, defaultUpdate: function(N, W, R, Y) {
          return Y;
        }, proxyEmit: function(N, W, R) {
          var Y = this._onEmit(N, W, R);
          return this.current = Y, Y;
        }, proxyUpdate: function(N, W, R, Y) {
          var I = this._onUpdate(N, W, R, Y);
          return this.current = I, I;
        }, staticValueEmit: function() {
          return this.current;
        }, staticValueUpdate: function() {
          return this.current;
        }, randomStaticValueEmit: function() {
          var N = Math.floor(Math.random() * this.propertyValue.length);
          return this.current = this.propertyValue[N], this.current;
        }, randomRangedValueEmit: function(N, W) {
          var R = U(this.start, this.end);
          if (N && N.data[W])
            N.data[W].min = R, N.data[W].max = this.end;
          return this.current = R, R;
        }, randomRangedIntEmit: function(N, W) {
          var R = E(this.start, this.end);
          if (N && N.data[W])
            N.data[W].min = R, N.data[W].max = this.end;
          return this.current = R, R;
        }, steppedEmit: function() {
          var N = this.counter, W = N, R = (this.end - this.start) / this.steps;
          if (this.yoyo) {
            var Y;
            if (this.direction === 0) {
              if (W += R, W >= this.end)
                Y = W - this.end, W = this.end - Y, this.direction = 1;
            } else if (W -= R, W <= this.start)
              Y = this.start - W, W = this.start + Y, this.direction = 0;
            this.counter = W;
          } else
            this.counter = Q(W + R, this.start, this.end);
          return this.current = N, N;
        }, easedValueEmit: function(N, W) {
          if (N && N.data[W]) {
            var R = N.data[W];
            R.min = this.start, R.max = this.end;
          }
          return this.current = this.start, this.start;
        }, easeValueUpdate: function(N, W, R) {
          var Y = N.data[W], I, P = this.ease(R);
          if (this.interpolation)
            I = this.interpolation(this.start, P);
          else
            I = (Y.max - Y.min) * P + Y.min;
          return this.current = I, I;
        }, destroy: function() {
          this.propertyValue = null, this.defaultValue = null, this.ease = null, this.interpolation = null, this._onEmit = null, this._onUpdate = null;
        } });
        M.exports = H;
      }, 24502: (M, B, $) => {
        var E = $(83419), L = $(95540), z = $(20286), U = new E({ Extends: z, initialize: function K(J, Z, D, Q, H) {
          if (typeof J === "object") {
            var N = J;
            J = L(N, "x", 0), Z = L(N, "y", 0), D = L(N, "power", 0), Q = L(N, "epsilon", 100), H = L(N, "gravity", 50);
          } else {
            if (J === undefined)
              J = 0;
            if (Z === undefined)
              Z = 0;
            if (D === undefined)
              D = 0;
            if (Q === undefined)
              Q = 100;
            if (H === undefined)
              H = 50;
          }
          z.call(this, J, Z, true), this._gravity = H, this._power = D * H, this._epsilon = Q * Q;
        }, update: function(K, J) {
          var Z = this.x - K.x, D = this.y - K.y, Q = Z * Z + D * D;
          if (Q === 0)
            return;
          var H = Math.sqrt(Q);
          if (Q < this._epsilon)
            Q = this._epsilon;
          var N = this._power * J / (Q * H) * 100;
          K.velocityX += Z * N, K.velocityY += D * N;
        }, epsilon: { get: function() {
          return Math.sqrt(this._epsilon);
        }, set: function(K) {
          this._epsilon = K * K;
        } }, power: { get: function() {
          return this._power / this._gravity;
        }, set: function(K) {
          this._power = K * this._gravity;
        } }, gravity: { get: function() {
          return this._gravity;
        }, set: function(K) {
          var J = this.power;
          this._gravity = K, this.power = J;
        } } });
        M.exports = U;
      }, 56480: (M, B, $) => {
        var E = $(9674), L = $(45319), z = $(83419), U = $(39506), K = $(87841), J = $(11520), Z = $(26099), D = new z({ initialize: function Q(H) {
          this.emitter = H, this.texture = null, this.frame = null, this.x = 0, this.y = 0, this.worldPosition = new Z, this.velocityX = 0, this.velocityY = 0, this.accelerationX = 0, this.accelerationY = 0, this.maxVelocityX = 1e4, this.maxVelocityY = 1e4, this.bounce = 0, this.scaleX = 1, this.scaleY = 1, this.alpha = 1, this.angle = 0, this.rotation = 0, this.tint = 16777215, this.life = 1000, this.lifeCurrent = 1000, this.delayCurrent = 0, this.holdCurrent = 0, this.lifeT = 0, this.data = { tint: { min: 16777215, max: 16777215 }, alpha: { min: 1, max: 1 }, rotate: { min: 0, max: 0 }, scaleX: { min: 1, max: 1 }, scaleY: { min: 1, max: 1 }, x: { min: 0, max: 0 }, y: { min: 0, max: 0 }, accelerationX: { min: 0, max: 0 }, accelerationY: { min: 0, max: 0 }, maxVelocityX: { min: 0, max: 0 }, maxVelocityY: { min: 0, max: 0 }, moveToX: { min: 0, max: 0 }, moveToY: { min: 0, max: 0 }, bounce: { min: 0, max: 0 } }, this.isCropped = false, this.scene = H.scene, this.anims = new E(this), this.bounds = new K;
        }, emit: function(Q, H, N, W, R, Y) {
          return this.emitter.emit(Q, H, N, W, R, Y);
        }, isAlive: function() {
          return this.lifeCurrent > 0;
        }, kill: function() {
          this.lifeCurrent = 0;
        }, setPosition: function(Q, H) {
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 0;
          this.x = Q, this.y = H;
        }, fire: function(Q, H) {
          var N = this.emitter, W = N.ops, R = N.getAnim();
          if (R)
            this.anims.play(R);
          else
            this.frame = N.getFrame(), this.texture = this.frame.texture;
          if (!this.frame)
            throw new Error("Particle has no texture frame");
          if (N.getEmitZone(this), Q === undefined)
            this.x += W.x.onEmit(this, "x");
          else if (W.x.steps > 0)
            this.x += Q + W.x.onEmit(this, "x");
          else
            this.x += Q;
          if (H === undefined)
            this.y += W.y.onEmit(this, "y");
          else if (W.y.steps > 0)
            this.y += H + W.y.onEmit(this, "y");
          else
            this.y += H;
          if (this.life = W.lifespan.onEmit(this, "lifespan"), this.lifeCurrent = this.life, this.lifeT = 0, this.delayCurrent = W.delay.onEmit(this, "delay"), this.holdCurrent = W.hold.onEmit(this, "hold"), this.scaleX = W.scaleX.onEmit(this, "scaleX"), this.scaleY = W.scaleY.active ? W.scaleY.onEmit(this, "scaleY") : this.scaleX, this.angle = W.rotate.onEmit(this, "rotate"), this.rotation = U(this.angle), N.worldMatrix.transformPoint(this.x, this.y, this.worldPosition), this.delayCurrent === 0 && N.getDeathZone(this))
            return this.lifeCurrent = 0, false;
          var Y = W.speedX.onEmit(this, "speedX"), I = W.speedY.active ? W.speedY.onEmit(this, "speedY") : Y;
          if (N.radial) {
            var P = U(W.angle.onEmit(this, "angle"));
            this.velocityX = Math.cos(P) * Math.abs(Y), this.velocityY = Math.sin(P) * Math.abs(I);
          } else if (N.moveTo) {
            var X = W.moveToX.onEmit(this, "moveToX"), G = W.moveToY.onEmit(this, "moveToY"), V = this.life / 1000;
            this.velocityX = (X - this.x) / V, this.velocityY = (G - this.y) / V;
          } else
            this.velocityX = Y, this.velocityY = I;
          if (N.acceleration)
            this.accelerationX = W.accelerationX.onEmit(this, "accelerationX"), this.accelerationY = W.accelerationY.onEmit(this, "accelerationY");
          if (this.maxVelocityX = W.maxVelocityX.onEmit(this, "maxVelocityX"), this.maxVelocityY = W.maxVelocityY.onEmit(this, "maxVelocityY"), this.bounce = W.bounce.onEmit(this, "bounce"), this.alpha = W.alpha.onEmit(this, "alpha"), W.color.active)
            this.tint = W.color.onEmit(this, "tint");
          else
            this.tint = W.tint.onEmit(this, "tint");
          return true;
        }, update: function(Q, H, N) {
          if (this.lifeCurrent <= 0)
            if (this.holdCurrent > 0)
              return this.holdCurrent -= Q, this.holdCurrent <= 0;
            else
              return true;
          if (this.delayCurrent > 0)
            return this.delayCurrent -= Q, false;
          this.anims.update(0, Q);
          var W = this.emitter, R = W.ops, Y = 1 - this.lifeCurrent / this.life;
          if (this.lifeT = Y, this.x = R.x.onUpdate(this, "x", Y, this.x), this.y = R.y.onUpdate(this, "y", Y, this.y), W.moveTo) {
            var I = R.moveToX.onUpdate(this, "moveToX", Y, W.moveToX), P = R.moveToY.onUpdate(this, "moveToY", Y, W.moveToY), X = this.lifeCurrent / 1000;
            this.velocityX = (I - this.x) / X, this.velocityY = (P - this.y) / X;
          }
          if (this.computeVelocity(W, Q, H, N, Y), this.scaleX = R.scaleX.onUpdate(this, "scaleX", Y, this.scaleX), R.scaleY.active)
            this.scaleY = R.scaleY.onUpdate(this, "scaleY", Y, this.scaleY);
          else
            this.scaleY = this.scaleX;
          if (this.angle = R.rotate.onUpdate(this, "rotate", Y, this.angle), this.rotation = U(this.angle), W.getDeathZone(this))
            return this.lifeCurrent = 0, true;
          if (this.alpha = L(R.alpha.onUpdate(this, "alpha", Y, this.alpha), 0, 1), R.color.active)
            this.tint = R.color.onUpdate(this, "color", Y, this.tint);
          else
            this.tint = R.tint.onUpdate(this, "tint", Y, this.tint);
          return this.lifeCurrent -= Q, this.lifeCurrent <= 0 && this.holdCurrent <= 0;
        }, computeVelocity: function(Q, H, N, W, R) {
          var Y = Q.ops, I = this.velocityX, P = this.velocityY, X = Y.accelerationX.onUpdate(this, "accelerationX", R, this.accelerationX), G = Y.accelerationY.onUpdate(this, "accelerationY", R, this.accelerationY), V = Y.maxVelocityX.onUpdate(this, "maxVelocityX", R, this.maxVelocityX), A = Y.maxVelocityY.onUpdate(this, "maxVelocityY", R, this.maxVelocityY);
          this.bounce = Y.bounce.onUpdate(this, "bounce", R, this.bounce), I += Q.gravityX * N + X * N, P += Q.gravityY * N + G * N, I = L(I, -V, V), P = L(P, -A, A), this.velocityX = I, this.velocityY = P, this.x += I * N, this.y += P * N, Q.worldMatrix.transformPoint(this.x, this.y, this.worldPosition);
          for (var F = 0;F < W.length; F++) {
            var j = W[F];
            if (j.active)
              j.update(this, H, N, R);
          }
        }, setSizeToFrame: function() {
        }, getBounds: function(Q) {
          if (Q === undefined)
            Q = this.emitter.getWorldTransformMatrix();
          var H = Math.abs(Q.scaleX) * this.scaleX, N = Math.abs(Q.scaleY) * this.scaleY, W = this.x, R = this.y, Y = this.rotation, I = this.frame.width * H / 2, P = this.frame.height * N / 2, X = this.bounds, G = new Z(W - I, R - P), V = new Z(W + I, R - P), A = new Z(W - I, R + P), F = new Z(W + I, R + P);
          if (Y !== 0)
            J(G, W, R, Y), J(V, W, R, Y), J(A, W, R, Y), J(F, W, R, Y);
          return Q.transformPoint(G.x, G.y, G), Q.transformPoint(V.x, V.y, V), Q.transformPoint(A.x, A.y, A), Q.transformPoint(F.x, F.y, F), X.x = Math.min(G.x, V.x, A.x, F.x), X.y = Math.min(G.y, V.y, A.y, F.y), X.width = Math.max(G.x, V.x, A.x, F.x) - X.x, X.height = Math.max(G.y, V.y, A.y, F.y) - X.y, X;
        }, destroy: function() {
          this.anims.destroy(), this.anims = null, this.emitter = null, this.texture = null, this.frame = null, this.scene = null;
        } });
        M.exports = D;
      }, 69601: (M, B, $) => {
        var E = $(83419), L = $(20286), z = $(87841), U = new E({ Extends: L, initialize: function K(J, Z, D, Q, H, N, W, R) {
          if (H === undefined)
            H = true;
          if (N === undefined)
            N = true;
          if (W === undefined)
            W = true;
          if (R === undefined)
            R = true;
          L.call(this, J, Z, true), this.bounds = new z(J, Z, D, Q), this.collideLeft = H, this.collideRight = N, this.collideTop = W, this.collideBottom = R;
        }, update: function(K) {
          var J = this.bounds, Z = -K.bounce, D = K.worldPosition;
          if (D.x < J.x && this.collideLeft)
            K.x += J.x - D.x, K.velocityX *= Z;
          else if (D.x > J.right && this.collideRight)
            K.x -= D.x - J.right, K.velocityX *= Z;
          if (D.y < J.y && this.collideTop)
            K.y += J.y - D.y, K.velocityY *= Z;
          else if (D.y > J.bottom && this.collideBottom)
            K.y -= D.y - J.bottom, K.velocityY *= Z;
        } });
        M.exports = U;
      }, 31600: (M, B, $) => {
        var E = $(83419), L = $(31401), z = $(53774), U = $(43459), K = $(26388), J = $(19909), Z = $(76472), D = $(44777), Q = $(20696), H = $(95643), N = $(95540), W = $(26546), R = $(24502), Y = $(1985), I = $(97022), P = $(86091), X = $(73162), G = $(20074), V = $(56480), A = $(68875), F = $(87841), j = $(59996), T = $(72905), C = $(90668), v = $(19186), O = $(61340), q = $(26099), w = $(15994), g = $(69601), b = ["active", "advance", "blendMode", "colorEase", "deathCallback", "deathCallbackScope", "duration", "emitCallback", "emitCallbackScope", "follow", "frequency", "gravityX", "gravityY", "maxAliveParticles", "maxParticles", "name", "emitting", "particleBringToTop", "particleClass", "radial", "sortCallback", "sortOrderAsc", "sortProperty", "stopAfter", "tintFill", "timeScale", "trackVisible", "visible"], x = ["accelerationX", "accelerationY", "alpha", "angle", "bounce", "color", "delay", "hold", "lifespan", "maxVelocityX", "maxVelocityY", "moveToX", "moveToY", "quantity", "rotate", "scaleX", "scaleY", "speedX", "speedY", "tint", "x", "y"], k = new E({ Extends: H, Mixins: [L.AlphaSingle, L.BlendMode, L.Depth, L.Mask, L.Pipeline, L.PostPipeline, L.ScrollFactor, L.Texture, L.Transform, L.Visible, C], initialize: function S(f, h, m, y, d) {
          if (H.call(this, f, "ParticleEmitter"), this.particleClass = V, this.ops = { accelerationX: new D("accelerationX", 0), accelerationY: new D("accelerationY", 0), alpha: new D("alpha", 1), angle: new D("angle", { min: 0, max: 360 }, true), bounce: new D("bounce", 0), color: new Z("color"), delay: new D("delay", 0, true), hold: new D("hold", 0, true), lifespan: new D("lifespan", 1000, true), maxVelocityX: new D("maxVelocityX", 1e4), maxVelocityY: new D("maxVelocityY", 1e4), moveToX: new D("moveToX", 0), moveToY: new D("moveToY", 0), quantity: new D("quantity", 1, true), rotate: new D("rotate", 0), scaleX: new D("scaleX", 1), scaleY: new D("scaleY", 1), speedX: new D("speedX", 0, true), speedY: new D("speedY", 0, true), tint: new D("tint", 16777215), x: new D("x", 0), y: new D("y", 0) }, this.radial = true, this.gravityX = 0, this.gravityY = 0, this.acceleration = false, this.moveTo = false, this.emitCallback = null, this.emitCallbackScope = null, this.deathCallback = null, this.deathCallbackScope = null, this.maxParticles = 0, this.maxAliveParticles = 0, this.stopAfter = 0, this.duration = 0, this.frequency = 0, this.emitting = true, this.particleBringToTop = true, this.timeScale = 1, this.emitZones = [], this.deathZones = [], this.viewBounds = null, this.follow = null, this.followOffset = new q, this.trackVisible = false, this.frames = [], this.randomFrame = true, this.frameQuantity = 1, this.anims = [], this.randomAnim = true, this.animQuantity = 1, this.dead = [], this.alive = [], this.counters = new Float32Array(10), this.skipping = false, this.worldMatrix = new O, this.sortProperty = "", this.sortOrderAsc = true, this.sortCallback = this.depthSortCallback, this.processors = new X(this), this.tintFill = false, this.initPipeline(), this.initPostPipeline(), this.setPosition(h, m), this.setTexture(y), d)
            this.setConfig(d);
        }, addedToScene: function() {
          this.scene.sys.updateList.add(this);
        }, removedFromScene: function() {
          this.scene.sys.updateList.remove(this);
        }, setConfig: function(S) {
          if (!S)
            return this;
          var f = 0, h = "", m = this.ops;
          for (f = 0;f < x.length; f++)
            h = x[f], m[h].loadConfig(S);
          for (f = 0;f < b.length; f++)
            if (h = b[f], I(S, h))
              this[h] = N(S, h);
          if (this.acceleration = this.accelerationX !== 0 || this.accelerationY !== 0, this.moveTo = this.moveToX !== 0 && this.moveToY !== 0, I(S, "speed"))
            m.speedX.loadConfig(S, "speed"), m.speedY.active = false;
          if (Y(S, ["speedX", "speedY"]) || this.moveTo)
            this.radial = false;
          if (I(S, "scale"))
            m.scaleX.loadConfig(S, "scale"), m.scaleY.active = false;
          if (I(S, "callbackScope")) {
            var y = N(S, "callbackScope", null);
            this.emitCallbackScope = y, this.deathCallbackScope = y;
          }
          if (I(S, "emitZone"))
            this.addEmitZone(S.emitZone);
          if (I(S, "deathZone"))
            this.addDeathZone(S.deathZone);
          if (I(S, "bounds")) {
            var d = this.addParticleBounds(S.bounds);
            d.collideLeft = N(S, "collideLeft", true), d.collideRight = N(S, "collideRight", true), d.collideTop = N(S, "collideTop", true), d.collideBottom = N(S, "collideBottom", true);
          }
          if (I(S, "followOffset"))
            this.followOffset.setFromObject(N(S, "followOffset", 0));
          if (I(S, "texture"))
            this.setTexture(S.texture);
          if (I(S, "frame"))
            this.setEmitterFrame(S.frame);
          else if (I(S, "anim"))
            this.setAnim(S.anim);
          if (I(S, "reserve"))
            this.reserve(S.reserve);
          if (I(S, "advance"))
            this.fastForward(S.advance);
          if (this.resetCounters(this.frequency, this.emitting), this.emitting)
            this.emit(Q.START, this);
          return this;
        }, toJSON: function() {
          var S = z(this), f = 0, h = "";
          for (f = 0;f < b.length; f++)
            h = b[f], S[h] = this[h];
          var m = this.ops;
          for (f = 0;f < x.length; f++)
            if (h = x[f], m[h])
              S[h] = m[h].toJSON();
          if (!m.speedY.active)
            delete S.speedX, S.speed = m.speedX.toJSON();
          if (this.scaleX === this.scaleY)
            delete S.scaleX, delete S.scaleY, S.scale = m.scaleX.toJSON();
          return S;
        }, resetCounters: function(S, f) {
          var h = this.counters;
          if (h.fill(0), h[0] = S, f)
            h[5] = 1;
        }, startFollow: function(S, f, h, m) {
          if (f === undefined)
            f = 0;
          if (h === undefined)
            h = 0;
          if (m === undefined)
            m = false;
          return this.follow = S, this.followOffset.set(f, h), this.trackVisible = m, this;
        }, stopFollow: function() {
          return this.follow = null, this.followOffset.set(0, 0), this.trackVisible = false, this;
        }, getFrame: function() {
          var S = this.frames, f = S.length, h;
          if (f === 1)
            h = S[0];
          else if (this.randomFrame)
            h = W(S);
          else if (h = S[this.currentFrame], this.frameCounter++, this.frameCounter === this.frameQuantity) {
            if (this.frameCounter = 0, this.currentFrame++, this.currentFrame === f)
              this.currentFrame = 0;
          }
          return this.texture.get(h);
        }, setEmitterFrame: function(S, f, h) {
          if (f === undefined)
            f = true;
          if (h === undefined)
            h = 1;
          this.randomFrame = f, this.frameQuantity = h, this.currentFrame = 0;
          var m = typeof S;
          if (this.frames.length = 0, Array.isArray(S))
            this.frames = this.frames.concat(S);
          else if (m === "string" || m === "number")
            this.frames.push(S);
          else if (m === "object") {
            var y = S;
            if (S = N(y, "frames", null), S)
              this.frames = this.frames.concat(S);
            var d = N(y, "cycle", false);
            this.randomFrame = d ? false : true, this.frameQuantity = N(y, "quantity", h);
          }
          if (this.frames.length === 1)
            this.frameQuantity = 1, this.randomFrame = false;
          return this;
        }, getAnim: function() {
          var S = this.anims, f = S.length;
          if (f === 0)
            return null;
          else if (f === 1)
            return S[0];
          else if (this.randomAnim)
            return W(S);
          else {
            var h = S[this.currentAnim];
            if (this.animCounter++, this.animCounter >= this.animQuantity)
              this.animCounter = 0, this.currentAnim = w(this.currentAnim + 1, 0, f);
            return h;
          }
        }, setAnim: function(S, f, h) {
          if (f === undefined)
            f = true;
          if (h === undefined)
            h = 1;
          this.randomAnim = f, this.animQuantity = h, this.currentAnim = 0;
          var m = typeof S;
          if (this.anims.length = 0, Array.isArray(S))
            this.anims = this.anims.concat(S);
          else if (m === "string")
            this.anims.push(S);
          else if (m === "object") {
            var y = S;
            if (S = N(y, "anims", null), S)
              this.anims = this.anims.concat(S);
            var d = N(y, "cycle", false);
            this.randomAnim = d ? false : true, this.animQuantity = N(y, "quantity", h);
          }
          if (this.anims.length === 1)
            this.animQuantity = 1, this.randomAnim = false;
          return this;
        }, setRadial: function(S) {
          if (S === undefined)
            S = true;
          return this.radial = S, this;
        }, addParticleBounds: function(S, f, h, m, y, d, p, u) {
          if (typeof S === "object") {
            var s = S;
            S = s.x, f = s.y, h = I(s, "w") ? s.w : s.width, m = I(s, "h") ? s.h : s.height;
          }
          return this.addParticleProcessor(new g(S, f, h, m, y, d, p, u));
        }, setParticleSpeed: function(S, f) {
          if (f === undefined)
            f = S;
          if (this.ops.speedX.onChange(S), S === f)
            this.ops.speedY.active = false;
          else
            this.ops.speedY.onChange(f);
          return this.radial = true, this;
        }, setParticleScale: function(S, f) {
          if (S === undefined)
            S = 1;
          if (f === undefined)
            f = S;
          return this.ops.scaleX.onChange(S), this.ops.scaleY.onChange(f), this;
        }, setParticleGravity: function(S, f) {
          return this.gravityX = S, this.gravityY = f, this;
        }, setParticleAlpha: function(S) {
          return this.ops.alpha.onChange(S), this;
        }, setParticleTint: function(S) {
          return this.ops.tint.onChange(S), this;
        }, setEmitterAngle: function(S) {
          return this.ops.angle.onChange(S), this;
        }, setParticleLifespan: function(S) {
          return this.ops.lifespan.onChange(S), this;
        }, setQuantity: function(S) {
          return this.quantity = S, this;
        }, setFrequency: function(S, f) {
          if (this.frequency = S, this.flowCounter = S > 0 ? S : 0, f)
            this.quantity = f;
          return this;
        }, addDeathZone: function(S) {
          if (!Array.isArray(S))
            S = [S];
          var f, h = [];
          for (var m = 0;m < S.length; m++)
            if (f = S[m], f instanceof K)
              h.push(f);
            else if (typeof f.contains === "function")
              f = new K(f, true), h.push(f);
            else {
              var y = N(f, "type", "onEnter"), d = N(f, "source", null);
              if (d && typeof d.contains === "function") {
                var p = y === "onEnter" ? true : false;
                f = new K(d, p), h.push(f);
              }
            }
          return this.deathZones = this.deathZones.concat(h), h;
        }, removeDeathZone: function(S) {
          return T(this.deathZones, S), this;
        }, clearDeathZones: function() {
          return this.deathZones.length = 0, this;
        }, addEmitZone: function(S) {
          if (!Array.isArray(S))
            S = [S];
          var f, h = [];
          for (var m = 0;m < S.length; m++)
            if (f = S[m], f instanceof A || f instanceof J)
              h.push(f);
            else {
              var y = N(f, "source", null);
              if (y) {
                var d = N(f, "type", "random");
                if (d === "random" && typeof y.getRandomPoint === "function")
                  f = new A(y), h.push(f);
                else if (d === "edge" && typeof y.getPoints === "function") {
                  var p = N(f, "quantity", 1), u = N(f, "stepRate", 0), s = N(f, "yoyo", false), c = N(f, "seamless", true), n = N(f, "total", -1);
                  f = new J(y, p, u, s, c, n), h.push(f);
                }
              }
            }
          return this.emitZones = this.emitZones.concat(h), h;
        }, removeEmitZone: function(S) {
          return T(this.emitZones, S), this.zoneIndex = 0, this;
        }, clearEmitZones: function() {
          return this.emitZones.length = 0, this.zoneIndex = 0, this;
        }, getEmitZone: function(S) {
          var f = this.emitZones, h = f.length;
          if (h === 0)
            return;
          else {
            var m = f[this.zoneIndex];
            if (m.getPoint(S), m.total > -1) {
              if (this.zoneTotal++, this.zoneTotal === m.total) {
                if (this.zoneTotal = 0, this.zoneIndex++, this.zoneIndex === h)
                  this.zoneIndex = 0;
              }
            }
          }
        }, getDeathZone: function(S) {
          var f = this.deathZones;
          for (var h = 0;h < f.length; h++) {
            var m = f[h];
            if (m.willKill(S))
              return this.emit(Q.DEATH_ZONE, this, S, m), true;
          }
          return false;
        }, setEmitZone: function(S) {
          var f;
          if (isFinite(S))
            f = S;
          else
            f = this.emitZones.indexOf(S);
          if (f >= 0)
            this.zoneIndex = f;
          return this;
        }, addParticleProcessor: function(S) {
          if (!this.processors.exists(S)) {
            if (S.emitter)
              S.emitter.removeParticleProcessor(S);
            this.processors.add(S), S.emitter = this;
          }
          return S;
        }, removeParticleProcessor: function(S) {
          if (this.processors.exists(S))
            this.processors.remove(S, true), S.emitter = null;
          return S;
        }, getProcessors: function() {
          return this.processors.getAll("active", true);
        }, createGravityWell: function(S) {
          return this.addParticleProcessor(new R(S));
        }, reserve: function(S) {
          var f = this.dead;
          if (this.maxParticles > 0) {
            var h = this.getParticleCount();
            if (h + S > this.maxParticles)
              S = this.maxParticles - (h + S);
          }
          for (var m = 0;m < S; m++)
            f.push(new this.particleClass(this));
          return this;
        }, getAliveParticleCount: function() {
          return this.alive.length;
        }, getDeadParticleCount: function() {
          return this.dead.length;
        }, getParticleCount: function() {
          return this.getAliveParticleCount() + this.getDeadParticleCount();
        }, atLimit: function() {
          if (this.maxParticles > 0 && this.getParticleCount() >= this.maxParticles)
            return true;
          return this.maxAliveParticles > 0 && this.getAliveParticleCount() >= this.maxAliveParticles;
        }, onParticleEmit: function(S, f) {
          if (S === undefined)
            this.emitCallback = null, this.emitCallbackScope = null;
          else if (typeof S === "function") {
            if (this.emitCallback = S, f)
              this.emitCallbackScope = f;
          }
          return this;
        }, onParticleDeath: function(S, f) {
          if (S === undefined)
            this.deathCallback = null, this.deathCallbackScope = null;
          else if (typeof S === "function") {
            if (this.deathCallback = S, f)
              this.deathCallbackScope = f;
          }
          return this;
        }, killAll: function() {
          var S = this.dead, f = this.alive;
          while (f.length > 0)
            S.push(f.pop());
          return this;
        }, forEachAlive: function(S, f) {
          var h = this.alive, m = h.length;
          for (var y = 0;y < m; y++)
            S.call(f, h[y], this);
          return this;
        }, forEachDead: function(S, f) {
          var h = this.dead, m = h.length;
          for (var y = 0;y < m; y++)
            S.call(f, h[y], this);
          return this;
        }, start: function(S, f) {
          if (S === undefined)
            S = 0;
          if (!this.emitting) {
            if (S > 0)
              this.fastForward(S);
            if (this.emitting = true, this.resetCounters(this.frequency, true), f !== undefined)
              this.duration = Math.abs(f);
            this.emit(Q.START, this);
          }
          return this;
        }, stop: function(S) {
          if (S === undefined)
            S = false;
          if (this.emitting) {
            if (this.emitting = false, S)
              this.killAll();
            this.emit(Q.STOP, this);
          }
          return this;
        }, pause: function() {
          return this.active = false, this;
        }, resume: function() {
          return this.active = true, this;
        }, setSortProperty: function(S, f) {
          if (S === undefined)
            S = "";
          if (f === undefined)
            f = this.true;
          return this.sortProperty = S, this.sortOrderAsc = f, this.sortCallback = this.depthSortCallback, this;
        }, setSortCallback: function(S) {
          if (this.sortProperty !== "")
            S = this.depthSortCallback;
          else
            S = null;
          return this.sortCallback = S, this;
        }, depthSort: function() {
          return v(this.alive, this.sortCallback.bind(this)), this;
        }, depthSortCallback: function(S, f) {
          var h = this.sortProperty;
          if (this.sortOrderAsc)
            return S[h] - f[h];
          else
            return f[h] - S[h];
        }, flow: function(S, f, h) {
          if (f === undefined)
            f = 1;
          if (this.emitting = false, this.frequency = S, this.quantity = f, h !== undefined)
            this.stopAfter = h;
          return this.start();
        }, explode: function(S, f, h) {
          this.frequency = -1, this.resetCounters(-1, true);
          var m = this.emitParticle(S, f, h);
          return this.emit(Q.EXPLODE, this, m), m;
        }, emitParticleAt: function(S, f, h) {
          return this.emitParticle(h, S, f);
        }, emitParticle: function(S, f, h) {
          if (this.atLimit())
            return;
          if (S === undefined)
            S = this.ops.quantity.onEmit();
          var m = this.dead, y = this.stopAfter, d = this.follow ? this.follow.x + this.followOffset.x : f, p = this.follow ? this.follow.y + this.followOffset.y : h;
          for (var u = 0;u < S; u++) {
            var s = m.pop();
            if (!s)
              s = new this.particleClass(this);
            if (s.fire(d, p)) {
              if (this.particleBringToTop)
                this.alive.push(s);
              else
                this.alive.unshift(s);
              if (this.emitCallback)
                this.emitCallback.call(this.emitCallbackScope, s, this);
            } else
              this.dead.push(s);
            if (y > 0) {
              if (this.stopCounter++, this.stopCounter >= y)
                break;
            }
            if (this.atLimit())
              break;
          }
          return s;
        }, fastForward: function(S, f) {
          if (f === undefined)
            f = 16.666666666666668;
          var h = 0;
          this.skipping = true;
          while (h < Math.abs(S))
            this.preUpdate(0, f), h += f;
          return this.skipping = false, this;
        }, preUpdate: function(S, f) {
          f *= this.timeScale;
          var h = f / 1000;
          if (this.trackVisible)
            this.visible = this.follow.visible;
          this.getWorldTransformMatrix(this.worldMatrix);
          var m = this.getProcessors(), y = this.alive, d = this.dead, p = 0, u = [], s = y.length;
          for (p = 0;p < s; p++) {
            var c = y[p];
            if (c.update(f, h, m))
              u.push({ index: p, particle: c });
          }
          if (s = u.length, s > 0) {
            var n = this.deathCallback, _ = this.deathCallbackScope;
            for (p = s - 1;p >= 0; p--) {
              var l = u[p];
              if (y.splice(l.index, 1), d.push(l.particle), n)
                n.call(_, l.particle);
              l.particle.setPosition();
            }
          }
          if (!this.emitting && !this.skipping) {
            if (this.completeFlag === 1 && y.length === 0)
              this.completeFlag = 0, this.emit(Q.COMPLETE, this);
            return;
          }
          if (this.frequency === 0)
            this.emitParticle();
          else if (this.frequency > 0) {
            this.flowCounter -= f;
            while (this.flowCounter <= 0)
              this.emitParticle(), this.flowCounter += this.frequency;
          }
          if (!this.skipping) {
            if (this.duration > 0) {
              if (this.elapsed += f, this.elapsed >= this.duration)
                this.stop();
            }
            if (this.stopAfter > 0 && this.stopCounter >= this.stopAfter)
              this.stop();
          }
        }, overlap: function(S) {
          var f = this.getWorldTransformMatrix(), h = this.alive, m = h.length, y = [];
          for (var d = 0;d < m; d++) {
            var p = h[d];
            if (j(S, p.getBounds(f)))
              y.push(p);
          }
          return y;
        }, getBounds: function(S, f, h, m) {
          if (S === undefined)
            S = 0;
          if (f === undefined)
            f = 0;
          if (h === undefined)
            h = 16.666666666666668;
          if (m === undefined)
            m = new F;
          var y = this.getWorldTransformMatrix(), d, p, u = this.alive, s = false;
          if (m.setTo(0, 0, 0, 0), f > 0) {
            var c = 0;
            this.skipping = true;
            while (c < Math.abs(f)) {
              this.preUpdate(0, h);
              for (d = 0;d < u.length; d++)
                if (p = u[d].getBounds(y), !s)
                  s = true, U(p, m);
                else
                  G(m, p);
              c += h;
            }
            this.skipping = false;
          } else
            for (d = 0;d < u.length; d++)
              if (p = u[d].getBounds(y), !s)
                s = true, U(p, m);
              else
                G(m, p);
          if (S > 0)
            P(m, S, S);
          return m;
        }, createEmitter: function() {
          throw new Error("createEmitter removed. See ParticleEmitter docs for info");
        }, particleX: { get: function() {
          return this.ops.x.current;
        }, set: function(S) {
          this.ops.x.onChange(S);
        } }, particleY: { get: function() {
          return this.ops.y.current;
        }, set: function(S) {
          this.ops.y.onChange(S);
        } }, accelerationX: { get: function() {
          return this.ops.accelerationX.current;
        }, set: function(S) {
          this.ops.accelerationX.onChange(S);
        } }, accelerationY: { get: function() {
          return this.ops.accelerationY.current;
        }, set: function(S) {
          this.ops.accelerationY.onChange(S);
        } }, maxVelocityX: { get: function() {
          return this.ops.maxVelocityX.current;
        }, set: function(S) {
          this.ops.maxVelocityX.onChange(S);
        } }, maxVelocityY: { get: function() {
          return this.ops.maxVelocityY.current;
        }, set: function(S) {
          this.ops.maxVelocityY.onChange(S);
        } }, speed: { get: function() {
          return this.ops.speedX.current;
        }, set: function(S) {
          this.ops.speedX.onChange(S), this.ops.speedY.onChange(S);
        } }, speedX: { get: function() {
          return this.ops.speedX.current;
        }, set: function(S) {
          this.ops.speedX.onChange(S);
        } }, speedY: { get: function() {
          return this.ops.speedY.current;
        }, set: function(S) {
          this.ops.speedY.onChange(S);
        } }, moveToX: { get: function() {
          return this.ops.moveToX.current;
        }, set: function(S) {
          this.ops.moveToX.onChange(S);
        } }, moveToY: { get: function() {
          return this.ops.moveToY.current;
        }, set: function(S) {
          this.ops.moveToY.onChange(S);
        } }, bounce: { get: function() {
          return this.ops.bounce.current;
        }, set: function(S) {
          this.ops.bounce.onChange(S);
        } }, particleScaleX: { get: function() {
          return this.ops.scaleX.current;
        }, set: function(S) {
          this.ops.scaleX.onChange(S);
        } }, particleScaleY: { get: function() {
          return this.ops.scaleY.current;
        }, set: function(S) {
          this.ops.scaleY.onChange(S);
        } }, particleColor: { get: function() {
          return this.ops.color.current;
        }, set: function(S) {
          this.ops.color.onChange(S);
        } }, colorEase: { get: function() {
          return this.ops.color.easeName;
        }, set: function(S) {
          this.ops.color.setEase(S);
        } }, particleTint: { get: function() {
          return this.ops.tint.current;
        }, set: function(S) {
          this.ops.tint.onChange(S);
        } }, particleAlpha: { get: function() {
          return this.ops.alpha.current;
        }, set: function(S) {
          this.ops.alpha.onChange(S);
        } }, lifespan: { get: function() {
          return this.ops.lifespan.current;
        }, set: function(S) {
          this.ops.lifespan.onChange(S);
        } }, particleAngle: { get: function() {
          return this.ops.angle.current;
        }, set: function(S) {
          this.ops.angle.onChange(S);
        } }, particleRotate: { get: function() {
          return this.ops.rotate.current;
        }, set: function(S) {
          this.ops.rotate.onChange(S);
        } }, quantity: { get: function() {
          return this.ops.quantity.current;
        }, set: function(S) {
          this.ops.quantity.onChange(S);
        } }, delay: { get: function() {
          return this.ops.delay.current;
        }, set: function(S) {
          this.ops.delay.onChange(S);
        } }, hold: { get: function() {
          return this.ops.hold.current;
        }, set: function(S) {
          this.ops.hold.onChange(S);
        } }, flowCounter: { get: function() {
          return this.counters[0];
        }, set: function(S) {
          this.counters[0] = S;
        } }, frameCounter: { get: function() {
          return this.counters[1];
        }, set: function(S) {
          this.counters[1] = S;
        } }, animCounter: { get: function() {
          return this.counters[2];
        }, set: function(S) {
          this.counters[2] = S;
        } }, elapsed: { get: function() {
          return this.counters[3];
        }, set: function(S) {
          this.counters[3] = S;
        } }, stopCounter: { get: function() {
          return this.counters[4];
        }, set: function(S) {
          this.counters[4] = S;
        } }, completeFlag: { get: function() {
          return this.counters[5];
        }, set: function(S) {
          this.counters[5] = S;
        } }, zoneIndex: { get: function() {
          return this.counters[6];
        }, set: function(S) {
          this.counters[6] = S;
        } }, zoneTotal: { get: function() {
          return this.counters[7];
        }, set: function(S) {
          this.counters[7] = S;
        } }, currentFrame: { get: function() {
          return this.counters[8];
        }, set: function(S) {
          this.counters[8] = S;
        } }, currentAnim: { get: function() {
          return this.counters[9];
        }, set: function(S) {
          this.counters[9] = S;
        } }, preDestroy: function() {
          this.texture = null, this.frames = null, this.anims = null, this.emitCallback = null, this.emitCallbackScope = null, this.deathCallback = null, this.deathCallbackScope = null, this.emitZones = null, this.deathZones = null, this.bounds = null, this.follow = null, this.counters = null;
          var S, f = this.ops;
          for (S = 0;S < x.length; S++) {
            var h = x[S];
            f[h].destroy();
          }
          for (S = 0;S < this.alive.length; S++)
            this.alive[S].destroy();
          for (S = 0;S < this.dead.length; S++)
            this.dead[S].destroy();
          this.ops = null, this.alive = [], this.dead = [], this.worldMatrix.destroy();
        } });
        M.exports = k;
      }, 9871: (M, B, $) => {
        var E = $(59996), L = $(61340), z = new L, U = new L, K = new L, J = new L, Z = function(D, Q, H, N) {
          var W = z, R = U, Y = K, I = J;
          if (N)
            I.loadIdentity(), I.multiply(N), I.translate(Q.x, Q.y), I.rotate(Q.rotation), I.scale(Q.scaleX, Q.scaleY);
          else
            I.applyITRS(Q.x, Q.y, Q.rotation, Q.scaleX, Q.scaleY);
          var P = D.currentContext, X = H.roundPixels, G = H.alpha, V = Q.alpha, A = Q.alive, F = A.length, j = Q.viewBounds;
          if (!Q.visible || F === 0 || j && !E(j, H.worldView))
            return;
          if (Q.sortCallback)
            Q.depthSort();
          H.addToRenderList(Q);
          var { scrollFactorX: T, scrollFactorY: C } = Q;
          P.save(), P.globalCompositeOperation = D.blendModes[Q.blendMode];
          for (var v = 0;v < F; v++) {
            var O = A[v], q = O.alpha * V * G;
            if (q <= 0 || O.scaleX === 0 || O.scaleY === 0)
              continue;
            Y.applyITRS(O.x, O.y, O.rotation, O.scaleX, O.scaleY), W.copyFrom(H.matrix), W.multiplyWithOffset(I, -H.scrollX * T, -H.scrollY * C), Y.e = O.x, Y.f = O.y, W.multiply(Y, R);
            var w = O.frame, g = w.canvasData;
            if (g.width > 0 && g.height > 0) {
              var b = -w.halfWidth, x = -w.halfHeight;
              if (P.globalAlpha = q, P.save(), R.setToContext(P), X)
                b = Math.round(b), x = Math.round(x);
              P.imageSmoothingEnabled = !w.source.scaleMode, P.drawImage(w.source.image, g.x, g.y, g.width, g.height, b, x, g.width, g.height), P.restore();
            }
          }
          P.restore();
        };
        M.exports = Z;
      }, 92730: (M, B, $) => {
        var E = $(25305), L = $(44603), z = $(23568), U = $(95540), K = $(31600);
        L.register("particles", function(J, Z) {
          if (J === undefined)
            J = {};
          var D = z(J, "key", null), Q = U(J, "config", null), H = new K(this.scene, 0, 0, D);
          if (Z !== undefined)
            J.add = Z;
          if (E(this.scene, H, J), Q)
            H.setConfig(Q);
          return H;
        });
      }, 676: (M, B, $) => {
        var E = $(39429), L = $(31600);
        E.register("particles", function(z, U, K, J) {
          if (z !== undefined && typeof z === "string")
            console.warn("ParticleEmitterManager was removed in Phaser 3.60. See documentation for details");
          return this.displayList.add(new L(this.scene, z, U, K, J));
        });
      }, 90668: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(21188), z = $(9871), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 21188: (M, B, $) => {
        var E = $(59996), L = $(61340), z = $(70554), U = new L, K = new L, J = new L, Z = new L, D = function(Q, H, N, W) {
          var R = Q.pipelines.set(H.pipeline), Y = U, I = K, P = J, X = Z;
          if (W)
            X.loadIdentity(), X.multiply(W), X.translate(H.x, H.y), X.rotate(H.rotation), X.scale(H.scaleX, H.scaleY);
          else
            X.applyITRS(H.x, H.y, H.rotation, H.scaleX, H.scaleY);
          var G = z.getTintAppendFloatAlpha, V = N.alpha, A = H.alpha;
          Q.pipelines.preBatch(H);
          var F = H.alive, j = F.length, T = H.viewBounds;
          if (j === 0 || T && !E(T, N.worldView))
            return;
          if (H.sortCallback)
            H.depthSort();
          if (N.addToRenderList(H), Y.copyFrom(N.matrix), Y.multiplyWithOffset(X, -N.scrollX * H.scrollFactorX, -N.scrollY * H.scrollFactorY), Q.setBlendMode(H.blendMode), H.mask)
            H.mask.preRenderWebGL(Q, H, N), Q.pipelines.set(H.pipeline);
          var C = H.tintFill, v, O;
          for (var q = 0;q < j; q++) {
            var w = F[q], g = w.alpha * A * V;
            if (g <= 0 || w.scaleX === 0 || w.scaleY === 0)
              continue;
            P.applyITRS(w.x, w.y, w.rotation, w.scaleX, w.scaleY), P.e = w.x, P.f = w.y, Y.multiply(P, I);
            var b = w.frame;
            if (b.glTexture !== O)
              O = b.glTexture, v = R.setGameObject(H, b);
            var x = -b.halfWidth, k = -b.halfHeight, S = I.setQuad(x, k, x + b.width, k + b.height), f = G(w.tint, g);
            if (R.shouldFlush(6))
              R.flush(), v = R.setGameObject(H, b);
            R.batchQuad(H, S[0], S[1], S[2], S[3], S[4], S[5], S[6], S[7], b.u0, b.v0, b.u1, b.v1, f, f, f, f, C, O, v);
          }
          if (H.mask)
            H.mask.postRenderWebGL(Q, N);
          Q.pipelines.postBatch(H);
        };
        M.exports = D;
      }, 20286: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U, K, J) {
          if (U === undefined)
            U = 0;
          if (K === undefined)
            K = 0;
          if (J === undefined)
            J = true;
          this.emitter, this.x = U, this.y = K, this.active = J;
        }, update: function() {
        }, destroy: function() {
          this.emitter = null;
        } });
        M.exports = L;
      }, 9774: (M) => {
        M.exports = "complete";
      }, 812: (M) => {
        M.exports = "deathzone";
      }, 30522: (M) => {
        M.exports = "explode";
      }, 96695: (M) => {
        M.exports = "start";
      }, 18677: (M) => {
        M.exports = "stop";
      }, 20696: (M, B, $) => {
        M.exports = { COMPLETE: $(9774), DEATH_ZONE: $(812), EXPLODE: $(30522), START: $(96695), STOP: $(18677) };
      }, 18404: (M, B, $) => {
        M.exports = { EmitterColorOp: $(76472), EmitterOp: $(44777), Events: $(20696), GravityWell: $(24502), Particle: $(56480), ParticleBounds: $(69601), ParticleEmitter: $(31600), ParticleProcessor: $(20286), Zones: $(21024) };
      }, 26388: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U, K) {
          this.source = U, this.killOnEnter = K;
        }, willKill: function(z) {
          var U = z.worldPosition, K = this.source.contains(U.x, U.y);
          return K && this.killOnEnter || !K && !this.killOnEnter;
        } });
        M.exports = L;
      }, 19909: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U, K, J, Z, D, Q) {
          if (Z === undefined)
            Z = false;
          if (D === undefined)
            D = true;
          if (Q === undefined)
            Q = -1;
          this.source = U, this.points = [], this.quantity = K, this.stepRate = J, this.yoyo = Z, this.counter = -1, this.seamless = D, this._length = 0, this._direction = 0, this.total = Q, this.updateSource();
        }, updateSource: function() {
          if (this.points = this.source.getPoints(this.quantity, this.stepRate), this.seamless) {
            var z = this.points[0], U = this.points[this.points.length - 1];
            if (z.x === U.x && z.y === U.y)
              this.points.pop();
          }
          var K = this._length;
          if (this._length = this.points.length, this._length < K && this.counter > this._length)
            this.counter = this._length - 1;
          return this;
        }, changeSource: function(z) {
          return this.source = z, this.updateSource();
        }, getPoint: function(z) {
          if (this._direction === 0) {
            if (this.counter++, this.counter >= this._length)
              if (this.yoyo)
                this._direction = 1, this.counter = this._length - 1;
              else
                this.counter = 0;
          } else if (this.counter--, this.counter === -1)
            if (this.yoyo)
              this._direction = 0, this.counter = 0;
            else
              this.counter = this._length - 1;
          var U = this.points[this.counter];
          if (U)
            z.x = U.x, z.y = U.y;
        } });
        M.exports = L;
      }, 68875: (M, B, $) => {
        var E = $(83419), L = $(26099), z = new E({ initialize: function U(K) {
          this.source = K, this._tempVec = new L, this.total = -1;
        }, getPoint: function(U) {
          var K = this._tempVec;
          this.source.getRandomPoint(K), U.x = K.x, U.y = K.y;
        } });
        M.exports = z;
      }, 21024: (M, B, $) => {
        M.exports = { DeathZone: $(26388), EdgeZone: $(19909), RandomZone: $(68875) };
      }, 1159: (M, B, $) => {
        var E = $(83419), L = $(31401), z = $(68287), U = new E({ Extends: z, Mixins: [L.PathFollower], initialize: function K(J, Z, D, Q, H, N) {
          z.call(this, J, D, Q, H, N), this.path = Z;
        }, preUpdate: function(K, J) {
          this.anims.update(K, J), this.pathUpdate(K);
        } });
        M.exports = U;
      }, 90145: (M, B, $) => {
        var E = $(39429), L = $(1159);
        E.register("follower", function(z, U, K, J, Z) {
          var D = new L(this.scene, z, U, K, J, Z);
          return this.displayList.add(D), this.updateList.add(D), D;
        });
      }, 33663: (M, B, $) => {
        var E = $(9674), L = $(83419), z = $(48803), U = $(90664), K = $(4703), J = $(45650), Z = new L({ Extends: K, initialize: function D(Q, H, N, W, R, Y, I, P) {
          if (!W)
            W = "__DEFAULT";
          K.call(this, Q, H, N, W, R), this.type = "Plane", this.anims = new E(this), this.gridWidth, this.gridHeight, this.isTiled, this._checkerboard = null, this.hideCCW = false, this.setGridSize(Y, I, P), this.setSizeToFrame(false), this.setViewHeight();
        }, originX: { get: function() {
          return 0.5;
        } }, originY: { get: function() {
          return 0.5;
        } }, setGridSize: function(D, Q, H) {
          if (D === undefined)
            D = 8;
          if (Q === undefined)
            Q = 8;
          if (H === undefined)
            H = false;
          var N = false;
          if (H)
            N = true;
          return this.gridWidth = D, this.gridHeight = Q, this.isTiled = H, this.clear(), z({ mesh: this, widthSegments: D, heightSegments: Q, isOrtho: false, tile: H, flipY: N }), this;
        }, setSizeToFrame: function(D) {
          if (D === undefined)
            D = true;
          var Q = this.frame;
          if (this.setPerspective(this.width / Q.width, this.height / Q.height), this._checkerboard && this._checkerboard !== this.texture)
            this.removeCheckerboard();
          if (!D)
            return this;
          var H = this.gridWidth, N = this.gridHeight, W = this.vertices, R = Q.u0, Y = Q.u1, I = Q.v0, P = Q.v1, X, G, V = 0;
          if (this.isTiled) {
            I = Q.v1, P = Q.v0;
            for (G = 0;G < N; G++)
              for (X = 0;X < H; X++)
                W[V++].setUVs(R, P), W[V++].setUVs(R, I), W[V++].setUVs(Y, P), W[V++].setUVs(R, I), W[V++].setUVs(Y, I), W[V++].setUVs(Y, P);
          } else {
            var A = H + 1, F = N + 1, j = Y - R, T = P - I, C = [];
            for (G = 0;G < F; G++)
              for (X = 0;X < A; X++) {
                var v = R + j * (X / H), O = I + T * (G / N);
                C.push(v, O);
              }
            for (G = 0;G < N; G++)
              for (X = 0;X < H; X++) {
                var q = (X + A * G) * 2, w = (X + A * (G + 1)) * 2, g = (X + 1 + A * (G + 1)) * 2, b = (X + 1 + A * G) * 2;
                W[V++].setUVs(C[q], C[q + 1]), W[V++].setUVs(C[w], C[w + 1]), W[V++].setUVs(C[b], C[b + 1]), W[V++].setUVs(C[w], C[w + 1]), W[V++].setUVs(C[g], C[g + 1]), W[V++].setUVs(C[b], C[b + 1]);
              }
          }
          return this;
        }, setViewHeight: function(D) {
          if (D === undefined)
            D = this.frame.height;
          var Q = this.fov * (Math.PI / 180);
          this.viewPosition.z = this.height / D / Math.tan(Q / 2), this.dirtyCache[10] = 1;
        }, createCheckerboard: function(D, Q, H, N, W) {
          if (D === undefined)
            D = 16777215;
          if (Q === undefined)
            Q = 255;
          if (H === undefined)
            H = 255;
          if (N === undefined)
            N = 255;
          if (W === undefined)
            W = 128;
          var R = U(D), Y = U(Q), I = [];
          for (var P = 0;P < 16; P++)
            for (var X = 0;X < 16; X++)
              if (P < 8 && X < 8 || P > 7 && X > 7)
                I.push(R.r, R.g, R.b, H);
              else
                I.push(Y.r, Y.g, Y.b, N);
          var G = this.scene.sys.textures.addUint8Array(J(), new Uint8Array(I), 16, 16);
          return this.removeCheckerboard(), this.setTexture(G), this.setSizeToFrame(), this.setViewHeight(W), this;
        }, removeCheckerboard: function() {
          if (this._checkerboard)
            this._checkerboard.destroy(), this._checkerboard = null;
        }, play: function(D, Q) {
          return this.anims.play(D, Q);
        }, playReverse: function(D, Q) {
          return this.anims.playReverse(D, Q);
        }, playAfterDelay: function(D, Q) {
          return this.anims.playAfterDelay(D, Q);
        }, playAfterRepeat: function(D, Q) {
          return this.anims.playAfterRepeat(D, Q);
        }, stop: function() {
          return this.anims.stop();
        }, stopAfterDelay: function(D) {
          return this.anims.stopAfterDelay(D);
        }, stopAfterRepeat: function(D) {
          return this.anims.stopAfterRepeat(D);
        }, stopOnFrame: function(D) {
          return this.anims.stopOnFrame(D);
        }, preUpdate: function(D, Q) {
          K.prototype.preUpdate.call(this, D, Q), this.anims.update(D, Q);
        }, preDestroy: function() {
          this.clear(), this.removeCheckerboard(), this.anims.destroy(), this.anims = undefined, this.debugCallback = null, this.debugGraphic = null;
        } });
        M.exports = Z;
      }, 56015: (M, B, $) => {
        var E = $(25305), L = $(13059), z = $(44603), U = $(23568), K = $(35154), J = $(33663);
        z.register("plane", function(Z, D) {
          if (Z === undefined)
            Z = {};
          var Q = U(Z, "key", null), H = U(Z, "frame", null), N = K(Z, "width", 8), W = K(Z, "height", 8), R = K(Z, "tile", false), Y = new J(this.scene, 0, 0, Q, H, N, W, R);
          if (D !== undefined)
            Z.add = D;
          var I = K(Z, "checkerboard", null);
          if (I) {
            var P = K(I, "color1", 16777215), X = K(I, "color2", 255), G = K(I, "alpha1", 255), V = K(I, "alpha2", 255), A = K(I, "height", 128);
            Y.createCheckerboard(P, X, G, V, A);
          }
          return E(this.scene, Y, Z), L(Y, Z), Y;
        });
      }, 30985: (M, B, $) => {
        var E = $(33663), L = $(39429);
        L.register("plane", function(z, U, K, J, Z, D, Q) {
          return this.displayList.add(new E(this.scene, z, U, K, J, Z, D, Q));
        });
      }, 80321: (M, B, $) => {
        var E = $(83419), L = $(31401), z = $(95643), U = $(30100), K = $(36060), J = $(67277), Z = new E({ Extends: z, Mixins: [L.AlphaSingle, L.BlendMode, L.Depth, L.Mask, L.Pipeline, L.PostPipeline, L.ScrollFactor, L.Transform, L.Visible, J], initialize: function D(Q, H, N, W, R, Y, I) {
          if (W === undefined)
            W = 16777215;
          if (R === undefined)
            R = 128;
          if (Y === undefined)
            Y = 1;
          if (I === undefined)
            I = 0.1;
          z.call(this, Q, "PointLight"), this.initPipeline(K.POINTLIGHT_PIPELINE), this.initPostPipeline(), this.setPosition(H, N), this.color = U(W), this.intensity = Y, this.attenuation = I, this.width = R * 2, this.height = R * 2, this._radius = R;
        }, radius: { get: function() {
          return this._radius;
        }, set: function(D) {
          this._radius = D, this.width = D * 2, this.height = D * 2;
        } }, originX: { get: function() {
          return 0.5;
        } }, originY: { get: function() {
          return 0.5;
        } }, displayOriginX: { get: function() {
          return this._radius;
        } }, displayOriginY: { get: function() {
          return this._radius;
        } } });
        M.exports = Z;
      }, 39829: (M, B, $) => {
        var E = $(25305), L = $(44603), z = $(23568), U = $(80321);
        L.register("pointlight", function(K, J) {
          if (K === undefined)
            K = {};
          var Z = z(K, "color", 16777215), D = z(K, "radius", 128), Q = z(K, "intensity", 1), H = z(K, "attenuation", 0.1), N = new U(this.scene, 0, 0, Z, D, Q, H);
          if (J !== undefined)
            K.add = J;
          return E(this.scene, N, K), N;
        });
      }, 71255: (M, B, $) => {
        var E = $(39429), L = $(80321);
        E.register("pointlight", function(z, U, K, J, Z, D) {
          return this.displayList.add(new L(this.scene, z, U, K, J, Z, D));
        });
      }, 67277: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(57787), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 57787: (M, B, $) => {
        var E = $(91296), L = function(z, U, K, J) {
          K.addToRenderList(U);
          var Z = z.pipelines.set(U.pipeline), D = E(U, K, J).calc, Q = U.width, H = U.height, N = -U._radius, W = -U._radius, R = N + Q, Y = W + H, I = D.getX(0, 0), P = D.getY(0, 0), X = D.getX(N, W), G = D.getY(N, W), V = D.getX(N, Y), A = D.getY(N, Y), F = D.getX(R, Y), j = D.getY(R, Y), T = D.getX(R, W), C = D.getY(R, W);
          z.pipelines.preBatch(U), Z.batchPointLight(U, K, X, G, V, A, F, j, T, C, I, P), z.pipelines.postBatch(U);
        };
        M.exports = L;
      }, 591: (M, B, $) => {
        var E = $(83419), L = $(81320), z = $(88571), U = new E({ Extends: z, initialize: function K(J, Z, D, Q, H) {
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 32;
          if (H === undefined)
            H = 32;
          var N = new L(J.sys.textures, "", Q, H);
          z.call(this, J, Z, D, N), this.type = "RenderTexture", this.camera = this.texture.camera, this._saved = false;
        }, setSize: function(K, J) {
          this.width = K, this.height = J, this.texture.setSize(K, J), this.updateDisplayOrigin();
          var Z = this.input;
          if (Z && !Z.customHitArea)
            Z.hitArea.width = K, Z.hitArea.height = J;
          return this;
        }, resize: function(K, J) {
          return this.setSize(K, J), this;
        }, saveTexture: function(K) {
          var J = this.texture;
          if (J.key = K, J.manager.addDynamicTexture(J))
            this._saved = true;
          return J;
        }, fill: function(K, J, Z, D, Q, H) {
          return this.texture.fill(K, J, Z, D, Q, H), this;
        }, clear: function() {
          return this.texture.clear(), this;
        }, stamp: function(K, J, Z, D, Q) {
          return this.texture.stamp(K, J, Z, D, Q), this;
        }, erase: function(K, J, Z) {
          return this.texture.erase(K, J, Z), this;
        }, draw: function(K, J, Z, D, Q) {
          return this.texture.draw(K, J, Z, D, Q), this;
        }, drawFrame: function(K, J, Z, D, Q, H) {
          return this.texture.drawFrame(K, J, Z, D, Q, H), this;
        }, repeat: function(K, J, Z, D, Q, H, N, W, R) {
          return this.texture.repeat(K, J, Z, D, Q, H, N, W, R), this;
        }, beginDraw: function() {
          return this.texture.beginDraw(), this;
        }, batchDraw: function(K, J, Z, D, Q) {
          return this.texture.batchDraw(K, J, Z, D, Q), this;
        }, batchDrawFrame: function(K, J, Z, D, Q, H) {
          return this.texture.batchDrawFrame(K, J, Z, D, Q, H), this;
        }, endDraw: function(K) {
          return this.texture.endDraw(K), this;
        }, snapshotArea: function(K, J, Z, D, Q, H, N) {
          return this.texture.snapshotArea(K, J, Z, D, Q, H, N), this;
        }, snapshot: function(K, J, Z) {
          return this.snapshotArea(0, 0, this.width, this.height, K, J, Z);
        }, snapshotPixel: function(K, J, Z) {
          return this.snapshotArea(K, J, 1, 1, Z, "pixel");
        }, preDestroy: function() {
          if (this.camera = null, !this._saved)
            this.texture.destroy();
        } });
        M.exports = U;
      }, 34495: (M, B, $) => {
        var E = $(25305), L = $(44603), z = $(23568), U = $(591);
        L.register("renderTexture", function(K, J) {
          if (K === undefined)
            K = {};
          var Z = z(K, "x", 0), D = z(K, "y", 0), Q = z(K, "width", 32), H = z(K, "height", 32), N = new U(this.scene, Z, D, Q, H);
          if (J !== undefined)
            K.add = J;
          return E(this.scene, N, K), N;
        });
      }, 60505: (M, B, $) => {
        var E = $(39429), L = $(591);
        E.register("renderTexture", function(z, U, K, J) {
          return this.displayList.add(new L(this.scene, z, U, K, J));
        });
      }, 77757: (M, B, $) => {
        var E = $(9674), L = $(83419), z = $(31401), U = $(95643), K = $(36060), J = $(38745), Z = $(26099), D = new L({ Extends: U, Mixins: [z.AlphaSingle, z.BlendMode, z.Depth, z.Flip, z.Mask, z.Pipeline, z.PostPipeline, z.Size, z.Texture, z.Transform, z.Visible, z.ScrollFactor, J], initialize: function Q(H, N, W, R, Y, I, P, X, G) {
          if (R === undefined)
            R = "__DEFAULT";
          if (I === undefined)
            I = 2;
          if (P === undefined)
            P = true;
          if (U.call(this, H, "Rope"), this.anims = new E(this), this.points = I, this.vertices, this.uv, this.colors, this.alphas, this.tintFill = R === "__DEFAULT" ? true : false, this.dirty = false, this.horizontal = P, this._flipX = false, this._flipY = false, this._perp = new Z, this.debugCallback = null, this.debugGraphic = null, this.setTexture(R, Y), this.setPosition(N, W), this.setSizeToFrame(), this.initPipeline(K.ROPE_PIPELINE), this.initPostPipeline(), Array.isArray(I))
            this.resizeArrays(I.length);
          this.setPoints(I, X, G), this.updateVertices();
        }, addedToScene: function() {
          this.scene.sys.updateList.add(this);
        }, removedFromScene: function() {
          this.scene.sys.updateList.remove(this);
        }, preUpdate: function(Q, H) {
          var N = this.anims.currentFrame;
          if (this.anims.update(Q, H), this.anims.currentFrame !== N)
            this.updateUVs(), this.updateVertices();
        }, play: function(Q, H, N) {
          return this.anims.play(Q, H, N), this;
        }, setDirty: function() {
          return this.dirty = true, this;
        }, setHorizontal: function(Q, H, N) {
          if (Q === undefined)
            Q = this.points.length;
          if (this.horizontal)
            return this;
          return this.horizontal = true, this.setPoints(Q, H, N);
        }, setVertical: function(Q, H, N) {
          if (Q === undefined)
            Q = this.points.length;
          if (!this.horizontal)
            return this;
          return this.horizontal = false, this.setPoints(Q, H, N);
        }, setTintFill: function(Q) {
          if (Q === undefined)
            Q = false;
          return this.tintFill = Q, this;
        }, setAlphas: function(Q, H) {
          var N = this.points.length;
          if (N < 1)
            return this;
          var W = this.alphas;
          if (Q === undefined)
            Q = [1];
          else if (!Array.isArray(Q) && H === undefined)
            Q = [Q];
          var R, Y = 0;
          if (H !== undefined)
            for (R = 0;R < N; R++)
              Y = R * 2, W[Y] = Q, W[Y + 1] = H;
          else if (Q.length === N)
            for (R = 0;R < N; R++)
              Y = R * 2, W[Y] = Q[R], W[Y + 1] = Q[R];
          else {
            var I = Q[0];
            for (R = 0;R < N; R++) {
              if (Y = R * 2, Q.length > Y)
                I = Q[Y];
              if (W[Y] = I, Q.length > Y + 1)
                I = Q[Y + 1];
              W[Y + 1] = I;
            }
          }
          return this;
        }, setColors: function(Q) {
          var H = this.points.length;
          if (H < 1)
            return this;
          var N = this.colors;
          if (Q === undefined)
            Q = [16777215];
          else if (!Array.isArray(Q))
            Q = [Q];
          var W, R = 0;
          if (Q.length === H)
            for (W = 0;W < H; W++)
              R = W * 2, N[R] = Q[W], N[R + 1] = Q[W];
          else {
            var Y = Q[0];
            for (W = 0;W < H; W++) {
              if (R = W * 2, Q.length > R)
                Y = Q[R];
              if (N[R] = Y, Q.length > R + 1)
                Y = Q[R + 1];
              N[R + 1] = Y;
            }
          }
          return this;
        }, setPoints: function(Q, H, N) {
          if (Q === undefined)
            Q = 2;
          if (typeof Q === "number") {
            var W = Q;
            if (W < 2)
              W = 2;
            Q = [];
            var R, Y, I;
            if (this.horizontal) {
              I = -this.frame.halfWidth, Y = this.frame.width / (W - 1);
              for (R = 0;R < W; R++)
                Q.push({ x: I + R * Y, y: 0 });
            } else {
              I = -this.frame.halfHeight, Y = this.frame.height / (W - 1);
              for (R = 0;R < W; R++)
                Q.push({ x: 0, y: I + R * Y });
            }
          }
          var P = Q.length, X = this.points.length;
          if (P < 1)
            return console.warn("Rope: Not enough points given"), this;
          else if (P === 1)
            Q.unshift({ x: 0, y: 0 }), P++;
          if (X !== P)
            this.resizeArrays(P);
          if (this.dirty = true, this.points = Q, this.updateUVs(), H !== undefined && H !== null)
            this.setColors(H);
          if (N !== undefined && N !== null)
            this.setAlphas(N);
          return this;
        }, updateUVs: function() {
          var Q = this.uv, H = this.points.length, N = this.frame.u0, W = this.frame.v0, R = this.frame.u1, Y = this.frame.v1, I = (R - N) / (H - 1), P = (Y - W) / (H - 1);
          for (var X = 0;X < H; X++) {
            var G = X * 4, V, A, F, j;
            if (this.horizontal) {
              if (this._flipX)
                V = R - X * I, F = R - X * I;
              else
                V = N + X * I, F = N + X * I;
              if (this._flipY)
                A = Y, j = W;
              else
                A = W, j = Y;
            } else {
              if (this._flipX)
                V = N, F = R;
              else
                V = R, F = N;
              if (this._flipY)
                A = Y - X * P, j = Y - X * P;
              else
                A = W + X * P, j = W + X * P;
            }
            Q[G + 0] = V, Q[G + 1] = A, Q[G + 2] = F, Q[G + 3] = j;
          }
          return this;
        }, resizeArrays: function(Q) {
          var H = this.colors, N = this.alphas;
          this.vertices = new Float32Array(Q * 4), this.uv = new Float32Array(Q * 4), H = new Uint32Array(Q * 2), N = new Float32Array(Q * 2);
          for (var W = 0;W < Q * 2; W++)
            H[W] = 16777215, N[W] = 1;
          return this.colors = H, this.alphas = N, this.dirty = true, this;
        }, updateVertices: function() {
          var Q = this._perp, H = this.points, N = this.vertices, W = H.length;
          if (this.dirty = false, W < 1)
            return;
          var R, Y = H[0], I = this.horizontal ? this.frame.halfHeight : this.frame.halfWidth;
          for (var P = 0;P < W; P++) {
            var X = H[P], G = P * 4;
            if (P < W - 1)
              R = H[P + 1];
            else
              R = X;
            Q.x = R.y - Y.y, Q.y = -(R.x - Y.x);
            var V = Q.length();
            Q.x /= V, Q.y /= V, Q.x *= I, Q.y *= I, N[G] = X.x + Q.x, N[G + 1] = X.y + Q.y, N[G + 2] = X.x - Q.x, N[G + 3] = X.y - Q.y, Y = X;
          }
          return this;
        }, setDebug: function(Q, H) {
          if (this.debugGraphic = Q, !Q && !H)
            this.debugCallback = null;
          else if (!H)
            this.debugCallback = this.renderDebugVerts;
          else
            this.debugCallback = H;
          return this;
        }, renderDebugVerts: function(Q, H, N) {
          var W = Q.debugGraphic, R = N[0], Y = N[1], I = N[2], P = N[3];
          W.lineBetween(R, Y, I, P);
          for (var X = 4;X < H; X += 4) {
            var G = N[X + 0], V = N[X + 1], A = N[X + 2], F = N[X + 3];
            W.lineBetween(R, Y, G, V), W.lineBetween(I, P, A, F), W.lineBetween(I, P, G, V), W.lineBetween(G, V, A, F), R = G, Y = V, I = A, P = F;
          }
        }, preDestroy: function() {
          this.anims.destroy(), this.anims = undefined, this.points = null, this.vertices = null, this.uv = null, this.colors = null, this.alphas = null, this.debugCallback = null, this.debugGraphic = null;
        }, flipX: { get: function() {
          return this._flipX;
        }, set: function(Q) {
          return this._flipX = Q, this.updateUVs();
        } }, flipY: { get: function() {
          return this._flipY;
        }, set: function(Q) {
          return this._flipY = Q, this.updateUVs();
        } } });
        M.exports = D;
      }, 95262: (M) => {
        var B = function() {
        };
        M.exports = B;
      }, 26209: (M, B, $) => {
        var E = $(25305), L = $(44603), z = $(23568), U = $(35154), K = $(77757);
        L.register("rope", function(J, Z) {
          if (J === undefined)
            J = {};
          var D = z(J, "key", null), Q = z(J, "frame", null), H = z(J, "horizontal", true), N = U(J, "points", undefined), W = U(J, "colors", undefined), R = U(J, "alphas", undefined), Y = new K(this.scene, 0, 0, D, Q, N, H, W, R);
          if (Z !== undefined)
            J.add = Z;
          return E(this.scene, Y, J), Y;
        });
      }, 96819: (M, B, $) => {
        var E = $(77757), L = $(39429);
        L.register("rope", function(z, U, K, J, Z, D, Q, H) {
          return this.displayList.add(new E(this.scene, z, U, K, J, Z, D, Q, H));
        });
      }, 38745: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(20439), z = $(95262), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 20439: (M, B, $) => {
        var E = $(91296), L = $(70554), z = function(U, K, J, Z) {
          J.addToRenderList(K);
          var D = U.pipelines.set(K.pipeline, K), Q = E(K, J, Z).calc, H = K.vertices, N = K.uv, W = K.colors, R = K.alphas, Y = K.alpha, I = L.getTintAppendFloatAlpha, P = J.roundPixels, X = H.length, G = Math.floor(X * 0.5);
          D.flush(), U.pipelines.preBatch(K);
          var V = D.setGameObject(K), A = D.vertexViewF32, F = D.vertexViewU32, j = D.vertexCount * D.currentShader.vertexComponentCount - 1, T = 0, C = K.tintFill;
          if (K.dirty)
            K.updateVertices();
          var v = K.debugCallback, O = [];
          for (var q = 0;q < X; q += 2) {
            var w = H[q + 0], g = H[q + 1], b = w * Q.a + g * Q.c + Q.e, x = w * Q.b + g * Q.d + Q.f;
            if (P)
              b = Math.round(b), x = Math.round(x);
            if (A[++j] = b, A[++j] = x, A[++j] = N[q + 0], A[++j] = N[q + 1], A[++j] = V, A[++j] = C, F[++j] = I(W[T], J.alpha * (R[T] * Y)), T++, v)
              O[q + 0] = b, O[q + 1] = x;
          }
          if (v)
            v.call(K, K, X, O);
          D.vertexCount += G, D.currentBatch.count = D.vertexCount - D.currentBatch.start, U.pipelines.postBatch(K);
        };
        M.exports = z;
      }, 20071: (M, B, $) => {
        var E = $(83419), L = $(31401), z = $(95643), U = $(95540), K = $(79291), J = $(61622), Z = $(25479), D = $(61340), Q = $(95428), H = $(92503), N = new E({ Extends: z, Mixins: [L.ComputedSize, L.Depth, L.GetBounds, L.Mask, L.Origin, L.ScrollFactor, L.Transform, L.Visible, Z], initialize: function W(R, Y, I, P, X, G, V, A) {
          if (I === undefined)
            I = 0;
          if (P === undefined)
            P = 0;
          if (X === undefined)
            X = 128;
          if (G === undefined)
            G = 128;
          z.call(this, R, "Shader"), this.blendMode = -1, this.shader;
          var F = R.sys.renderer;
          this.renderer = F, this.gl = F.gl, this.vertexData = new ArrayBuffer(6 * (Float32Array.BYTES_PER_ELEMENT * 2)), this.vertexBuffer = F.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW), this._deferSetShader = null, this._deferProjOrtho = null, this.program = null, this.bytes = new Uint8Array(this.vertexData), this.vertexViewF32 = new Float32Array(this.vertexData), this._tempMatrix1 = new D, this._tempMatrix2 = new D, this._tempMatrix3 = new D, this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.uniforms = {}, this.pointer = null, this._rendererWidth = F.width, this._rendererHeight = F.height, this._textureCount = 0, this.framebuffer = null, this.glTexture = null, this.renderToTexture = false, this.texture = null, this.setPosition(I, P), this.setSize(X, G), this.setOrigin(0.5, 0.5), this.setShader(Y, V, A), this.renderer.on(H.RESTORE_WEBGL, this.onContextRestored, this);
        }, willRender: function(W) {
          if (this.renderToTexture)
            return true;
          else
            return !(z.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & W.id);
        }, setRenderToTexture: function(W, R) {
          if (R === undefined)
            R = false;
          if (!this.renderToTexture) {
            var Y = this.width, I = this.height, P = this.renderer;
            if (this.glTexture = P.createTextureFromSource(null, Y, I, 0), this.framebuffer = P.createFramebuffer(Y, I, this.glTexture, false), this._rendererWidth = Y, this._rendererHeight = I, this.renderToTexture = true, this.projOrtho(0, this.width, this.height, 0), W)
              this.texture = this.scene.sys.textures.addGLTexture(W, this.glTexture);
          }
          if (this.shader)
            P.pipelines.clear(), this.load(), this.flush(), P.pipelines.rebind();
          return this;
        }, setShader: function(W, R, Y) {
          if (this.renderer.contextLost)
            return this._deferSetShader = { key: W, textures: R, textureData: Y }, this;
          if (R === undefined)
            R = [];
          if (typeof W === "string") {
            var I = this.scene.sys.cache.shader;
            if (!I.has(W))
              return console.warn("Shader missing: " + W), this;
            this.shader = I.get(W);
          } else
            this.shader = W;
          var P = this.gl, X = this.renderer;
          if (this.program)
            X.deleteProgram(this.program);
          var G = X.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc);
          P.uniformMatrix4fv(P.getUniformLocation(G.webGLProgram, "uViewMatrix"), false, this.viewMatrix), P.uniformMatrix4fv(P.getUniformLocation(G.webGLProgram, "uProjectionMatrix"), false, this.projectionMatrix), P.uniform2f(P.getUniformLocation(G.webGLProgram, "uResolution"), this.width, this.height), this.program = G;
          var V = new Date, A = { resolution: { type: "2f", value: { x: this.width, y: this.height } }, time: { type: "1f", value: 0 }, mouse: { type: "2f", value: { x: this.width / 2, y: this.height / 2 } }, date: { type: "4fv", value: [V.getFullYear(), V.getMonth(), V.getDate(), V.getHours() * 60 * 60 + V.getMinutes() * 60 + V.getSeconds()] }, sampleRate: { type: "1f", value: 44100 }, iChannel0: { type: "sampler2D", value: null, textureData: { repeat: true } }, iChannel1: { type: "sampler2D", value: null, textureData: { repeat: true } }, iChannel2: { type: "sampler2D", value: null, textureData: { repeat: true } }, iChannel3: { type: "sampler2D", value: null, textureData: { repeat: true } } };
          if (this.shader.uniforms)
            this.uniforms = K(true, {}, this.shader.uniforms, A);
          else
            this.uniforms = A;
          for (var F = 0;F < 4; F++)
            if (R[F])
              this.setSampler2D("iChannel" + F, R[F], F, Y);
          return this.initUniforms(), this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0), this;
        }, setPointer: function(W) {
          return this.pointer = W, this;
        }, projOrtho: function(W, R, Y, I) {
          if (this.renderer.contextLost) {
            this._deferProjOrtho = { left: W, right: R, bottom: Y, top: I };
            return;
          }
          var P = -1000, X = 1000, G = 1 / (W - R), V = 1 / (Y - I), A = 1 / (P - X), F = this.projectionMatrix;
          F[0] = -2 * G, F[5] = -2 * V, F[10] = 2 * A, F[12] = (W + R) * G, F[13] = (I + Y) * V, F[14] = (X + P) * A;
          var j = this.program, T = this.gl, C = this.renderer;
          C.setProgram(j), T.uniformMatrix4fv(T.getUniformLocation(j.webGLProgram, "uProjectionMatrix"), false, this.projectionMatrix), this._rendererWidth = R, this._rendererHeight = Y;
        }, initUniforms: function() {
          var W = this.renderer.glFuncMap, R = this.program;
          this._textureCount = 0;
          for (var Y in this.uniforms) {
            var I = this.uniforms[Y], P = I.type, X = W[P];
            if (I.uniformLocation = this.renderer.createUniformLocation(R, Y), P !== "sampler2D")
              I.glMatrix = X.matrix, I.glValueLength = X.length, I.glFunc = X.func;
          }
        }, setSampler2DBuffer: function(W, R, Y, I, P, X) {
          if (P === undefined)
            P = 0;
          if (X === undefined)
            X = {};
          var G = this.uniforms[W];
          return G.value = R, X.width = Y, X.height = I, G.textureData = X, this._textureCount = P, this.initSampler2D(G), this;
        }, setSampler2D: function(W, R, Y, I) {
          if (Y === undefined)
            Y = 0;
          var P = this.scene.sys.textures;
          if (P.exists(R)) {
            var X = P.getFrame(R);
            if (X.glTexture && X.glTexture.isRenderTexture)
              return this.setSampler2DBuffer(W, X.glTexture, X.width, X.height, Y, I);
            var G = this.uniforms[W], V = X.source;
            if (G.textureKey = R, G.source = V.image, G.value = X.glTexture, V.isGLTexture) {
              if (!I)
                I = {};
              I.width = V.width, I.height = V.height;
            }
            if (I)
              G.textureData = I;
            this._textureCount = Y, this.initSampler2D(G);
          }
          return this;
        }, setUniform: function(W, R) {
          return J(this.uniforms, W, R), this;
        }, getUniform: function(W) {
          return U(this.uniforms, W, null);
        }, setChannel0: function(W, R) {
          return this.setSampler2D("iChannel0", W, 0, R);
        }, setChannel1: function(W, R) {
          return this.setSampler2D("iChannel1", W, 1, R);
        }, setChannel2: function(W, R) {
          return this.setSampler2D("iChannel2", W, 2, R);
        }, setChannel3: function(W, R) {
          return this.setSampler2D("iChannel3", W, 3, R);
        }, initSampler2D: function(W) {
          if (!W.value)
            return;
          var R = W.textureData;
          if (R && !W.value.isRenderTexture) {
            var Y = this.gl, I = W.value, P = Y[U(R, "magFilter", "linear").toUpperCase()], X = Y[U(R, "minFilter", "linear").toUpperCase()], G = Y[U(R, "wrapS", "repeat").toUpperCase()], V = Y[U(R, "wrapT", "repeat").toUpperCase()], A = Y[U(R, "format", "rgba").toUpperCase()], F = U(R, "flipY", false), j = U(R, "width", I.width), T = U(R, "height", I.height), C = U(R, "source", I.pixels);
            if (R.repeat)
              G = Y.REPEAT, V = Y.REPEAT;
            if (R.width)
              C = null;
            I.update(C, j, T, F, G, V, X, P, A);
          }
          this.renderer.setProgram(this.program), this._textureCount++;
        }, syncUniforms: function() {
          var W = this.gl, R = this.uniforms, Y, I, P, X, G, V = 0;
          for (var A in R) {
            if (Y = R[A], P = Y.glFunc, I = Y.glValueLength, X = Y.uniformLocation, G = Y.value, G === null)
              continue;
            if (I === 1)
              if (Y.glMatrix)
                P.call(W, X.webGLUniformLocation, Y.transpose, G);
              else
                P.call(W, X.webGLUniformLocation, G);
            else if (I === 2)
              P.call(W, X.webGLUniformLocation, G.x, G.y);
            else if (I === 3)
              P.call(W, X.webGLUniformLocation, G.x, G.y, G.z);
            else if (I === 4)
              P.call(W, X.webGLUniformLocation, G.x, G.y, G.z, G.w);
            else if (Y.type === "sampler2D")
              W.activeTexture(W.TEXTURE0 + V), W.bindTexture(W.TEXTURE_2D, G.webGLTexture), W.uniform1i(X.webGLUniformLocation, V), V++;
          }
        }, load: function(W) {
          var R = this.gl, Y = this.width, I = this.height, P = this.renderer, X = this.program, G = this.viewMatrix;
          if (!this.renderToTexture) {
            var V = -this._displayOriginX, A = -this._displayOriginY;
            G[0] = W[0], G[1] = W[1], G[4] = W[2], G[5] = W[3], G[8] = W[4], G[9] = W[5], G[12] = G[0] * V + G[4] * A, G[13] = G[1] * V + G[5] * A;
          }
          R.useProgram(X.webGLProgram), R.uniformMatrix4fv(R.getUniformLocation(X.webGLProgram, "uViewMatrix"), false, G), R.uniformMatrix4fv(R.getUniformLocation(X.webGLProgram, "uProjectionMatrix"), false, this.projectionMatrix), R.uniform2f(R.getUniformLocation(X.webGLProgram, "uResolution"), this.width, this.height);
          var F = this.uniforms, j = F.resolution;
          j.value.x = Y, j.value.y = I, F.time.value = P.game.loop.getDuration();
          var T = this.pointer;
          if (T) {
            var C = F.mouse, v = T.x / Y, O = 1 - T.y / I;
            C.value.x = v.toFixed(2), C.value.y = O.toFixed(2);
          }
          this.syncUniforms();
        }, flush: function() {
          var W = this.width, R = this.height, Y = this.program, I = this.gl, P = this.vertexBuffer, X = this.renderer, G = Float32Array.BYTES_PER_ELEMENT * 2;
          if (this.renderToTexture)
            X.setFramebuffer(this.framebuffer), I.clearColor(0, 0, 0, 0), I.clear(I.COLOR_BUFFER_BIT);
          I.bindBuffer(I.ARRAY_BUFFER, P.webGLBuffer);
          var V = I.getAttribLocation(Y.webGLProgram, "inPosition");
          if (V !== -1)
            I.enableVertexAttribArray(V), I.vertexAttribPointer(V, 2, I.FLOAT, false, G, 0);
          var A = this.vertexViewF32;
          A[3] = R, A[4] = W, A[5] = R, A[8] = W, A[9] = R, A[10] = W;
          var F = 6;
          if (I.bufferSubData(I.ARRAY_BUFFER, 0, this.bytes.subarray(0, F * G)), I.drawArrays(I.TRIANGLES, 0, F), this.renderToTexture)
            X.setFramebuffer(null, false);
        }, setAlpha: function() {
        }, setBlendMode: function() {
        }, onContextRestored: function() {
          if (this._deferSetShader !== null) {
            var W = this._deferSetShader.key, R = this._deferSetShader.textures, Y = this._deferSetShader.textureData;
            this._deferSetShader = null, this.setShader(W, R, Y);
          }
          if (this._deferProjOrtho !== null) {
            var I = this._deferProjOrtho.left, P = this._deferProjOrtho.right, X = this._deferProjOrtho.bottom, G = this._deferProjOrtho.top;
            this._deferProjOrtho = null, this.projOrtho(I, P, X, G);
          }
        }, preDestroy: function() {
          var W = this.renderer;
          if (W.off(H.RESTORE_WEBGL, this.onContextRestored, this), W.deleteProgram(this.program), W.deleteBuffer(this.vertexBuffer), this.renderToTexture)
            W.deleteFramebuffer(this.framebuffer), this.texture.destroy(), this.framebuffer = null, this.glTexture = null, this.texture = null;
          Q(this.uniforms, function(R) {
            W.deleteUniformLocation(R.uniformLocation), R.uniformLocation = null;
          });
        } });
        M.exports = N;
      }, 80464: (M) => {
        var B = function() {
        };
        M.exports = B;
      }, 54935: (M, B, $) => {
        var E = $(25305), L = $(44603), z = $(23568), U = $(20071);
        L.register("shader", function(K, J) {
          if (K === undefined)
            K = {};
          var Z = z(K, "key", null), D = z(K, "x", 0), Q = z(K, "y", 0), H = z(K, "width", 128), N = z(K, "height", 128), W = new U(this.scene, Z, D, Q, H, N);
          if (J !== undefined)
            K.add = J;
          return E(this.scene, W, K), W;
        });
      }, 74177: (M, B, $) => {
        var E = $(20071), L = $(39429);
        L.register("shader", function(z, U, K, J, Z, D, Q) {
          return this.displayList.add(new E(this.scene, z, U, K, J, Z, D, Q));
        });
      }, 25479: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(19257), z = $(80464), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 19257: (M, B, $) => {
        var E = $(91296), L = function(z, U, K, J) {
          if (!U.shader)
            return;
          if (K.addToRenderList(U), z.pipelines.clear(), U.renderToTexture)
            U.load(), U.flush();
          else {
            var Z = E(U, K, J).calc;
            if (z.width !== U._rendererWidth || z.height !== U._rendererHeight)
              U.projOrtho(0, z.width, z.height, 0);
            U.load(Z.matrix), U.flush();
          }
          z.pipelines.rebind();
        };
        M.exports = L;
      }, 10441: (M, B, $) => {
        var E = $(70554), L = function(z, U, K, J, Z, D) {
          var Q = E.getTintAppendFloatAlpha(K.fillColor, K.fillAlpha * J), H = K.pathData, N = K.pathIndexes;
          for (var W = 0;W < N.length; W += 3) {
            var R = N[W] * 2, Y = N[W + 1] * 2, I = N[W + 2] * 2, P = H[R + 0] - Z, X = H[R + 1] - D, G = H[Y + 0] - Z, V = H[Y + 1] - D, A = H[I + 0] - Z, F = H[I + 1] - D, j = U.getX(P, X), T = U.getY(P, X), C = U.getX(G, V), v = U.getY(G, V), O = U.getX(A, F), q = U.getY(A, F);
            z.batchTri(K, j, T, C, v, O, q, 0, 0, 1, 1, Q, Q, Q, 2);
          }
        };
        M.exports = L;
      }, 65960: (M) => {
        var B = function($, E, L, z) {
          var U = L ? L : E.fillColor, K = z ? z : E.fillAlpha, J = (U & 16711680) >>> 16, Z = (U & 65280) >>> 8, D = U & 255;
          $.fillStyle = "rgba(" + J + "," + Z + "," + D + "," + K + ")";
        };
        M.exports = B;
      }, 75177: (M) => {
        var B = function($, E, L, z) {
          var U = L ? L : E.strokeColor, K = z ? z : E.strokeAlpha, J = (U & 16711680) >>> 16, Z = (U & 65280) >>> 8, D = U & 255;
          $.strokeStyle = "rgba(" + J + "," + Z + "," + D + "," + K + ")", $.lineWidth = E.lineWidth;
        };
        M.exports = B;
      }, 17803: (M, B, $) => {
        var E = $(83419), L = $(31401), z = $(95643), U = $(23031), K = new E({ Extends: z, Mixins: [L.AlphaSingle, L.BlendMode, L.Depth, L.GetBounds, L.Mask, L.Origin, L.Pipeline, L.PostPipeline, L.ScrollFactor, L.Transform, L.Visible], initialize: function J(Z, D, Q) {
          if (D === undefined)
            D = "Shape";
          z.call(this, Z, D), this.geom = Q, this.pathData = [], this.pathIndexes = [], this.fillColor = 16777215, this.fillAlpha = 1, this.strokeColor = 16777215, this.strokeAlpha = 1, this.lineWidth = 1, this.isFilled = false, this.isStroked = false, this.closePath = true, this._tempLine = new U, this.width = 0, this.height = 0, this.initPipeline(), this.initPostPipeline();
        }, setFillStyle: function(J, Z) {
          if (Z === undefined)
            Z = 1;
          if (J === undefined)
            this.isFilled = false;
          else
            this.fillColor = J, this.fillAlpha = Z, this.isFilled = true;
          return this;
        }, setStrokeStyle: function(J, Z, D) {
          if (D === undefined)
            D = 1;
          if (J === undefined)
            this.isStroked = false;
          else
            this.lineWidth = J, this.strokeColor = Z, this.strokeAlpha = D, this.isStroked = true;
          return this;
        }, setClosePath: function(J) {
          return this.closePath = J, this;
        }, setSize: function(J, Z) {
          return this.width = J, this.height = Z, this;
        }, setDisplaySize: function(J, Z) {
          return this.displayWidth = J, this.displayHeight = Z, this;
        }, preDestroy: function() {
          this.geom = null, this._tempLine = null, this.pathData = [], this.pathIndexes = [];
        }, displayWidth: { get: function() {
          return this.scaleX * this.width;
        }, set: function(J) {
          this.scaleX = J / this.width;
        } }, displayHeight: { get: function() {
          return this.scaleY * this.height;
        }, set: function(J) {
          this.scaleY = J / this.height;
        } } });
        M.exports = K;
      }, 34682: (M, B, $) => {
        var E = $(70554), L = function(z, U, K, J, Z) {
          var D = z.strokeTint, Q = E.getTintAppendFloatAlpha(U.strokeColor, U.strokeAlpha * K);
          D.TL = Q, D.TR = Q, D.BL = Q, D.BR = Q;
          var H = U.pathData, N = H.length - 1, W = U.lineWidth, R = W / 2, Y = H[0] - J, I = H[1] - Z;
          if (!U.closePath)
            N -= 2;
          for (var P = 2;P < N; P += 2) {
            var X = H[P] - J, G = H[P + 1] - Z;
            z.batchLine(Y, I, X, G, R, R, W, P - 2, U.closePath ? P === N - 1 : false), Y = X, I = G;
          }
        };
        M.exports = L;
      }, 23629: (M, B, $) => {
        var E = $(13609), L = $(83419), z = $(39506), U = $(94811), K = $(96503), J = $(36383), Z = $(17803), D = new L({ Extends: Z, Mixins: [E], initialize: function Q(H, N, W, R, Y, I, P, X, G) {
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = 0;
          if (R === undefined)
            R = 128;
          if (Y === undefined)
            Y = 0;
          if (I === undefined)
            I = 360;
          if (P === undefined)
            P = false;
          Z.call(this, H, "Arc", new K(0, 0, R)), this._startAngle = Y, this._endAngle = I, this._anticlockwise = P, this._iterations = 0.01, this.setPosition(N, W);
          var V = this.geom.radius * 2;
          if (this.setSize(V, V), X !== undefined)
            this.setFillStyle(X, G);
          this.updateDisplayOrigin(), this.updateData();
        }, iterations: { get: function() {
          return this._iterations;
        }, set: function(Q) {
          this._iterations = Q, this.updateData();
        } }, radius: { get: function() {
          return this.geom.radius;
        }, set: function(Q) {
          this.geom.radius = Q;
          var H = Q * 2;
          this.setSize(H, H), this.updateDisplayOrigin(), this.updateData();
        } }, startAngle: { get: function() {
          return this._startAngle;
        }, set: function(Q) {
          this._startAngle = Q, this.updateData();
        } }, endAngle: { get: function() {
          return this._endAngle;
        }, set: function(Q) {
          this._endAngle = Q, this.updateData();
        } }, anticlockwise: { get: function() {
          return this._anticlockwise;
        }, set: function(Q) {
          this._anticlockwise = Q, this.updateData();
        } }, setRadius: function(Q) {
          return this.radius = Q, this;
        }, setIterations: function(Q) {
          if (Q === undefined)
            Q = 0.01;
          return this.iterations = Q, this;
        }, setStartAngle: function(Q, H) {
          if (this._startAngle = Q, H !== undefined)
            this._anticlockwise = H;
          return this.updateData();
        }, setEndAngle: function(Q, H) {
          if (this._endAngle = Q, H !== undefined)
            this._anticlockwise = H;
          return this.updateData();
        }, updateData: function() {
          var Q = this._iterations, H = Q, N = this.geom.radius, W = z(this._startAngle), R = z(this._endAngle), Y = this._anticlockwise, I = N, P = N;
          if (R -= W, Y) {
            if (R < -J.PI2)
              R = -J.PI2;
            else if (R > 0)
              R = -J.PI2 + R % J.PI2;
          } else if (R > J.PI2)
            R = J.PI2;
          else if (R < 0)
            R = J.PI2 + R % J.PI2;
          var X = [I + Math.cos(W) * N, P + Math.sin(W) * N], G;
          while (H < 1)
            G = R * H + W, X.push(I + Math.cos(G) * N, P + Math.sin(G) * N), H += Q;
          return G = R + W, X.push(I + Math.cos(G) * N, P + Math.sin(G) * N), X.push(I + Math.cos(W) * N, P + Math.sin(W) * N), this.pathIndexes = U(X), this.pathData = X, this;
        } });
        M.exports = D;
      }, 42542: (M, B, $) => {
        var E = $(39506), L = $(65960), z = $(75177), U = $(20926), K = function(J, Z, D, Q) {
          D.addToRenderList(Z);
          var H = J.currentContext;
          if (U(J, H, Z, D, Q)) {
            var N = Z.radius;
            if (H.beginPath(), H.arc(N - Z.originX * (N * 2), N - Z.originY * (N * 2), N, E(Z._startAngle), E(Z._endAngle), Z.anticlockwise), Z.closePath)
              H.closePath();
            if (Z.isFilled)
              L(H, Z), H.fill();
            if (Z.isStroked)
              z(H, Z), H.stroke();
            H.restore();
          }
        };
        M.exports = K;
      }, 42563: (M, B, $) => {
        var E = $(23629), L = $(39429);
        L.register("arc", function(z, U, K, J, Z, D, Q, H) {
          return this.displayList.add(new E(this.scene, z, U, K, J, Z, D, Q, H));
        }), L.register("circle", function(z, U, K, J, Z) {
          return this.displayList.add(new E(this.scene, z, U, K, 0, 360, false, J, Z));
        });
      }, 13609: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(41447), z = $(42542), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 41447: (M, B, $) => {
        var E = $(91296), L = $(10441), z = $(34682), U = function(K, J, Z, D) {
          Z.addToRenderList(J);
          var Q = K.pipelines.set(J.pipeline), H = E(J, Z, D), N = Q.calcMatrix.copyFrom(H.calc), W = J._displayOriginX, R = J._displayOriginY, Y = Z.alpha * J.alpha;
          if (K.pipelines.preBatch(J), J.isFilled)
            L(Q, N, J, Y, W, R);
          if (J.isStroked)
            z(Q, J, Y, W, R);
          K.pipelines.postBatch(J);
        };
        M.exports = U;
      }, 89: (M, B, $) => {
        var E = $(83419), L = $(33141), z = $(94811), U = $(87841), K = $(17803), J = new E({ Extends: K, Mixins: [L], initialize: function Z(D, Q, H, N, W, R) {
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 0;
          if (K.call(this, D, "Curve", N), this._smoothness = 32, this._curveBounds = new U, this.closePath = false, this.setPosition(Q, H), W !== undefined)
            this.setFillStyle(W, R);
          this.updateData();
        }, smoothness: { get: function() {
          return this._smoothness;
        }, set: function(Z) {
          this._smoothness = Z, this.updateData();
        } }, setSmoothness: function(Z) {
          return this._smoothness = Z, this.updateData();
        }, updateData: function() {
          var Z = this._curveBounds, D = this._smoothness;
          this.geom.getBounds(Z, D), this.setSize(Z.width, Z.height), this.updateDisplayOrigin();
          var Q = [], H = this.geom.getPoints(D);
          for (var N = 0;N < H.length; N++)
            Q.push(H[N].x, H[N].y);
          return Q.push(H[0].x, H[0].y), this.pathIndexes = z(Q), this.pathData = Q, this;
        } });
        M.exports = J;
      }, 3170: (M, B, $) => {
        var E = $(65960), L = $(75177), z = $(20926), U = function(K, J, Z, D) {
          Z.addToRenderList(J);
          var Q = K.currentContext;
          if (z(K, Q, J, Z, D)) {
            var H = J._displayOriginX + J._curveBounds.x, N = J._displayOriginY + J._curveBounds.y, W = J.pathData, R = W.length - 1, Y = W[0] - H, I = W[1] - N;
            if (Q.beginPath(), Q.moveTo(Y, I), !J.closePath)
              R -= 2;
            for (var P = 2;P < R; P += 2) {
              var X = W[P] - H, G = W[P + 1] - N;
              Q.lineTo(X, G);
            }
            if (J.closePath)
              Q.closePath();
            if (J.isFilled)
              E(Q, J), Q.fill();
            if (J.isStroked)
              L(Q, J), Q.stroke();
            Q.restore();
          }
        };
        M.exports = U;
      }, 40511: (M, B, $) => {
        var E = $(39429), L = $(89);
        E.register("curve", function(z, U, K, J, Z) {
          return this.displayList.add(new L(this.scene, z, U, K, J, Z));
        });
      }, 33141: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(53987), z = $(3170), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 53987: (M, B, $) => {
        var E = $(10441), L = $(91296), z = $(34682), U = function(K, J, Z, D) {
          Z.addToRenderList(J);
          var Q = K.pipelines.set(J.pipeline), H = L(J, Z, D), N = Q.calcMatrix.copyFrom(H.calc), W = J._displayOriginX + J._curveBounds.x, R = J._displayOriginY + J._curveBounds.y, Y = Z.alpha * J.alpha;
          if (K.pipelines.preBatch(J), J.isFilled)
            E(Q, N, J, Y, W, R);
          if (J.isStroked)
            z(Q, J, Y, W, R);
          K.pipelines.postBatch(J);
        };
        M.exports = U;
      }, 19921: (M, B, $) => {
        var E = $(83419), L = $(94811), z = $(54205), U = $(8497), K = $(17803), J = new E({ Extends: K, Mixins: [z], initialize: function Z(D, Q, H, N, W, R, Y) {
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = 128;
          if (W === undefined)
            W = 128;
          if (K.call(this, D, "Ellipse", new U(N / 2, W / 2, N, W)), this._smoothness = 64, this.setPosition(Q, H), this.width = N, this.height = W, R !== undefined)
            this.setFillStyle(R, Y);
          this.updateDisplayOrigin(), this.updateData();
        }, smoothness: { get: function() {
          return this._smoothness;
        }, set: function(Z) {
          this._smoothness = Z, this.updateData();
        } }, setSize: function(Z, D) {
          return this.width = Z, this.height = D, this.geom.setPosition(Z / 2, D / 2), this.geom.setSize(Z, D), this.updateData();
        }, setSmoothness: function(Z) {
          return this._smoothness = Z, this.updateData();
        }, updateData: function() {
          var Z = [], D = this.geom.getPoints(this._smoothness);
          for (var Q = 0;Q < D.length; Q++)
            Z.push(D[Q].x, D[Q].y);
          return Z.push(D[0].x, D[0].y), this.pathIndexes = L(Z), this.pathData = Z, this;
        } });
        M.exports = J;
      }, 7930: (M, B, $) => {
        var E = $(65960), L = $(75177), z = $(20926), U = function(K, J, Z, D) {
          Z.addToRenderList(J);
          var Q = K.currentContext;
          if (z(K, Q, J, Z, D)) {
            var { _displayOriginX: H, _displayOriginY: N, pathData: W } = J, R = W.length - 1, Y = W[0] - H, I = W[1] - N;
            if (Q.beginPath(), Q.moveTo(Y, I), !J.closePath)
              R -= 2;
            for (var P = 2;P < R; P += 2) {
              var X = W[P] - H, G = W[P + 1] - N;
              Q.lineTo(X, G);
            }
            if (Q.closePath(), J.isFilled)
              E(Q, J), Q.fill();
            if (J.isStroked)
              L(Q, J), Q.stroke();
            Q.restore();
          }
        };
        M.exports = U;
      }, 1543: (M, B, $) => {
        var E = $(19921), L = $(39429);
        L.register("ellipse", function(z, U, K, J, Z, D) {
          return this.displayList.add(new E(this.scene, z, U, K, J, Z, D));
        });
      }, 54205: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(19467), z = $(7930), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 19467: (M, B, $) => {
        var E = $(10441), L = $(91296), z = $(34682), U = function(K, J, Z, D) {
          Z.addToRenderList(J);
          var Q = K.pipelines.set(J.pipeline), H = L(J, Z, D), N = Q.calcMatrix.copyFrom(H.calc), W = J._displayOriginX, R = J._displayOriginY, Y = Z.alpha * J.alpha;
          if (K.pipelines.preBatch(J), J.isFilled)
            E(Q, N, J, Y, W, R);
          if (J.isStroked)
            z(Q, J, Y, W, R);
          K.pipelines.postBatch(J);
        };
        M.exports = U;
      }, 30479: (M, B, $) => {
        var E = $(83419), L = $(17803), z = $(26015), U = new E({ Extends: L, Mixins: [z], initialize: function K(J, Z, D, Q, H, N, W, R, Y, I, P) {
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 128;
          if (H === undefined)
            H = 128;
          if (N === undefined)
            N = 32;
          if (W === undefined)
            W = 32;
          if (L.call(this, J, "Grid", null), this.cellWidth = N, this.cellHeight = W, this.showCells = true, this.outlineFillColor = 0, this.outlineFillAlpha = 0, this.showOutline = true, this.showAltCells = false, this.altFillColor, this.altFillAlpha, this.setPosition(Z, D), this.setSize(Q, H), this.setFillStyle(R, Y), I !== undefined)
            this.setOutlineStyle(I, P);
          this.updateDisplayOrigin();
        }, setFillStyle: function(K, J) {
          if (J === undefined)
            J = 1;
          if (K === undefined)
            this.showCells = false;
          else
            this.fillColor = K, this.fillAlpha = J, this.showCells = true;
          return this;
        }, setAltFillStyle: function(K, J) {
          if (J === undefined)
            J = 1;
          if (K === undefined)
            this.showAltCells = false;
          else
            this.altFillColor = K, this.altFillAlpha = J, this.showAltCells = true;
          return this;
        }, setOutlineStyle: function(K, J) {
          if (J === undefined)
            J = 1;
          if (K === undefined)
            this.showOutline = false;
          else
            this.outlineFillColor = K, this.outlineFillAlpha = J, this.showOutline = true;
          return this;
        } });
        M.exports = U;
      }, 49912: (M, B, $) => {
        var E = $(65960), L = $(75177), z = $(20926), U = function(K, J, Z, D) {
          Z.addToRenderList(J);
          var Q = K.currentContext;
          if (z(K, Q, J, Z, D)) {
            var H = -J._displayOriginX, N = -J._displayOriginY, W = Z.alpha * J.alpha, R = J.width, Y = J.height, I = J.cellWidth, P = J.cellHeight, X = Math.ceil(R / I), G = Math.ceil(Y / P), V = I, A = P, F = I - (X * I - R), j = P - (G * P - Y), T = J.showCells, C = J.showAltCells, v = J.showOutline, O = 0, q = 0, w = 0, g = 0, b = 0;
            if (v) {
              if (V--, A--, F === I)
                F--;
              if (j === P)
                j--;
            }
            if (T && J.fillAlpha > 0) {
              E(Q, J);
              for (q = 0;q < G; q++) {
                if (C)
                  w = q % 2;
                for (O = 0;O < X; O++) {
                  if (C && w) {
                    w = 0;
                    continue;
                  }
                  w++, g = O < X - 1 ? V : F, b = q < G - 1 ? A : j, Q.fillRect(H + O * I, N + q * P, g, b);
                }
              }
            }
            if (C && J.altFillAlpha > 0) {
              E(Q, J, J.altFillColor, J.altFillAlpha * W);
              for (q = 0;q < G; q++) {
                if (C)
                  w = q % 2;
                for (O = 0;O < X; O++) {
                  if (C && !w) {
                    w = 1;
                    continue;
                  }
                  w = 0, g = O < X - 1 ? V : F, b = q < G - 1 ? A : j, Q.fillRect(H + O * I, N + q * P, g, b);
                }
              }
            }
            if (v && J.outlineFillAlpha > 0) {
              L(Q, J, J.outlineFillColor, J.outlineFillAlpha * W);
              for (O = 1;O < X; O++) {
                var x = O * I;
                Q.beginPath(), Q.moveTo(x + H, N), Q.lineTo(x + H, Y + N), Q.stroke();
              }
              for (q = 1;q < G; q++) {
                var k = q * P;
                Q.beginPath(), Q.moveTo(H, k + N), Q.lineTo(H + R, k + N), Q.stroke();
              }
            }
            Q.restore();
          }
        };
        M.exports = U;
      }, 34137: (M, B, $) => {
        var E = $(39429), L = $(30479);
        E.register("grid", function(z, U, K, J, Z, D, Q, H, N, W) {
          return this.displayList.add(new L(this.scene, z, U, K, J, Z, D, Q, H, N, W));
        });
      }, 26015: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(46161), z = $(49912), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 46161: (M, B, $) => {
        var E = $(91296), L = $(70554), z = function(U, K, J, Z) {
          J.addToRenderList(K);
          var D = U.pipelines.set(K.pipeline), Q = E(K, J, Z), H = D.calcMatrix.copyFrom(Q.calc);
          H.translate(-K._displayOriginX, -K._displayOriginY);
          var N = J.alpha * K.alpha, W = K.width, R = K.height, Y = K.cellWidth, I = K.cellHeight, P = Math.ceil(W / Y), X = Math.ceil(R / I), G = Y, V = I, A = Y - (P * Y - W), F = I - (X * I - R), j, T, C = K.showCells, v = K.showAltCells, O = K.showOutline, q = 0, w = 0, g = 0, b = 0, x = 0;
          if (O) {
            if (G--, V--, A === Y)
              A--;
            if (F === I)
              F--;
          }
          if (U.pipelines.preBatch(K), C && K.fillAlpha > 0) {
            j = D.fillTint, T = L.getTintAppendFloatAlpha(K.fillColor, K.fillAlpha * N), j.TL = T, j.TR = T, j.BL = T, j.BR = T;
            for (w = 0;w < X; w++) {
              if (v)
                g = w % 2;
              for (q = 0;q < P; q++) {
                if (v && g) {
                  g = 0;
                  continue;
                }
                g++, b = q < P - 1 ? G : A, x = w < X - 1 ? V : F, D.batchFillRect(q * Y, w * I, b, x);
              }
            }
          }
          if (v && K.altFillAlpha > 0) {
            j = D.fillTint, T = L.getTintAppendFloatAlpha(K.altFillColor, K.altFillAlpha * N), j.TL = T, j.TR = T, j.BL = T, j.BR = T;
            for (w = 0;w < X; w++) {
              if (v)
                g = w % 2;
              for (q = 0;q < P; q++) {
                if (v && !g) {
                  g = 1;
                  continue;
                }
                g = 0, b = q < P - 1 ? G : A, x = w < X - 1 ? V : F, D.batchFillRect(q * Y, w * I, b, x);
              }
            }
          }
          if (O && K.outlineFillAlpha > 0) {
            var k = D.strokeTint, S = L.getTintAppendFloatAlpha(K.outlineFillColor, K.outlineFillAlpha * N);
            k.TL = S, k.TR = S, k.BL = S, k.BR = S;
            for (q = 1;q < P; q++) {
              var f = q * Y;
              D.batchLine(f, 0, f, R, 1, 1, 1, 0, false);
            }
            for (w = 1;w < X; w++) {
              var h = w * I;
              D.batchLine(0, h, W, h, 1, 1, 1, 0, false);
            }
          }
          U.pipelines.postBatch(K);
        };
        M.exports = z;
      }, 61475: (M, B, $) => {
        var E = $(99651), L = $(83419), z = $(17803), U = new L({ Extends: z, Mixins: [E], initialize: function K(J, Z, D, Q, H, N, W, R) {
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 48;
          if (H === undefined)
            H = 32;
          if (N === undefined)
            N = 15658734;
          if (W === undefined)
            W = 10066329;
          if (R === undefined)
            R = 13421772;
          z.call(this, J, "IsoBox", null), this.projection = 4, this.fillTop = N, this.fillLeft = W, this.fillRight = R, this.showTop = true, this.showLeft = true, this.showRight = true, this.isFilled = true, this.setPosition(Z, D), this.setSize(Q, H), this.updateDisplayOrigin();
        }, setProjection: function(K) {
          return this.projection = K, this;
        }, setFaces: function(K, J, Z) {
          if (K === undefined)
            K = true;
          if (J === undefined)
            J = true;
          if (Z === undefined)
            Z = true;
          return this.showTop = K, this.showLeft = J, this.showRight = Z, this;
        }, setFillStyle: function(K, J, Z) {
          return this.fillTop = K, this.fillLeft = J, this.fillRight = Z, this.isFilled = true, this;
        } });
        M.exports = U;
      }, 11508: (M, B, $) => {
        var E = $(65960), L = $(20926), z = function(U, K, J, Z) {
          J.addToRenderList(K);
          var D = U.currentContext;
          if (L(U, D, K, J, Z) && K.isFilled) {
            var { width: Q, height: H } = K, N = Q / 2, W = Q / K.projection;
            if (K.showTop)
              E(D, K, K.fillTop), D.beginPath(), D.moveTo(-N, -H), D.lineTo(0, -W - H), D.lineTo(N, -H), D.lineTo(N, -1), D.lineTo(0, W - 1), D.lineTo(-N, -1), D.lineTo(-N, -H), D.fill();
            if (K.showLeft)
              E(D, K, K.fillLeft), D.beginPath(), D.moveTo(-N, 0), D.lineTo(0, W), D.lineTo(0, W - H), D.lineTo(-N, -H), D.lineTo(-N, 0), D.fill();
            if (K.showRight)
              E(D, K, K.fillRight), D.beginPath(), D.moveTo(N, 0), D.lineTo(0, W), D.lineTo(0, W - H), D.lineTo(N, -H), D.lineTo(N, 0), D.fill();
            D.restore();
          }
        };
        M.exports = z;
      }, 3933: (M, B, $) => {
        var E = $(39429), L = $(61475);
        E.register("isobox", function(z, U, K, J, Z, D, Q) {
          return this.displayList.add(new L(this.scene, z, U, K, J, Z, D, Q));
        });
      }, 99651: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(68149), z = $(11508), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 68149: (M, B, $) => {
        var E = $(91296), L = $(70554), z = function(U, K, J, Z) {
          J.addToRenderList(K);
          var D = U.pipelines.set(K.pipeline), Q = E(K, J, Z), H = D.calcMatrix.copyFrom(Q.calc), N = K.width, W = K.height, R = N / 2, Y = N / K.projection, I = J.alpha * K.alpha;
          if (!K.isFilled)
            return;
          var P, X, G, V, A, F, j, T, C;
          if (U.pipelines.preBatch(K), K.showTop)
            P = L.getTintAppendFloatAlpha(K.fillTop, I), X = H.getX(-R, -W), G = H.getY(-R, -W), V = H.getX(0, -Y - W), A = H.getY(0, -Y - W), F = H.getX(R, -W), j = H.getY(R, -W), T = H.getX(0, Y - W), C = H.getY(0, Y - W), D.batchQuad(K, X, G, V, A, F, j, T, C, 0, 0, 1, 1, P, P, P, P, 2);
          if (K.showLeft)
            P = L.getTintAppendFloatAlpha(K.fillLeft, I), X = H.getX(-R, 0), G = H.getY(-R, 0), V = H.getX(0, Y), A = H.getY(0, Y), F = H.getX(0, Y - W), j = H.getY(0, Y - W), T = H.getX(-R, -W), C = H.getY(-R, -W), D.batchQuad(K, X, G, V, A, F, j, T, C, 0, 0, 1, 1, P, P, P, P, 2);
          if (K.showRight)
            P = L.getTintAppendFloatAlpha(K.fillRight, I), X = H.getX(R, 0), G = H.getY(R, 0), V = H.getX(0, Y), A = H.getY(0, Y), F = H.getX(0, Y - W), j = H.getY(0, Y - W), T = H.getX(R, -W), C = H.getY(R, -W), D.batchQuad(K, X, G, V, A, F, j, T, C, 0, 0, 1, 1, P, P, P, P, 2);
          U.pipelines.postBatch(K);
        };
        M.exports = z;
      }, 16933: (M, B, $) => {
        var E = $(83419), L = $(60561), z = $(17803), U = new E({ Extends: z, Mixins: [L], initialize: function K(J, Z, D, Q, H, N, W, R, Y) {
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 48;
          if (H === undefined)
            H = 32;
          if (N === undefined)
            N = false;
          if (W === undefined)
            W = 15658734;
          if (R === undefined)
            R = 10066329;
          if (Y === undefined)
            Y = 13421772;
          z.call(this, J, "IsoTriangle", null), this.projection = 4, this.fillTop = W, this.fillLeft = R, this.fillRight = Y, this.showTop = true, this.showLeft = true, this.showRight = true, this.isReversed = N, this.isFilled = true, this.setPosition(Z, D), this.setSize(Q, H), this.updateDisplayOrigin();
        }, setProjection: function(K) {
          return this.projection = K, this;
        }, setReversed: function(K) {
          return this.isReversed = K, this;
        }, setFaces: function(K, J, Z) {
          if (K === undefined)
            K = true;
          if (J === undefined)
            J = true;
          if (Z === undefined)
            Z = true;
          return this.showTop = K, this.showLeft = J, this.showRight = Z, this;
        }, setFillStyle: function(K, J, Z) {
          return this.fillTop = K, this.fillLeft = J, this.fillRight = Z, this.isFilled = true, this;
        } });
        M.exports = U;
      }, 79590: (M, B, $) => {
        var E = $(65960), L = $(20926), z = function(U, K, J, Z) {
          J.addToRenderList(K);
          var D = U.currentContext;
          if (L(U, D, K, J, Z) && K.isFilled) {
            var { width: Q, height: H } = K, N = Q / 2, W = Q / K.projection, R = K.isReversed;
            if (K.showTop && R)
              E(D, K, K.fillTop), D.beginPath(), D.moveTo(-N, -H), D.lineTo(0, -W - H), D.lineTo(N, -H), D.lineTo(0, W - H), D.fill();
            if (K.showLeft) {
              if (E(D, K, K.fillLeft), D.beginPath(), R)
                D.moveTo(-N, -H), D.lineTo(0, W), D.lineTo(0, W - H);
              else
                D.moveTo(-N, 0), D.lineTo(0, W), D.lineTo(0, W - H);
              D.fill();
            }
            if (K.showRight) {
              if (E(D, K, K.fillRight), D.beginPath(), R)
                D.moveTo(N, -H), D.lineTo(0, W), D.lineTo(0, W - H);
              else
                D.moveTo(N, 0), D.lineTo(0, W), D.lineTo(0, W - H);
              D.fill();
            }
            D.restore();
          }
        };
        M.exports = z;
      }, 49803: (M, B, $) => {
        var E = $(39429), L = $(16933);
        E.register("isotriangle", function(z, U, K, J, Z, D, Q, H) {
          return this.displayList.add(new L(this.scene, z, U, K, J, Z, D, Q, H));
        });
      }, 60561: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(51503), z = $(79590), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 51503: (M, B, $) => {
        var E = $(91296), L = $(70554), z = function(U, K, J, Z) {
          J.addToRenderList(K);
          var D = U.pipelines.set(K.pipeline), Q = E(K, J, Z), H = D.calcMatrix.copyFrom(Q.calc), N = K.width, W = K.height, R = N / 2, Y = N / K.projection, I = K.isReversed, P = J.alpha * K.alpha;
          if (!K.isFilled)
            return;
          U.pipelines.preBatch(K);
          var X, G, V, A, F, j, T;
          if (K.showTop && I) {
            X = L.getTintAppendFloatAlpha(K.fillTop, P), G = H.getX(-R, -W), V = H.getY(-R, -W), A = H.getX(0, -Y - W), F = H.getY(0, -Y - W), j = H.getX(R, -W), T = H.getY(R, -W);
            var C = H.getX(0, Y - W), v = H.getY(0, Y - W);
            D.batchQuad(K, G, V, A, F, j, T, C, v, 0, 0, 1, 1, X, X, X, X, 2);
          }
          if (K.showLeft) {
            if (X = L.getTintAppendFloatAlpha(K.fillLeft, P), I)
              G = H.getX(-R, -W), V = H.getY(-R, -W), A = H.getX(0, Y), F = H.getY(0, Y), j = H.getX(0, Y - W), T = H.getY(0, Y - W);
            else
              G = H.getX(-R, 0), V = H.getY(-R, 0), A = H.getX(0, Y), F = H.getY(0, Y), j = H.getX(0, Y - W), T = H.getY(0, Y - W);
            D.batchTri(K, G, V, A, F, j, T, 0, 0, 1, 1, X, X, X, 2);
          }
          if (K.showRight) {
            if (X = L.getTintAppendFloatAlpha(K.fillRight, P), I)
              G = H.getX(R, -W), V = H.getY(R, -W), A = H.getX(0, Y), F = H.getY(0, Y), j = H.getX(0, Y - W), T = H.getY(0, Y - W);
            else
              G = H.getX(R, 0), V = H.getY(R, 0), A = H.getX(0, Y), F = H.getY(0, Y), j = H.getX(0, Y - W), T = H.getY(0, Y - W);
            D.batchTri(K, G, V, A, F, j, T, 0, 0, 1, 1, X, X, X, 2);
          }
          U.pipelines.postBatch(K);
        };
        M.exports = z;
      }, 57847: (M, B, $) => {
        var E = $(83419), L = $(17803), z = $(23031), U = $(36823), K = new E({ Extends: L, Mixins: [U], initialize: function J(Z, D, Q, H, N, W, R, Y, I) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = 128;
          if (R === undefined)
            R = 0;
          L.call(this, Z, "Line", new z(H, N, W, R));
          var P = Math.max(1, this.geom.right - this.geom.left), X = Math.max(1, this.geom.bottom - this.geom.top);
          if (this.lineWidth = 1, this._startWidth = 1, this._endWidth = 1, this.setPosition(D, Q), this.setSize(P, X), Y !== undefined)
            this.setStrokeStyle(1, Y, I);
          this.updateDisplayOrigin();
        }, setLineWidth: function(J, Z) {
          if (Z === undefined)
            Z = J;
          return this._startWidth = J, this._endWidth = Z, this.lineWidth = J, this;
        }, setTo: function(J, Z, D, Q) {
          return this.geom.setTo(J, Z, D, Q), this;
        } });
        M.exports = K;
      }, 17440: (M, B, $) => {
        var E = $(75177), L = $(20926), z = function(U, K, J, Z) {
          J.addToRenderList(K);
          var D = U.currentContext;
          if (L(U, D, K, J, Z)) {
            var { _displayOriginX: Q, _displayOriginY: H } = K;
            if (K.isStroked)
              E(D, K), D.beginPath(), D.moveTo(K.geom.x1 - Q, K.geom.y1 - H), D.lineTo(K.geom.x2 - Q, K.geom.y2 - H), D.stroke();
            D.restore();
          }
        };
        M.exports = z;
      }, 2481: (M, B, $) => {
        var E = $(39429), L = $(57847);
        E.register("line", function(z, U, K, J, Z, D, Q, H) {
          return this.displayList.add(new L(this.scene, z, U, K, J, Z, D, Q, H));
        });
      }, 36823: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(77385), z = $(17440), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 77385: (M, B, $) => {
        var E = $(91296), L = $(70554), z = function(U, K, J, Z) {
          J.addToRenderList(K);
          var D = U.pipelines.set(K.pipeline), Q = E(K, J, Z);
          D.calcMatrix.copyFrom(Q.calc);
          var { _displayOriginX: H, _displayOriginY: N } = K, W = J.alpha * K.alpha;
          if (U.pipelines.preBatch(K), K.isStroked) {
            var R = D.strokeTint, Y = L.getTintAppendFloatAlpha(K.strokeColor, K.strokeAlpha * W);
            R.TL = Y, R.TR = Y, R.BL = Y, R.BR = Y, D.batchLine(K.geom.x1 - H, K.geom.y1 - N, K.geom.x2 - H, K.geom.y2 - N, K._startWidth / 2, K._endWidth / 2, 1, 0, false, Q.sprite, Q.camera);
          }
          U.pipelines.postBatch(K);
        };
        M.exports = z;
      }, 24949: (M, B, $) => {
        var E = $(90273), L = $(83419), z = $(94811), U = $(13829), K = $(25717), J = $(17803), Z = $(5469), D = new L({ Extends: J, Mixins: [E], initialize: function Q(H, N, W, R, Y, I) {
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = 0;
          J.call(this, H, "Polygon", new K(R));
          var P = U(this.geom);
          if (this.setPosition(N, W), this.setSize(P.width, P.height), Y !== undefined)
            this.setFillStyle(Y, I);
          this.updateDisplayOrigin(), this.updateData();
        }, smooth: function(Q) {
          if (Q === undefined)
            Q = 1;
          for (var H = 0;H < Q; H++)
            Z(this.geom);
          return this.updateData();
        }, setTo: function(Q) {
          this.geom.setTo(Q);
          var H = U(this.geom);
          return this.setSize(H.width, H.height), this.updateDisplayOrigin(), this.updateData();
        }, updateData: function() {
          var Q = [], H = this.geom.points;
          for (var N = 0;N < H.length; N++)
            Q.push(H[N].x, H[N].y);
          return Q.push(H[0].x, H[0].y), this.pathIndexes = z(Q), this.pathData = Q, this;
        } });
        M.exports = D;
      }, 38710: (M, B, $) => {
        var E = $(65960), L = $(75177), z = $(20926), U = function(K, J, Z, D) {
          Z.addToRenderList(J);
          var Q = K.currentContext;
          if (z(K, Q, J, Z, D)) {
            var { _displayOriginX: H, _displayOriginY: N, pathData: W } = J, R = W.length - 1, Y = W[0] - H, I = W[1] - N;
            if (Q.beginPath(), Q.moveTo(Y, I), !J.closePath)
              R -= 2;
            for (var P = 2;P < R; P += 2) {
              var X = W[P] - H, G = W[P + 1] - N;
              Q.lineTo(X, G);
            }
            if (J.closePath)
              Q.closePath();
            if (J.isFilled)
              E(Q, J), Q.fill();
            if (J.isStroked)
              L(Q, J), Q.stroke();
            Q.restore();
          }
        };
        M.exports = U;
      }, 64827: (M, B, $) => {
        var E = $(39429), L = $(24949);
        E.register("polygon", function(z, U, K, J, Z) {
          return this.displayList.add(new L(this.scene, z, U, K, J, Z));
        });
      }, 90273: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(73695), z = $(38710), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 73695: (M, B, $) => {
        var E = $(10441), L = $(91296), z = $(34682), U = function(K, J, Z, D) {
          Z.addToRenderList(J);
          var Q = K.pipelines.set(J.pipeline), H = L(J, Z, D), N = Q.calcMatrix.copyFrom(H.calc), W = J._displayOriginX, R = J._displayOriginY, Y = Z.alpha * J.alpha;
          if (K.pipelines.preBatch(J), J.isFilled)
            E(Q, N, J, Y, W, R);
          if (J.isStroked)
            z(Q, J, Y, W, R);
          K.pipelines.postBatch(J);
        };
        M.exports = U;
      }, 74561: (M, B, $) => {
        var E = $(83419), L = $(87841), z = $(17803), U = $(95597), K = new E({ Extends: z, Mixins: [U], initialize: function J(Z, D, Q, H, N, W, R) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 128;
          if (N === undefined)
            N = 128;
          if (z.call(this, Z, "Rectangle", new L(0, 0, H, N)), this.setPosition(D, Q), this.setSize(H, N), W !== undefined)
            this.setFillStyle(W, R);
          this.updateDisplayOrigin(), this.updateData();
        }, setSize: function(J, Z) {
          this.width = J, this.height = Z, this.geom.setSize(J, Z), this.updateData(), this.updateDisplayOrigin();
          var D = this.input;
          if (D && !D.customHitArea)
            D.hitArea.width = J, D.hitArea.height = Z;
          return this;
        }, updateData: function() {
          var J = [], Z = this.geom, D = this._tempLine;
          return Z.getLineA(D), J.push(D.x1, D.y1, D.x2, D.y2), Z.getLineB(D), J.push(D.x2, D.y2), Z.getLineC(D), J.push(D.x2, D.y2), Z.getLineD(D), J.push(D.x2, D.y2), this.pathData = J, this;
        } });
        M.exports = K;
      }, 48682: (M, B, $) => {
        var E = $(65960), L = $(75177), z = $(20926), U = function(K, J, Z, D) {
          Z.addToRenderList(J);
          var Q = K.currentContext;
          if (z(K, Q, J, Z, D)) {
            var { _displayOriginX: H, _displayOriginY: N } = J;
            if (J.isFilled)
              E(Q, J), Q.fillRect(-H, -N, J.width, J.height);
            if (J.isStroked)
              L(Q, J), Q.beginPath(), Q.rect(-H, -N, J.width, J.height), Q.stroke();
            Q.restore();
          }
        };
        M.exports = U;
      }, 87959: (M, B, $) => {
        var E = $(39429), L = $(74561);
        E.register("rectangle", function(z, U, K, J, Z, D) {
          return this.displayList.add(new L(this.scene, z, U, K, J, Z, D));
        });
      }, 95597: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(52059), z = $(48682), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 52059: (M, B, $) => {
        var E = $(91296), L = $(34682), z = $(70554), U = function(K, J, Z, D) {
          Z.addToRenderList(J);
          var Q = K.pipelines.set(J.pipeline), H = E(J, Z, D);
          Q.calcMatrix.copyFrom(H.calc);
          var { _displayOriginX: N, _displayOriginY: W } = J, R = Z.alpha * J.alpha;
          if (K.pipelines.preBatch(J), J.isFilled) {
            var Y = Q.fillTint, I = z.getTintAppendFloatAlpha(J.fillColor, J.fillAlpha * R);
            Y.TL = I, Y.TR = I, Y.BL = I, Y.BR = I, Q.batchFillRect(-N, -W, J.width, J.height);
          }
          if (J.isStroked)
            L(Q, J, R, N, W);
          K.pipelines.postBatch(J);
        };
        M.exports = U;
      }, 55911: (M, B, $) => {
        var E = $(81991), L = $(83419), z = $(94811), U = $(17803), K = new L({ Extends: U, Mixins: [E], initialize: function J(Z, D, Q, H, N, W, R, Y) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 5;
          if (N === undefined)
            N = 32;
          if (W === undefined)
            W = 64;
          if (U.call(this, Z, "Star", null), this._points = H, this._innerRadius = N, this._outerRadius = W, this.setPosition(D, Q), this.setSize(W * 2, W * 2), R !== undefined)
            this.setFillStyle(R, Y);
          this.updateDisplayOrigin(), this.updateData();
        }, setPoints: function(J) {
          return this._points = J, this.updateData();
        }, setInnerRadius: function(J) {
          return this._innerRadius = J, this.updateData();
        }, setOuterRadius: function(J) {
          return this._outerRadius = J, this.updateData();
        }, points: { get: function() {
          return this._points;
        }, set: function(J) {
          this._points = J, this.updateData();
        } }, innerRadius: { get: function() {
          return this._innerRadius;
        }, set: function(J) {
          this._innerRadius = J, this.updateData();
        } }, outerRadius: { get: function() {
          return this._outerRadius;
        }, set: function(J) {
          this._outerRadius = J, this.updateData();
        } }, updateData: function() {
          var J = [], Z = this._points, D = this._innerRadius, Q = this._outerRadius, H = Math.PI / 2 * 3, N = Math.PI / Z, W = Q, R = Q;
          J.push(W, R + -Q);
          for (var Y = 0;Y < Z; Y++)
            J.push(W + Math.cos(H) * Q, R + Math.sin(H) * Q), H += N, J.push(W + Math.cos(H) * D, R + Math.sin(H) * D), H += N;
          return J.push(W, R + -Q), this.pathIndexes = z(J), this.pathData = J, this;
        } });
        M.exports = K;
      }, 64272: (M, B, $) => {
        var E = $(65960), L = $(75177), z = $(20926), U = function(K, J, Z, D) {
          Z.addToRenderList(J);
          var Q = K.currentContext;
          if (z(K, Q, J, Z, D)) {
            var { _displayOriginX: H, _displayOriginY: N, pathData: W } = J, R = W.length - 1, Y = W[0] - H, I = W[1] - N;
            if (Q.beginPath(), Q.moveTo(Y, I), !J.closePath)
              R -= 2;
            for (var P = 2;P < R; P += 2) {
              var X = W[P] - H, G = W[P + 1] - N;
              Q.lineTo(X, G);
            }
            if (Q.closePath(), J.isFilled)
              E(Q, J), Q.fill();
            if (J.isStroked)
              L(Q, J), Q.stroke();
            Q.restore();
          }
        };
        M.exports = U;
      }, 93697: (M, B, $) => {
        var E = $(55911), L = $(39429);
        L.register("star", function(z, U, K, J, Z, D, Q) {
          return this.displayList.add(new E(this.scene, z, U, K, J, Z, D, Q));
        });
      }, 81991: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(57017), z = $(64272), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 57017: (M, B, $) => {
        var E = $(10441), L = $(91296), z = $(34682), U = function(K, J, Z, D) {
          Z.addToRenderList(J);
          var Q = K.pipelines.set(J.pipeline), H = L(J, Z, D), N = Q.calcMatrix.copyFrom(H.calc), W = J._displayOriginX, R = J._displayOriginY, Y = Z.alpha * J.alpha;
          if (K.pipelines.preBatch(J), J.isFilled)
            E(Q, N, J, Y, W, R);
          if (J.isStroked)
            z(Q, J, Y, W, R);
          K.pipelines.postBatch(J);
        };
        M.exports = U;
      }, 36931: (M, B, $) => {
        var E = $(83419), L = $(17803), z = $(16483), U = $(96195), K = new E({ Extends: L, Mixins: [U], initialize: function J(Z, D, Q, H, N, W, R, Y, I, P, X) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = 128;
          if (W === undefined)
            W = 64;
          if (R === undefined)
            R = 0;
          if (Y === undefined)
            Y = 128;
          if (I === undefined)
            I = 128;
          L.call(this, Z, "Triangle", new z(H, N, W, R, Y, I));
          var G = this.geom.right - this.geom.left, V = this.geom.bottom - this.geom.top;
          if (this.setPosition(D, Q), this.setSize(G, V), P !== undefined)
            this.setFillStyle(P, X);
          this.updateDisplayOrigin(), this.updateData();
        }, setTo: function(J, Z, D, Q, H, N) {
          return this.geom.setTo(J, Z, D, Q, H, N), this.updateData();
        }, updateData: function() {
          var J = [], Z = this.geom, D = this._tempLine;
          return Z.getLineA(D), J.push(D.x1, D.y1, D.x2, D.y2), Z.getLineB(D), J.push(D.x2, D.y2), Z.getLineC(D), J.push(D.x2, D.y2), this.pathData = J, this;
        } });
        M.exports = K;
      }, 85172: (M, B, $) => {
        var E = $(65960), L = $(75177), z = $(20926), U = function(K, J, Z, D) {
          Z.addToRenderList(J);
          var Q = K.currentContext;
          if (z(K, Q, J, Z, D)) {
            var { _displayOriginX: H, _displayOriginY: N } = J, W = J.geom.x1 - H, R = J.geom.y1 - N, Y = J.geom.x2 - H, I = J.geom.y2 - N, P = J.geom.x3 - H, X = J.geom.y3 - N;
            if (Q.beginPath(), Q.moveTo(W, R), Q.lineTo(Y, I), Q.lineTo(P, X), Q.closePath(), J.isFilled)
              E(Q, J), Q.fill();
            if (J.isStroked)
              L(Q, J), Q.stroke();
            Q.restore();
          }
        };
        M.exports = U;
      }, 45245: (M, B, $) => {
        var E = $(39429), L = $(36931);
        E.register("triangle", function(z, U, K, J, Z, D, Q, H, N, W) {
          return this.displayList.add(new L(this.scene, z, U, K, J, Z, D, Q, H, N, W));
        });
      }, 96195: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(83253), z = $(85172), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 83253: (M, B, $) => {
        var E = $(91296), L = $(34682), z = $(70554), U = function(K, J, Z, D) {
          Z.addToRenderList(J);
          var Q = K.pipelines.set(J.pipeline), H = E(J, Z, D);
          Q.calcMatrix.copyFrom(H.calc);
          var { _displayOriginX: N, _displayOriginY: W } = J, R = Z.alpha * J.alpha;
          if (K.pipelines.preBatch(J), J.isFilled) {
            var Y = Q.fillTint, I = z.getTintAppendFloatAlpha(J.fillColor, J.fillAlpha * R);
            Y.TL = I, Y.TR = I, Y.BL = I, Y.BR = I;
            var P = J.geom.x1 - N, X = J.geom.y1 - W, G = J.geom.x2 - N, V = J.geom.y2 - W, A = J.geom.x3 - N, F = J.geom.y3 - W;
            Q.batchFillTriangle(P, X, G, V, A, F, H.sprite, H.camera);
          }
          if (J.isStroked)
            L(Q, J, R, N, W);
          K.pipelines.postBatch(J);
        };
        M.exports = U;
      }, 68287: (M, B, $) => {
        var E = $(9674), L = $(83419), z = $(31401), U = $(95643), K = $(92751), J = new L({ Extends: U, Mixins: [z.Alpha, z.BlendMode, z.Depth, z.Flip, z.GetBounds, z.Mask, z.Origin, z.Pipeline, z.PostPipeline, z.ScrollFactor, z.Size, z.TextureCrop, z.Tint, z.Transform, z.Visible, K], initialize: function Z(D, Q, H, N, W) {
          U.call(this, D, "Sprite"), this._crop = this.resetCropObject(), this.anims = new E(this), this.setTexture(N, W), this.setPosition(Q, H), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline(), this.initPostPipeline(true);
        }, addedToScene: function() {
          this.scene.sys.updateList.add(this);
        }, removedFromScene: function() {
          this.scene.sys.updateList.remove(this);
        }, preUpdate: function(Z, D) {
          this.anims.update(Z, D);
        }, play: function(Z, D) {
          return this.anims.play(Z, D);
        }, playReverse: function(Z, D) {
          return this.anims.playReverse(Z, D);
        }, playAfterDelay: function(Z, D) {
          return this.anims.playAfterDelay(Z, D);
        }, playAfterRepeat: function(Z, D) {
          return this.anims.playAfterRepeat(Z, D);
        }, chain: function(Z) {
          return this.anims.chain(Z);
        }, stop: function() {
          return this.anims.stop();
        }, stopAfterDelay: function(Z) {
          return this.anims.stopAfterDelay(Z);
        }, stopAfterRepeat: function(Z) {
          return this.anims.stopAfterRepeat(Z);
        }, stopOnFrame: function(Z) {
          return this.anims.stopOnFrame(Z);
        }, toJSON: function() {
          return z.ToJSON(this);
        }, preDestroy: function() {
          this.anims.destroy(), this.anims = undefined;
        } });
        M.exports = J;
      }, 76552: (M) => {
        var B = function($, E, L, z) {
          L.addToRenderList(E), $.batchSprite(E, E.frame, L, z);
        };
        M.exports = B;
      }, 15567: (M, B, $) => {
        var E = $(25305), L = $(13059), z = $(44603), U = $(23568), K = $(68287);
        z.register("sprite", function(J, Z) {
          if (J === undefined)
            J = {};
          var D = U(J, "key", null), Q = U(J, "frame", null), H = new K(this.scene, 0, 0, D, Q);
          if (Z !== undefined)
            J.add = Z;
          return E(this.scene, H, J), L(H, J), H;
        });
      }, 46409: (M, B, $) => {
        var E = $(39429), L = $(68287);
        E.register("sprite", function(z, U, K, J) {
          return this.displayList.add(new L(this.scene, z, U, K, J));
        });
      }, 92751: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(9409), z = $(76552), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 9409: (M) => {
        var B = function($, E, L, z) {
          L.addToRenderList(E), E.pipeline.batchSprite(E, L, z);
        };
        M.exports = B;
      }, 14220: (M) => {
        var B = function($, E, L) {
          var { canvas: z, context: U, style: K } = $, J = [], Z = 0, D = L.length;
          if (K.maxLines > 0 && K.maxLines < L.length)
            D = K.maxLines;
          K.syncFont(z, U);
          for (var Q = 0;Q < D; Q++) {
            var H = K.strokeThickness;
            if (H += U.measureText(L[Q]).width, L[Q].length > 1)
              H += $.letterSpacing * (L[Q].length - 1);
            if (K.wordWrap)
              H -= U.measureText(" ").width;
            J[Q] = Math.ceil(H), Z = Math.max(Z, J[Q]);
          }
          var N = E.fontSize + K.strokeThickness, W = N * D, R = $.lineSpacing;
          if (D > 1)
            W += R * (D - 1);
          return { width: Z, height: W, lines: D, lineWidths: J, lineSpacing: R, lineHeight: N };
        };
        M.exports = B;
      }, 79557: (M, B, $) => {
        var E = $(27919), L = function(z) {
          var U = E.create(this), K = U.getContext("2d", { willReadFrequently: true });
          z.syncFont(U, K);
          var J = K.measureText(z.testString);
          if ("actualBoundingBoxAscent" in J) {
            var { actualBoundingBoxAscent: Z, actualBoundingBoxDescent: D } = J;
            return E.remove(U), { ascent: Z, descent: D, fontSize: Z + D };
          }
          var Q = Math.ceil(J.width * z.baselineX), H = Q, N = 2 * H;
          H = H * z.baselineY | 0, U.width = Q, U.height = N, K.fillStyle = "#f00", K.fillRect(0, 0, Q, N), K.font = z._font, K.textBaseline = "alphabetic", K.fillStyle = "#000", K.fillText(z.testString, 0, H);
          var W = { ascent: 0, descent: 0, fontSize: 0 }, R = K.getImageData(0, 0, Q, N);
          if (!R)
            return W.ascent = H, W.descent = H + 6, W.fontSize = W.ascent + W.descent, E.remove(U), W;
          var Y = R.data, I = Y.length, P = Q * 4, X, G, V = 0, A = false;
          for (X = 0;X < H; X++) {
            for (G = 0;G < P; G += 4)
              if (Y[V + G] !== 255) {
                A = true;
                break;
              }
            if (!A)
              V += P;
            else
              break;
          }
          W.ascent = H - X, V = I - P, A = false;
          for (X = N;X > H; X--) {
            for (G = 0;G < P; G += 4)
              if (Y[V + G] !== 255) {
                A = true;
                break;
              }
            if (!A)
              V -= P;
            else
              break;
          }
          return W.descent = X - H, W.fontSize = W.ascent + W.descent, E.remove(U), W;
        };
        M.exports = L;
      }, 50171: (M, B, $) => {
        var E = $(40366), L = $(27919), z = $(83419), U = $(31401), K = $(95643), J = $(14220), Z = $(35154), D = $(35846), Q = $(61771), H = $(35762), N = $(45650), W = new z({ Extends: K, Mixins: [U.Alpha, U.BlendMode, U.ComputedSize, U.Crop, U.Depth, U.Flip, U.GetBounds, U.Mask, U.Origin, U.Pipeline, U.PostPipeline, U.ScrollFactor, U.Tint, U.Transform, U.Visible, Q], initialize: function R(Y, I, P, X, G) {
          if (I === undefined)
            I = 0;
          if (P === undefined)
            P = 0;
          if (K.call(this, Y, "Text"), this.renderer = Y.sys.renderer, this.setPosition(I, P), this.setOrigin(0, 0), this.initPipeline(), this.initPostPipeline(true), this.canvas = L.create(this), this.context, this.style = new H(this, G), this.autoRound = true, this.splitRegExp = /(?:\r\n|\r|\n)/, this._text = undefined, this.padding = { left: 0, right: 0, top: 0, bottom: 0 }, this.width = 1, this.height = 1, this.lineSpacing = 0, this.letterSpacing = 0, this.style.resolution === 0)
            this.style.resolution = 1;
          if (this._crop = this.resetCropObject(), this._textureKey = N(), this.texture = Y.sys.textures.addCanvas(this._textureKey, this.canvas), this.context = this.texture.context, this.frame = this.texture.get(), this.frame.source.resolution = this.style.resolution, this.renderer && this.renderer.gl)
            this.renderer.deleteTexture(this.frame.source.glTexture), this.frame.source.glTexture = null;
          if (this.initRTL(), this.setText(X), G && G.padding)
            this.setPadding(G.padding);
          if (G && G.lineSpacing)
            this.setLineSpacing(G.lineSpacing);
        }, initRTL: function() {
          if (!this.style.rtl)
            return;
          this.canvas.dir = "rtl", this.context.direction = "rtl", this.canvas.style.display = "none", E(this.canvas, this.scene.sys.canvas), this.originX = 1;
        }, runWordWrap: function(R) {
          var Y = this.style;
          if (Y.wordWrapCallback) {
            var I = Y.wordWrapCallback.call(Y.wordWrapCallbackScope, R, this);
            if (Array.isArray(I))
              I = I.join("\n");
            return I;
          } else if (Y.wordWrapWidth)
            if (Y.wordWrapUseAdvanced)
              return this.advancedWordWrap(R, this.context, this.style.wordWrapWidth);
            else
              return this.basicWordWrap(R, this.context, this.style.wordWrapWidth);
          else
            return R;
        }, advancedWordWrap: function(R, Y, I) {
          var P = "", X = R.replace(/ +/gi, " ").split(this.splitRegExp), G = X.length;
          for (var V = 0;V < G; V++) {
            var A = X[V], F = "";
            A = A.replace(/^ *|\s*$/gi, "");
            var j = Y.measureText(A).width;
            if (j < I) {
              P += A + "\n";
              continue;
            }
            var T = I, C = A.split(" ");
            for (var v = 0;v < C.length; v++) {
              var O = C[v], q = O + " ", w = Y.measureText(q).width;
              if (w > T) {
                if (v === 0) {
                  var g = q;
                  while (g.length)
                    if (g = g.slice(0, -1), w = Y.measureText(g).width, w <= T)
                      break;
                  if (!g.length)
                    throw new Error("wordWrapWidth < a single character");
                  var b = O.substr(g.length);
                  C[v] = b, F += g;
                }
                var x = C[v].length ? v : v + 1, k = C.slice(x).join(" ").replace(/[ \n]*$/gi, "");
                X.splice(V + 1, 0, k), G = X.length;
                break;
              } else
                F += q, T -= w;
            }
            P += F.replace(/[ \n]*$/gi, "") + "\n";
          }
          return P = P.replace(/[\s|\n]*$/gi, ""), P;
        }, basicWordWrap: function(R, Y, I) {
          var P = "", X = R.split(this.splitRegExp), G = X.length - 1, V = Y.measureText(" ").width;
          for (var A = 0;A <= G; A++) {
            var F = I, j = X[A].split(" "), T = j.length - 1;
            for (var C = 0;C <= T; C++) {
              var v = j[C], O = Y.measureText(v).width, q = O;
              if (C < T)
                q += V;
              if (q > F) {
                if (C > 0)
                  P += "\n", F = I;
              }
              if (P += v, C < T)
                P += " ", F -= q;
              else
                F -= O;
            }
            if (A < G)
              P += "\n";
          }
          return P;
        }, getWrappedText: function(R) {
          if (R === undefined)
            R = this._text;
          this.style.syncFont(this.canvas, this.context);
          var Y = this.runWordWrap(R);
          return Y.split(this.splitRegExp);
        }, setText: function(R) {
          if (!R && R !== 0)
            R = "";
          if (Array.isArray(R))
            R = R.join("\n");
          if (R !== this._text)
            this._text = R.toString(), this.updateText();
          return this;
        }, appendText: function(R, Y) {
          if (Y === undefined)
            Y = true;
          if (!R && R !== 0)
            R = "";
          if (Array.isArray(R))
            R = R.join("\n");
          R = R.toString();
          var I = this._text.concat(Y ? "\n" + R : R);
          if (I !== this._text)
            this._text = I, this.updateText();
          return this;
        }, setStyle: function(R) {
          return this.style.setStyle(R);
        }, setFont: function(R) {
          return this.style.setFont(R);
        }, setFontFamily: function(R) {
          return this.style.setFontFamily(R);
        }, setFontSize: function(R) {
          return this.style.setFontSize(R);
        }, setFontStyle: function(R) {
          return this.style.setFontStyle(R);
        }, setFixedSize: function(R, Y) {
          return this.style.setFixedSize(R, Y);
        }, setBackgroundColor: function(R) {
          return this.style.setBackgroundColor(R);
        }, setFill: function(R) {
          return this.style.setFill(R);
        }, setColor: function(R) {
          return this.style.setColor(R);
        }, setStroke: function(R, Y) {
          return this.style.setStroke(R, Y);
        }, setShadow: function(R, Y, I, P, X, G) {
          return this.style.setShadow(R, Y, I, P, X, G);
        }, setShadowOffset: function(R, Y) {
          return this.style.setShadowOffset(R, Y);
        }, setShadowColor: function(R) {
          return this.style.setShadowColor(R);
        }, setShadowBlur: function(R) {
          return this.style.setShadowBlur(R);
        }, setShadowStroke: function(R) {
          return this.style.setShadowStroke(R);
        }, setShadowFill: function(R) {
          return this.style.setShadowFill(R);
        }, setWordWrapWidth: function(R, Y) {
          return this.style.setWordWrapWidth(R, Y);
        }, setWordWrapCallback: function(R, Y) {
          return this.style.setWordWrapCallback(R, Y);
        }, setAlign: function(R) {
          return this.style.setAlign(R);
        }, setResolution: function(R) {
          return this.style.setResolution(R);
        }, setLineSpacing: function(R) {
          return this.lineSpacing = R, this.updateText();
        }, setLetterSpacing: function(R) {
          return this.letterSpacing = R, this.updateText();
        }, setPadding: function(R, Y, I, P) {
          if (typeof R === "object") {
            var X = R, G = Z(X, "x", null);
            if (G !== null)
              R = G, I = G;
            else
              R = Z(X, "left", 0), I = Z(X, "right", R);
            var V = Z(X, "y", null);
            if (V !== null)
              Y = V, P = V;
            else
              Y = Z(X, "top", 0), P = Z(X, "bottom", Y);
          } else {
            if (R === undefined)
              R = 0;
            if (Y === undefined)
              Y = R;
            if (I === undefined)
              I = R;
            if (P === undefined)
              P = Y;
          }
          return this.padding.left = R, this.padding.top = Y, this.padding.right = I, this.padding.bottom = P, this.updateText();
        }, setMaxLines: function(R) {
          return this.style.setMaxLines(R);
        }, setRTL: function(R) {
          if (R === undefined)
            R = true;
          var Y = this.style;
          if (Y.rtl === R)
            return this;
          if (Y.rtl = R, R)
            this.canvas.dir = "rtl", this.context.direction = "rtl", this.canvas.style.display = "none", E(this.canvas, this.scene.sys.canvas);
          else
            this.canvas.dir = "ltr", this.context.direction = "ltr";
          if (Y.align === "left")
            Y.align = "right";
          else if (Y.align === "right")
            Y.align = "left";
          return this;
        }, updateText: function() {
          var R = this.canvas, Y = this.context, I = this.style, P = I.resolution, X = I.metrics;
          I.syncFont(R, Y);
          var G = this._text;
          if (I.wordWrapWidth || I.wordWrapCallback)
            G = this.runWordWrap(this._text);
          var V = G.split(this.splitRegExp), A = J(this, X, V), F = this.padding, j;
          if (I.fixedWidth === 0)
            this.width = A.width + F.left + F.right, j = A.width;
          else if (this.width = I.fixedWidth, j = this.width - F.left - F.right, j < A.width)
            j = A.width;
          if (I.fixedHeight === 0)
            this.height = A.height + F.top + F.bottom;
          else
            this.height = I.fixedHeight;
          var T = this.width, C = this.height;
          if (this.updateDisplayOrigin(), T *= P, C *= P, T = Math.max(T, 1), C = Math.max(C, 1), R.width !== T || R.height !== C) {
            if (R.width = T, R.height = C, this.frame.setSize(T, C), I.syncFont(R, Y), I.rtl)
              Y.direction = "rtl";
          } else
            Y.clearRect(0, 0, T, C);
          if (Y.save(), Y.scale(P, P), I.backgroundColor)
            Y.fillStyle = I.backgroundColor, Y.fillRect(0, 0, T, C);
          I.syncStyle(R, Y), Y.translate(F.left, F.top);
          var v, O;
          for (var q = 0;q < A.lines; q++) {
            if (v = I.strokeThickness / 2, O = I.strokeThickness / 2 + q * A.lineHeight + X.ascent, q > 0)
              O += A.lineSpacing * q;
            if (I.rtl)
              v = T - v - F.left - F.right;
            else if (I.align === "right")
              v += j - A.lineWidths[q];
            else if (I.align === "center")
              v += (j - A.lineWidths[q]) / 2;
            else if (I.align === "justify") {
              var w = 0.85;
              if (A.lineWidths[q] / A.width >= w) {
                var g = A.width - A.lineWidths[q], b = Y.measureText(" ").width, x = V[q].trim(), k = x.split(" ");
                g += (V[q].length - x.length) * b;
                var S = Math.floor(g / b), f = 0;
                while (S > 0)
                  k[f] += " ", f = (f + 1) % (k.length - 1 || 1), --S;
                V[q] = k.join(" ");
              }
            }
            if (this.autoRound)
              v = Math.round(v), O = Math.round(O);
            if (I.strokeThickness)
              I.syncShadow(Y, I.shadowStroke), Y.strokeText(V[q], v, O);
            if (I.color) {
              I.syncShadow(Y, I.shadowFill);
              var h = this.letterSpacing;
              if (h !== 0) {
                var m = 0, y = V[q].split("");
                for (var d = 0;d < y.length; d++)
                  Y.fillText(y[d], v + m, O), m += Y.measureText(y[d]).width + h;
              } else
                Y.fillText(V[q], v, O);
            }
          }
          if (Y.restore(), this.renderer && this.renderer.gl)
            this.frame.source.glTexture = this.renderer.canvasToTexture(R, this.frame.source.glTexture, true);
          var p = this.input;
          if (p && !p.customHitArea)
            p.hitArea.width = this.width, p.hitArea.height = this.height;
          return this;
        }, getTextMetrics: function() {
          return this.style.getTextMetrics();
        }, text: { get: function() {
          return this._text;
        }, set: function(R) {
          this.setText(R);
        } }, toJSON: function() {
          var R = U.ToJSON(this), Y = { autoRound: this.autoRound, text: this._text, style: this.style.toJSON(), padding: { left: this.padding.left, right: this.padding.right, top: this.padding.top, bottom: this.padding.bottom } };
          return R.data = Y, R;
        }, preDestroy: function() {
          D(this.canvas), L.remove(this.canvas);
          var R = this.texture;
          if (R)
            R.destroy();
        } });
        M.exports = W;
      }, 79724: (M) => {
        var B = function($, E, L, z) {
          if (E.width === 0 || E.height === 0)
            return;
          L.addToRenderList(E), $.batchSprite(E, E.frame, L, z);
        };
        M.exports = B;
      }, 71259: (M, B, $) => {
        var E = $(25305), L = $(44603), z = $(23568), U = $(50171);
        L.register("text", function(K, J) {
          if (K === undefined)
            K = {};
          var Z = z(K, "text", ""), D = z(K, "style", null), Q = z(K, "padding", null);
          if (Q !== null)
            D.padding = Q;
          var H = new U(this.scene, 0, 0, Z, D);
          if (J !== undefined)
            K.add = J;
          return E(this.scene, H, K), H.autoRound = z(K, "autoRound", true), H.resolution = z(K, "resolution", 1), H;
        });
      }, 68005: (M, B, $) => {
        var E = $(50171), L = $(39429);
        L.register("text", function(z, U, K, J) {
          return this.displayList.add(new E(this.scene, z, U, K, J));
        });
      }, 61771: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(34397), z = $(79724), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 35762: (M, B, $) => {
        var E = $(83419), L = $(23568), z = $(35154), U = $(79557), K = { fontFamily: ["fontFamily", "Courier"], fontSize: ["fontSize", "16px"], fontStyle: ["fontStyle", ""], backgroundColor: ["backgroundColor", null], color: ["color", "#fff"], stroke: ["stroke", "#fff"], strokeThickness: ["strokeThickness", 0], shadowOffsetX: ["shadow.offsetX", 0], shadowOffsetY: ["shadow.offsetY", 0], shadowColor: ["shadow.color", "#000"], shadowBlur: ["shadow.blur", 0], shadowStroke: ["shadow.stroke", false], shadowFill: ["shadow.fill", false], align: ["align", "left"], maxLines: ["maxLines", 0], fixedWidth: ["fixedWidth", 0], fixedHeight: ["fixedHeight", 0], resolution: ["resolution", 0], rtl: ["rtl", false], testString: ["testString", "|M\xC3\u2030qgy"], baselineX: ["baselineX", 1.2], baselineY: ["baselineY", 1.4], wordWrapWidth: ["wordWrap.width", null], wordWrapCallback: ["wordWrap.callback", null], wordWrapCallbackScope: ["wordWrap.callbackScope", null], wordWrapUseAdvanced: ["wordWrap.useAdvancedWrap", false] }, J = new E({ initialize: function Z(D, Q) {
          this.parent = D, this.fontFamily, this.fontSize, this.fontStyle, this.backgroundColor, this.color, this.stroke, this.strokeThickness, this.shadowOffsetX, this.shadowOffsetY, this.shadowColor, this.shadowBlur, this.shadowStroke, this.shadowFill, this.align, this.maxLines, this.fixedWidth, this.fixedHeight, this.resolution, this.rtl, this.testString, this.baselineX, this.baselineY, this.wordWrapWidth, this.wordWrapCallback, this.wordWrapCallbackScope, this.wordWrapUseAdvanced, this._font, this.setStyle(Q, false, true);
        }, setStyle: function(Z, D, Q) {
          if (D === undefined)
            D = true;
          if (Q === undefined)
            Q = false;
          if (Z && Z.hasOwnProperty("fontSize") && typeof Z.fontSize === "number")
            Z.fontSize = Z.fontSize.toString() + "px";
          for (var H in K) {
            var N = Q ? K[H][1] : this[H];
            if (H === "wordWrapCallback" || H === "wordWrapCallbackScope")
              this[H] = z(Z, K[H][0], N);
            else
              this[H] = L(Z, K[H][0], N);
          }
          var W = z(Z, "font", null);
          if (W !== null)
            this.setFont(W, false);
          this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim();
          var R = z(Z, "fill", null);
          if (R !== null)
            this.color = R;
          var Y = z(Z, "metrics", false);
          if (Y)
            this.metrics = { ascent: z(Y, "ascent", 0), descent: z(Y, "descent", 0), fontSize: z(Y, "fontSize", 0) };
          else if (D || !this.metrics)
            this.metrics = U(this);
          if (D)
            return this.parent.updateText();
          else
            return this.parent;
        }, syncFont: function(Z, D) {
          D.font = this._font;
        }, syncStyle: function(Z, D) {
          D.textBaseline = "alphabetic", D.fillStyle = this.color, D.strokeStyle = this.stroke, D.lineWidth = this.strokeThickness, D.lineCap = "round", D.lineJoin = "round";
        }, syncShadow: function(Z, D) {
          if (D)
            Z.shadowOffsetX = this.shadowOffsetX, Z.shadowOffsetY = this.shadowOffsetY, Z.shadowColor = this.shadowColor, Z.shadowBlur = this.shadowBlur;
          else
            Z.shadowOffsetX = 0, Z.shadowOffsetY = 0, Z.shadowColor = 0, Z.shadowBlur = 0;
        }, update: function(Z) {
          if (Z)
            this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(" ").trim(), this.metrics = U(this);
          return this.parent.updateText();
        }, setFont: function(Z, D) {
          if (D === undefined)
            D = true;
          var Q = Z, H = "", N = "";
          if (typeof Z !== "string")
            Q = z(Z, "fontFamily", "Courier"), H = z(Z, "fontSize", "16px"), N = z(Z, "fontStyle", "");
          else {
            var W = Z.split(" "), R = 0;
            N = W.length > 2 ? W[R++] : "", H = W[R++] || "16px", Q = W[R++] || "Courier";
          }
          if (Q !== this.fontFamily || H !== this.fontSize || N !== this.fontStyle) {
            if (this.fontFamily = Q, this.fontSize = H, this.fontStyle = N, D)
              this.update(true);
          }
          return this.parent;
        }, setFontFamily: function(Z) {
          if (this.fontFamily !== Z)
            this.fontFamily = Z, this.update(true);
          return this.parent;
        }, setFontStyle: function(Z) {
          if (this.fontStyle !== Z)
            this.fontStyle = Z, this.update(true);
          return this.parent;
        }, setFontSize: function(Z) {
          if (typeof Z === "number")
            Z = Z.toString() + "px";
          if (this.fontSize !== Z)
            this.fontSize = Z, this.update(true);
          return this.parent;
        }, setTestString: function(Z) {
          return this.testString = Z, this.update(true);
        }, setFixedSize: function(Z, D) {
          if (this.fixedWidth = Z, this.fixedHeight = D, Z)
            this.parent.width = Z;
          if (D)
            this.parent.height = D;
          return this.update(false);
        }, setBackgroundColor: function(Z) {
          return this.backgroundColor = Z, this.update(false);
        }, setFill: function(Z) {
          return this.color = Z, this.update(false);
        }, setColor: function(Z) {
          return this.color = Z, this.update(false);
        }, setResolution: function(Z) {
          return this.resolution = Z, this.update(false);
        }, setStroke: function(Z, D) {
          if (D === undefined)
            D = this.strokeThickness;
          if (Z === undefined && this.strokeThickness !== 0)
            this.strokeThickness = 0, this.update(true);
          else if (this.stroke !== Z || this.strokeThickness !== D)
            this.stroke = Z, this.strokeThickness = D, this.update(true);
          return this.parent;
        }, setShadow: function(Z, D, Q, H, N, W) {
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = "#000";
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = false;
          if (W === undefined)
            W = true;
          return this.shadowOffsetX = Z, this.shadowOffsetY = D, this.shadowColor = Q, this.shadowBlur = H, this.shadowStroke = N, this.shadowFill = W, this.update(false);
        }, setShadowOffset: function(Z, D) {
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = Z;
          return this.shadowOffsetX = Z, this.shadowOffsetY = D, this.update(false);
        }, setShadowColor: function(Z) {
          if (Z === undefined)
            Z = "#000";
          return this.shadowColor = Z, this.update(false);
        }, setShadowBlur: function(Z) {
          if (Z === undefined)
            Z = 0;
          return this.shadowBlur = Z, this.update(false);
        }, setShadowStroke: function(Z) {
          return this.shadowStroke = Z, this.update(false);
        }, setShadowFill: function(Z) {
          return this.shadowFill = Z, this.update(false);
        }, setWordWrapWidth: function(Z, D) {
          if (D === undefined)
            D = false;
          return this.wordWrapWidth = Z, this.wordWrapUseAdvanced = D, this.update(false);
        }, setWordWrapCallback: function(Z, D) {
          if (D === undefined)
            D = null;
          return this.wordWrapCallback = Z, this.wordWrapCallbackScope = D, this.update(false);
        }, setAlign: function(Z) {
          if (Z === undefined)
            Z = "left";
          return this.align = Z, this.update(false);
        }, setMaxLines: function(Z) {
          if (Z === undefined)
            Z = 0;
          return this.maxLines = Z, this.update(false);
        }, getTextMetrics: function() {
          var Z = this.metrics;
          return { ascent: Z.ascent, descent: Z.descent, fontSize: Z.fontSize };
        }, toJSON: function() {
          var Z = {};
          for (var D in K)
            Z[D] = this[D];
          return Z.metrics = this.getTextMetrics(), Z;
        }, destroy: function() {
          this.parent = undefined;
        } });
        M.exports = J;
      }, 34397: (M, B, $) => {
        var E = $(70554), L = function(z, U, K, J) {
          if (U.width === 0 || U.height === 0)
            return;
          K.addToRenderList(U);
          var Z = U.frame, D = Z.width, Q = Z.height, H = E.getTintAppendFloatAlpha, N = z.pipelines.set(U.pipeline, U), W = N.setTexture2D(Z.glTexture, U);
          N.batchTexture(U, Z.glTexture, D, Q, U.x, U.y, D / U.style.resolution, Q / U.style.resolution, U.scaleX, U.scaleY, U.rotation, U.flipX, U.flipY, U.scrollFactorX, U.scrollFactorY, U.displayOriginX, U.displayOriginY, 0, 0, D, Q, H(U.tintTopLeft, K.alpha * U._alphaTL), H(U.tintTopRight, K.alpha * U._alphaTR), H(U.tintBottomLeft, K.alpha * U._alphaBL), H(U.tintBottomRight, K.alpha * U._alphaBR), U.tintFill, 0, 0, K, J, false, W);
        };
        M.exports = L;
      }, 20839: (M, B, $) => {
        var E = $(27919), L = $(83419), z = $(31401), U = $(95643), K = $(98439), J = $(68703), Z = $(56295), D = $(45650), Q = $(26099), H = 8, N = new L({ Extends: U, Mixins: [z.Alpha, z.BlendMode, z.ComputedSize, z.Crop, z.Depth, z.Flip, z.GetBounds, z.Mask, z.Origin, z.Pipeline, z.PostPipeline, z.ScrollFactor, z.Tint, z.Transform, z.Visible, Z], initialize: function W(R, Y, I, P, X, G, V) {
          var A = R.sys.renderer;
          U.call(this, R, "TileSprite");
          var F = R.sys.textures.get(G), j = F.get(V);
          if (j.source.compressionAlgorithm)
            console.warn("TileSprite cannot use compressed texture"), F = R.sys.textures.get("__MISSING"), j = F.get();
          if (F.type === "DynamicTexture")
            console.warn("TileSprite cannot use Dynamic Texture"), F = R.sys.textures.get("__MISSING"), j = F.get();
          if (!P || !X)
            P = j.width, X = j.height;
          else
            P = Math.floor(P), X = Math.floor(X);
          this._tilePosition = new Q, this._tileScale = new Q(1, 1), this.dirty = false, this.renderer = A, this.canvas = E.create(this, P, X), this.context = this.canvas.getContext("2d", { willReadFrequently: false }), this.displayTexture = F, this.displayFrame = j, this._crop = this.resetCropObject(), this._textureKey = D(), this.texture = R.sys.textures.addCanvas(this._textureKey, this.canvas), this.frame = this.texture.get(), this.potWidth = K(j.width), this.potHeight = K(j.height), this.fillCanvas = E.create2D(this, this.potWidth, this.potHeight), this.fillContext = this.fillCanvas.getContext("2d", { willReadFrequently: false }), this.fillPattern = null, this.setPosition(Y, I), this.setSize(P, X), this.setFrame(V), this.setOriginFromFrame(), this.initPipeline(), this.initPostPipeline(true);
        }, setTexture: function(W, R) {
          return this.displayTexture = this.scene.sys.textures.get(W), this.setFrame(R);
        }, setFrame: function(W) {
          var R = this.displayTexture.get(W);
          if (this.potWidth = K(R.width), this.potHeight = K(R.height), this.canvas.width = 0, !R.cutWidth || !R.cutHeight)
            this.renderFlags &= ~H;
          else
            this.renderFlags |= H;
          return this.displayFrame = R, this.dirty = true, this.updateTileTexture(), this;
        }, setTilePosition: function(W, R) {
          if (W !== undefined)
            this.tilePositionX = W;
          if (R !== undefined)
            this.tilePositionY = R;
          return this;
        }, setTileScale: function(W, R) {
          if (W === undefined)
            W = this.tileScaleX;
          if (R === undefined)
            R = W;
          return this.tileScaleX = W, this.tileScaleY = R, this;
        }, updateTileTexture: function() {
          if (!this.dirty || !this.renderer)
            return;
          var W = this.displayFrame;
          if (W.source.isRenderTexture || W.source.isGLTexture) {
            console.warn("TileSprites can only use Image or Canvas based textures"), this.dirty = false;
            return;
          }
          var R = this.fillContext, Y = this.fillCanvas, I = this.potWidth, P = this.potHeight;
          if (!this.renderer || !this.renderer.gl)
            I = W.cutWidth, P = W.cutHeight;
          if (R.clearRect(0, 0, I, P), Y.width = I, Y.height = P, R.drawImage(W.source.image, W.cutX, W.cutY, W.cutWidth, W.cutHeight, 0, 0, I, P), this.renderer && this.renderer.gl)
            this.fillPattern = this.renderer.canvasToTexture(Y, this.fillPattern);
          else
            this.fillPattern = R.createPattern(Y, "repeat");
          this.updateCanvas(), this.dirty = false;
        }, updateCanvas: function() {
          var W = this.canvas;
          if (W.width !== this.width || W.height !== this.height)
            W.width = this.width, W.height = this.height, this.frame.setSize(this.width, this.height), this.updateDisplayOrigin(), this.dirty = true;
          if (!this.dirty || this.renderer && this.renderer.gl) {
            this.dirty = false;
            return;
          }
          var R = this.context;
          if (!this.scene.sys.game.config.antialias)
            J.disable(R);
          var Y = this._tileScale.x, I = this._tileScale.y, P = this._tilePosition.x, X = this._tilePosition.y;
          R.clearRect(0, 0, this.width, this.height), R.save(), R.scale(Y, I), R.translate(-P, -X), R.fillStyle = this.fillPattern, R.fillRect(P, X, this.width / Y, this.height / I), R.restore(), this.dirty = false;
        }, preDestroy: function() {
          if (this.renderer && this.renderer.gl)
            this.renderer.deleteTexture(this.fillPattern);
          E.remove(this.canvas), E.remove(this.fillCanvas), this.fillPattern = null, this.fillContext = null, this.fillCanvas = null, this.displayTexture = null, this.displayFrame = null;
          var W = this.texture;
          if (W)
            W.destroy();
          this.renderer = null;
        }, tilePositionX: { get: function() {
          return this._tilePosition.x;
        }, set: function(W) {
          this._tilePosition.x = W, this.dirty = true;
        } }, tilePositionY: { get: function() {
          return this._tilePosition.y;
        }, set: function(W) {
          this._tilePosition.y = W, this.dirty = true;
        } }, tileScaleX: { get: function() {
          return this._tileScale.x;
        }, set: function(W) {
          this._tileScale.x = W, this.dirty = true;
        } }, tileScaleY: { get: function() {
          return this._tileScale.y;
        }, set: function(W) {
          this._tileScale.y = W, this.dirty = true;
        } } });
        M.exports = N;
      }, 46992: (M) => {
        var B = function($, E, L, z) {
          E.updateCanvas(), L.addToRenderList(E), $.batchSprite(E, E.frame, L, z);
        };
        M.exports = B;
      }, 14167: (M, B, $) => {
        var E = $(25305), L = $(44603), z = $(23568), U = $(20839);
        L.register("tileSprite", function(K, J) {
          if (K === undefined)
            K = {};
          var Z = z(K, "x", 0), D = z(K, "y", 0), Q = z(K, "width", 512), H = z(K, "height", 512), N = z(K, "key", ""), W = z(K, "frame", ""), R = new U(this.scene, Z, D, Q, H, N, W);
          if (J !== undefined)
            K.add = J;
          return E(this.scene, R, K), R;
        });
      }, 91681: (M, B, $) => {
        var E = $(20839), L = $(39429);
        L.register("tileSprite", function(z, U, K, J, Z, D) {
          return this.displayList.add(new E(this.scene, z, U, K, J, Z, D));
        });
      }, 56295: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(18553), z = $(46992), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 18553: (M, B, $) => {
        var E = $(70554), L = function(z, U, K, J) {
          U.updateCanvas();
          var { width: Z, height: D } = U;
          if (Z === 0 || D === 0)
            return;
          K.addToRenderList(U);
          var Q = E.getTintAppendFloatAlpha, H = z.pipelines.set(U.pipeline, U), N = H.setTexture2D(U.fillPattern, U);
          H.batchTexture(U, U.fillPattern, U.displayFrame.width * U.tileScaleX, U.displayFrame.height * U.tileScaleY, U.x, U.y, Z, D, U.scaleX, U.scaleY, U.rotation, U.flipX, U.flipY, U.scrollFactorX, U.scrollFactorY, U.originX * Z, U.originY * D, 0, 0, Z, D, Q(U.tintTopLeft, K.alpha * U._alphaTL), Q(U.tintTopRight, K.alpha * U._alphaTR), Q(U.tintBottomLeft, K.alpha * U._alphaBL), Q(U.tintBottomRight, K.alpha * U._alphaBR), U.tintFill, U.tilePositionX % U.displayFrame.width / U.displayFrame.width, U.tilePositionY % U.displayFrame.height / U.displayFrame.height, K, J, false, N);
        };
        M.exports = L;
      }, 18471: (M, B, $) => {
        var E = $(45319), L = $(83419), z = $(31401), U = $(51708), K = $(8443), J = $(95643), Z = $(36383), D = $(14463), Q = $(45650), H = $(10247), N = new L({ Extends: J, Mixins: [z.Alpha, z.BlendMode, z.ComputedSize, z.Depth, z.Flip, z.GetBounds, z.Mask, z.Origin, z.Pipeline, z.PostPipeline, z.ScrollFactor, z.TextureCrop, z.Tint, z.Transform, z.Visible, H], initialize: function W(R, Y, I, P) {
          J.call(this, R, "Video"), this.video, this.videoTexture, this.videoTextureSource, this.snapshotTexture, this.flipY = false, this._key = Q(), this.touchLocked = false, this.playWhenUnlocked = false, this.frameReady = false, this.isStalled = false, this.failedPlayAttempts = 0, this.metadata, this.retry = 0, this.retryInterval = 500, this._systemMuted = false, this._codeMuted = false, this._systemPaused = false, this._codePaused = false, this._callbacks = { ended: this.completeHandler.bind(this), legacy: this.legacyPlayHandler.bind(this), playing: this.playingHandler.bind(this), seeked: this.seekedHandler.bind(this), seeking: this.seekingHandler.bind(this), stalled: this.stalledHandler.bind(this), suspend: this.stalledHandler.bind(this), waiting: this.stalledHandler.bind(this) }, this._loadCallbackHandler = this.loadErrorHandler.bind(this), this._metadataCallbackHandler = this.metadataHandler.bind(this), this._crop = this.resetCropObject(), this.markers = {}, this._markerIn = 0, this._markerOut = 0, this._playingMarker = false, this._lastUpdate = 0, this.cacheKey = "", this.isSeeking = false, this._playCalled = false, this._rfvCallbackId = 0;
          var X = R.sys.game;
          this._device = X.device.video, this.setPosition(Y, I), this.setSize(256, 256), this.initPipeline(), this.initPostPipeline(true), X.events.on(K.PAUSE, this.globalPause, this), X.events.on(K.RESUME, this.globalResume, this);
          var G = R.sys.sound;
          if (G)
            G.on(D.GLOBAL_MUTE, this.globalMute, this);
          if (P)
            this.load(P);
        }, addedToScene: function() {
          this.scene.sys.updateList.add(this);
        }, removedFromScene: function() {
          this.scene.sys.updateList.remove(this);
        }, load: function(W) {
          var R = this.scene.sys.cache.video.get(W);
          if (R)
            this.cacheKey = W, this.loadHandler(R.url, R.noAudio, R.crossOrigin);
          else
            console.warn("No video in cache for key: " + W);
          return this;
        }, changeSource: function(W, R, Y, I, P) {
          if (R === undefined)
            R = true;
          if (Y === undefined)
            Y = false;
          if (this.cacheKey !== W) {
            if (this.load(W), R)
              this.play(Y, I, P);
          }
        }, getVideoKey: function() {
          return this.cacheKey;
        }, loadURL: function(W, R, Y) {
          if (R === undefined)
            R = false;
          var I = this._device.getVideoURL(W);
          if (!I)
            console.warn("No supported video format found for " + W);
          else
            this.cacheKey = "", this.loadHandler(I.url, R, Y);
          return this;
        }, loadMediaStream: function(W, R, Y) {
          return this.loadHandler(null, R, Y, W);
        }, loadHandler: function(W, R, Y, I) {
          if (!R)
            R = false;
          var P = this.video;
          if (P)
            this.removeLoadEventHandlers(), this.stop();
          else
            P = document.createElement("video"), P.controls = false, P.setAttribute("playsinline", "playsinline"), P.setAttribute("preload", "auto"), P.setAttribute("disablePictureInPicture", "true");
          if (R)
            P.muted = true, P.defaultMuted = true, P.setAttribute("autoplay", "autoplay");
          else
            P.muted = false, P.defaultMuted = false, P.removeAttribute("autoplay");
          if (!Y)
            P.removeAttribute("crossorigin");
          else
            P.setAttribute("crossorigin", Y);
          if (I)
            if ("srcObject" in P)
              try {
                P.srcObject = I;
              } catch (G) {
                if (G.name !== "TypeError")
                  throw G;
                P.src = URL.createObjectURL(I);
              }
            else
              P.src = URL.createObjectURL(I);
          else
            P.src = W;
          this.retry = 0, this.video = P, this._playCalled = false, P.load(), this.addLoadEventHandlers();
          var X = this.scene.sys.textures.get(this._key);
          return this.setTexture(X), this;
        }, requestVideoFrame: function(W, R) {
          var Y = this.video;
          if (!Y)
            return;
          var { width: I, height: P } = R, X = this.videoTexture, G = this.videoTextureSource, V = !X || G.source !== Y;
          if (V) {
            if (this._codePaused = Y.paused, this._codeMuted = Y.muted, !X)
              X = this.scene.sys.textures.create(this._key, Y, I, P), X.add("__BASE", 0, 0, 0, I, P), this.setTexture(X), this.videoTexture = X, this.videoTextureSource = X.source[0], this.videoTextureSource.setFlipY(this.flipY), this.emit(U.VIDEO_TEXTURE, this, X);
            else
              G.source = Y, G.width = I, G.height = P, X.get().setSize(I, P);
            this.setSizeToFrame(), this.updateDisplayOrigin();
          } else
            G.update();
          this.isStalled = false, this.metadata = R;
          var A = R.mediaTime;
          if (V) {
            if (this._lastUpdate = A, this.emit(U.VIDEO_CREATED, this, I, P), !this.frameReady)
              this.frameReady = true, this.emit(U.VIDEO_PLAY, this);
          }
          if (this._playingMarker) {
            if (A >= this._markerOut)
              if (Y.loop)
                Y.currentTime = this._markerIn, this.emit(U.VIDEO_LOOP, this);
              else
                this.stop(false), this.emit(U.VIDEO_COMPLETE, this);
          } else if (A < this._lastUpdate)
            this.emit(U.VIDEO_LOOP, this);
          this._lastUpdate = A, this._rfvCallbackId = this.video.requestVideoFrameCallback(this.requestVideoFrame.bind(this));
        }, play: function(W, R, Y) {
          if (R === undefined)
            R = -1;
          if (Y === undefined)
            Y = Z.MAX_SAFE_INTEGER;
          var I = this.video;
          if (!I || this.isPlaying()) {
            if (!I)
              console.warn("Video not loaded");
            return this;
          }
          if (W === undefined)
            W = I.loop;
          if (I.loop = W, this._markerIn = R, this._markerOut = Y, this._playingMarker = R > -1 && Y > R && Y < Z.MAX_SAFE_INTEGER, !this._playCalled)
            this._rfvCallbackId = I.requestVideoFrameCallback(this.requestVideoFrame.bind(this)), this._playCalled = true, this.createPlayPromise();
          return this;
        }, addLoadEventHandlers: function() {
          var W = this.video;
          if (W)
            W.addEventListener("error", this._loadCallbackHandler), W.addEventListener("abort", this._loadCallbackHandler), W.addEventListener("loadedmetadata", this._metadataCallbackHandler);
        }, removeLoadEventHandlers: function() {
          var W = this.video;
          if (W)
            W.removeEventListener("error", this._loadCallbackHandler), W.removeEventListener("abort", this._loadCallbackHandler);
        }, addEventHandlers: function() {
          var W = this.video;
          if (W) {
            var R = this._callbacks;
            for (var Y in R)
              W.addEventListener(Y, R[Y]);
          }
        }, removeEventHandlers: function() {
          var W = this.video;
          if (W) {
            var R = this._callbacks;
            for (var Y in R)
              W.removeEventListener(Y, R[Y]);
          }
        }, createPlayPromise: function(W) {
          if (W === undefined)
            W = true;
          var R = this.video, Y = R.play();
          if (Y !== undefined) {
            var I = this.playSuccess.bind(this), P = this.playError.bind(this);
            if (!W) {
              var X = this;
              P = function() {
                X.failedPlayAttempts++;
              };
            }
            Y.then(I).catch(P);
          } else if (R.addEventListener("playing", this._callbacks.legacy), !W)
            this.failedPlayAttempts++;
        }, addMarker: function(W, R, Y) {
          if (!isNaN(R) && R >= 0 && !isNaN(Y) && Y > R)
            this.markers[W] = [R, Y];
          return this;
        }, playMarker: function(W, R) {
          var Y = this.markers[W];
          if (Y)
            this.play(R, Y[0], Y[1]);
          return this;
        }, removeMarker: function(W) {
          return delete this.markers[W], this;
        }, snapshot: function(W, R) {
          if (W === undefined)
            W = this.width;
          if (R === undefined)
            R = this.height;
          return this.snapshotArea(0, 0, this.width, this.height, W, R);
        }, snapshotArea: function(W, R, Y, I, P, X) {
          if (W === undefined)
            W = 0;
          if (R === undefined)
            R = 0;
          if (Y === undefined)
            Y = this.width;
          if (I === undefined)
            I = this.height;
          if (P === undefined)
            P = Y;
          if (X === undefined)
            X = I;
          var G = this.video, V = this.snapshotTexture;
          if (!V) {
            if (V = this.scene.sys.textures.createCanvas(Q(), P, X), this.snapshotTexture = V, G)
              V.context.drawImage(G, W, R, Y, I, 0, 0, P, X);
          } else if (V.setSize(P, X), G)
            V.context.drawImage(G, W, R, Y, I, 0, 0, P, X);
          return V.update();
        }, saveSnapshotTexture: function(W) {
          if (this.snapshotTexture)
            this.scene.sys.textures.renameTexture(this.snapshotTexture.key, W);
          else
            this.snapshotTexture = this.scene.sys.textures.createCanvas(W, this.width, this.height);
          return this.snapshotTexture;
        }, playSuccess: function() {
          if (!this._playCalled)
            return;
          if (this.addEventHandlers(), this._codePaused = false, this.touchLocked)
            this.touchLocked = false, this.emit(U.VIDEO_UNLOCKED, this);
          var W = this.scene.sys.sound;
          if (W && W.mute)
            this.setMute(true);
          if (this._markerIn > -1)
            this.video.currentTime = this._markerIn;
        }, playError: function(W) {
          var R = W.name;
          if (R === "NotAllowedError")
            this.touchLocked = true, this.playWhenUnlocked = true, this.failedPlayAttempts = 1, this.emit(U.VIDEO_LOCKED, this);
          else if (R === "NotSupportedError")
            this.stop(false), this.emit(U.VIDEO_UNSUPPORTED, this, W);
          else
            this.stop(false), this.emit(U.VIDEO_ERROR, this, W);
        }, legacyPlayHandler: function() {
          var W = this.video;
          if (W)
            this.playSuccess(), W.removeEventListener("playing", this._callbacks.legacy);
        }, playingHandler: function() {
          this.isStalled = false, this.emit(U.VIDEO_PLAYING, this);
        }, loadErrorHandler: function(W) {
          this.stop(false), this.emit(U.VIDEO_ERROR, this, W);
        }, metadataHandler: function(W) {
          this.emit(U.VIDEO_METADATA, this, W);
        }, setSizeToFrame: function(W) {
          if (!W)
            W = this.frame;
          if (this.width = W.realWidth, this.height = W.realHeight, this.scaleX !== 1)
            this.scaleX = this.displayWidth / this.width;
          if (this.scaleY !== 1)
            this.scaleY = this.displayHeight / this.height;
          var R = this.input;
          if (R && !R.customHitArea)
            R.hitArea.width = this.width, R.hitArea.height = this.height;
          return this;
        }, stalledHandler: function(W) {
          this.isStalled = true, this.emit(U.VIDEO_STALLED, this, W);
        }, completeHandler: function() {
          this._playCalled = false, this.emit(U.VIDEO_COMPLETE, this);
        }, preUpdate: function(W, R) {
          var Y = this.video;
          if (!Y || !this._playCalled)
            return;
          if (this.touchLocked && this.playWhenUnlocked) {
            if (this.retry += R, this.retry >= this.retryInterval)
              this.createPlayPromise(false), this.retry = 0;
          }
        }, seekTo: function(W) {
          var R = this.video;
          if (R) {
            var Y = R.duration;
            if (Y !== Infinity && !isNaN(Y)) {
              var I = Y * W;
              this.setCurrentTime(I);
            }
          }
          return this;
        }, getCurrentTime: function() {
          return this.video ? this.video.currentTime : 0;
        }, setCurrentTime: function(W) {
          var R = this.video;
          if (R) {
            if (typeof W === "string") {
              var Y = W[0], I = parseFloat(W.substr(1));
              if (Y === "+")
                W = R.currentTime + I;
              else if (Y === "-")
                W = R.currentTime - I;
            }
            R.currentTime = W;
          }
          return this;
        }, seekingHandler: function() {
          this.isSeeking = true, this.emit(U.VIDEO_SEEKING, this);
        }, seekedHandler: function() {
          this.isSeeking = false, this.emit(U.VIDEO_SEEKED, this);
        }, getProgress: function() {
          var W = this.video;
          if (W) {
            var R = W.duration;
            if (R !== Infinity && !isNaN(R))
              return W.currentTime / R;
          }
          return -1;
        }, getDuration: function() {
          return this.video ? this.video.duration : 0;
        }, setMute: function(W) {
          if (W === undefined)
            W = true;
          this._codeMuted = W;
          var R = this.video;
          if (R)
            R.muted = this._systemMuted ? true : W;
          return this;
        }, isMuted: function() {
          return this._codeMuted;
        }, globalMute: function(W, R) {
          this._systemMuted = R;
          var Y = this.video;
          if (Y)
            Y.muted = this._codeMuted ? true : R;
        }, globalPause: function() {
          if (this._systemPaused = true, this.video && !this.video.ended)
            this.removeEventHandlers(), this.video.pause();
        }, globalResume: function() {
          if (this._systemPaused = false, this.video && !this._codePaused && !this.video.ended)
            this.createPlayPromise();
        }, setPaused: function(W) {
          if (W === undefined)
            W = true;
          var R = this.video;
          if (this._codePaused = W, R && !R.ended) {
            if (W) {
              if (!R.paused)
                this.removeEventHandlers(), R.pause();
            } else if (!W) {
              if (!this._playCalled)
                this.play();
              else if (R.paused && !this._systemPaused)
                this.createPlayPromise();
            }
          }
          return this;
        }, pause: function() {
          return this.setPaused(true);
        }, resume: function() {
          return this.setPaused(false);
        }, getVolume: function() {
          return this.video ? this.video.volume : 1;
        }, setVolume: function(W) {
          if (W === undefined)
            W = 1;
          if (this.video)
            this.video.volume = E(W, 0, 1);
          return this;
        }, getPlaybackRate: function() {
          return this.video ? this.video.playbackRate : 1;
        }, setPlaybackRate: function(W) {
          if (this.video)
            this.video.playbackRate = W;
          return this;
        }, getLoop: function() {
          return this.video ? this.video.loop : false;
        }, setLoop: function(W) {
          if (W === undefined)
            W = true;
          if (this.video)
            this.video.loop = W;
          return this;
        }, isPlaying: function() {
          return this.video ? !(this.video.paused || this.video.ended) : false;
        }, isPaused: function() {
          return this.video && this._playCalled && this.video.paused || this._codePaused || this._systemPaused;
        }, saveTexture: function(W, R) {
          if (R === undefined)
            R = false;
          if (this.videoTexture)
            this.scene.sys.textures.renameTexture(this._key, W), this.videoTextureSource.setFlipY(R);
          return this._key = W, this.flipY = R, this.videoTexture ? true : false;
        }, stop: function(W) {
          if (W === undefined)
            W = true;
          var R = this.video;
          if (R)
            this.removeEventHandlers(), R.cancelVideoFrameCallback(this._rfvCallbackId), R.pause();
          if (this.retry = 0, this._playCalled = false, W)
            this.emit(U.VIDEO_STOP, this);
          return this;
        }, removeVideoElement: function() {
          var W = this.video;
          if (!W)
            return;
          if (W.parentNode)
            W.parentNode.removeChild(W);
          while (W.hasChildNodes())
            W.removeChild(W.firstChild);
          W.removeAttribute("autoplay"), W.removeAttribute("src"), this.video = null;
        }, preDestroy: function() {
          this.stop(false), this.removeLoadEventHandlers(), this.removeVideoElement();
          var W = this.scene.sys.game.events;
          W.off(K.PAUSE, this.globalPause, this), W.off(K.RESUME, this.globalResume, this);
          var R = this.scene.sys.sound;
          if (R)
            R.off(D.GLOBAL_MUTE, this.globalMute, this);
        } });
        M.exports = N;
      }, 58352: (M) => {
        var B = function($, E, L, z) {
          if (E.videoTexture)
            L.addToRenderList(E), $.batchSprite(E, E.frame, L, z);
        };
        M.exports = B;
      }, 11511: (M, B, $) => {
        var E = $(25305), L = $(44603), z = $(23568), U = $(18471);
        L.register("video", function(K, J) {
          if (K === undefined)
            K = {};
          var Z = z(K, "key", null), D = new U(this.scene, 0, 0, Z);
          if (J !== undefined)
            K.add = J;
          return E(this.scene, D, K), D;
        });
      }, 89025: (M, B, $) => {
        var E = $(18471), L = $(39429);
        L.register("video", function(z, U, K) {
          return this.displayList.add(new E(this.scene, z, U, K));
        });
      }, 10247: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(29849), z = $(58352), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 29849: (M) => {
        var B = function($, E, L, z) {
          if (E.videoTexture)
            L.addToRenderList(E), E.pipeline.batchSprite(E, L, z);
        };
        M.exports = B;
      }, 41481: (M, B, $) => {
        var E = $(10312), L = $(96503), z = $(87902), U = $(83419), K = $(31401), J = $(95643), Z = $(87841), D = $(37303), Q = new U({ Extends: J, Mixins: [K.Depth, K.GetBounds, K.Origin, K.Transform, K.ScrollFactor, K.Visible], initialize: function H(N, W, R, Y, I) {
          if (Y === undefined)
            Y = 1;
          if (I === undefined)
            I = Y;
          J.call(this, N, "Zone"), this.setPosition(W, R), this.width = Y, this.height = I, this.blendMode = E.NORMAL, this.updateDisplayOrigin();
        }, displayWidth: { get: function() {
          return this.scaleX * this.width;
        }, set: function(H) {
          this.scaleX = H / this.width;
        } }, displayHeight: { get: function() {
          return this.scaleY * this.height;
        }, set: function(H) {
          this.scaleY = H / this.height;
        } }, setSize: function(H, N, W) {
          if (W === undefined)
            W = true;
          this.width = H, this.height = N, this.updateDisplayOrigin();
          var R = this.input;
          if (W && R && !R.customHitArea)
            R.hitArea.width = H, R.hitArea.height = N;
          return this;
        }, setDisplaySize: function(H, N) {
          return this.displayWidth = H, this.displayHeight = N, this;
        }, setCircleDropZone: function(H) {
          return this.setDropZone(new L(0, 0, H), z);
        }, setRectangleDropZone: function(H, N) {
          return this.setDropZone(new Z(0, 0, H, N), D);
        }, setDropZone: function(H, N) {
          if (!this.input)
            this.setInteractive(H, N, true);
          return this;
        }, setAlpha: function() {
        }, setBlendMode: function() {
        }, renderCanvas: function(H, N, W) {
          W.addToRenderList(N);
        }, renderWebGL: function(H, N, W) {
          W.addToRenderList(N);
        } });
        M.exports = Q;
      }, 95261: (M, B, $) => {
        var E = $(44603), L = $(23568), z = $(41481);
        E.register("zone", function(U) {
          var K = L(U, "x", 0), J = L(U, "y", 0), Z = L(U, "width", 1), D = L(U, "height", Z);
          return new z(this.scene, K, J, Z, D);
        });
      }, 84175: (M, B, $) => {
        var E = $(41481), L = $(39429);
        L.register("zone", function(z, U, K, J) {
          return this.displayList.add(new E(this.scene, z, U, K, J));
        });
      }, 95166: (M) => {
        var B = function($) {
          return $.radius > 0 ? Math.PI * $.radius * $.radius : 0;
        };
        M.exports = B;
      }, 96503: (M, B, $) => {
        var E = $(83419), L = $(87902), z = $(26241), U = $(79124), K = $(23777), J = $(28176), Z = new E({ initialize: function D(Q, H, N) {
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = 0;
          this.type = K.CIRCLE, this.x = Q, this.y = H, this._radius = N, this._diameter = N * 2;
        }, contains: function(D, Q) {
          return L(this, D, Q);
        }, getPoint: function(D, Q) {
          return z(this, D, Q);
        }, getPoints: function(D, Q, H) {
          return U(this, D, Q, H);
        }, getRandomPoint: function(D) {
          return J(this, D);
        }, setTo: function(D, Q, H) {
          return this.x = D, this.y = Q, this._radius = H, this._diameter = H * 2, this;
        }, setEmpty: function() {
          return this._radius = 0, this._diameter = 0, this;
        }, setPosition: function(D, Q) {
          if (Q === undefined)
            Q = D;
          return this.x = D, this.y = Q, this;
        }, isEmpty: function() {
          return this._radius <= 0;
        }, radius: { get: function() {
          return this._radius;
        }, set: function(D) {
          this._radius = D, this._diameter = D * 2;
        } }, diameter: { get: function() {
          return this._diameter;
        }, set: function(D) {
          this._diameter = D, this._radius = D * 0.5;
        } }, left: { get: function() {
          return this.x - this._radius;
        }, set: function(D) {
          this.x = D + this._radius;
        } }, right: { get: function() {
          return this.x + this._radius;
        }, set: function(D) {
          this.x = D - this._radius;
        } }, top: { get: function() {
          return this.y - this._radius;
        }, set: function(D) {
          this.y = D + this._radius;
        } }, bottom: { get: function() {
          return this.y + this._radius;
        }, set: function(D) {
          this.y = D - this._radius;
        } } });
        M.exports = Z;
      }, 71562: (M) => {
        var B = function($) {
          return 2 * (Math.PI * $.radius);
        };
        M.exports = B;
      }, 92110: (M, B, $) => {
        var E = $(2141), L = function(z, U, K) {
          if (K === undefined)
            K = new E;
          return K.x = z.x + z.radius * Math.cos(U), K.y = z.y + z.radius * Math.sin(U), K;
        };
        M.exports = L;
      }, 42250: (M, B, $) => {
        var E = $(96503), L = function(z) {
          return new E(z.x, z.y, z.radius);
        };
        M.exports = L;
      }, 87902: (M) => {
        var B = function($, E, L) {
          if ($.radius > 0 && E >= $.left && E <= $.right && L >= $.top && L <= $.bottom) {
            var z = ($.x - E) * ($.x - E), U = ($.y - L) * ($.y - L);
            return z + U <= $.radius * $.radius;
          } else
            return false;
        };
        M.exports = B;
      }, 5698: (M, B, $) => {
        var E = $(87902), L = function(z, U) {
          return E(z, U.x, U.y);
        };
        M.exports = L;
      }, 70588: (M, B, $) => {
        var E = $(87902), L = function(z, U) {
          return E(z, U.x, U.y) && E(z, U.right, U.y) && E(z, U.x, U.bottom) && E(z, U.right, U.bottom);
        };
        M.exports = L;
      }, 26394: (M) => {
        var B = function($, E) {
          return E.setTo($.x, $.y, $.radius);
        };
        M.exports = B;
      }, 76278: (M) => {
        var B = function($, E) {
          return $.x === E.x && $.y === E.y && $.radius === E.radius;
        };
        M.exports = B;
      }, 2074: (M, B, $) => {
        var E = $(87841), L = function(z, U) {
          if (U === undefined)
            U = new E;
          return U.x = z.left, U.y = z.top, U.width = z.diameter, U.height = z.diameter, U;
        };
        M.exports = L;
      }, 26241: (M, B, $) => {
        var E = $(92110), L = $(62945), z = $(36383), U = $(2141), K = function(J, Z, D) {
          if (D === undefined)
            D = new U;
          var Q = L(Z, 0, z.PI2);
          return E(J, Q, D);
        };
        M.exports = K;
      }, 79124: (M, B, $) => {
        var E = $(71562), L = $(92110), z = $(62945), U = $(36383), K = function(J, Z, D, Q) {
          if (Q === undefined)
            Q = [];
          if (!Z && D > 0)
            Z = E(J) / D;
          for (var H = 0;H < Z; H++) {
            var N = z(H / Z, 0, U.PI2);
            Q.push(L(J, N));
          }
          return Q;
        };
        M.exports = K;
      }, 50884: (M) => {
        var B = function($, E, L) {
          return $.x += E, $.y += L, $;
        };
        M.exports = B;
      }, 39212: (M) => {
        var B = function($, E) {
          return $.x += E.x, $.y += E.y, $;
        };
        M.exports = B;
      }, 28176: (M, B, $) => {
        var E = $(2141), L = function(z, U) {
          if (U === undefined)
            U = new E;
          var K = 2 * Math.PI * Math.random(), J = Math.random() + Math.random(), Z = J > 1 ? 2 - J : J, D = Z * Math.cos(K), Q = Z * Math.sin(K);
          return U.x = z.x + D * z.radius, U.y = z.y + Q * z.radius, U;
        };
        M.exports = L;
      }, 88911: (M, B, $) => {
        var E = $(96503);
        E.Area = $(95166), E.Circumference = $(71562), E.CircumferencePoint = $(92110), E.Clone = $(42250), E.Contains = $(87902), E.ContainsPoint = $(5698), E.ContainsRect = $(70588), E.CopyFrom = $(26394), E.Equals = $(76278), E.GetBounds = $(2074), E.GetPoint = $(26241), E.GetPoints = $(79124), E.Offset = $(50884), E.OffsetPoint = $(39212), E.Random = $(28176), M.exports = E;
      }, 23777: (M) => {
        var B = { CIRCLE: 0, ELLIPSE: 1, LINE: 2, POINT: 3, POLYGON: 4, RECTANGLE: 5, TRIANGLE: 6 };
        M.exports = B;
      }, 78874: (M) => {
        var B = function($) {
          if ($.isEmpty())
            return 0;
          return $.getMajorRadius() * $.getMinorRadius() * Math.PI;
        };
        M.exports = B;
      }, 92990: (M) => {
        var B = function($) {
          var E = $.width / 2, L = $.height / 2, z = Math.pow(E - L, 2) / Math.pow(E + L, 2);
          return Math.PI * (E + L) * (1 + 3 * z / (10 + Math.sqrt(4 - 3 * z)));
        };
        M.exports = B;
      }, 79522: (M, B, $) => {
        var E = $(2141), L = function(z, U, K) {
          if (K === undefined)
            K = new E;
          var J = z.width / 2, Z = z.height / 2;
          return K.x = z.x + J * Math.cos(U), K.y = z.y + Z * Math.sin(U), K;
        };
        M.exports = L;
      }, 58102: (M, B, $) => {
        var E = $(8497), L = function(z) {
          return new E(z.x, z.y, z.width, z.height);
        };
        M.exports = L;
      }, 81154: (M) => {
        var B = function($, E, L) {
          if ($.width <= 0 || $.height <= 0)
            return false;
          var z = (E - $.x) / $.width, U = (L - $.y) / $.height;
          return z *= z, U *= U, z + U < 0.25;
        };
        M.exports = B;
      }, 46662: (M, B, $) => {
        var E = $(81154), L = function(z, U) {
          return E(z, U.x, U.y);
        };
        M.exports = L;
      }, 1632: (M, B, $) => {
        var E = $(81154), L = function(z, U) {
          return E(z, U.x, U.y) && E(z, U.right, U.y) && E(z, U.x, U.bottom) && E(z, U.right, U.bottom);
        };
        M.exports = L;
      }, 65534: (M) => {
        var B = function($, E) {
          return E.setTo($.x, $.y, $.width, $.height);
        };
        M.exports = B;
      }, 8497: (M, B, $) => {
        var E = $(83419), L = $(81154), z = $(90549), U = $(48320), K = $(23777), J = $(24820), Z = new E({ initialize: function D(Q, H, N, W) {
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = 0;
          this.type = K.ELLIPSE, this.x = Q, this.y = H, this.width = N, this.height = W;
        }, contains: function(D, Q) {
          return L(this, D, Q);
        }, getPoint: function(D, Q) {
          return z(this, D, Q);
        }, getPoints: function(D, Q, H) {
          return U(this, D, Q, H);
        }, getRandomPoint: function(D) {
          return J(this, D);
        }, setTo: function(D, Q, H, N) {
          return this.x = D, this.y = Q, this.width = H, this.height = N, this;
        }, setEmpty: function() {
          return this.width = 0, this.height = 0, this;
        }, setPosition: function(D, Q) {
          if (Q === undefined)
            Q = D;
          return this.x = D, this.y = Q, this;
        }, setSize: function(D, Q) {
          if (Q === undefined)
            Q = D;
          return this.width = D, this.height = Q, this;
        }, isEmpty: function() {
          return this.width <= 0 || this.height <= 0;
        }, getMinorRadius: function() {
          return Math.min(this.width, this.height) / 2;
        }, getMajorRadius: function() {
          return Math.max(this.width, this.height) / 2;
        }, left: { get: function() {
          return this.x - this.width / 2;
        }, set: function(D) {
          this.x = D + this.width / 2;
        } }, right: { get: function() {
          return this.x + this.width / 2;
        }, set: function(D) {
          this.x = D - this.width / 2;
        } }, top: { get: function() {
          return this.y - this.height / 2;
        }, set: function(D) {
          this.y = D + this.height / 2;
        } }, bottom: { get: function() {
          return this.y + this.height / 2;
        }, set: function(D) {
          this.y = D - this.height / 2;
        } } });
        M.exports = Z;
      }, 36146: (M) => {
        var B = function($, E) {
          return $.x === E.x && $.y === E.y && $.width === E.width && $.height === E.height;
        };
        M.exports = B;
      }, 23694: (M, B, $) => {
        var E = $(87841), L = function(z, U) {
          if (U === undefined)
            U = new E;
          return U.x = z.left, U.y = z.top, U.width = z.width, U.height = z.height, U;
        };
        M.exports = L;
      }, 90549: (M, B, $) => {
        var E = $(79522), L = $(62945), z = $(36383), U = $(2141), K = function(J, Z, D) {
          if (D === undefined)
            D = new U;
          var Q = L(Z, 0, z.PI2);
          return E(J, Q, D);
        };
        M.exports = K;
      }, 48320: (M, B, $) => {
        var E = $(92990), L = $(79522), z = $(62945), U = $(36383), K = function(J, Z, D, Q) {
          if (Q === undefined)
            Q = [];
          if (!Z && D > 0)
            Z = E(J) / D;
          for (var H = 0;H < Z; H++) {
            var N = z(H / Z, 0, U.PI2);
            Q.push(L(J, N));
          }
          return Q;
        };
        M.exports = K;
      }, 73424: (M) => {
        var B = function($, E, L) {
          return $.x += E, $.y += L, $;
        };
        M.exports = B;
      }, 44808: (M) => {
        var B = function($, E) {
          return $.x += E.x, $.y += E.y, $;
        };
        M.exports = B;
      }, 24820: (M, B, $) => {
        var E = $(2141), L = function(z, U) {
          if (U === undefined)
            U = new E;
          var K = Math.random() * Math.PI * 2, J = Math.sqrt(Math.random());
          return U.x = z.x + J * Math.cos(K) * z.width / 2, U.y = z.y + J * Math.sin(K) * z.height / 2, U;
        };
        M.exports = L;
      }, 49203: (M, B, $) => {
        var E = $(8497);
        E.Area = $(78874), E.Circumference = $(92990), E.CircumferencePoint = $(79522), E.Clone = $(58102), E.Contains = $(81154), E.ContainsPoint = $(46662), E.ContainsRect = $(1632), E.CopyFrom = $(65534), E.Equals = $(36146), E.GetBounds = $(23694), E.GetPoint = $(90549), E.GetPoints = $(48320), E.Offset = $(73424), E.OffsetPoint = $(44808), E.Random = $(24820), M.exports = E;
      }, 55738: (M, B, $) => {
        var E = $(23777), L = $(79291), z = { Circle: $(88911), Ellipse: $(49203), Intersects: $(91865), Line: $(2529), Mesh: $(73090), Point: $(43711), Polygon: $(58423), Rectangle: $(93232), Triangle: $(84435) };
        z = L(false, z, E), M.exports = z;
      }, 2044: (M, B, $) => {
        var E = $(20339), L = function(z, U) {
          return E(z.x, z.y, U.x, U.y) <= z.radius + U.radius;
        };
        M.exports = L;
      }, 81491: (M) => {
        var B = function($, E) {
          var L = E.width / 2, z = E.height / 2, U = Math.abs($.x - E.x - L), K = Math.abs($.y - E.y - z), J = L + $.radius, Z = z + $.radius;
          if (U > J || K > Z)
            return false;
          else if (U <= L || K <= z)
            return true;
          else {
            var D = U - L, Q = K - z, H = D * D, N = Q * Q, W = $.radius * $.radius;
            return H + N <= W;
          }
        };
        M.exports = B;
      }, 63376: (M, B, $) => {
        var E = $(2141), L = $(2044), z = function(U, K, J) {
          if (J === undefined)
            J = [];
          if (L(U, K)) {
            var { x: Z, y: D, radius: Q } = U, H = K.x, N = K.y, W = K.radius, R, Y, I, P, X;
            if (D === N) {
              if (X = (W * W - Q * Q - H * H + Z * Z) / (2 * (Z - H)), R = 1, Y = -2 * N, I = H * H + X * X - 2 * H * X + N * N - W * W, P = Y * Y - 4 * R * I, P === 0)
                J.push(new E(X, -Y / (2 * R)));
              else if (P > 0)
                J.push(new E(X, (-Y + Math.sqrt(P)) / (2 * R))), J.push(new E(X, (-Y - Math.sqrt(P)) / (2 * R)));
            } else {
              var G = (Z - H) / (D - N), V = (W * W - Q * Q - H * H + Z * Z - N * N + D * D) / (2 * (D - N));
              if (R = G * G + 1, Y = 2 * D * G - 2 * V * G - 2 * Z, I = Z * Z + D * D + V * V - Q * Q - 2 * D * V, P = Y * Y - 4 * R * I, P === 0)
                X = -Y / (2 * R), J.push(new E(X, V - X * G));
              else if (P > 0)
                X = (-Y + Math.sqrt(P)) / (2 * R), J.push(new E(X, V - X * G)), X = (-Y - Math.sqrt(P)) / (2 * R), J.push(new E(X, V - X * G));
            }
          }
          return J;
        };
        M.exports = z;
      }, 97439: (M, B, $) => {
        var E = $(4042), L = $(81491), z = function(U, K, J) {
          if (J === undefined)
            J = [];
          if (L(U, K)) {
            var Z = K.getLineA(), D = K.getLineB(), Q = K.getLineC(), H = K.getLineD();
            E(Z, U, J), E(D, U, J), E(Q, U, J), E(H, U, J);
          }
          return J;
        };
        M.exports = z;
      }, 4042: (M, B, $) => {
        var E = $(2141), L = $(80462), z = function(U, K, J) {
          if (J === undefined)
            J = [];
          if (L(U, K)) {
            var { x1: Z, y1: D, x2: Q, y2: H } = U, N = K.x, W = K.y, R = K.radius, Y = Q - Z, I = H - D, P = Z - N, X = D - W, G = Y * Y + I * I, V = 2 * (Y * P + I * X), A = P * P + X * X - R * R, F = V * V - 4 * G * A, j, T;
            if (F === 0) {
              var C = -V / (2 * G);
              if (j = Z + C * Y, T = D + C * I, C >= 0 && C <= 1)
                J.push(new E(j, T));
            } else if (F > 0) {
              var v = (-V - Math.sqrt(F)) / (2 * G);
              if (j = Z + v * Y, T = D + v * I, v >= 0 && v <= 1)
                J.push(new E(j, T));
              var O = (-V + Math.sqrt(F)) / (2 * G);
              if (j = Z + O * Y, T = D + O * I, O >= 0 && O <= 1)
                J.push(new E(j, T));
            }
          }
          return J;
        };
        M.exports = z;
      }, 36100: (M, B, $) => {
        var E = $(25836), L = function(z, U, K, J) {
          if (K === undefined)
            K = false;
          var { x1: Z, y1: D, x2: Q, y2: H } = z, N = U.x1, W = U.y1, R = U.x2, Y = U.y2, I = Q - Z, P = H - D, X = R - N, G = Y - W, V = I * G - P * X;
          if (V === 0)
            return null;
          var A, F, j;
          if (K) {
            if (A = (I * (W - D) + P * (Z - N)) / (X * P - G * I), F = (N + X * A - Z) / I, F < 0 || A < 0 || A > 1)
              return null;
            j = F;
          } else {
            if (A = ((N - Z) * G - (W - D) * X) / V, F = ((D - W) * I - (Z - N) * P) / V, A < 0 || A > 1 || F < 0 || F > 1)
              return null;
            j = A;
          }
          if (J === undefined)
            J = new E;
          return J.set(Z + I * j, D + P * j, j);
        };
        M.exports = L;
      }, 3073: (M, B, $) => {
        var E = $(36100), L = $(23031), z = $(25836), U = new L, K = new z, J = function(Z, D, Q, H) {
          if (Q === undefined)
            Q = false;
          if (H === undefined)
            H = new z;
          var N = false;
          H.set(), K.set();
          var W = D[D.length - 1];
          for (var R = 0;R < D.length; R++) {
            var Y = D[R];
            if (U.setTo(W.x, W.y, Y.x, Y.y), W = Y, E(Z, U, Q, K)) {
              if (!N || K.z < H.z)
                H.copy(K), N = true;
            }
          }
          return N ? H : null;
        };
        M.exports = J;
      }, 56362: (M, B, $) => {
        var E = $(25836), L = $(61369), z = $(3073), U = new E, K = function(J, Z, D, Q) {
          if (Q === undefined)
            Q = new L;
          if (!Array.isArray(Z))
            Z = [Z];
          var H = false;
          Q.set(), U.set();
          for (var N = 0;N < Z.length; N++)
            if (z(J, Z[N].points, D, U)) {
              if (!H || U.z < Q.z)
                Q.set(U.x, U.y, U.z, N), H = true;
            }
          return H ? Q : null;
        };
        M.exports = K;
      }, 60646: (M, B, $) => {
        var E = $(2141), L = $(76112), z = $(92773), U = function(K, J, Z) {
          if (Z === undefined)
            Z = [];
          if (z(K, J)) {
            var D = J.getLineA(), Q = J.getLineB(), H = J.getLineC(), N = J.getLineD(), W = [new E, new E, new E, new E], R = [L(D, K, W[0]), L(Q, K, W[1]), L(H, K, W[2]), L(N, K, W[3])];
            for (var Y = 0;Y < 4; Y++)
              if (R[Y])
                Z.push(W[Y]);
          }
          return Z;
        };
        M.exports = U;
      }, 71147: (M, B, $) => {
        var E = $(61369), L = $(56362), z = $(23031), U = new z;
        function K(D, Q, H, N, W) {
          var R = Math.cos(D), Y = Math.sin(D);
          U.setTo(Q, H, Q + R, H + Y);
          var I = L(U, N, true);
          if (I)
            W.push(new E(I.x, I.y, D, I.w));
        }
        function J(D, Q) {
          return D.z - Q.z;
        }
        var Z = function(D, Q, H) {
          if (!Array.isArray(H))
            H = [H];
          var N = [], W = [];
          for (var R = 0;R < H.length; R++) {
            var Y = H[R].points;
            for (var I = 0;I < Y.length; I++) {
              var P = Math.atan2(Y[I].y - Q, Y[I].x - D);
              if (W.indexOf(P) === -1)
                K(P, D, Q, H, N), K(P - 0.00001, D, Q, H, N), K(P + 0.00001, D, Q, H, N), W.push(P);
            }
          }
          return N.sort(J);
        };
        M.exports = Z;
      }, 68389: (M, B, $) => {
        var E = $(87841), L = $(59996), z = function(U, K, J) {
          if (J === undefined)
            J = new E;
          if (L(U, K))
            J.x = Math.max(U.x, K.x), J.y = Math.max(U.y, K.y), J.width = Math.min(U.right, K.right) - J.x, J.height = Math.min(U.bottom, K.bottom) - J.y;
          return J;
        };
        M.exports = z;
      }, 52784: (M, B, $) => {
        var E = $(60646), L = $(59996), z = function(U, K, J) {
          if (J === undefined)
            J = [];
          if (L(U, K)) {
            var Z = U.getLineA(), D = U.getLineB(), Q = U.getLineC(), H = U.getLineD();
            E(Z, K, J), E(D, K, J), E(Q, K, J), E(H, K, J);
          }
          return J;
        };
        M.exports = z;
      }, 26341: (M, B, $) => {
        var E = $(89265), L = $(60646), z = function(U, K, J) {
          if (J === undefined)
            J = [];
          if (E(U, K)) {
            var Z = K.getLineA(), D = K.getLineB(), Q = K.getLineC();
            L(Z, U, J), L(D, U, J), L(Q, U, J);
          }
          return J;
        };
        M.exports = z;
      }, 38720: (M, B, $) => {
        var E = $(4042), L = $(67636), z = function(U, K, J) {
          if (J === undefined)
            J = [];
          if (L(U, K)) {
            var Z = U.getLineA(), D = U.getLineB(), Q = U.getLineC();
            E(Z, K, J), E(D, K, J), E(Q, K, J);
          }
          return J;
        };
        M.exports = z;
      }, 13882: (M, B, $) => {
        var E = $(2141), L = $(2822), z = $(76112), U = function(K, J, Z) {
          if (Z === undefined)
            Z = [];
          if (L(K, J)) {
            var D = K.getLineA(), Q = K.getLineB(), H = K.getLineC(), N = [new E, new E, new E], W = [z(D, J, N[0]), z(Q, J, N[1]), z(H, J, N[2])];
            for (var R = 0;R < 3; R++)
              if (W[R])
                Z.push(N[R]);
          }
          return Z;
        };
        M.exports = U;
      }, 75636: (M, B, $) => {
        var E = $(82944), L = $(13882), z = function(U, K, J) {
          if (J === undefined)
            J = [];
          if (E(U, K)) {
            var Z = K.getLineA(), D = K.getLineB(), Q = K.getLineC();
            L(U, Z, J), L(U, D, J), L(U, Q, J);
          }
          return J;
        };
        M.exports = z;
      }, 80462: (M, B, $) => {
        var E = $(87902), L = $(2141), z = new L, U = function(K, J, Z) {
          if (Z === undefined)
            Z = z;
          if (E(J, K.x1, K.y1))
            return Z.x = K.x1, Z.y = K.y1, true;
          if (E(J, K.x2, K.y2))
            return Z.x = K.x2, Z.y = K.y2, true;
          var D = K.x2 - K.x1, Q = K.y2 - K.y1, H = J.x - K.x1, N = J.y - K.y1, W = D * D + Q * Q, R = D, Y = Q;
          if (W > 0) {
            var I = (H * D + N * Q) / W;
            R *= I, Y *= I;
          }
          Z.x = K.x1 + R, Z.y = K.y1 + Y;
          var P = R * R + Y * Y;
          return P <= W && R * D + Y * Q >= 0 && E(J, Z.x, Z.y);
        };
        M.exports = U;
      }, 76112: (M) => {
        var B = function($, E, L) {
          var { x1: z, y1: U, x2: K, y2: J } = $, Z = E.x1, D = E.y1, Q = E.x2, H = E.y2;
          if (z === K && U === J || Z === Q && D === H)
            return false;
          var N = (H - D) * (K - z) - (Q - Z) * (J - U);
          if (N === 0)
            return false;
          var W = ((Q - Z) * (U - D) - (H - D) * (z - Z)) / N, R = ((K - z) * (U - D) - (J - U) * (z - Z)) / N;
          if (W < 0 || W > 1 || R < 0 || R > 1)
            return false;
          else {
            if (L)
              L.x = z + W * (K - z), L.y = U + W * (J - U);
            return true;
          }
        };
        M.exports = B;
      }, 92773: (M) => {
        var B = function($, E) {
          var { x1: L, y1: z, x2: U, y2: K } = $, J = E.x, Z = E.y, D = E.right, Q = E.bottom, H = 0;
          if (L >= J && L <= D && z >= Z && z <= Q || U >= J && U <= D && K >= Z && K <= Q)
            return true;
          if (L < J && U >= J) {
            if (H = z + (K - z) * (J - L) / (U - L), H > Z && H <= Q)
              return true;
          } else if (L > D && U <= D) {
            if (H = z + (K - z) * (D - L) / (U - L), H >= Z && H <= Q)
              return true;
          }
          if (z < Z && K >= Z) {
            if (H = L + (U - L) * (Z - z) / (K - z), H >= J && H <= D)
              return true;
          } else if (z > Q && K <= Q) {
            if (H = L + (U - L) * (Q - z) / (K - z), H >= J && H <= D)
              return true;
          }
          return false;
        };
        M.exports = B;
      }, 16204: (M) => {
        var B = function($, E, L) {
          if (L === undefined)
            L = 1;
          var { x1: z, y1: U, x2: K, y2: J } = E, Z = $.x, D = $.y, Q = (K - z) * (K - z) + (J - U) * (J - U);
          if (Q === 0)
            return false;
          var H = ((Z - z) * (K - z) + (D - U) * (J - U)) / Q;
          if (H < 0)
            return Math.sqrt((z - Z) * (z - Z) + (U - D) * (U - D)) <= L;
          else if (H >= 0 && H <= 1) {
            var N = ((U - D) * (K - z) - (z - Z) * (J - U)) / Q;
            return Math.abs(N) * Math.sqrt(Q) <= L;
          } else
            return Math.sqrt((K - Z) * (K - Z) + (J - D) * (J - D)) <= L;
        };
        M.exports = B;
      }, 14199: (M, B, $) => {
        var E = $(16204), L = function(z, U) {
          if (!E(z, U))
            return false;
          var K = Math.min(U.x1, U.x2), J = Math.max(U.x1, U.x2), Z = Math.min(U.y1, U.y2), D = Math.max(U.y1, U.y2);
          return z.x >= K && z.x <= J && (z.y >= Z && z.y <= D);
        };
        M.exports = L;
      }, 59996: (M) => {
        var B = function($, E) {
          if ($.width <= 0 || $.height <= 0 || E.width <= 0 || E.height <= 0)
            return false;
          return !($.right < E.x || $.bottom < E.y || $.x > E.right || $.y > E.bottom);
        };
        M.exports = B;
      }, 89265: (M, B, $) => {
        var E = $(76112), L = $(37303), z = $(48653), U = $(77493), K = function(J, Z) {
          if (Z.left > J.right || Z.right < J.left || Z.top > J.bottom || Z.bottom < J.top)
            return false;
          var D = Z.getLineA(), Q = Z.getLineB(), H = Z.getLineC();
          if (L(J, D.x1, D.y1) || L(J, D.x2, D.y2))
            return true;
          if (L(J, Q.x1, Q.y1) || L(J, Q.x2, Q.y2))
            return true;
          if (L(J, H.x1, H.y1) || L(J, H.x2, H.y2))
            return true;
          var N = J.getLineA(), W = J.getLineB(), R = J.getLineC(), Y = J.getLineD();
          if (E(D, N) || E(D, W) || E(D, R) || E(D, Y))
            return true;
          if (E(Q, N) || E(Q, W) || E(Q, R) || E(Q, Y))
            return true;
          if (E(H, N) || E(H, W) || E(H, R) || E(H, Y))
            return true;
          var I = U(J), P = z(Z, I, true);
          return P.length > 0;
        };
        M.exports = K;
      }, 84411: (M) => {
        var B = function($, E, L, z, U, K) {
          if (K === undefined)
            K = 0;
          return !(E > $.right + K || L < $.left - K || z > $.bottom + K || U < $.top - K);
        };
        M.exports = B;
      }, 67636: (M, B, $) => {
        var E = $(80462), L = $(10690), z = function(U, K) {
          if (U.left > K.right || U.right < K.left || U.top > K.bottom || U.bottom < K.top)
            return false;
          if (L(U, K.x, K.y))
            return true;
          if (E(U.getLineA(), K))
            return true;
          if (E(U.getLineB(), K))
            return true;
          if (E(U.getLineC(), K))
            return true;
          return false;
        };
        M.exports = z;
      }, 2822: (M, B, $) => {
        var E = $(76112), L = function(z, U) {
          if (z.contains(U.x1, U.y1) || z.contains(U.x2, U.y2))
            return true;
          if (E(z.getLineA(), U))
            return true;
          if (E(z.getLineB(), U))
            return true;
          if (E(z.getLineC(), U))
            return true;
          return false;
        };
        M.exports = L;
      }, 82944: (M, B, $) => {
        var E = $(48653), L = $(71694), z = $(76112), U = function(K, J) {
          if (K.left > J.right || K.right < J.left || K.top > J.bottom || K.bottom < J.top)
            return false;
          var Z = K.getLineA(), D = K.getLineB(), Q = K.getLineC(), H = J.getLineA(), N = J.getLineB(), W = J.getLineC();
          if (z(Z, H) || z(Z, N) || z(Z, W))
            return true;
          if (z(D, H) || z(D, N) || z(D, W))
            return true;
          if (z(Q, H) || z(Q, N) || z(Q, W))
            return true;
          var R = L(K), Y = E(J, R, true);
          if (Y.length > 0)
            return true;
          if (R = L(J), Y = E(K, R, true), Y.length > 0)
            return true;
          return false;
        };
        M.exports = U;
      }, 91865: (M, B, $) => {
        M.exports = { CircleToCircle: $(2044), CircleToRectangle: $(81491), GetCircleToCircle: $(63376), GetCircleToRectangle: $(97439), GetLineToCircle: $(4042), GetLineToLine: $(36100), GetLineToPoints: $(3073), GetLineToPolygon: $(56362), GetLineToRectangle: $(60646), GetRaysFromPointToPolygon: $(71147), GetRectangleIntersection: $(68389), GetRectangleToRectangle: $(52784), GetRectangleToTriangle: $(26341), GetTriangleToCircle: $(38720), GetTriangleToLine: $(13882), GetTriangleToTriangle: $(75636), LineToCircle: $(80462), LineToLine: $(76112), LineToRectangle: $(92773), PointToLine: $(16204), PointToLineSegment: $(14199), RectangleToRectangle: $(59996), RectangleToTriangle: $(89265), RectangleToValues: $(84411), TriangleToCircle: $(67636), TriangleToLine: $(2822), TriangleToTriangle: $(82944) };
      }, 91938: (M) => {
        var B = function($) {
          return Math.atan2($.y2 - $.y1, $.x2 - $.x1);
        };
        M.exports = B;
      }, 84993: (M) => {
        var B = function($, E, L) {
          if (E === undefined)
            E = 1;
          if (L === undefined)
            L = [];
          var z = Math.round($.x1), U = Math.round($.y1), K = Math.round($.x2), J = Math.round($.y2), Z = Math.abs(K - z), D = Math.abs(J - U), Q = z < K ? 1 : -1, H = U < J ? 1 : -1, N = Z - D;
          L.push({ x: z, y: U });
          var W = 1;
          while (!(z === K && U === J)) {
            var R = N << 1;
            if (R > -D)
              N -= D, z += Q;
            if (R < Z)
              N += Z, U += H;
            if (W % E === 0)
              L.push({ x: z, y: U });
            W++;
          }
          return L;
        };
        M.exports = B;
      }, 36469: (M) => {
        var B = function($, E, L) {
          var z = E - ($.x1 + $.x2) / 2, U = L - ($.y1 + $.y2) / 2;
          return $.x1 += z, $.y1 += U, $.x2 += z, $.y2 += U, $;
        };
        M.exports = B;
      }, 31116: (M, B, $) => {
        var E = $(23031), L = function(z) {
          return new E(z.x1, z.y1, z.x2, z.y2);
        };
        M.exports = L;
      }, 59944: (M) => {
        var B = function($, E) {
          return E.setTo($.x1, $.y1, $.x2, $.y2);
        };
        M.exports = B;
      }, 59220: (M) => {
        var B = function($, E) {
          return $.x1 === E.x1 && $.y1 === E.y1 && $.x2 === E.x2 && $.y2 === E.y2;
        };
        M.exports = B;
      }, 78177: (M, B, $) => {
        var E = $(35001), L = function(z, U, K) {
          if (K === undefined)
            K = U;
          var J = E(z), Z = z.x2 - z.x1, D = z.y2 - z.y1;
          if (U)
            z.x1 = z.x1 - Z / J * U, z.y1 = z.y1 - D / J * U;
          if (K)
            z.x2 = z.x2 + Z / J * K, z.y2 = z.y2 + D / J * K;
          return z;
        };
        M.exports = L;
      }, 26708: (M, B, $) => {
        var E = $(52816), L = $(6113), z = $(2141), U = function(K, J, Z, D, Q) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = [];
          var H = [], N = K.x1, W = K.y1, R = K.x2 - N, Y = K.y2 - W, I = L(J, Q), P, X, G = Z - 1;
          for (P = 0;P < G; P++)
            X = I(P / G), H.push(new z(N + R * X, W + Y * X));
          if (X = I(1), H.push(new z(N + R * X, W + Y * X)), D > 0) {
            var V = H[0], A = [V];
            for (P = 1;P < H.length - 1; P++) {
              var F = H[P];
              if (E(V, F) >= D)
                A.push(F), V = F;
            }
            var j = H[H.length - 1];
            if (E(V, j) < D)
              A.pop();
            return A.push(j), A;
          } else
            return H;
        };
        M.exports = U;
      }, 32125: (M, B, $) => {
        var E = $(2141), L = function(z, U) {
          if (U === undefined)
            U = new E;
          return U.x = (z.x1 + z.x2) / 2, U.y = (z.y1 + z.y2) / 2, U;
        };
        M.exports = L;
      }, 99569: (M, B, $) => {
        var E = $(2141), L = function(z, U, K) {
          if (K === undefined)
            K = new E;
          var { x1: J, y1: Z, x2: D, y2: Q } = z, H = (D - J) * (D - J) + (Q - Z) * (Q - Z);
          if (H === 0)
            return K;
          var N = ((U.x - J) * (D - J) + (U.y - Z) * (Q - Z)) / H;
          return K.x = J + N * (D - J), K.y = Z + N * (Q - Z), K;
        };
        M.exports = L;
      }, 34638: (M, B, $) => {
        var E = $(36383), L = $(91938), z = $(2141), U = function(K, J) {
          if (J === undefined)
            J = new z;
          var Z = L(K) - E.TAU;
          return J.x = Math.cos(Z), J.y = Math.sin(Z), J;
        };
        M.exports = U;
      }, 13151: (M, B, $) => {
        var E = $(2141), L = function(z, U, K) {
          if (K === undefined)
            K = new E;
          return K.x = z.x1 + (z.x2 - z.x1) * U, K.y = z.y1 + (z.y2 - z.y1) * U, K;
        };
        M.exports = L;
      }, 15258: (M, B, $) => {
        var E = $(35001), L = $(2141), z = function(U, K, J, Z) {
          if (Z === undefined)
            Z = [];
          if (!K && J > 0)
            K = E(U) / J;
          var { x1: D, y1: Q, x2: H, y2: N } = U;
          for (var W = 0;W < K; W++) {
            var R = W / K, Y = D + (H - D) * R, I = Q + (N - Q) * R;
            Z.push(new L(Y, I));
          }
          return Z;
        };
        M.exports = z;
      }, 26408: (M) => {
        var B = function($, E) {
          var { x1: L, y1: z, x2: U, y2: K } = $, J = (U - L) * (U - L) + (K - z) * (K - z);
          if (J === 0)
            return false;
          var Z = ((z - E.y) * (U - L) - (L - E.x) * (K - z)) / J;
          return Math.abs(Z) * Math.sqrt(J);
        };
        M.exports = B;
      }, 98770: (M) => {
        var B = function($) {
          return Math.abs($.y1 - $.y2);
        };
        M.exports = B;
      }, 35001: (M) => {
        var B = function($) {
          return Math.sqrt(($.x2 - $.x1) * ($.x2 - $.x1) + ($.y2 - $.y1) * ($.y2 - $.y1));
        };
        M.exports = B;
      }, 23031: (M, B, $) => {
        var E = $(83419), L = $(13151), z = $(15258), U = $(23777), K = $(65822), J = $(26099), Z = new E({ initialize: function D(Q, H, N, W) {
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = 0;
          this.type = U.LINE, this.x1 = Q, this.y1 = H, this.x2 = N, this.y2 = W;
        }, getPoint: function(D, Q) {
          return L(this, D, Q);
        }, getPoints: function(D, Q, H) {
          return z(this, D, Q, H);
        }, getRandomPoint: function(D) {
          return K(this, D);
        }, setTo: function(D, Q, H, N) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = 0;
          return this.x1 = D, this.y1 = Q, this.x2 = H, this.y2 = N, this;
        }, setFromObjects: function(D, Q) {
          return this.x1 = D.x, this.y1 = D.y, this.x2 = Q.x, this.y2 = Q.y, this;
        }, getPointA: function(D) {
          if (D === undefined)
            D = new J;
          return D.set(this.x1, this.y1), D;
        }, getPointB: function(D) {
          if (D === undefined)
            D = new J;
          return D.set(this.x2, this.y2), D;
        }, left: { get: function() {
          return Math.min(this.x1, this.x2);
        }, set: function(D) {
          if (this.x1 <= this.x2)
            this.x1 = D;
          else
            this.x2 = D;
        } }, right: { get: function() {
          return Math.max(this.x1, this.x2);
        }, set: function(D) {
          if (this.x1 > this.x2)
            this.x1 = D;
          else
            this.x2 = D;
        } }, top: { get: function() {
          return Math.min(this.y1, this.y2);
        }, set: function(D) {
          if (this.y1 <= this.y2)
            this.y1 = D;
          else
            this.y2 = D;
        } }, bottom: { get: function() {
          return Math.max(this.y1, this.y2);
        }, set: function(D) {
          if (this.y1 > this.y2)
            this.y1 = D;
          else
            this.y2 = D;
        } } });
        M.exports = Z;
      }, 64795: (M, B, $) => {
        var E = $(36383), L = $(15994), z = $(91938), U = function(K) {
          var J = z(K) - E.TAU;
          return L(J, -Math.PI, Math.PI);
        };
        M.exports = U;
      }, 52616: (M, B, $) => {
        var E = $(36383), L = $(91938), z = function(U) {
          return Math.cos(L(U) - E.TAU);
        };
        M.exports = z;
      }, 87231: (M, B, $) => {
        var E = $(36383), L = $(91938), z = function(U) {
          return Math.sin(L(U) - E.TAU);
        };
        M.exports = z;
      }, 89662: (M) => {
        var B = function($, E, L) {
          return $.x1 += E, $.y1 += L, $.x2 += E, $.y2 += L, $;
        };
        M.exports = B;
      }, 71165: (M) => {
        var B = function($) {
          return -(($.x2 - $.x1) / ($.y2 - $.y1));
        };
        M.exports = B;
      }, 65822: (M, B, $) => {
        var E = $(2141), L = function(z, U) {
          if (U === undefined)
            U = new E;
          var K = Math.random();
          return U.x = z.x1 + K * (z.x2 - z.x1), U.y = z.y1 + K * (z.y2 - z.y1), U;
        };
        M.exports = L;
      }, 69777: (M, B, $) => {
        var E = $(91938), L = $(64795), z = function(U, K) {
          return 2 * L(K) - Math.PI - E(U);
        };
        M.exports = z;
      }, 39706: (M, B, $) => {
        var E = $(64400), L = function(z, U) {
          var K = (z.x1 + z.x2) / 2, J = (z.y1 + z.y2) / 2;
          return E(z, K, J, U);
        };
        M.exports = L;
      }, 82585: (M, B, $) => {
        var E = $(64400), L = function(z, U, K) {
          return E(z, U.x, U.y, K);
        };
        M.exports = L;
      }, 64400: (M) => {
        var B = function($, E, L, z) {
          var U = Math.cos(z), K = Math.sin(z), J = $.x1 - E, Z = $.y1 - L;
          return $.x1 = J * U - Z * K + E, $.y1 = J * K + Z * U + L, J = $.x2 - E, Z = $.y2 - L, $.x2 = J * U - Z * K + E, $.y2 = J * K + Z * U + L, $;
        };
        M.exports = B;
      }, 62377: (M) => {
        var B = function($, E, L, z, U) {
          return $.x1 = E, $.y1 = L, $.x2 = E + Math.cos(z) * U, $.y2 = L + Math.sin(z) * U, $;
        };
        M.exports = B;
      }, 71366: (M) => {
        var B = function($) {
          return ($.y2 - $.y1) / ($.x2 - $.x1);
        };
        M.exports = B;
      }, 10809: (M) => {
        var B = function($) {
          return Math.abs($.x1 - $.x2);
        };
        M.exports = B;
      }, 2529: (M, B, $) => {
        var E = $(23031);
        E.Angle = $(91938), E.BresenhamPoints = $(84993), E.CenterOn = $(36469), E.Clone = $(31116), E.CopyFrom = $(59944), E.Equals = $(59220), E.Extend = $(78177), E.GetEasedPoints = $(26708), E.GetMidPoint = $(32125), E.GetNearestPoint = $(99569), E.GetNormal = $(34638), E.GetPoint = $(13151), E.GetPoints = $(15258), E.GetShortestDistance = $(26408), E.Height = $(98770), E.Length = $(35001), E.NormalAngle = $(64795), E.NormalX = $(52616), E.NormalY = $(87231), E.Offset = $(89662), E.PerpSlope = $(71165), E.Random = $(65822), E.ReflectAngle = $(69777), E.Rotate = $(39706), E.RotateAroundPoint = $(82585), E.RotateAroundXY = $(64400), E.SetToAngle = $(62377), E.Slope = $(71366), E.Width = $(10809), M.exports = E;
      }, 83997: (M, B, $) => {
        var E = $(83419), L = $(87841), z = $(26099);
        function U(J, Z, D, Q) {
          var H = J - D, N = Z - Q, W = H * H + N * N;
          return Math.sqrt(W);
        }
        var K = new E({ initialize: function J(Z, D, Q) {
          this.vertex1 = Z, this.vertex2 = D, this.vertex3 = Q, this.bounds = new L, this._inCenter = new z;
        }, getInCenter: function(J) {
          if (J === undefined)
            J = true;
          var Z = this.vertex1, D = this.vertex2, Q = this.vertex3, H, N, W, R, Y, I;
          if (J)
            H = Z.x, N = Z.y, W = D.x, R = D.y, Y = Q.x, I = Q.y;
          else
            H = Z.vx, N = Z.vy, W = D.vx, R = D.vy, Y = Q.vx, I = Q.vy;
          var P = U(Y, I, W, R), X = U(H, N, Y, I), G = U(W, R, H, N), V = P + X + G;
          return this._inCenter.set((H * P + W * X + Y * G) / V, (N * P + R * X + I * G) / V);
        }, contains: function(J, Z, D) {
          var Q = this.vertex1, H = this.vertex2, N = this.vertex3, W = Q.vx, R = Q.vy, Y = H.vx, I = H.vy, P = N.vx, X = N.vy;
          if (D) {
            var { a: G, b: V, c: A, d: F, e: j, f: T } = D;
            W = Q.vx * G + Q.vy * A + j, R = Q.vx * V + Q.vy * F + T, Y = H.vx * G + H.vy * A + j, I = H.vx * V + H.vy * F + T, P = N.vx * G + N.vy * A + j, X = N.vx * V + N.vy * F + T;
          }
          var C = P - W, v = X - R, O = Y - W, q = I - R, w = J - W, g = Z - R, b = C * C + v * v, x = C * O + v * q, k = C * w + v * g, S = O * O + q * q, f = O * w + q * g, h = b * S - x * x, m = h === 0 ? 0 : 1 / h, y = (S * k - x * f) * m, d = (b * f - x * k) * m;
          return y >= 0 && d >= 0 && y + d < 1;
        }, isCounterClockwise: function(J) {
          var Z = this.vertex1, D = this.vertex2, Q = this.vertex3, H = (D.vx - Z.vx) * (Q.vy - Z.vy) - (D.vy - Z.vy) * (Q.vx - Z.vx);
          return J <= 0 ? H >= 0 : H < 0;
        }, load: function(J, Z, D, Q, H) {
          return D = this.vertex1.load(J, Z, D, Q, H), D = this.vertex2.load(J, Z, D, Q, H), D = this.vertex3.load(J, Z, D, Q, H), D;
        }, transformCoordinatesLocal: function(J, Z, D, Q) {
          return this.vertex1.transformCoordinatesLocal(J, Z, D, Q), this.vertex2.transformCoordinatesLocal(J, Z, D, Q), this.vertex3.transformCoordinatesLocal(J, Z, D, Q), this;
        }, updateBounds: function() {
          var J = this.vertex1, Z = this.vertex2, D = this.vertex3, Q = this.bounds;
          return Q.x = Math.min(J.vx, Z.vx, D.vx), Q.y = Math.min(J.vy, Z.vy, D.vy), Q.width = Math.max(J.vx, Z.vx, D.vx) - Q.x, Q.height = Math.max(J.vy, Z.vy, D.vy) - Q.y, this;
        }, isInView: function(J, Z, D, Q, H, N, W, R, Y, I, P) {
          this.update(Q, H, N, W, R, Y, I, P);
          var X = this.vertex1, G = this.vertex2, V = this.vertex3;
          if (X.ta <= 0 && G.ta <= 0 && V.ta <= 0)
            return false;
          if (Z && !this.isCounterClockwise(D))
            return false;
          var A = this.bounds;
          A.x = Math.min(X.tx, G.tx, V.tx), A.y = Math.min(X.ty, G.ty, V.ty), A.width = Math.max(X.tx, G.tx, V.tx) - A.x, A.height = Math.max(X.ty, G.ty, V.ty) - A.y;
          var F = J.x + J.width, j = J.y + J.height;
          if (A.width <= 0 || A.height <= 0 || J.width <= 0 || J.height <= 0)
            return false;
          return !(A.right < J.x || A.bottom < J.y || A.x > F || A.y > j);
        }, scrollUV: function(J, Z) {
          return this.vertex1.scrollUV(J, Z), this.vertex2.scrollUV(J, Z), this.vertex3.scrollUV(J, Z), this;
        }, scaleUV: function(J, Z) {
          return this.vertex1.scaleUV(J, Z), this.vertex2.scaleUV(J, Z), this.vertex3.scaleUV(J, Z), this;
        }, setColor: function(J) {
          return this.vertex1.color = J, this.vertex2.color = J, this.vertex3.color = J, this;
        }, update: function(J, Z, D, Q, H, N, W, R) {
          return this.vertex1.update(Z, D, Q, H, N, W, R, J), this.vertex2.update(Z, D, Q, H, N, W, R, J), this.vertex3.update(Z, D, Q, H, N, W, R, J), this;
        }, translate: function(J, Z) {
          if (Z === undefined)
            Z = 0;
          var D = this.vertex1, Q = this.vertex2, H = this.vertex3;
          return D.x += J, D.y += Z, Q.x += J, Q.y += Z, H.x += J, H.y += Z, this;
        }, x: { get: function() {
          return this.getInCenter().x;
        }, set: function(J) {
          var Z = this.getInCenter();
          this.translate(J - Z.x, 0);
        } }, y: { get: function() {
          return this.getInCenter().y;
        }, set: function(J) {
          var Z = this.getInCenter();
          this.translate(0, J - Z.y);
        } }, alpha: { get: function() {
          var J = this.vertex1, Z = this.vertex2, D = this.vertex3;
          return (J.alpha + Z.alpha + D.alpha) / 3;
        }, set: function(J) {
          this.vertex1.alpha = J, this.vertex2.alpha = J, this.vertex3.alpha = J;
        } }, depth: { get: function() {
          var J = this.vertex1, Z = this.vertex2, D = this.vertex3;
          return (J.vz + Z.vz + D.vz) / 3;
        } }, destroy: function() {
          this.vertex1 = null, this.vertex2 = null, this.vertex3 = null;
        } });
        M.exports = K;
      }, 48803: (M, B, $) => {
        var E = $(83997), L = $(95540), z = $(37867), U = $(25836), K = $(39318), J = new U, Z = new U, D = new z, Q = function(H) {
          var N = L(H, "mesh"), W = L(H, "texture", null), R = L(H, "frame"), Y = L(H, "width", 1), I = L(H, "height", Y), P = L(H, "widthSegments", 1), X = L(H, "heightSegments", P), G = L(H, "x", 0), V = L(H, "y", 0), A = L(H, "z", 0), F = L(H, "rotateX", 0), j = L(H, "rotateY", 0), T = L(H, "rotateZ", 0), C = L(H, "zIsUp", true), v = L(H, "isOrtho", N ? N.dirtyCache[11] : false), O = L(H, "colors", [16777215]), q = L(H, "alphas", [1]), w = L(H, "tile", false), g = L(H, "flipY", false), b = L(H, "width", null), x = { faces: [], verts: [] };
          J.set(G, V, A), Z.set(F, j, T), D.fromRotationXYTranslation(Z, J, C);
          var k;
          if (!W && N) {
            if (W = N.texture, !R)
              k = N.frame;
          } else if (N && typeof W === "string")
            W = N.scene.sys.textures.get(W);
          else if (!W)
            return x;
          if (!k)
            k = W.get(R);
          if (!b && v && W && N)
            Y = k.width / N.height, I = k.height / N.height;
          var S = Y / 2, f = I / 2, h = Math.floor(P), m = Math.floor(X), y = h + 1, d = m + 1, p = Y / h, u = I / m, s = [], c = [], n, _, l = 0, i = 1, t = 0, $0 = 1;
          if (k)
            if (l = k.u0, i = k.u1, !g)
              t = k.v0, $0 = k.v1;
            else
              t = k.v1, $0 = k.v0;
          var e = i - l, o = $0 - t;
          for (_ = 0;_ < d; _++) {
            var r = _ * u - f;
            for (n = 0;n < y; n++) {
              var a = n * p - S;
              c.push(a, -r);
              var J0 = l + e * (n / h), Q0 = t + o * (_ / m);
              s.push(J0, Q0);
            }
          }
          if (!Array.isArray(O))
            O = [O];
          if (!Array.isArray(q))
            q = [q];
          var D0 = 0, z0 = 0;
          for (_ = 0;_ < m; _++)
            for (n = 0;n < h; n++) {
              var K0 = (n + y * _) * 2, Z0 = (n + y * (_ + 1)) * 2, W0 = (n + 1 + y * (_ + 1)) * 2, U0 = (n + 1 + y * _) * 2, N0 = O[z0], E0 = q[D0], L0 = new K(c[K0], c[K0 + 1], 0, s[K0], s[K0 + 1], N0, E0).transformMat4(D), I0 = new K(c[Z0], c[Z0 + 1], 0, s[Z0], s[Z0 + 1], N0, E0).transformMat4(D), X0 = new K(c[U0], c[U0 + 1], 0, s[U0], s[U0 + 1], N0, E0).transformMat4(D), P0 = new K(c[Z0], c[Z0 + 1], 0, s[Z0], s[Z0 + 1], N0, E0).transformMat4(D), G0 = new K(c[W0], c[W0 + 1], 0, s[W0], s[W0 + 1], N0, E0).transformMat4(D), V0 = new K(c[U0], c[U0 + 1], 0, s[U0], s[U0 + 1], N0, E0).transformMat4(D);
              if (w)
                L0.setUVs(l, $0), I0.setUVs(l, t), X0.setUVs(i, $0), P0.setUVs(l, t), G0.setUVs(i, t), V0.setUVs(i, $0);
              if (z0++, z0 === O.length)
                z0 = 0;
              if (D0++, D0 === q.length)
                D0 = 0;
              x.verts.push(L0, I0, X0, P0, G0, V0), x.faces.push(new E(L0, I0, X0), new E(P0, G0, V0));
            }
          if (N)
            N.faces = N.faces.concat(x.faces), N.vertices = N.vertices.concat(x.verts);
          return x;
        };
        M.exports = Q;
      }, 34684: (M, B, $) => {
        var E = $(83997), L = $(37867), z = $(25836), U = $(39318), K = new z, J = new z, Z = new L, D = function(Q, H, N, W, R, Y, I, P, X, G) {
          if (N === undefined)
            N = 1;
          if (W === undefined)
            W = 0;
          if (R === undefined)
            R = 0;
          if (Y === undefined)
            Y = 0;
          if (I === undefined)
            I = 0;
          if (P === undefined)
            P = 0;
          if (X === undefined)
            X = 0;
          if (G === undefined)
            G = true;
          var V = { faces: [], verts: [] }, A = Q.materials;
          K.set(W, R, Y), J.set(I, P, X), Z.fromRotationXYTranslation(J, K, G);
          for (var F = 0;F < Q.models.length; F++) {
            var j = Q.models[F], T = j.vertices, C = j.textureCoords, v = j.faces;
            for (var O = 0;O < v.length; O++) {
              var q = v[O], w = q.vertices[0], g = q.vertices[1], b = q.vertices[2], x = T[w.vertexIndex], k = T[g.vertexIndex], S = T[b.vertexIndex], f = w.textureCoordsIndex, h = g.textureCoordsIndex, m = b.textureCoordsIndex, y = f === -1 ? { u: 0, v: 1 } : C[f], d = h === -1 ? { u: 0, v: 0 } : C[h], p = m === -1 ? { u: 1, v: 1 } : C[m], u = 16777215;
              if (q.material !== "" && A[q.material])
                u = A[q.material];
              var s = new U(x.x * N, x.y * N, x.z * N, y.u, y.v, u).transformMat4(Z), c = new U(k.x * N, k.y * N, k.z * N, d.u, d.v, u).transformMat4(Z), n = new U(S.x * N, S.y * N, S.z * N, p.u, p.v, u).transformMat4(Z);
              V.verts.push(s, c, n), V.faces.push(new E(s, c, n));
            }
          }
          if (H)
            H.faces = H.faces.concat(V.faces), H.vertices = H.vertices.concat(V.verts);
          return V;
        };
        M.exports = D;
      }, 92515: (M, B, $) => {
        var E = $(83997), L = $(39318), z = function(U, K, J, Z, D, Q, H, N) {
          if (Z === undefined)
            Z = false;
          if (Q === undefined)
            Q = 16777215;
          if (H === undefined)
            H = 1;
          if (N === undefined)
            N = false;
          if (U.length !== K.length && !Z) {
            console.warn("GenerateVerts: vertices and uvs count not equal");
            return;
          }
          var W = { faces: [], vertices: [] }, R, Y, I, P, X, G, V, A, F, j, T, C = Z ? 3 : 2, v = Array.isArray(Q), O = Array.isArray(H);
          if (Array.isArray(J) && J.length > 0)
            for (R = 0;R < J.length; R++) {
              var q = J[R], w = J[R] * 2, g = J[R] * C;
              if (Y = U[g], I = U[g + 1], P = Z ? U[g + 2] : 0, X = K[w], G = K[w + 1], N)
                G = 1 - G;
              if (V = v ? Q[q] : Q, A = O ? H[q] : H, F = 0, j = 0, T = 0, D)
                F = D[g], j = D[g + 1], T = Z ? D[g + 2] : 0;
              W.vertices.push(new L(Y, I, P, X, G, V, A, F, j, T));
            }
          else {
            var b = 0, x = 0;
            for (R = 0;R < U.length; R += C) {
              if (Y = U[R], I = U[R + 1], P = Z ? U[R + 2] : 0, X = K[b], G = K[b + 1], V = v ? Q[x] : Q, A = O ? H[x] : H, F = 0, j = 0, T = 0, D)
                F = D[R], j = D[R + 1], T = Z ? D[R + 2] : 0;
              W.vertices.push(new L(Y, I, P, X, G, V, A, F, j, T)), b += 2, x++;
            }
          }
          for (R = 0;R < W.vertices.length; R += 3) {
            var k = W.vertices[R], S = W.vertices[R + 1], f = W.vertices[R + 2];
            W.faces.push(new E(k, S, f));
          }
          return W;
        };
        M.exports = z;
      }, 85048: (M) => {
        var B = true, $ = "untitled", E = "", L = "";
        function z(Y) {
          var I = Y.indexOf("#");
          return I > -1 ? Y.substring(0, I) : Y;
        }
        function U(Y) {
          if (Y.models.length === 0)
            Y.models.push({ faces: [], name: $, textureCoords: [], vertexNormals: [], vertices: [] });
          return E = "", Y.models[Y.models.length - 1];
        }
        function K(Y, I) {
          var P = Y.length >= 2 ? Y[1] : $;
          I.models.push({ faces: [], name: P, textureCoords: [], vertexNormals: [], vertices: [] }), E = "";
        }
        function J(Y) {
          if (Y.length === 2)
            E = Y[1];
        }
        function Z(Y, I) {
          var P = Y.length, X = P >= 2 ? parseFloat(Y[1]) : 0, G = P >= 3 ? parseFloat(Y[2]) : 0, V = P >= 4 ? parseFloat(Y[3]) : 0;
          U(I).vertices.push({ x: X, y: G, z: V });
        }
        function D(Y, I) {
          var P = Y.length, X = P >= 2 ? parseFloat(Y[1]) : 0, G = P >= 3 ? parseFloat(Y[2]) : 0, V = P >= 4 ? parseFloat(Y[3]) : 0;
          if (isNaN(X))
            X = 0;
          if (isNaN(G))
            G = 0;
          if (isNaN(V))
            V = 0;
          if (B)
            G = 1 - G;
          U(I).textureCoords.push({ u: X, v: G, w: V });
        }
        function Q(Y, I) {
          var P = Y.length, X = P >= 2 ? parseFloat(Y[1]) : 0, G = P >= 3 ? parseFloat(Y[2]) : 0, V = P >= 4 ? parseFloat(Y[3]) : 0;
          U(I).vertexNormals.push({ x: X, y: G, z: V });
        }
        function H(Y, I) {
          var P = Y.length - 1;
          if (P < 3)
            return;
          var X = { group: E, material: L, vertices: [] };
          for (var G = 0;G < P; G++) {
            var V = Y[G + 1], A = V.split("/"), F = A.length;
            if (F < 1 || F > 3)
              continue;
            var j = 0, T = 0, C = 0;
            if (j = parseInt(A[0], 10), F > 1 && A[1] !== "")
              T = parseInt(A[1], 10);
            if (F > 2)
              C = parseInt(A[2], 10);
            if (j !== 0) {
              if (j < 0)
                j = U(I).vertices.length + 1 + j;
              T -= 1, j -= 1, C -= 1, X.vertices.push({ textureCoordsIndex: T, vertexIndex: j, vertexNormalIndex: C });
            }
          }
          U(I).faces.push(X);
        }
        function N(Y, I) {
          if (Y.length >= 2)
            I.materialLibraries.push(Y[1]);
        }
        function W(Y) {
          if (Y.length >= 2)
            L = Y[1];
        }
        var R = function(Y, I) {
          if (I === undefined)
            I = true;
          B = I;
          var P = { materials: {}, materialLibraries: [], models: [] };
          E = "", L = "";
          var X = Y.split("\n");
          for (var G = 0;G < X.length; G++) {
            var V = z(X[G]), A = V.replace(/\s\s+/g, " ").trim().split(" ");
            switch (A[0].toLowerCase()) {
              case "o":
                K(A, P);
                break;
              case "g":
                J(A);
                break;
              case "v":
                Z(A, P);
                break;
              case "vt":
                D(A, P);
                break;
              case "vn":
                Q(A, P);
                break;
              case "f":
                H(A, P);
                break;
              case "mtllib":
                N(A, P);
                break;
              case "usemtl":
                W(A);
                break;
            }
          }
          return P;
        };
        M.exports = R;
      }, 61485: (M, B, $) => {
        var E = $(37589), L = function(z) {
          var U = {}, K = z.split("\n"), J = "";
          for (var Z = 0;Z < K.length; Z++) {
            var D = K[Z].trim();
            if (D.indexOf("#") === 0 || D === "")
              continue;
            var Q = D.replace(/\s\s+/g, " ").trim().split(" ");
            switch (Q[0].toLowerCase()) {
              case "newmtl": {
                J = Q[1];
                break;
              }
              case "kd": {
                var H = Math.floor(Q[1] * 255), N = Q.length >= 2 ? Math.floor(Q[2] * 255) : H, W = Q.length >= 3 ? Math.floor(Q[3] * 255) : H;
                U[J] = E(H, N, W);
                break;
              }
            }
          }
          return U;
        };
        M.exports = L;
      }, 92570: (M) => {
        var B = function($, E, L, z) {
          var U, K;
          if (L === undefined && z === undefined) {
            var J = $.getInCenter();
            U = J.x, K = J.y;
          }
          var Z = Math.cos(E), D = Math.sin(E), Q = $.vertex1, H = $.vertex2, N = $.vertex3, W = Q.x - U, R = Q.y - K;
          Q.set(W * Z - R * D + U, W * D + R * Z + K), W = H.x - U, R = H.y - K, H.set(W * Z - R * D + U, W * D + R * Z + K), W = N.x - U, R = N.y - K, N.set(W * Z - R * D + U, W * D + R * Z + K);
        };
        M.exports = B;
      }, 39318: (M, B, $) => {
        var E = $(83419), L = $(70554), z = $(25836), U = new E({ Extends: z, initialize: function K(J, Z, D, Q, H, N, W, R, Y, I) {
          if (N === undefined)
            N = 16777215;
          if (W === undefined)
            W = 1;
          if (R === undefined)
            R = 0;
          if (Y === undefined)
            Y = 0;
          if (I === undefined)
            I = 0;
          z.call(this, J, Z, D), this.vx = 0, this.vy = 0, this.vz = 0, this.nx = R, this.ny = Y, this.nz = I, this.u = Q, this.v = H, this.color = N, this.alpha = W, this.tx = 0, this.ty = 0, this.ta = 0, this.tu = Q, this.tv = H;
        }, setUVs: function(K, J) {
          return this.u = K, this.v = J, this.tu = K, this.tv = J, this;
        }, scrollUV: function(K, J) {
          return this.tu += K, this.tv += J, this;
        }, scaleUV: function(K, J) {
          return this.tu = this.u * K, this.tv = this.v * J, this;
        }, transformCoordinatesLocal: function(K, J, Z, D) {
          var Q = this.x, H = this.y, N = this.z, W = K.val, R = Q * W[0] + H * W[4] + N * W[8] + W[12], Y = Q * W[1] + H * W[5] + N * W[9] + W[13], I = Q * W[2] + H * W[6] + N * W[10] + W[14], P = Q * W[3] + H * W[7] + N * W[11] + W[15];
          if (this.vx = R / P * J, this.vy = -(Y / P) * Z, D <= 0)
            this.vz = I / P;
          else
            this.vz = -(I / P);
        }, resize: function(K, J, Z, D, Q, H) {
          if (this.x = K, this.y = J, this.vx = this.x * Z, this.vy = -this.y * D, this.vz = 0, Q < 0.5)
            this.vx += Z * (0.5 - Q);
          else if (Q > 0.5)
            this.vx -= Z * (Q - 0.5);
          if (H < 0.5)
            this.vy += D * (0.5 - H);
          else if (H > 0.5)
            this.vy -= D * (H - 0.5);
          return this;
        }, update: function(K, J, Z, D, Q, H, N, W) {
          var R = this.vx * K + this.vy * Z + Q, Y = this.vx * J + this.vy * D + H;
          if (N)
            R = Math.round(R), Y = Math.round(Y);
          return this.tx = R, this.ty = Y, this.ta = this.alpha * W, this;
        }, load: function(K, J, Z, D, Q) {
          return K[++Z] = this.tx, K[++Z] = this.ty, K[++Z] = this.tu, K[++Z] = this.tv, K[++Z] = D, K[++Z] = Q, J[++Z] = L.getTintAppendFloatAlpha(this.color, this.ta), Z;
        } });
        M.exports = U;
      }, 73090: (M, B, $) => {
        var E = { Face: $(83997), GenerateGridVerts: $(48803), GenerateObjVerts: $(34684), GenerateVerts: $(92515), ParseObj: $(85048), ParseObjMaterial: $(61485), RotateFace: $(92570), Vertex: $(39318) };
        M.exports = E;
      }, 96550: (M) => {
        var B = function($) {
          return $.setTo(Math.ceil($.x), Math.ceil($.y));
        };
        M.exports = B;
      }, 99706: (M, B, $) => {
        var E = $(2141), L = function(z) {
          return new E(z.x, z.y);
        };
        M.exports = L;
      }, 68010: (M) => {
        var B = function($, E) {
          return E.setTo($.x, $.y);
        };
        M.exports = B;
      }, 27814: (M) => {
        var B = function($, E) {
          return $.x === E.x && $.y === E.y;
        };
        M.exports = B;
      }, 73565: (M) => {
        var B = function($) {
          return $.setTo(Math.floor($.x), Math.floor($.y));
        };
        M.exports = B;
      }, 87555: (M, B, $) => {
        var E = $(2141), L = function(z, U) {
          if (U === undefined)
            U = new E;
          if (!Array.isArray(z))
            throw new Error("GetCentroid points argument must be an array");
          var K = z.length;
          if (K < 1)
            throw new Error("GetCentroid points array must not be empty");
          else if (K === 1)
            U.x = z[0].x, U.y = z[0].y;
          else {
            for (var J = 0;J < K; J++)
              U.x += z[J].x, U.y += z[J].y;
            U.x /= K, U.y /= K;
          }
          return U;
        };
        M.exports = L;
      }, 28793: (M) => {
        var B = function($) {
          return Math.sqrt($.x * $.x + $.y * $.y);
        };
        M.exports = B;
      }, 44405: (M) => {
        var B = function($) {
          return $.x * $.x + $.y * $.y;
        };
        M.exports = B;
      }, 20873: (M, B, $) => {
        var E = $(87841), L = function(z, U) {
          if (U === undefined)
            U = new E;
          var { NEGATIVE_INFINITY: K, POSITIVE_INFINITY: J, NEGATIVE_INFINITY: Z, POSITIVE_INFINITY: D } = Number;
          for (var Q = 0;Q < z.length; Q++) {
            var H = z[Q];
            if (H.x > K)
              K = H.x;
            if (H.x < J)
              J = H.x;
            if (H.y > Z)
              Z = H.y;
            if (H.y < D)
              D = H.y;
          }
          return U.x = J, U.y = D, U.width = K - J, U.height = Z - D, U;
        };
        M.exports = L;
      }, 26152: (M, B, $) => {
        var E = $(2141), L = function(z, U, K, J) {
          if (K === undefined)
            K = 0;
          if (J === undefined)
            J = new E;
          return J.x = z.x + (U.x - z.x) * K, J.y = z.y + (U.y - z.y) * K, J;
        };
        M.exports = L;
      }, 55767: (M) => {
        var B = function($) {
          return $.setTo($.y, $.x);
        };
        M.exports = B;
      }, 79432: (M, B, $) => {
        var E = $(2141), L = function(z, U) {
          if (U === undefined)
            U = new E;
          return U.setTo(-z.x, -z.y);
        };
        M.exports = L;
      }, 2141: (M, B, $) => {
        var E = $(83419), L = $(23777), z = new E({ initialize: function U(K, J) {
          if (K === undefined)
            K = 0;
          if (J === undefined)
            J = K;
          this.type = L.POINT, this.x = K, this.y = J;
        }, setTo: function(U, K) {
          if (U === undefined)
            U = 0;
          if (K === undefined)
            K = U;
          return this.x = U, this.y = K, this;
        } });
        M.exports = z;
      }, 72930: (M, B, $) => {
        var E = $(2141), L = $(44405), z = function(U, K, J) {
          if (J === undefined)
            J = new E;
          var Z = U.x * K.x + U.y * K.y, D = Z / L(K);
          if (D !== 0)
            J.x = D * K.x, J.y = D * K.y;
          return J;
        };
        M.exports = z;
      }, 62880: (M, B, $) => {
        var E = $(2141), L = function(z, U, K) {
          if (K === undefined)
            K = new E;
          var J = z.x * U.x + z.y * U.y;
          if (J !== 0)
            K.x = J * U.x, K.y = J * U.y;
          return K;
        };
        M.exports = L;
      }, 15093: (M, B, $) => {
        var E = $(28793), L = function(z, U) {
          if (z.x !== 0 || z.y !== 0) {
            var K = E(z);
            z.x /= K, z.y /= K;
          }
          return z.x *= U, z.y *= U, z;
        };
        M.exports = L;
      }, 43711: (M, B, $) => {
        var E = $(2141);
        E.Ceil = $(96550), E.Clone = $(99706), E.CopyFrom = $(68010), E.Equals = $(27814), E.Floor = $(73565), E.GetCentroid = $(87555), E.GetMagnitude = $(28793), E.GetMagnitudeSq = $(44405), E.GetRectangleFromPoints = $(20873), E.Interpolate = $(26152), E.Invert = $(55767), E.Negative = $(79432), E.Project = $(72930), E.ProjectUnit = $(62880), E.SetMagnitude = $(15093), M.exports = E;
      }, 12306: (M, B, $) => {
        var E = $(25717), L = function(z) {
          return new E(z.points);
        };
        M.exports = L;
      }, 63814: (M) => {
        var B = function($, E, L) {
          var z = false;
          for (var U = -1, K = $.points.length - 1;++U < $.points.length; K = U) {
            var J = $.points[U].x, Z = $.points[U].y, D = $.points[K].x, Q = $.points[K].y;
            if ((Z <= L && L < Q || Q <= L && L < Z) && E < (D - J) * (L - Z) / (Q - Z) + J)
              z = !z;
          }
          return z;
        };
        M.exports = B;
      }, 99338: (M, B, $) => {
        var E = $(63814), L = function(z, U) {
          return E(z, U.x, U.y);
        };
        M.exports = L;
      }, 94811: (M) => {
        function B(x, k, S) {
          S = S || 2;
          var f = k && k.length, h = f ? k[0] * S : x.length, m = $(x, 0, h, S, true), y = [];
          if (!m || m.next === m.prev)
            return y;
          var d, p, u, s, c, n, _;
          if (f)
            m = Z(x, k, m, S);
          if (x.length > 80 * S) {
            d = u = x[0], p = s = x[1];
            for (var l = S;l < h; l += S) {
              if (c = x[l], n = x[l + 1], c < d)
                d = c;
              if (n < p)
                p = n;
              if (c > u)
                u = c;
              if (n > s)
                s = n;
            }
            _ = Math.max(u - d, s - p), _ = _ !== 0 ? 32767 / _ : 0;
          }
          return L(m, y, S, d, p, _, 0), y;
        }
        function $(x, k, S, f, h) {
          var m, y;
          if (h === b(x, k, S, f) > 0)
            for (m = k;m < S; m += f)
              y = q(m, x[m], x[m + 1], y);
          else
            for (m = S - f;m >= k; m -= f)
              y = q(m, x[m], x[m + 1], y);
          if (y && V(y, y.next))
            w(y), y = y.next;
          return y;
        }
        function E(x, k) {
          if (!x)
            return x;
          if (!k)
            k = x;
          var S = x, f;
          do
            if (f = false, !S.steiner && (V(S, S.next) || G(S.prev, S, S.next) === 0)) {
              if (w(S), S = k = S.prev, S === S.next)
                break;
              f = true;
            } else
              S = S.next;
          while (f || S !== k);
          return k;
        }
        function L(x, k, S, f, h, m, y) {
          if (!x)
            return;
          if (!y && m)
            W(x, f, h, m);
          var d = x, p, u;
          while (x.prev !== x.next) {
            if (p = x.prev, u = x.next, m ? U(x, f, h, m) : z(x)) {
              k.push(p.i / S | 0), k.push(x.i / S | 0), k.push(u.i / S | 0), w(x), x = u.next, d = u.next;
              continue;
            }
            if (x = u, x === d) {
              if (!y)
                L(E(x), k, S, f, h, m, 1);
              else if (y === 1)
                x = K(E(x), k, S), L(x, k, S, f, h, m, 2);
              else if (y === 2)
                J(x, k, S, f, h, m);
              break;
            }
          }
        }
        function z(x) {
          var k = x.prev, S = x, f = x.next;
          if (G(k, S, f) >= 0)
            return false;
          var h = k.x, m = S.x, y = f.x, d = k.y, p = S.y, u = f.y, s = h < m ? h < y ? h : y : m < y ? m : y, c = d < p ? d < u ? d : u : p < u ? p : u, n = h > m ? h > y ? h : y : m > y ? m : y, _ = d > p ? d > u ? d : u : p > u ? p : u, l = f.next;
          while (l !== k) {
            if (l.x >= s && l.x <= n && l.y >= c && l.y <= _ && P(h, d, m, p, y, u, l.x, l.y) && G(l.prev, l, l.next) >= 0)
              return false;
            l = l.next;
          }
          return true;
        }
        function U(x, k, S, f) {
          var h = x.prev, m = x, y = x.next;
          if (G(h, m, y) >= 0)
            return false;
          var d = h.x, p = m.x, u = y.x, s = h.y, c = m.y, n = y.y, _ = d < p ? d < u ? d : u : p < u ? p : u, l = s < c ? s < n ? s : n : c < n ? c : n, i = d > p ? d > u ? d : u : p > u ? p : u, t = s > c ? s > n ? s : n : c > n ? c : n, $0 = Y(_, l, k, S, f), e = Y(i, t, k, S, f), o = x.prevZ, r = x.nextZ;
          while (o && o.z >= $0 && r && r.z <= e) {
            if (o.x >= _ && o.x <= i && o.y >= l && o.y <= t && o !== h && o !== y && P(d, s, p, c, u, n, o.x, o.y) && G(o.prev, o, o.next) >= 0)
              return false;
            if (o = o.prevZ, r.x >= _ && r.x <= i && r.y >= l && r.y <= t && r !== h && r !== y && P(d, s, p, c, u, n, r.x, r.y) && G(r.prev, r, r.next) >= 0)
              return false;
            r = r.nextZ;
          }
          while (o && o.z >= $0) {
            if (o.x >= _ && o.x <= i && o.y >= l && o.y <= t && o !== h && o !== y && P(d, s, p, c, u, n, o.x, o.y) && G(o.prev, o, o.next) >= 0)
              return false;
            o = o.prevZ;
          }
          while (r && r.z <= e) {
            if (r.x >= _ && r.x <= i && r.y >= l && r.y <= t && r !== h && r !== y && P(d, s, p, c, u, n, r.x, r.y) && G(r.prev, r, r.next) >= 0)
              return false;
            r = r.nextZ;
          }
          return true;
        }
        function K(x, k, S) {
          var f = x;
          do {
            var h = f.prev, m = f.next.next;
            if (!V(h, m) && A(h, f, f.next, m) && C(h, m) && C(m, h))
              k.push(h.i / S | 0), k.push(f.i / S | 0), k.push(m.i / S | 0), w(f), w(f.next), f = x = m;
            f = f.next;
          } while (f !== x);
          return E(f);
        }
        function J(x, k, S, f, h, m) {
          var y = x;
          do {
            var d = y.next.next;
            while (d !== y.prev) {
              if (y.i !== d.i && X(y, d)) {
                var p = O(y, d);
                y = E(y, y.next), p = E(p, p.next), L(y, k, S, f, h, m, 0), L(p, k, S, f, h, m, 0);
                return;
              }
              d = d.next;
            }
            y = y.next;
          } while (y !== x);
        }
        function Z(x, k, S, f) {
          var h = [], m, y, d, p, u;
          for (m = 0, y = k.length;m < y; m++) {
            if (d = k[m] * f, p = m < y - 1 ? k[m + 1] * f : x.length, u = $(x, d, p, f, false), u === u.next)
              u.steiner = true;
            h.push(I(u));
          }
          h.sort(D);
          for (m = 0;m < h.length; m++)
            S = Q(h[m], S);
          return S;
        }
        function D(x, k) {
          return x.x - k.x;
        }
        function Q(x, k) {
          var S = H(x, k);
          if (!S)
            return k;
          var f = O(S, x);
          return E(f, f.next), E(S, S.next);
        }
        function H(x, k) {
          var S = k, f = x.x, h = x.y, m = (-Infinity), y;
          do {
            if (h <= S.y && h >= S.next.y && S.next.y !== S.y) {
              var d = S.x + (h - S.y) * (S.next.x - S.x) / (S.next.y - S.y);
              if (d <= f && d > m) {
                if (m = d, y = S.x < S.next.x ? S : S.next, d === f)
                  return y;
              }
            }
            S = S.next;
          } while (S !== k);
          if (!y)
            return null;
          var p = y, u = y.x, s = y.y, c = Infinity, n;
          S = y;
          do {
            if (f >= S.x && S.x >= u && f !== S.x && P(h < s ? f : m, h, u, s, h < s ? m : f, h, S.x, S.y)) {
              if (n = Math.abs(h - S.y) / (f - S.x), C(S, x) && (n < c || n === c && (S.x > y.x || S.x === y.x && N(y, S))))
                y = S, c = n;
            }
            S = S.next;
          } while (S !== p);
          return y;
        }
        function N(x, k) {
          return G(x.prev, x, k.prev) < 0 && G(k.next, x, x.next) < 0;
        }
        function W(x, k, S, f) {
          var h = x;
          do {
            if (h.z === 0)
              h.z = Y(h.x, h.y, k, S, f);
            h.prevZ = h.prev, h.nextZ = h.next, h = h.next;
          } while (h !== x);
          h.prevZ.nextZ = null, h.prevZ = null, R(h);
        }
        function R(x) {
          var k, S, f, h, m, y, d, p, u = 1;
          do {
            S = x, x = null, m = null, y = 0;
            while (S) {
              y++, f = S, d = 0;
              for (k = 0;k < u; k++)
                if (d++, f = f.nextZ, !f)
                  break;
              p = u;
              while (d > 0 || p > 0 && f) {
                if (d !== 0 && (p === 0 || !f || S.z <= f.z))
                  h = S, S = S.nextZ, d--;
                else
                  h = f, f = f.nextZ, p--;
                if (m)
                  m.nextZ = h;
                else
                  x = h;
                h.prevZ = m, m = h;
              }
              S = f;
            }
            m.nextZ = null, u *= 2;
          } while (y > 1);
          return x;
        }
        function Y(x, k, S, f, h) {
          return x = (x - S) * h | 0, k = (k - f) * h | 0, x = (x | x << 8) & 16711935, x = (x | x << 4) & 252645135, x = (x | x << 2) & 858993459, x = (x | x << 1) & 1431655765, k = (k | k << 8) & 16711935, k = (k | k << 4) & 252645135, k = (k | k << 2) & 858993459, k = (k | k << 1) & 1431655765, x | k << 1;
        }
        function I(x) {
          var k = x, S = x;
          do {
            if (k.x < S.x || k.x === S.x && k.y < S.y)
              S = k;
            k = k.next;
          } while (k !== x);
          return S;
        }
        function P(x, k, S, f, h, m, y, d) {
          return (h - y) * (k - d) >= (x - y) * (m - d) && (x - y) * (f - d) >= (S - y) * (k - d) && (S - y) * (m - d) >= (h - y) * (f - d);
        }
        function X(x, k) {
          return x.next.i !== k.i && x.prev.i !== k.i && !T(x, k) && (C(x, k) && C(k, x) && v(x, k) && (G(x.prev, x, k.prev) || G(x, k.prev, k)) || V(x, k) && G(x.prev, x, x.next) > 0 && G(k.prev, k, k.next) > 0);
        }
        function G(x, k, S) {
          return (k.y - x.y) * (S.x - k.x) - (k.x - x.x) * (S.y - k.y);
        }
        function V(x, k) {
          return x.x === k.x && x.y === k.y;
        }
        function A(x, k, S, f) {
          var h = j(G(x, k, S)), m = j(G(x, k, f)), y = j(G(S, f, x)), d = j(G(S, f, k));
          if (h !== m && y !== d)
            return true;
          if (h === 0 && F(x, S, k))
            return true;
          if (m === 0 && F(x, f, k))
            return true;
          if (y === 0 && F(S, x, f))
            return true;
          if (d === 0 && F(S, k, f))
            return true;
          return false;
        }
        function F(x, k, S) {
          return k.x <= Math.max(x.x, S.x) && k.x >= Math.min(x.x, S.x) && k.y <= Math.max(x.y, S.y) && k.y >= Math.min(x.y, S.y);
        }
        function j(x) {
          return x > 0 ? 1 : x < 0 ? -1 : 0;
        }
        function T(x, k) {
          var S = x;
          do {
            if (S.i !== x.i && S.next.i !== x.i && S.i !== k.i && S.next.i !== k.i && A(S, S.next, x, k))
              return true;
            S = S.next;
          } while (S !== x);
          return false;
        }
        function C(x, k) {
          return G(x.prev, x, x.next) < 0 ? G(x, k, x.next) >= 0 && G(x, x.prev, k) >= 0 : G(x, k, x.prev) < 0 || G(x, x.next, k) < 0;
        }
        function v(x, k) {
          var S = x, f = false, h = (x.x + k.x) / 2, m = (x.y + k.y) / 2;
          do {
            if (S.y > m !== S.next.y > m && S.next.y !== S.y && h < (S.next.x - S.x) * (m - S.y) / (S.next.y - S.y) + S.x)
              f = !f;
            S = S.next;
          } while (S !== x);
          return f;
        }
        function O(x, k) {
          var S = new g(x.i, x.x, x.y), f = new g(k.i, k.x, k.y), h = x.next, m = k.prev;
          return x.next = k, k.prev = x, S.next = h, h.prev = S, f.next = S, S.prev = f, m.next = f, f.prev = m, f;
        }
        function q(x, k, S, f) {
          var h = new g(x, k, S);
          if (!f)
            h.prev = h, h.next = h;
          else
            h.next = f.next, h.prev = f, f.next.prev = h, f.next = h;
          return h;
        }
        function w(x) {
          if (x.next.prev = x.prev, x.prev.next = x.next, x.prevZ)
            x.prevZ.nextZ = x.nextZ;
          if (x.nextZ)
            x.nextZ.prevZ = x.prevZ;
        }
        function g(x, k, S) {
          this.i = x, this.x = k, this.y = S, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
        }
        B.deviation = function(x, k, S, f) {
          var h = k && k.length, m = h ? k[0] * S : x.length, y = Math.abs(b(x, 0, m, S));
          if (h)
            for (var d = 0, p = k.length;d < p; d++) {
              var u = k[d] * S, s = d < p - 1 ? k[d + 1] * S : x.length;
              y -= Math.abs(b(x, u, s, S));
            }
          var c = 0;
          for (d = 0;d < f.length; d += 3) {
            var n = f[d] * S, _ = f[d + 1] * S, l = f[d + 2] * S;
            c += Math.abs((x[n] - x[l]) * (x[_ + 1] - x[n + 1]) - (x[n] - x[_]) * (x[l + 1] - x[n + 1]));
          }
          return y === 0 && c === 0 ? 0 : Math.abs((c - y) / y);
        };
        function b(x, k, S, f) {
          var h = 0;
          for (var m = k, y = S - f;m < S; m += f)
            h += (x[y] - x[m]) * (x[m + 1] + x[y + 1]), y = m;
          return h;
        }
        B.flatten = function(x) {
          var k = x[0][0].length, S = { vertices: [], holes: [], dimensions: k }, f = 0;
          for (var h = 0;h < x.length; h++) {
            for (var m = 0;m < x[h].length; m++)
              for (var y = 0;y < k; y++)
                S.vertices.push(x[h][m][y]);
            if (h > 0)
              f += x[h - 1].length, S.holes.push(f);
          }
          return S;
        }, M.exports = B;
      }, 13829: (M, B, $) => {
        var E = $(87841), L = function(z, U) {
          if (U === undefined)
            U = new E;
          var K = Infinity, J = Infinity, Z = -K, D = -J, Q;
          for (var H = 0;H < z.points.length; H++)
            Q = z.points[H], K = Math.min(K, Q.x), J = Math.min(J, Q.y), Z = Math.max(Z, Q.x), D = Math.max(D, Q.y);
          return U.x = K, U.y = J, U.width = Z - K, U.height = D - J, U;
        };
        M.exports = L;
      }, 26173: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = [];
          for (var L = 0;L < $.points.length; L++)
            E.push($.points[L].x), E.push($.points[L].y);
          return E;
        };
        M.exports = B;
      }, 9564: (M, B, $) => {
        var E = $(35001), L = $(23031), z = $(30052), U = function(K, J, Z, D) {
          if (D === undefined)
            D = [];
          var Q = K.points, H = z(K);
          if (!J && Z > 0)
            J = H / Z;
          for (var N = 0;N < J; N++) {
            var W = H * (N / J), R = 0;
            for (var Y = 0;Y < Q.length; Y++) {
              var I = Q[Y], P = Q[(Y + 1) % Q.length], X = new L(I.x, I.y, P.x, P.y), G = E(X);
              if (W < R || W > R + G) {
                R += G;
                continue;
              }
              var V = X.getPoint((W - R) / G);
              D.push(V);
              break;
            }
          }
          return D;
        };
        M.exports = U;
      }, 30052: (M, B, $) => {
        var E = $(35001), L = $(23031), z = function(U) {
          var K = U.points, J = 0;
          for (var Z = 0;Z < K.length; Z++) {
            var D = K[Z], Q = K[(Z + 1) % K.length], H = new L(D.x, D.y, Q.x, Q.y);
            J += E(H);
          }
          return J;
        };
        M.exports = z;
      }, 25717: (M, B, $) => {
        var E = $(83419), L = $(63814), z = $(9564), U = $(23777), K = new E({ initialize: function J(Z) {
          if (this.type = U.POLYGON, this.area = 0, this.points = [], Z)
            this.setTo(Z);
        }, contains: function(J, Z) {
          return L(this, J, Z);
        }, setTo: function(J) {
          if (this.area = 0, this.points = [], typeof J === "string")
            J = J.split(" ");
          if (!Array.isArray(J))
            return this;
          var Z;
          for (var D = 0;D < J.length; D++) {
            if (Z = { x: 0, y: 0 }, typeof J[D] === "number" || typeof J[D] === "string")
              Z.x = parseFloat(J[D]), Z.y = parseFloat(J[D + 1]), D++;
            else if (Array.isArray(J[D]))
              Z.x = J[D][0], Z.y = J[D][1];
            else
              Z.x = J[D].x, Z.y = J[D].y;
            this.points.push(Z);
          }
          return this.calculateArea(), this;
        }, calculateArea: function() {
          if (this.points.length < 3)
            return this.area = 0, this.area;
          var J = 0, Z, D;
          for (var Q = 0;Q < this.points.length - 1; Q++)
            Z = this.points[Q], D = this.points[Q + 1], J += (D.x - Z.x) * (Z.y + D.y);
          return Z = this.points[0], D = this.points[this.points.length - 1], J += (Z.x - D.x) * (D.y + Z.y), this.area = -J * 0.5, this.area;
        }, getPoints: function(J, Z, D) {
          return z(this, J, Z, D);
        } });
        M.exports = K;
      }, 8133: (M) => {
        var B = function($) {
          return $.points.reverse(), $;
        };
        M.exports = B;
      }, 29524: (M) => {
        function B(K, J) {
          var Z = K.x - J.x, D = K.y - J.y;
          return Z * Z + D * D;
        }
        function $(K, J, Z) {
          var { x: D, y: Q } = J, H = Z.x - D, N = Z.y - Q;
          if (H !== 0 || N !== 0) {
            var W = ((K.x - D) * H + (K.y - Q) * N) / (H * H + N * N);
            if (W > 1)
              D = Z.x, Q = Z.y;
            else if (W > 0)
              D += H * W, Q += N * W;
          }
          return H = K.x - D, N = K.y - Q, H * H + N * N;
        }
        function E(K, J) {
          var Z = K[0], D = [Z], Q;
          for (var H = 1, N = K.length;H < N; H++)
            if (Q = K[H], B(Q, Z) > J)
              D.push(Q), Z = Q;
          if (Z !== Q)
            D.push(Q);
          return D;
        }
        function L(K, J, Z, D, Q) {
          var H = D, N;
          for (var W = J + 1;W < Z; W++) {
            var R = $(K[W], K[J], K[Z]);
            if (R > H)
              N = W, H = R;
          }
          if (H > D) {
            if (N - J > 1)
              L(K, J, N, D, Q);
            if (Q.push(K[N]), Z - N > 1)
              L(K, N, Z, D, Q);
          }
        }
        function z(K, J) {
          var Z = K.length - 1, D = [K[0]];
          return L(K, 0, Z, J, D), D.push(K[Z]), D;
        }
        var U = function(K, J, Z) {
          if (J === undefined)
            J = 1;
          if (Z === undefined)
            Z = false;
          var D = K.points;
          if (D.length > 2) {
            var Q = J * J;
            if (!Z)
              D = E(D, Q);
            K.setTo(z(D, Q));
          }
          return K;
        };
        M.exports = U;
      }, 5469: (M) => {
        var B = function(E, L) {
          return E[0] = L[0], E[1] = L[1], E;
        }, $ = function(E) {
          var L, z = [], U = E.points;
          for (L = 0;L < U.length; L++)
            z.push([U[L].x, U[L].y]);
          var K = [];
          if (z.length > 0)
            K.push(B([0, 0], z[0]));
          for (L = 0;L < z.length - 1; L++) {
            var J = z[L], Z = z[L + 1], D = J[0], Q = J[1], H = Z[0], N = Z[1];
            K.push([0.85 * D + 0.15 * H, 0.85 * Q + 0.15 * N]), K.push([0.15 * D + 0.85 * H, 0.15 * Q + 0.85 * N]);
          }
          if (z.length > 1)
            K.push(B([0, 0], z[z.length - 1]));
          return E.setTo(K);
        };
        M.exports = $;
      }, 24709: (M) => {
        var B = function($, E, L) {
          var z = $.points;
          for (var U = 0;U < z.length; U++)
            z[U].x += E, z[U].y += L;
          return $;
        };
        M.exports = B;
      }, 58423: (M, B, $) => {
        var E = $(25717);
        E.Clone = $(12306), E.Contains = $(63814), E.ContainsPoint = $(99338), E.Earcut = $(94811), E.GetAABB = $(13829), E.GetNumberArray = $(26173), E.GetPoints = $(9564), E.Perimeter = $(30052), E.Reverse = $(8133), E.Simplify = $(29524), E.Smooth = $(5469), E.Translate = $(24709), M.exports = E;
      }, 62224: (M) => {
        var B = function($) {
          return $.width * $.height;
        };
        M.exports = B;
      }, 98615: (M) => {
        var B = function($) {
          return $.x = Math.ceil($.x), $.y = Math.ceil($.y), $;
        };
        M.exports = B;
      }, 31688: (M) => {
        var B = function($) {
          return $.x = Math.ceil($.x), $.y = Math.ceil($.y), $.width = Math.ceil($.width), $.height = Math.ceil($.height), $;
        };
        M.exports = B;
      }, 67502: (M) => {
        var B = function($, E, L) {
          return $.x = E - $.width / 2, $.y = L - $.height / 2, $;
        };
        M.exports = B;
      }, 65085: (M, B, $) => {
        var E = $(87841), L = function(z) {
          return new E(z.x, z.y, z.width, z.height);
        };
        M.exports = L;
      }, 37303: (M) => {
        var B = function($, E, L) {
          if ($.width <= 0 || $.height <= 0)
            return false;
          return $.x <= E && $.x + $.width >= E && $.y <= L && $.y + $.height >= L;
        };
        M.exports = B;
      }, 96553: (M, B, $) => {
        var E = $(37303), L = function(z, U) {
          return E(z, U.x, U.y);
        };
        M.exports = L;
      }, 70273: (M) => {
        var B = function($, E) {
          if (E.width * E.height > $.width * $.height)
            return false;
          return E.x > $.x && E.x < $.right && (E.right > $.x && E.right < $.right) && (E.y > $.y && E.y < $.bottom) && (E.bottom > $.y && E.bottom < $.bottom);
        };
        M.exports = B;
      }, 43459: (M) => {
        var B = function($, E) {
          return E.setTo($.x, $.y, $.width, $.height);
        };
        M.exports = B;
      }, 77493: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = [];
          return E.push({ x: $.x, y: $.y }), E.push({ x: $.right, y: $.y }), E.push({ x: $.right, y: $.bottom }), E.push({ x: $.x, y: $.bottom }), E;
        };
        M.exports = B;
      }, 9219: (M) => {
        var B = function($, E) {
          return $.x === E.x && $.y === E.y && $.width === E.width && $.height === E.height;
        };
        M.exports = B;
      }, 53751: (M, B, $) => {
        var E = $(8249), L = function(z, U) {
          var K = E(z);
          if (K < E(U))
            z.setSize(U.height * K, U.height);
          else
            z.setSize(U.width, U.width / K);
          return z.setPosition(U.centerX - z.width / 2, U.centerY - z.height / 2);
        };
        M.exports = L;
      }, 16088: (M, B, $) => {
        var E = $(8249), L = function(z, U) {
          var K = E(z);
          if (K > E(U))
            z.setSize(U.height * K, U.height);
          else
            z.setSize(U.width, U.width / K);
          return z.setPosition(U.centerX - z.width / 2, U.centerY - z.height / 2);
        };
        M.exports = L;
      }, 80774: (M) => {
        var B = function($) {
          return $.x = Math.floor($.x), $.y = Math.floor($.y), $;
        };
        M.exports = B;
      }, 83859: (M) => {
        var B = function($) {
          return $.x = Math.floor($.x), $.y = Math.floor($.y), $.width = Math.floor($.width), $.height = Math.floor($.height), $;
        };
        M.exports = B;
      }, 19217: (M, B, $) => {
        var E = $(87841), L = $(36383), z = function(U, K) {
          if (K === undefined)
            K = new E;
          if (U.length === 0)
            return K;
          var { MAX_VALUE: J, MAX_VALUE: Z } = Number, D = L.MIN_SAFE_INTEGER, Q = L.MIN_SAFE_INTEGER, H, N, W;
          for (var R = 0;R < U.length; R++) {
            if (H = U[R], Array.isArray(H))
              N = H[0], W = H[1];
            else
              N = H.x, W = H.y;
            J = Math.min(J, N), Z = Math.min(Z, W), D = Math.max(D, N), Q = Math.max(Q, W);
          }
          return K.x = J, K.y = Z, K.width = D - J, K.height = Q - Z, K;
        };
        M.exports = z;
      }, 9477: (M, B, $) => {
        var E = $(87841), L = function(z, U, K, J, Z) {
          if (Z === undefined)
            Z = new E;
          return Z.setTo(Math.min(z, K), Math.min(U, J), Math.abs(z - K), Math.abs(U - J));
        };
        M.exports = L;
      }, 8249: (M) => {
        var B = function($) {
          return $.height === 0 ? NaN : $.width / $.height;
        };
        M.exports = B;
      }, 27165: (M, B, $) => {
        var E = $(2141), L = function(z, U) {
          if (U === undefined)
            U = new E;
          return U.x = z.centerX, U.y = z.centerY, U;
        };
        M.exports = L;
      }, 20812: (M, B, $) => {
        var E = $(13019), L = $(2141), z = function(U, K, J) {
          if (J === undefined)
            J = new L;
          if (K <= 0 || K >= 1)
            return J.x = U.x, J.y = U.y, J;
          var Z = E(U) * K;
          if (K > 0.5)
            if (Z -= U.width + U.height, Z <= U.width)
              J.x = U.right - Z, J.y = U.bottom;
            else
              J.x = U.x, J.y = U.bottom - (Z - U.width);
          else if (Z <= U.width)
            J.x = U.x + Z, J.y = U.y;
          else
            J.x = U.right, J.y = U.y + (Z - U.width);
          return J;
        };
        M.exports = z;
      }, 34819: (M, B, $) => {
        var E = $(20812), L = $(13019), z = function(U, K, J, Z) {
          if (Z === undefined)
            Z = [];
          if (!K && J > 0)
            K = L(U) / J;
          for (var D = 0;D < K; D++) {
            var Q = D / K;
            Z.push(E(U, Q));
          }
          return Z;
        };
        M.exports = z;
      }, 51313: (M, B, $) => {
        var E = $(2141), L = function(z, U) {
          if (U === undefined)
            U = new E;
          return U.x = z.width, U.y = z.height, U;
        };
        M.exports = L;
      }, 86091: (M, B, $) => {
        var E = $(67502), L = function(z, U, K) {
          var { centerX: J, centerY: Z } = z;
          return z.setSize(z.width + U * 2, z.height + K * 2), E(z, J, Z);
        };
        M.exports = L;
      }, 53951: (M, B, $) => {
        var E = $(87841), L = $(59996), z = function(U, K, J) {
          if (J === undefined)
            J = new E;
          if (L(U, K))
            J.x = Math.max(U.x, K.x), J.y = Math.max(U.y, K.y), J.width = Math.min(U.right, K.right) - J.x, J.height = Math.min(U.bottom, K.bottom) - J.y;
          else
            J.setEmpty();
          return J;
        };
        M.exports = z;
      }, 14649: (M, B, $) => {
        var E = $(13019), L = $(2141), z = function(U, K, J, Z) {
          if (Z === undefined)
            Z = [];
          if (!K && !J)
            return Z;
          if (!K)
            K = E(U) / J;
          else
            J = Math.round(E(U) / K);
          var { x: D, y: Q } = U, H = 0;
          for (var N = 0;N < J; N++)
            switch (Z.push(new L(D, Q)), H) {
              case 0:
                if (D += K, D >= U.right)
                  H = 1, Q += D - U.right, D = U.right;
                break;
              case 1:
                if (Q += K, Q >= U.bottom)
                  H = 2, D -= Q - U.bottom, Q = U.bottom;
                break;
              case 2:
                if (D -= K, D <= U.left)
                  H = 3, Q -= U.left - D, D = U.left;
                break;
              case 3:
                if (Q -= K, Q <= U.top)
                  H = 0, Q = U.top;
                break;
            }
          return Z;
        };
        M.exports = z;
      }, 33595: (M) => {
        var B = function($, E) {
          var { x: L, right: z, y: U, bottom: K } = $;
          for (var J = 0;J < E.length; J++)
            L = Math.min(L, E[J].x), z = Math.max(z, E[J].x), U = Math.min(U, E[J].y), K = Math.max(K, E[J].y);
          return $.x = L, $.y = U, $.width = z - L, $.height = K - U, $;
        };
        M.exports = B;
      }, 20074: (M) => {
        var B = function($, E) {
          var L = Math.min($.x, E.x), z = Math.max($.right, E.right);
          $.x = L, $.width = z - L;
          var U = Math.min($.y, E.y), K = Math.max($.bottom, E.bottom);
          return $.y = U, $.height = K - U, $;
        };
        M.exports = B;
      }, 92171: (M) => {
        var B = function($, E, L) {
          var z = Math.min($.x, E), U = Math.max($.right, E);
          $.x = z, $.width = U - z;
          var K = Math.min($.y, L), J = Math.max($.bottom, L);
          return $.y = K, $.height = J - K, $;
        };
        M.exports = B;
      }, 42981: (M) => {
        var B = function($, E, L) {
          return $.x += E, $.y += L, $;
        };
        M.exports = B;
      }, 46907: (M) => {
        var B = function($, E) {
          return $.x += E.x, $.y += E.y, $;
        };
        M.exports = B;
      }, 60170: (M) => {
        var B = function($, E) {
          return $.x < E.right && $.right > E.x && $.y < E.bottom && $.bottom > E.y;
        };
        M.exports = B;
      }, 13019: (M) => {
        var B = function($) {
          return 2 * ($.width + $.height);
        };
        M.exports = B;
      }, 85133: (M, B, $) => {
        var E = $(2141), L = $(39506), z = function(U, K, J) {
          if (J === undefined)
            J = new E;
          K = L(K);
          var Z = Math.sin(K), D = Math.cos(K), Q = D > 0 ? U.width / 2 : U.width / -2, H = Z > 0 ? U.height / 2 : U.height / -2;
          if (Math.abs(Q * Z) < Math.abs(H * D))
            H = Q * Z / D;
          else
            Q = H * D / Z;
          return J.x = Q + U.centerX, J.y = H + U.centerY, J;
        };
        M.exports = z;
      }, 26597: (M, B, $) => {
        var E = $(2141), L = function(z, U) {
          if (U === undefined)
            U = new E;
          return U.x = z.x + Math.random() * z.width, U.y = z.y + Math.random() * z.height, U;
        };
        M.exports = L;
      }, 86470: (M, B, $) => {
        var E = $(30976), L = $(70273), z = $(2141), U = function(K, J, Z) {
          if (Z === undefined)
            Z = new z;
          if (L(K, J))
            switch (E(0, 3)) {
              case 0:
                Z.x = K.x + Math.random() * (J.right - K.x), Z.y = K.y + Math.random() * (J.top - K.y);
                break;
              case 1:
                Z.x = J.x + Math.random() * (K.right - J.x), Z.y = J.bottom + Math.random() * (K.bottom - J.bottom);
                break;
              case 2:
                Z.x = K.x + Math.random() * (J.x - K.x), Z.y = J.y + Math.random() * (K.bottom - J.y);
                break;
              case 3:
                Z.x = J.right + Math.random() * (K.right - J.right), Z.y = K.y + Math.random() * (J.bottom - K.y);
                break;
            }
          return Z;
        };
        M.exports = U;
      }, 87841: (M, B, $) => {
        var E = $(83419), L = $(37303), z = $(20812), U = $(34819), K = $(23777), J = $(23031), Z = $(26597), D = new E({ initialize: function Q(H, N, W, R) {
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = 0;
          if (R === undefined)
            R = 0;
          this.type = K.RECTANGLE, this.x = H, this.y = N, this.width = W, this.height = R;
        }, contains: function(Q, H) {
          return L(this, Q, H);
        }, getPoint: function(Q, H) {
          return z(this, Q, H);
        }, getPoints: function(Q, H, N) {
          return U(this, Q, H, N);
        }, getRandomPoint: function(Q) {
          return Z(this, Q);
        }, setTo: function(Q, H, N, W) {
          return this.x = Q, this.y = H, this.width = N, this.height = W, this;
        }, setEmpty: function() {
          return this.setTo(0, 0, 0, 0);
        }, setPosition: function(Q, H) {
          if (H === undefined)
            H = Q;
          return this.x = Q, this.y = H, this;
        }, setSize: function(Q, H) {
          if (H === undefined)
            H = Q;
          return this.width = Q, this.height = H, this;
        }, isEmpty: function() {
          return this.width <= 0 || this.height <= 0;
        }, getLineA: function(Q) {
          if (Q === undefined)
            Q = new J;
          return Q.setTo(this.x, this.y, this.right, this.y), Q;
        }, getLineB: function(Q) {
          if (Q === undefined)
            Q = new J;
          return Q.setTo(this.right, this.y, this.right, this.bottom), Q;
        }, getLineC: function(Q) {
          if (Q === undefined)
            Q = new J;
          return Q.setTo(this.right, this.bottom, this.x, this.bottom), Q;
        }, getLineD: function(Q) {
          if (Q === undefined)
            Q = new J;
          return Q.setTo(this.x, this.bottom, this.x, this.y), Q;
        }, left: { get: function() {
          return this.x;
        }, set: function(Q) {
          if (Q >= this.right)
            this.width = 0;
          else
            this.width = this.right - Q;
          this.x = Q;
        } }, right: { get: function() {
          return this.x + this.width;
        }, set: function(Q) {
          if (Q <= this.x)
            this.width = 0;
          else
            this.width = Q - this.x;
        } }, top: { get: function() {
          return this.y;
        }, set: function(Q) {
          if (Q >= this.bottom)
            this.height = 0;
          else
            this.height = this.bottom - Q;
          this.y = Q;
        } }, bottom: { get: function() {
          return this.y + this.height;
        }, set: function(Q) {
          if (Q <= this.y)
            this.height = 0;
          else
            this.height = Q - this.y;
        } }, centerX: { get: function() {
          return this.x + this.width / 2;
        }, set: function(Q) {
          this.x = Q - this.width / 2;
        } }, centerY: { get: function() {
          return this.y + this.height / 2;
        }, set: function(Q) {
          this.y = Q - this.height / 2;
        } } });
        M.exports = D;
      }, 94845: (M) => {
        var B = function($, E) {
          return $.width === E.width && $.height === E.height;
        };
        M.exports = B;
      }, 31730: (M) => {
        var B = function($, E, L) {
          if (L === undefined)
            L = E;
          return $.width *= E, $.height *= L, $;
        };
        M.exports = B;
      }, 36899: (M, B, $) => {
        var E = $(87841), L = function(z, U, K) {
          if (K === undefined)
            K = new E;
          var J = Math.min(z.x, U.x), Z = Math.min(z.y, U.y), D = Math.max(z.right, U.right) - J, Q = Math.max(z.bottom, U.bottom) - Z;
          return K.setTo(J, Z, D, Q);
        };
        M.exports = L;
      }, 93232: (M, B, $) => {
        var E = $(87841);
        E.Area = $(62224), E.Ceil = $(98615), E.CeilAll = $(31688), E.CenterOn = $(67502), E.Clone = $(65085), E.Contains = $(37303), E.ContainsPoint = $(96553), E.ContainsRect = $(70273), E.CopyFrom = $(43459), E.Decompose = $(77493), E.Equals = $(9219), E.FitInside = $(53751), E.FitOutside = $(16088), E.Floor = $(80774), E.FloorAll = $(83859), E.FromPoints = $(19217), E.FromXY = $(9477), E.GetAspectRatio = $(8249), E.GetCenter = $(27165), E.GetPoint = $(20812), E.GetPoints = $(34819), E.GetSize = $(51313), E.Inflate = $(86091), E.Intersection = $(53951), E.MarchingAnts = $(14649), E.MergePoints = $(33595), E.MergeRect = $(20074), E.MergeXY = $(92171), E.Offset = $(42981), E.OffsetPoint = $(46907), E.Overlaps = $(60170), E.Perimeter = $(13019), E.PerimeterPoint = $(85133), E.Random = $(26597), E.RandomOutside = $(86470), E.SameDimensions = $(94845), E.Scale = $(31730), E.Union = $(36899), M.exports = E;
      }, 41658: (M) => {
        var B = function($) {
          var { x1: E, y1: L, x2: z, y2: U, x3: K, y3: J } = $;
          return Math.abs(((K - E) * (U - L) - (z - E) * (J - L)) / 2);
        };
        M.exports = B;
      }, 39208: (M, B, $) => {
        var E = $(16483), L = function(z, U, K) {
          var J = K * (Math.sqrt(3) / 2), Z = z, D = U, Q = z + K / 2, H = U + J, N = z - K / 2, W = U + J;
          return new E(Z, D, Q, H, N, W);
        };
        M.exports = L;
      }, 39545: (M, B, $) => {
        var E = $(94811), L = $(16483), z = function(U, K, J, Z, D) {
          if (K === undefined)
            K = null;
          if (J === undefined)
            J = 1;
          if (Z === undefined)
            Z = 1;
          if (D === undefined)
            D = [];
          var Q = E(U, K), H, N, W, R, Y, I, P, X, G;
          for (var V = 0;V < Q.length; V += 3)
            H = Q[V], N = Q[V + 1], W = Q[V + 2], R = U[H * 2] * J, Y = U[H * 2 + 1] * Z, I = U[N * 2] * J, P = U[N * 2 + 1] * Z, X = U[W * 2] * J, G = U[W * 2 + 1] * Z, D.push(new L(R, Y, I, P, X, G));
          return D;
        };
        M.exports = z;
      }, 90301: (M, B, $) => {
        var E = $(16483), L = function(z, U, K, J) {
          if (J === undefined)
            J = K;
          var Z = z, D = U, Q = z, H = U - J, N = z + K, W = U;
          return new E(Z, D, Q, H, N, W);
        };
        M.exports = L;
      }, 23707: (M, B, $) => {
        var E = $(97523), L = $(13584), z = function(U, K, J, Z) {
          if (Z === undefined)
            Z = E;
          var D = Z(U), Q = K - D.x, H = J - D.y;
          return L(U, Q, H);
        };
        M.exports = z;
      }, 97523: (M, B, $) => {
        var E = $(2141), L = function(z, U) {
          if (U === undefined)
            U = new E;
          return U.x = (z.x1 + z.x2 + z.x3) / 3, U.y = (z.y1 + z.y2 + z.y3) / 3, U;
        };
        M.exports = L;
      }, 24951: (M, B, $) => {
        var E = $(26099);
        function L(U, K, J, Z) {
          return U * Z - K * J;
        }
        var z = function(U, K) {
          if (K === undefined)
            K = new E;
          var { x3: J, y3: Z } = U, D = U.x1 - J, Q = U.y1 - Z, H = U.x2 - J, N = U.y2 - Z, W = 2 * L(D, Q, H, N), R = L(Q, D * D + Q * Q, N, H * H + N * N), Y = L(D, D * D + Q * Q, H, H * H + N * N);
          return K.x = J - R / W, K.y = Z + Y / W, K;
        };
        M.exports = z;
      }, 85614: (M, B, $) => {
        var E = $(96503), L = function(z, U) {
          if (U === undefined)
            U = new E;
          var { x1: K, y1: J, x2: Z, y2: D, x3: Q, y3: H } = z, N = Z - K, W = D - J, R = Q - K, Y = H - J, I = N * (K + Z) + W * (J + D), P = R * (K + Q) + Y * (J + H), X = 2 * (N * (H - D) - W * (Q - Z)), G, V;
          if (Math.abs(X) < 0.000001) {
            var A = Math.min(K, Z, Q), F = Math.min(J, D, H);
            G = (Math.max(K, Z, Q) - A) * 0.5, V = (Math.max(J, D, H) - F) * 0.5, U.x = A + G, U.y = F + V, U.radius = Math.sqrt(G * G + V * V);
          } else
            U.x = (Y * I - W * P) / X, U.y = (N * P - R * I) / X, G = U.x - K, V = U.y - J, U.radius = Math.sqrt(G * G + V * V);
          return U;
        };
        M.exports = L;
      }, 74422: (M, B, $) => {
        var E = $(16483), L = function(z) {
          return new E(z.x1, z.y1, z.x2, z.y2, z.x3, z.y3);
        };
        M.exports = L;
      }, 10690: (M) => {
        var B = function($, E, L) {
          var z = $.x3 - $.x1, U = $.y3 - $.y1, K = $.x2 - $.x1, J = $.y2 - $.y1, Z = E - $.x1, D = L - $.y1, Q = z * z + U * U, H = z * K + U * J, N = z * Z + U * D, W = K * K + J * J, R = K * Z + J * D, Y = Q * W - H * H, I = Y === 0 ? 0 : 1 / Y, P = (W * N - H * R) * I, X = (Q * R - H * N) * I;
          return P >= 0 && X >= 0 && P + X < 1;
        };
        M.exports = B;
      }, 48653: (M) => {
        var B = function($, E, L, z) {
          if (L === undefined)
            L = false;
          if (z === undefined)
            z = [];
          var U = $.x3 - $.x1, K = $.y3 - $.y1, J = $.x2 - $.x1, Z = $.y2 - $.y1, D = U * U + K * K, Q = U * J + K * Z, H = J * J + Z * Z, N = D * H - Q * Q, W = N === 0 ? 0 : 1 / N, R, Y, I, P, X, G, V = $.x1, A = $.y1;
          for (var F = 0;F < E.length; F++)
            if (I = E[F].x - V, P = E[F].y - A, X = U * I + K * P, G = J * I + Z * P, R = (H * X - Q * G) * W, Y = (D * G - Q * X) * W, R >= 0 && Y >= 0 && R + Y < 1) {
              if (z.push({ x: E[F].x, y: E[F].y }), L)
                break;
            }
          return z;
        };
        M.exports = B;
      }, 96006: (M, B, $) => {
        var E = $(10690), L = function(z, U) {
          return E(z, U.x, U.y);
        };
        M.exports = L;
      }, 71326: (M) => {
        var B = function($, E) {
          return E.setTo($.x1, $.y1, $.x2, $.y2, $.x3, $.y3);
        };
        M.exports = B;
      }, 71694: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = [];
          return E.push({ x: $.x1, y: $.y1 }), E.push({ x: $.x2, y: $.y2 }), E.push({ x: $.x3, y: $.y3 }), E;
        };
        M.exports = B;
      }, 33522: (M) => {
        var B = function($, E) {
          return $.x1 === E.x1 && $.y1 === E.y1 && $.x2 === E.x2 && $.y2 === E.y2 && $.x3 === E.x3 && $.y3 === E.y3;
        };
        M.exports = B;
      }, 20437: (M, B, $) => {
        var E = $(2141), L = $(35001), z = function(U, K, J) {
          if (J === undefined)
            J = new E;
          var Z = U.getLineA(), D = U.getLineB(), Q = U.getLineC();
          if (K <= 0 || K >= 1)
            return J.x = Z.x1, J.y = Z.y1, J;
          var H = L(Z), N = L(D), W = L(Q), R = H + N + W, Y = R * K, I = 0;
          if (Y < H)
            I = Y / H, J.x = Z.x1 + (Z.x2 - Z.x1) * I, J.y = Z.y1 + (Z.y2 - Z.y1) * I;
          else if (Y > H + N)
            Y -= H + N, I = Y / W, J.x = Q.x1 + (Q.x2 - Q.x1) * I, J.y = Q.y1 + (Q.y2 - Q.y1) * I;
          else
            Y -= H, I = Y / N, J.x = D.x1 + (D.x2 - D.x1) * I, J.y = D.y1 + (D.y2 - D.y1) * I;
          return J;
        };
        M.exports = z;
      }, 80672: (M, B, $) => {
        var E = $(35001), L = $(2141), z = function(U, K, J, Z) {
          if (Z === undefined)
            Z = [];
          var D = U.getLineA(), Q = U.getLineB(), H = U.getLineC(), N = E(D), W = E(Q), R = E(H), Y = N + W + R;
          if (!K && J > 0)
            K = Y / J;
          for (var I = 0;I < K; I++) {
            var P = Y * (I / K), X = 0, G = new L;
            if (P < N)
              X = P / N, G.x = D.x1 + (D.x2 - D.x1) * X, G.y = D.y1 + (D.y2 - D.y1) * X;
            else if (P > N + W)
              P -= N + W, X = P / R, G.x = H.x1 + (H.x2 - H.x1) * X, G.y = H.y1 + (H.y2 - H.y1) * X;
            else
              P -= N, X = P / W, G.x = Q.x1 + (Q.x2 - Q.x1) * X, G.y = Q.y1 + (Q.y2 - Q.y1) * X;
            Z.push(G);
          }
          return Z;
        };
        M.exports = z;
      }, 39757: (M, B, $) => {
        var E = $(2141);
        function L(U, K, J, Z) {
          var D = U - J, Q = K - Z, H = D * D + Q * Q;
          return Math.sqrt(H);
        }
        var z = function(U, K) {
          if (K === undefined)
            K = new E;
          var { x1: J, y1: Z, x2: D, y2: Q, x3: H, y3: N } = U, W = L(H, N, D, Q), R = L(J, Z, H, N), Y = L(D, Q, J, Z), I = W + R + Y;
          return K.x = (J * W + D * R + H * Y) / I, K.y = (Z * W + Q * R + N * Y) / I, K;
        };
        M.exports = z;
      }, 13584: (M) => {
        var B = function($, E, L) {
          return $.x1 += E, $.y1 += L, $.x2 += E, $.y2 += L, $.x3 += E, $.y3 += L, $;
        };
        M.exports = B;
      }, 1376: (M, B, $) => {
        var E = $(35001), L = function(z) {
          var U = z.getLineA(), K = z.getLineB(), J = z.getLineC();
          return E(U) + E(K) + E(J);
        };
        M.exports = L;
      }, 90260: (M, B, $) => {
        var E = $(2141), L = function(z, U) {
          if (U === undefined)
            U = new E;
          var K = z.x2 - z.x1, J = z.y2 - z.y1, Z = z.x3 - z.x1, D = z.y3 - z.y1, Q = Math.random(), H = Math.random();
          if (Q + H >= 1)
            Q = 1 - Q, H = 1 - H;
          return U.x = z.x1 + (K * Q + Z * H), U.y = z.y1 + (J * Q + D * H), U;
        };
        M.exports = L;
      }, 52172: (M, B, $) => {
        var E = $(99614), L = $(39757), z = function(U, K) {
          var J = L(U);
          return E(U, J.x, J.y, K);
        };
        M.exports = z;
      }, 49907: (M, B, $) => {
        var E = $(99614), L = function(z, U, K) {
          return E(z, U.x, U.y, K);
        };
        M.exports = L;
      }, 99614: (M) => {
        var B = function($, E, L, z) {
          var U = Math.cos(z), K = Math.sin(z), J = $.x1 - E, Z = $.y1 - L;
          return $.x1 = J * U - Z * K + E, $.y1 = J * K + Z * U + L, J = $.x2 - E, Z = $.y2 - L, $.x2 = J * U - Z * K + E, $.y2 = J * K + Z * U + L, J = $.x3 - E, Z = $.y3 - L, $.x3 = J * U - Z * K + E, $.y3 = J * K + Z * U + L, $;
        };
        M.exports = B;
      }, 16483: (M, B, $) => {
        var E = $(83419), L = $(10690), z = $(20437), U = $(80672), K = $(23777), J = $(23031), Z = $(90260), D = new E({ initialize: function Q(H, N, W, R, Y, I) {
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = 0;
          if (R === undefined)
            R = 0;
          if (Y === undefined)
            Y = 0;
          if (I === undefined)
            I = 0;
          this.type = K.TRIANGLE, this.x1 = H, this.y1 = N, this.x2 = W, this.y2 = R, this.x3 = Y, this.y3 = I;
        }, contains: function(Q, H) {
          return L(this, Q, H);
        }, getPoint: function(Q, H) {
          return z(this, Q, H);
        }, getPoints: function(Q, H, N) {
          return U(this, Q, H, N);
        }, getRandomPoint: function(Q) {
          return Z(this, Q);
        }, setTo: function(Q, H, N, W, R, Y) {
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = 0;
          if (R === undefined)
            R = 0;
          if (Y === undefined)
            Y = 0;
          return this.x1 = Q, this.y1 = H, this.x2 = N, this.y2 = W, this.x3 = R, this.y3 = Y, this;
        }, getLineA: function(Q) {
          if (Q === undefined)
            Q = new J;
          return Q.setTo(this.x1, this.y1, this.x2, this.y2), Q;
        }, getLineB: function(Q) {
          if (Q === undefined)
            Q = new J;
          return Q.setTo(this.x2, this.y2, this.x3, this.y3), Q;
        }, getLineC: function(Q) {
          if (Q === undefined)
            Q = new J;
          return Q.setTo(this.x3, this.y3, this.x1, this.y1), Q;
        }, left: { get: function() {
          return Math.min(this.x1, this.x2, this.x3);
        }, set: function(Q) {
          var H = 0;
          if (this.x1 <= this.x2 && this.x1 <= this.x3)
            H = this.x1 - Q;
          else if (this.x2 <= this.x1 && this.x2 <= this.x3)
            H = this.x2 - Q;
          else
            H = this.x3 - Q;
          this.x1 -= H, this.x2 -= H, this.x3 -= H;
        } }, right: { get: function() {
          return Math.max(this.x1, this.x2, this.x3);
        }, set: function(Q) {
          var H = 0;
          if (this.x1 >= this.x2 && this.x1 >= this.x3)
            H = this.x1 - Q;
          else if (this.x2 >= this.x1 && this.x2 >= this.x3)
            H = this.x2 - Q;
          else
            H = this.x3 - Q;
          this.x1 -= H, this.x2 -= H, this.x3 -= H;
        } }, top: { get: function() {
          return Math.min(this.y1, this.y2, this.y3);
        }, set: function(Q) {
          var H = 0;
          if (this.y1 <= this.y2 && this.y1 <= this.y3)
            H = this.y1 - Q;
          else if (this.y2 <= this.y1 && this.y2 <= this.y3)
            H = this.y2 - Q;
          else
            H = this.y3 - Q;
          this.y1 -= H, this.y2 -= H, this.y3 -= H;
        } }, bottom: { get: function() {
          return Math.max(this.y1, this.y2, this.y3);
        }, set: function(Q) {
          var H = 0;
          if (this.y1 >= this.y2 && this.y1 >= this.y3)
            H = this.y1 - Q;
          else if (this.y2 >= this.y1 && this.y2 >= this.y3)
            H = this.y2 - Q;
          else
            H = this.y3 - Q;
          this.y1 -= H, this.y2 -= H, this.y3 -= H;
        } } });
        M.exports = D;
      }, 84435: (M, B, $) => {
        var E = $(16483);
        E.Area = $(41658), E.BuildEquilateral = $(39208), E.BuildFromPolygon = $(39545), E.BuildRight = $(90301), E.CenterOn = $(23707), E.Centroid = $(97523), E.CircumCenter = $(24951), E.CircumCircle = $(85614), E.Clone = $(74422), E.Contains = $(10690), E.ContainsArray = $(48653), E.ContainsPoint = $(96006), E.CopyFrom = $(71326), E.Decompose = $(71694), E.Equals = $(33522), E.GetPoint = $(20437), E.GetPoints = $(80672), E.InCenter = $(39757), E.Perimeter = $(1376), E.Offset = $(13584), E.Random = $(90260), E.Rotate = $(52172), E.RotateAroundPoint = $(49907), E.RotateAroundXY = $(99614), M.exports = E;
      }, 74457: (M) => {
        var B = function($, E, L) {
          return { gameObject: $, enabled: true, draggable: false, dropZone: false, cursor: false, target: null, camera: null, hitArea: E, hitAreaCallback: L, hitAreaDebug: null, customHitArea: false, localX: 0, localY: 0, dragState: 0, dragStartX: 0, dragStartY: 0, dragStartXGlobal: 0, dragStartYGlobal: 0, dragX: 0, dragY: 0 };
        };
        M.exports = B;
      }, 84409: (M) => {
        var B = function($, E) {
          return function(L, z, U, K) {
            var J = $.getPixelAlpha(z, U, K.texture.key, K.frame.name);
            return J && J >= E;
          };
        };
        M.exports = B;
      }, 7003: (M, B, $) => {
        var E = $(83419), L = $(93301), z = $(50792), U = $(8214), K = $(8443), J = $(78970), Z = $(85098), D = $(42515), Q = $(36210), H = $(61340), N = $(85955), W = new E({ initialize: function R(Y, I) {
          if (this.game = Y, this.scaleManager, this.canvas, this.config = I, this.enabled = true, this.events = new z, this.isOver = true, this.defaultCursor = "", this.keyboard = I.inputKeyboard ? new J(this) : null, this.mouse = I.inputMouse ? new Z(this) : null, this.touch = I.inputTouch ? new Q(this) : null, this.pointers = [], this.pointersTotal = I.inputActivePointers, I.inputTouch && this.pointersTotal === 1)
            this.pointersTotal = 2;
          for (var P = 0;P <= this.pointersTotal; P++) {
            var X = new D(this, P);
            X.smoothFactor = I.inputSmoothFactor, this.pointers.push(X);
          }
          this.mousePointer = I.inputMouse ? this.pointers[0] : null, this.activePointer = this.pointers[0], this.globalTopOnly = true, this.time = 0, this._tempPoint = { x: 0, y: 0 }, this._tempHitTest = [], this._tempMatrix = new H, this._tempMatrix2 = new H, this._tempSkip = false, this.mousePointerContainer = [this.mousePointer], Y.events.once(K.BOOT, this.boot, this);
        }, boot: function() {
          var R = this.game, Y = R.events;
          this.canvas = R.canvas, this.scaleManager = R.scale, this.events.emit(U.MANAGER_BOOT), Y.on(K.PRE_RENDER, this.preRender, this), Y.once(K.DESTROY, this.destroy, this);
        }, setCanvasOver: function(R) {
          this.isOver = true, this.events.emit(U.GAME_OVER, R);
        }, setCanvasOut: function(R) {
          this.isOver = false, this.events.emit(U.GAME_OUT, R);
        }, preRender: function() {
          var R = this.game.loop.now, Y = this.game.loop.delta, I = this.game.scene.getScenes(true, true);
          this.time = R, this.events.emit(U.MANAGER_UPDATE);
          for (var P = 0;P < I.length; P++) {
            var X = I[P];
            if (X.sys.input && X.sys.input.updatePoll(R, Y) && this.globalTopOnly)
              return;
          }
        }, setDefaultCursor: function(R) {
          if (this.defaultCursor = R, this.canvas.style.cursor !== R)
            this.canvas.style.cursor = R;
        }, setCursor: function(R) {
          if (R.cursor)
            this.canvas.style.cursor = R.cursor;
        }, resetCursor: function(R) {
          if (R.cursor && this.canvas)
            this.canvas.style.cursor = this.defaultCursor;
        }, addPointer: function(R) {
          if (R === undefined)
            R = 1;
          var Y = [];
          if (this.pointersTotal + R > 10)
            R = 10 - this.pointersTotal;
          for (var I = 0;I < R; I++) {
            var P = this.pointers.length, X = new D(this, P);
            X.smoothFactor = this.config.inputSmoothFactor, this.pointers.push(X), this.pointersTotal++, Y.push(X);
          }
          return Y;
        }, updateInputPlugins: function(R, Y) {
          var I = this.game.scene.getScenes(false, true);
          this._tempSkip = false;
          for (var P = 0;P < I.length; P++) {
            var X = I[P];
            if (X.sys.input) {
              var G = X.sys.input.update(R, Y);
              if (G && this.globalTopOnly || this._tempSkip)
                return;
            }
          }
        }, onTouchStart: function(R) {
          var Y = this.pointers, I = [];
          for (var P = 0;P < R.changedTouches.length; P++) {
            var X = R.changedTouches[P];
            for (var G = 1;G < this.pointersTotal; G++) {
              var V = Y[G];
              if (!V.active) {
                V.touchstart(X, R), this.activePointer = V, I.push(V);
                break;
              }
            }
          }
          this.updateInputPlugins(L.TOUCH_START, I);
        }, onTouchMove: function(R) {
          var Y = this.pointers, I = [];
          for (var P = 0;P < R.changedTouches.length; P++) {
            var X = R.changedTouches[P];
            for (var G = 1;G < this.pointersTotal; G++) {
              var V = Y[G];
              if (V.active && V.identifier === X.identifier) {
                var A = document.elementFromPoint(X.clientX, X.clientY), F = A === this.canvas;
                if (!this.isOver && F)
                  this.setCanvasOver(R);
                else if (this.isOver && !F)
                  this.setCanvasOut(R);
                if (this.isOver)
                  V.touchmove(X, R), this.activePointer = V, I.push(V);
                break;
              }
            }
          }
          this.updateInputPlugins(L.TOUCH_MOVE, I);
        }, onTouchEnd: function(R) {
          var Y = this.pointers, I = [];
          for (var P = 0;P < R.changedTouches.length; P++) {
            var X = R.changedTouches[P];
            for (var G = 1;G < this.pointersTotal; G++) {
              var V = Y[G];
              if (V.active && V.identifier === X.identifier) {
                V.touchend(X, R), I.push(V);
                break;
              }
            }
          }
          this.updateInputPlugins(L.TOUCH_END, I);
        }, onTouchCancel: function(R) {
          var Y = this.pointers, I = [];
          for (var P = 0;P < R.changedTouches.length; P++) {
            var X = R.changedTouches[P];
            for (var G = 1;G < this.pointersTotal; G++) {
              var V = Y[G];
              if (V.active && V.identifier === X.identifier) {
                V.touchcancel(X, R), I.push(V);
                break;
              }
            }
          }
          this.updateInputPlugins(L.TOUCH_CANCEL, I);
        }, onMouseDown: function(R) {
          var Y = this.mousePointer;
          Y.down(R), Y.updateMotion(), this.activePointer = Y, this.updateInputPlugins(L.MOUSE_DOWN, this.mousePointerContainer);
        }, onMouseMove: function(R) {
          var Y = this.mousePointer;
          Y.move(R), Y.updateMotion(), this.activePointer = Y, this.updateInputPlugins(L.MOUSE_MOVE, this.mousePointerContainer);
        }, onMouseUp: function(R) {
          var Y = this.mousePointer;
          Y.up(R), Y.updateMotion(), this.activePointer = Y, this.updateInputPlugins(L.MOUSE_UP, this.mousePointerContainer);
        }, onMouseWheel: function(R) {
          var Y = this.mousePointer;
          Y.wheel(R), this.activePointer = Y, this.updateInputPlugins(L.MOUSE_WHEEL, this.mousePointerContainer);
        }, onPointerLockChange: function(R) {
          var Y = this.mouse.locked;
          this.mousePointer.locked = Y, this.events.emit(U.POINTERLOCK_CHANGE, R, Y);
        }, inputCandidate: function(R, Y) {
          var I = R.input;
          if (!I || !I.enabled || !R.willRender(Y))
            return false;
          var P = true, X = R.parentContainer;
          if (X)
            do {
              if (!X.willRender(Y)) {
                P = false;
                break;
              }
              X = X.parentContainer;
            } while (X);
          return P;
        }, hitTest: function(R, Y, I, P) {
          if (P === undefined)
            P = this._tempHitTest;
          var X = this._tempPoint, G = I.scrollX, V = I.scrollY;
          P.length = 0;
          var { x: A, y: F } = R;
          I.getWorldPoint(A, F, X), R.worldX = X.x, R.worldY = X.y;
          var j = { x: 0, y: 0 }, T = this._tempMatrix, C = this._tempMatrix2;
          for (var v = 0;v < Y.length; v++) {
            var O = Y[v];
            if (!this.inputCandidate(O, I))
              continue;
            var q = X.x + G * O.scrollFactorX - G, w = X.y + V * O.scrollFactorY - V;
            if (O.parentContainer)
              O.getWorldTransformMatrix(T, C), T.applyInverse(q, w, j);
            else
              N(q, w, O.x, O.y, O.rotation, O.scaleX, O.scaleY, j);
            if (this.pointWithinHitArea(O, j.x, j.y))
              P.push(O);
          }
          return P;
        }, pointWithinHitArea: function(R, Y, I) {
          Y += R.displayOriginX, I += R.displayOriginY;
          var P = R.input;
          if (P && P.hitAreaCallback(P.hitArea, Y, I, R))
            return P.localX = Y, P.localY = I, true;
          else
            return false;
        }, pointWithinInteractiveObject: function(R, Y, I) {
          if (!R.hitArea)
            return false;
          return Y += R.gameObject.displayOriginX, I += R.gameObject.displayOriginY, R.localX = Y, R.localY = I, R.hitAreaCallback(R.hitArea, Y, I, R);
        }, transformPointer: function(R, Y, I, P) {
          var { position: X, prevPosition: G } = R;
          G.x = X.x, G.y = X.y;
          var V = this.scaleManager.transformX(Y), A = this.scaleManager.transformY(I), F = R.smoothFactor;
          if (!P || F === 0)
            X.x = V, X.y = A;
          else
            X.x = V * F + G.x * (1 - F), X.y = A * F + G.y * (1 - F);
        }, destroy: function() {
          if (this.events.removeAllListeners(), this.game.events.off(K.PRE_RENDER), this.keyboard)
            this.keyboard.destroy();
          if (this.mouse)
            this.mouse.destroy();
          if (this.touch)
            this.touch.destroy();
          for (var R = 0;R < this.pointers.length; R++)
            this.pointers[R].destroy();
          this.pointers = [], this._tempHitTest = [], this._tempMatrix.destroy(), this.canvas = null, this.game = null;
        } });
        M.exports = W;
      }, 48205: (M, B, $) => {
        var E = $(96503), L = $(87902), z = $(83419), U = $(93301), K = $(74457), J = $(84409), Z = $(20339), D = $(8497), Q = $(81154), H = $(8214), N = $(50792), W = $(95540), R = $(23777), Y = $(89639), I = $(41212), P = $(37277), X = $(87841), G = $(37303), V = $(44594), A = $(16483), F = $(10690), j = new z({ Extends: N, initialize: function T(C) {
          N.call(this), this.scene = C, this.systems = C.sys, this.settings = C.sys.settings, this.manager = C.sys.game.input, this.pluginEvents = new N, this.enabled = true, this.displayList, this.cameras, Y.install(this), this.mouse = this.manager.mouse, this.topOnly = true, this.pollRate = -1, this._pollTimer = 0;
          var v = { cancelled: false };
          this._eventContainer = { stopPropagation: function() {
            v.cancelled = true;
          } }, this._eventData = v, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this._temp = [], this._tempZones = [], this._list = [], this._pendingInsertion = [], this._pendingRemoval = [], this._draggable = [], this._drag = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] }, this._dragState = [], this._over = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] }, this._validTypes = ["onDown", "onUp", "onOver", "onOut", "onMove", "onDragStart", "onDrag", "onDragEnd", "onDragEnter", "onDragLeave", "onDragOver", "onDrop"], this._updatedThisFrame = false, C.sys.events.once(V.BOOT, this.boot, this), C.sys.events.on(V.START, this.start, this);
        }, boot: function() {
          this.cameras = this.systems.cameras, this.displayList = this.systems.displayList, this.systems.events.once(V.DESTROY, this.destroy, this), this.pluginEvents.emit(H.BOOT);
        }, start: function() {
          var T = this.systems.events;
          T.on(V.TRANSITION_START, this.transitionIn, this), T.on(V.TRANSITION_OUT, this.transitionOut, this), T.on(V.TRANSITION_COMPLETE, this.transitionComplete, this), T.on(V.PRE_UPDATE, this.preUpdate, this), T.once(V.SHUTDOWN, this.shutdown, this), this.manager.events.on(H.GAME_OUT, this.onGameOut, this), this.manager.events.on(H.GAME_OVER, this.onGameOver, this), this.enabled = true, this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.pluginEvents.emit(H.START);
        }, onGameOver: function(T) {
          if (this.isActive())
            this.emit(H.GAME_OVER, T.timeStamp, T);
        }, onGameOut: function(T) {
          if (this.isActive())
            this.emit(H.GAME_OUT, T.timeStamp, T);
        }, preUpdate: function() {
          this.pluginEvents.emit(H.PRE_UPDATE);
          var T = this._pendingRemoval, C = this._pendingInsertion, v = T.length, O = C.length;
          if (v === 0 && O === 0)
            return;
          var q = this._list;
          for (var w = 0;w < v; w++) {
            var g = T[w], b = q.indexOf(g);
            if (b > -1)
              q.splice(b, 1), this.clear(g, true);
          }
          this._pendingRemoval.length = 0, this._list = q.concat(C.splice(0));
        }, isActive: function() {
          return this.enabled && this.scene.sys.canInput();
        }, updatePoll: function(T, C) {
          if (!this.isActive())
            return false;
          if (this.pluginEvents.emit(H.UPDATE, T, C), this._updatedThisFrame)
            return this._updatedThisFrame = false, false;
          var v, O = this.manager, q = O.pointers, w = O.pointersTotal;
          for (v = 0;v < w; v++)
            q[v].updateMotion();
          if (this._list.length === 0)
            return false;
          var g = this.pollRate;
          if (g === -1)
            return false;
          else if (g > 0)
            if (this._pollTimer -= C, this._pollTimer < 0)
              this._pollTimer = this.pollRate;
            else
              return false;
          var b = false;
          for (v = 0;v < w; v++) {
            var x = 0, k = q[v];
            if (this._tempZones = [], this._temp = this.hitTestPointer(k), this.sortGameObjects(this._temp, k), this.sortDropZones(this._tempZones), this.topOnly) {
              if (this._temp.length)
                this._temp.splice(1);
              if (this._tempZones.length)
                this._tempZones.splice(1);
            }
            if (x += this.processOverOutEvents(k), this.getDragState(k) === 2)
              this.processDragThresholdEvent(k, T);
            if (x > 0)
              b = true;
          }
          return b;
        }, update: function(T, C) {
          if (!this.isActive())
            return false;
          var v = C.length, O = false;
          for (var q = 0;q < v; q++) {
            var w = 0, g = C[q];
            if (this._tempZones = [], this._temp = this.hitTestPointer(g), this.sortGameObjects(this._temp, g), this.sortDropZones(this._tempZones), this.topOnly) {
              if (this._temp.length)
                this._temp.splice(1);
              if (this._tempZones.length)
                this._tempZones.splice(1);
            }
            switch (T) {
              case U.MOUSE_DOWN:
                w += this.processDragDownEvent(g), w += this.processDownEvents(g), w += this.processOverOutEvents(g);
                break;
              case U.MOUSE_UP:
                w += this.processDragUpEvent(g), w += this.processUpEvents(g), w += this.processOverOutEvents(g);
                break;
              case U.TOUCH_START:
                w += this.processDragDownEvent(g), w += this.processDownEvents(g), w += this.processOverEvents(g);
                break;
              case U.TOUCH_END:
              case U.TOUCH_CANCEL:
                w += this.processDragUpEvent(g), w += this.processUpEvents(g), w += this.processOutEvents(g);
                break;
              case U.MOUSE_MOVE:
              case U.TOUCH_MOVE:
                w += this.processDragMoveEvent(g), w += this.processMoveEvents(g), w += this.processOverOutEvents(g);
                break;
              case U.MOUSE_WHEEL:
                w += this.processWheelEvent(g);
                break;
            }
            if (w > 0)
              O = true;
          }
          return this._updatedThisFrame = true, O;
        }, clear: function(T, C) {
          if (C === undefined)
            C = false;
          this.disable(T);
          var v = T.input;
          if (v)
            this.removeDebug(T), this.manager.resetCursor(v), v.gameObject = undefined, v.target = undefined, v.hitArea = undefined, v.hitAreaCallback = undefined, v.callbackContext = undefined, T.input = null;
          if (!C)
            this.queueForRemoval(T);
          var O = this._draggable.indexOf(T);
          if (O > -1)
            this._draggable.splice(O, 1);
          return T;
        }, disable: function(T) {
          var C = T.input;
          if (C)
            C.enabled = false, C.dragState = 0;
          var v = this._drag, O = this._over, q = this.manager;
          for (var w = 0, g;w < q.pointersTotal; w++) {
            if (g = v[w].indexOf(T), g > -1)
              v[w].splice(g, 1);
            if (g = O[w].indexOf(T), g > -1)
              O[w].splice(g, 1);
          }
          return this;
        }, enable: function(T, C, v, O) {
          if (O === undefined)
            O = false;
          if (T.input)
            T.input.enabled = true;
          else
            this.setHitArea(T, C, v);
          if (T.input && O && !T.input.dropZone)
            T.input.dropZone = O;
          return this;
        }, hitTestPointer: function(T) {
          var C = this.cameras.getCamerasBelowPointer(T);
          for (var v = 0;v < C.length; v++) {
            var O = C[v], q = this.manager.hitTest(T, this._list, O);
            for (var w = 0;w < q.length; w++) {
              var g = q[w];
              if (g.input.dropZone)
                this._tempZones.push(g);
            }
            if (q.length > 0)
              return T.camera = O, q;
          }
          return T.camera = C[0], [];
        }, processDownEvents: function(T) {
          var C = 0, v = this._temp, O = this._eventData, q = this._eventContainer;
          O.cancelled = false;
          var w = false;
          for (var g = 0;g < v.length; g++) {
            var b = v[g];
            if (!b.input || !b.input.enabled)
              continue;
            if (C++, b.emit(H.GAMEOBJECT_POINTER_DOWN, T, b.input.localX, b.input.localY, q), O.cancelled || !b.input || !b.input.enabled) {
              w = true;
              break;
            }
            if (this.emit(H.GAMEOBJECT_DOWN, T, b, q), O.cancelled || !b.input) {
              w = true;
              break;
            }
          }
          if (!w && this.manager)
            if (T.downElement === this.manager.game.canvas)
              this.emit(H.POINTER_DOWN, T, v);
            else
              this.emit(H.POINTER_DOWN_OUTSIDE, T);
          return C;
        }, getDragState: function(T) {
          return this._dragState[T.id];
        }, setDragState: function(T, C) {
          this._dragState[T.id] = C;
        }, processDragThresholdEvent: function(T, C) {
          var v = false, O = this.dragTimeThreshold, q = this.dragDistanceThreshold;
          if (q > 0 && Z(T.x, T.y, T.downX, T.downY) >= q)
            v = true;
          else if (O > 0 && C >= T.downTime + O)
            v = true;
          if (v)
            return this.setDragState(T, 3), this.processDragStartList(T);
        }, processDragStartList: function(T) {
          if (this.getDragState(T) !== 3)
            return 0;
          var C = this._drag[T.id];
          for (var v = 0;v < C.length; v++) {
            var O = C[v], q = O.input;
            q.dragState = 2, q.dragStartX = O.x, q.dragStartY = O.y, q.dragStartXGlobal = T.worldX, q.dragStartYGlobal = T.worldY, q.dragX = q.dragStartXGlobal - q.dragStartX, q.dragY = q.dragStartYGlobal - q.dragStartY, O.emit(H.GAMEOBJECT_DRAG_START, T, q.dragX, q.dragY), this.emit(H.DRAG_START, T, O);
          }
          return this.setDragState(T, 4), C.length;
        }, processDragDownEvent: function(T) {
          var C = this._temp;
          if (this._draggable.length === 0 || C.length === 0 || !T.primaryDown || this.getDragState(T) !== 0)
            return 0;
          this.setDragState(T, 1);
          var v = [];
          for (var O = 0;O < C.length; O++) {
            var q = C[O];
            if (q.input.draggable && q.input.dragState === 0)
              v.push(q);
          }
          if (v.length === 0)
            return this.setDragState(T, 0), 0;
          else if (v.length > 1) {
            if (this.sortGameObjects(v, T), this.topOnly)
              v.splice(1);
          }
          if (this._drag[T.id] = v, this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0)
            return this.setDragState(T, 3), this.processDragStartList(T);
          else
            return this.setDragState(T, 2), 0;
        }, processDragMoveEvent: function(T) {
          if (this.getDragState(T) === 2)
            this.processDragThresholdEvent(T, this.manager.game.loop.now);
          if (this.getDragState(T) !== 4)
            return 0;
          var C = this._tempZones, v = this._drag[T.id];
          for (var O = 0;O < v.length; O++) {
            var q = v[O], w = q.input, g = w.target;
            if (g) {
              var b = C.indexOf(g);
              if (b === 0)
                q.emit(H.GAMEOBJECT_DRAG_OVER, T, g), this.emit(H.DRAG_OVER, T, q, g);
              else if (b > 0)
                q.emit(H.GAMEOBJECT_DRAG_LEAVE, T, g), this.emit(H.DRAG_LEAVE, T, q, g), w.target = C[0], g = w.target, q.emit(H.GAMEOBJECT_DRAG_ENTER, T, g), this.emit(H.DRAG_ENTER, T, q, g);
              else if (q.emit(H.GAMEOBJECT_DRAG_LEAVE, T, g), this.emit(H.DRAG_LEAVE, T, q, g), C[0])
                w.target = C[0], g = w.target, q.emit(H.GAMEOBJECT_DRAG_ENTER, T, g), this.emit(H.DRAG_ENTER, T, q, g);
              else
                w.target = null;
            } else if (!g && C[0])
              w.target = C[0], g = w.target, q.emit(H.GAMEOBJECT_DRAG_ENTER, T, g), this.emit(H.DRAG_ENTER, T, q, g);
            var x, k;
            if (!q.parentContainer)
              x = T.worldX - w.dragX, k = T.worldY - w.dragY;
            else {
              var S = T.worldX - w.dragStartXGlobal, f = T.worldY - w.dragStartYGlobal, h = q.getParentRotation(), m = S * Math.cos(h) + f * Math.sin(h), y = f * Math.cos(h) - S * Math.sin(h);
              m *= 1 / q.parentContainer.scaleX, y *= 1 / q.parentContainer.scaleY, x = m + w.dragStartX, k = y + w.dragStartY;
            }
            q.emit(H.GAMEOBJECT_DRAG, T, x, k), this.emit(H.DRAG, T, q, x, k);
          }
          return v.length;
        }, processDragUpEvent: function(T) {
          var C = this._drag[T.id];
          for (var v = 0;v < C.length; v++) {
            var O = C[v], q = O.input;
            if (q && q.dragState === 2) {
              q.dragState = 0, q.dragX = q.localX - O.displayOriginX, q.dragY = q.localY - O.displayOriginY;
              var w = false, g = q.target;
              if (g)
                O.emit(H.GAMEOBJECT_DROP, T, g), this.emit(H.DROP, T, O, g), q.target = null, w = true;
              if (O.input && O.input.enabled)
                O.emit(H.GAMEOBJECT_DRAG_END, T, q.dragX, q.dragY, w), this.emit(H.DRAG_END, T, O, w);
            }
          }
          return this.setDragState(T, 0), C.splice(0), 0;
        }, processMoveEvents: function(T) {
          var C = 0, v = this._temp, O = this._eventData, q = this._eventContainer;
          O.cancelled = false;
          var w = false;
          for (var g = 0;g < v.length; g++) {
            var b = v[g];
            if (!b.input || !b.input.enabled)
              continue;
            if (C++, b.emit(H.GAMEOBJECT_POINTER_MOVE, T, b.input.localX, b.input.localY, q), O.cancelled || !b.input || !b.input.enabled) {
              w = true;
              break;
            }
            if (this.emit(H.GAMEOBJECT_MOVE, T, b, q), O.cancelled || !b.input || !b.input.enabled) {
              w = true;
              break;
            }
            if (this.topOnly)
              break;
          }
          if (!w)
            this.emit(H.POINTER_MOVE, T, v);
          return C;
        }, processWheelEvent: function(T) {
          var C = 0, v = this._temp, O = this._eventData, q = this._eventContainer;
          O.cancelled = false;
          var w = false, g = T.deltaX, b = T.deltaY, x = T.deltaZ;
          for (var k = 0;k < v.length; k++) {
            var S = v[k];
            if (!S.input || !S.input.enabled)
              continue;
            if (C++, S.emit(H.GAMEOBJECT_POINTER_WHEEL, T, g, b, x, q), O.cancelled || !S.input || !S.input.enabled) {
              w = true;
              break;
            }
            if (this.emit(H.GAMEOBJECT_WHEEL, T, S, g, b, x, q), O.cancelled || !S.input || !S.input.enabled) {
              w = true;
              break;
            }
          }
          if (!w)
            this.emit(H.POINTER_WHEEL, T, v, g, b, x);
          return C;
        }, processOverEvents: function(T) {
          var C = this._temp, v = 0, O = C.length, q = [];
          if (O > 0) {
            var w = this.manager, g = this._eventData, b = this._eventContainer;
            g.cancelled = false;
            var x = false;
            for (var k = 0;k < O; k++) {
              var S = C[k];
              if (!S.input || !S.input.enabled)
                continue;
              if (q.push(S), w.setCursor(S.input), S.emit(H.GAMEOBJECT_POINTER_OVER, T, S.input.localX, S.input.localY, b), v++, g.cancelled || !S.input || !S.input.enabled) {
                x = true;
                break;
              }
              if (this.emit(H.GAMEOBJECT_OVER, T, S, b), g.cancelled || !S.input || !S.input.enabled) {
                x = true;
                break;
              }
            }
            if (!x)
              this.emit(H.POINTER_OVER, T, q);
          }
          return this._over[T.id] = q, v;
        }, processOutEvents: function(T) {
          var C = this._over[T.id], v = 0, O = C.length;
          if (O > 0) {
            var q = this.manager, w = this._eventData, g = this._eventContainer;
            w.cancelled = false;
            var b = false;
            this.sortGameObjects(C, T);
            for (var x = 0;x < O; x++) {
              var k = C[x];
              if (k = C[x], !k.input || !k.input.enabled)
                continue;
              if (q.resetCursor(k.input), k.emit(H.GAMEOBJECT_POINTER_OUT, T, g), v++, w.cancelled || !k.input || !k.input.enabled) {
                b = true;
                break;
              }
              if (this.emit(H.GAMEOBJECT_OUT, T, k, g), w.cancelled || !k.input || !k.input.enabled) {
                b = true;
                break;
              }
              if (!b)
                this.emit(H.POINTER_OUT, T, C);
            }
            this._over[T.id] = [];
          }
          return v;
        }, processOverOutEvents: function(T) {
          var C = this._temp, v, O, q = [], w = [], g = [], b = this._over[T.id], x = this._drag[T.id], k = this.manager;
          for (v = 0;v < b.length; v++)
            if (O = b[v], C.indexOf(O) === -1 && x.indexOf(O) === -1)
              q.push(O);
            else
              g.push(O);
          for (v = 0;v < C.length; v++)
            if (O = C[v], b.indexOf(O) === -1)
              w.push(O);
          var S = q.length, f = 0, h = this._eventData, m = this._eventContainer;
          h.cancelled = false;
          var y = false;
          if (S > 0) {
            this.sortGameObjects(q, T);
            for (v = 0;v < S; v++) {
              if (O = q[v], !O.input || !O.input.enabled)
                continue;
              if (k.resetCursor(O.input), O.emit(H.GAMEOBJECT_POINTER_OUT, T, m), f++, h.cancelled || !O.input || !O.input.enabled) {
                y = true;
                break;
              }
              if (this.emit(H.GAMEOBJECT_OUT, T, O, m), h.cancelled || !O.input || !O.input.enabled) {
                y = true;
                break;
              }
            }
            if (!y)
              this.emit(H.POINTER_OUT, T, q);
          }
          if (S = w.length, h.cancelled = false, y = false, S > 0) {
            this.sortGameObjects(w, T);
            for (v = 0;v < S; v++) {
              if (O = w[v], !O.input || !O.input.enabled)
                continue;
              if (k.setCursor(O.input), O.emit(H.GAMEOBJECT_POINTER_OVER, T, O.input.localX, O.input.localY, m), f++, h.cancelled || !O.input || !O.input.enabled) {
                y = true;
                break;
              }
              if (this.emit(H.GAMEOBJECT_OVER, T, O, m), h.cancelled || !O.input || !O.input.enabled) {
                y = true;
                break;
              }
            }
            if (!y)
              this.emit(H.POINTER_OVER, T, w);
          }
          return b = g.concat(w), this._over[T.id] = this.sortGameObjects(b, T), f;
        }, processUpEvents: function(T) {
          var C = this._temp, v = this._eventData, O = this._eventContainer;
          v.cancelled = false;
          var q = false;
          for (var w = 0;w < C.length; w++) {
            var g = C[w];
            if (!g.input || !g.input.enabled)
              continue;
            if (g.emit(H.GAMEOBJECT_POINTER_UP, T, g.input.localX, g.input.localY, O), v.cancelled || !g.input || !g.input.enabled) {
              q = true;
              break;
            }
            if (this.emit(H.GAMEOBJECT_UP, T, g, O), v.cancelled || !g.input || !g.input.enabled) {
              q = true;
              break;
            }
          }
          if (!q && this.manager)
            if (T.upElement === this.manager.game.canvas)
              this.emit(H.POINTER_UP, T, C);
            else
              this.emit(H.POINTER_UP_OUTSIDE, T);
          return C.length;
        }, queueForInsertion: function(T) {
          if (this._pendingInsertion.indexOf(T) === -1 && this._list.indexOf(T) === -1)
            this._pendingInsertion.push(T);
          return this;
        }, queueForRemoval: function(T) {
          return this._pendingRemoval.push(T), this;
        }, setDraggable: function(T, C) {
          if (C === undefined)
            C = true;
          if (!Array.isArray(T))
            T = [T];
          for (var v = 0;v < T.length; v++) {
            var O = T[v];
            O.input.draggable = C;
            var q = this._draggable.indexOf(O);
            if (C && q === -1)
              this._draggable.push(O);
            else if (!C && q > -1)
              this._draggable.splice(q, 1);
          }
          return this;
        }, makePixelPerfect: function(T) {
          if (T === undefined)
            T = 1;
          var C = this.systems.textures;
          return J(C, T);
        }, setHitArea: function(T, C, v) {
          if (C === undefined)
            return this.setHitAreaFromTexture(T);
          if (!Array.isArray(T))
            T = [T];
          var O = false, q = false, w = false, g = false, b = false, x = true;
          if (I(C) && Object.keys(C).length) {
            var k = C, S = T.some(function(d) {
              return d.hasOwnProperty("faces");
            });
            if (!S) {
              C = W(k, "hitArea", null), v = W(k, "hitAreaCallback", null), b = W(k, "pixelPerfect", false);
              var f = W(k, "alphaTolerance", 1);
              if (b)
                C = {}, v = this.makePixelPerfect(f);
            }
            if (O = W(k, "draggable", false), q = W(k, "dropZone", false), w = W(k, "cursor", false), g = W(k, "useHandCursor", false), !C || !v)
              this.setHitAreaFromTexture(T), x = false;
          } else if (typeof C === "function" && !v)
            v = C, C = {};
          for (var h = 0;h < T.length; h++) {
            var m = T[h];
            if (b && m.type === "Container") {
              console.warn("Cannot pixelPerfect test a Container. Use a custom callback.");
              continue;
            }
            var y = !m.input ? K(m, C, v) : m.input;
            if (y.customHitArea = x, y.dropZone = q, y.cursor = g ? "pointer" : w, m.input = y, O)
              this.setDraggable(m);
            this.queueForInsertion(m);
          }
          return this;
        }, setHitAreaCircle: function(T, C, v, O, q) {
          if (q === undefined)
            q = L;
          var w = new E(C, v, O);
          return this.setHitArea(T, w, q);
        }, setHitAreaEllipse: function(T, C, v, O, q, w) {
          if (w === undefined)
            w = Q;
          var g = new D(C, v, O, q);
          return this.setHitArea(T, g, w);
        }, setHitAreaFromTexture: function(T, C) {
          if (C === undefined)
            C = G;
          if (!Array.isArray(T))
            T = [T];
          for (var v = 0;v < T.length; v++) {
            var O = T[v], q = O.frame, w = 0, g = 0;
            if (O.width)
              w = O.width, g = O.height;
            else if (q)
              w = q.realWidth, g = q.realHeight;
            if (O.type === "Container" && (w === 0 || g === 0)) {
              console.warn("Container.setInteractive must specify a Shape or call setSize() first");
              continue;
            }
            if (w !== 0 && g !== 0)
              O.input = K(O, new X(0, 0, w, g), C), this.queueForInsertion(O);
          }
          return this;
        }, setHitAreaRectangle: function(T, C, v, O, q, w) {
          if (w === undefined)
            w = G;
          var g = new X(C, v, O, q);
          return this.setHitArea(T, g, w);
        }, setHitAreaTriangle: function(T, C, v, O, q, w, g, b) {
          if (b === undefined)
            b = F;
          var x = new A(C, v, O, q, w, g);
          return this.setHitArea(T, x, b);
        }, enableDebug: function(T, C) {
          if (C === undefined)
            C = 65280;
          var v = T.input;
          if (!v || !v.hitArea)
            return this;
          var O = v.hitArea, q = O.type, w = v.hitAreaDebug, g = this.systems.add, b = this.systems.updateList;
          if (w)
            b.remove(w), w.destroy(), w = null;
          var x = 0, k = 0;
          switch (q) {
            case R.CIRCLE:
              w = g.arc(0, 0, O.radius), x = O.x - O.radius, k = O.y - O.radius;
              break;
            case R.ELLIPSE:
              w = g.ellipse(0, 0, O.width, O.height), x = O.x - O.width / 2, k = O.y - O.height / 2;
              break;
            case R.LINE:
              w = g.line(0, 0, O.x1, O.y1, O.x2, O.y2);
              break;
            case R.POLYGON:
              w = g.polygon(0, 0, O.points);
              break;
            case R.RECTANGLE:
              w = g.rectangle(0, 0, O.width, O.height), x = O.x, k = O.y;
              break;
            case R.TRIANGLE:
              w = g.triangle(0, 0, O.x1, O.y1, O.x2, O.y2, O.x3, O.y3);
              break;
          }
          if (w)
            w.isFilled = false, w.strokeColor = C, w.preUpdate = function() {
              w.setVisible(T.visible), w.setStrokeStyle(1 / T.scale, w.strokeColor), w.setDisplayOrigin(T.displayOriginX, T.displayOriginY);
              var { x: S, y: f, rotation: h, scaleX: m, scaleY: y } = T;
              if (T.parentContainer) {
                var d = T.getWorldTransformMatrix();
                S = d.tx, f = d.ty, h = d.rotation, m = d.scaleX, y = d.scaleY;
              }
              w.setRotation(h), w.setScale(m, y), w.setPosition(S + x * m, f + k * y), w.setScrollFactor(T.scrollFactorX, T.scrollFactorY), w.setDepth(T.depth);
            }, b.add(w), v.hitAreaDebug = w;
          return this;
        }, removeDebug: function(T) {
          var C = T.input;
          if (C && C.hitAreaDebug) {
            var v = C.hitAreaDebug;
            v.destroy(), C.hitAreaDebug = null;
          }
          return this;
        }, setPollAlways: function() {
          return this.setPollRate(0);
        }, setPollOnMove: function() {
          return this.setPollRate(-1);
        }, setPollRate: function(T) {
          return this.pollRate = T, this._pollTimer = 0, this;
        }, setGlobalTopOnly: function(T) {
          return this.manager.globalTopOnly = T, this;
        }, setTopOnly: function(T) {
          return this.topOnly = T, this;
        }, sortGameObjects: function(T, C) {
          if (T.length < 2 || !C.camera)
            return T;
          var v = C.camera.renderList;
          return T.sort(function(O, q) {
            var w = Math.max(v.indexOf(O), 0), g = Math.max(v.indexOf(q), 0);
            return g - w;
          });
        }, sortDropZones: function(T) {
          if (T.length < 2)
            return T;
          return this.scene.sys.depthSort(), T.sort(this.sortDropZoneHandler.bind(this));
        }, sortDropZoneHandler: function(T, C) {
          if (!T.parentContainer && !C.parentContainer)
            return this.displayList.getIndex(C) - this.displayList.getIndex(T);
          else if (T.parentContainer === C.parentContainer)
            return C.parentContainer.getIndex(C) - T.parentContainer.getIndex(T);
          else if (T.parentContainer === C)
            return -1;
          else if (C.parentContainer === T)
            return 1;
          else {
            var v = T.getIndexList(), O = C.getIndexList(), q = Math.min(v.length, O.length);
            for (var w = 0;w < q; w++) {
              var g = v[w], b = O[w];
              if (g === b)
                continue;
              else
                return b - g;
            }
            return O.length - v.length;
          }
          return 0;
        }, stopPropagation: function() {
          return this.manager._tempSkip = true, this;
        }, addPointer: function(T) {
          return this.manager.addPointer(T);
        }, setDefaultCursor: function(T) {
          return this.manager.setDefaultCursor(T), this;
        }, transitionIn: function() {
          this.enabled = this.settings.transitionAllowInput;
        }, transitionComplete: function() {
          if (!this.settings.transitionAllowInput)
            this.enabled = true;
        }, transitionOut: function() {
          this.enabled = this.settings.transitionAllowInput;
        }, shutdown: function() {
          this.pluginEvents.emit(H.SHUTDOWN), this._temp.length = 0, this._list.length = 0, this._draggable.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0, this._dragState.length = 0;
          for (var T = 0;T < 10; T++)
            this._drag[T] = [], this._over[T] = [];
          this.removeAllListeners();
          var C = this.manager;
          C.canvas.style.cursor = C.defaultCursor;
          var v = this.systems.events;
          v.off(V.TRANSITION_START, this.transitionIn, this), v.off(V.TRANSITION_OUT, this.transitionOut, this), v.off(V.TRANSITION_COMPLETE, this.transitionComplete, this), v.off(V.PRE_UPDATE, this.preUpdate, this), C.events.off(H.GAME_OUT, this.onGameOut, this), C.events.off(H.GAME_OVER, this.onGameOver, this), v.off(V.SHUTDOWN, this.shutdown, this);
        }, resetPointers: function() {
          var T = this.manager.pointers;
          for (var C = 0;C < T.length; C++)
            T[C].reset();
        }, destroy: function() {
          this.shutdown(), this.pluginEvents.emit(H.DESTROY), this.pluginEvents.removeAllListeners(), this.scene.sys.events.off(V.START, this.start, this), this.scene = null, this.cameras = null, this.manager = null, this.events = null, this.mouse = null;
        }, x: { get: function() {
          return this.manager.activePointer.x;
        } }, y: { get: function() {
          return this.manager.activePointer.y;
        } }, isOver: { get: function() {
          return this.manager.isOver;
        } }, mousePointer: { get: function() {
          return this.manager.mousePointer;
        } }, activePointer: { get: function() {
          return this.manager.activePointer;
        } }, pointer1: { get: function() {
          return this.manager.pointers[1];
        } }, pointer2: { get: function() {
          return this.manager.pointers[2];
        } }, pointer3: { get: function() {
          return this.manager.pointers[3];
        } }, pointer4: { get: function() {
          return this.manager.pointers[4];
        } }, pointer5: { get: function() {
          return this.manager.pointers[5];
        } }, pointer6: { get: function() {
          return this.manager.pointers[6];
        } }, pointer7: { get: function() {
          return this.manager.pointers[7];
        } }, pointer8: { get: function() {
          return this.manager.pointers[8];
        } }, pointer9: { get: function() {
          return this.manager.pointers[9];
        } }, pointer10: { get: function() {
          return this.manager.pointers[10];
        } } });
        P.register("InputPlugin", j, "input"), M.exports = j;
      }, 89639: (M, B, $) => {
        var E = $(35154), L = {}, z = {};
        z.register = function(U, K, J, Z, D) {
          L[U] = { plugin: K, mapping: J, settingsKey: Z, configKey: D };
        }, z.getPlugin = function(U) {
          return L[U];
        }, z.install = function(U) {
          var K = U.scene.sys, J = K.settings.input, Z = K.game.config;
          for (var D in L) {
            var Q = L[D].plugin, H = L[D].mapping, N = L[D].settingsKey, W = L[D].configKey;
            if (E(J, N, Z[W]))
              U[H] = new Q(U);
          }
        }, z.remove = function(U) {
          if (L.hasOwnProperty(U))
            delete L[U];
        }, M.exports = z;
      }, 42515: (M, B, $) => {
        var E = $(31040), L = $(83419), z = $(20339), U = $(43855), K = $(47235), J = $(26099), Z = $(25892), D = new L({ initialize: function Q(H, N) {
          this.manager = H, this.id = N, this.event, this.downElement, this.upElement, this.camera = null, this.button = 0, this.buttons = 0, this.position = new J, this.prevPosition = new J, this.midPoint = new J(-1, -1), this.velocity = new J, this.angle = 0, this.distance = 0, this.smoothFactor = 0, this.motionFactor = 0.2, this.worldX = 0, this.worldY = 0, this.moveTime = 0, this.downX = 0, this.downY = 0, this.downTime = 0, this.upX = 0, this.upY = 0, this.upTime = 0, this.primaryDown = false, this.isDown = false, this.wasTouch = false, this.wasCanceled = false, this.movementX = 0, this.movementY = 0, this.identifier = 0, this.pointerId = null, this.active = N === 0 ? true : false, this.locked = false, this.deltaX = 0, this.deltaY = 0, this.deltaZ = 0;
        }, updateWorldPoint: function(Q) {
          var H = Q.getWorldPoint(this.x, this.y);
          return this.worldX = H.x, this.worldY = H.y, this;
        }, positionToCamera: function(Q, H) {
          return Q.getWorldPoint(this.x, this.y, H);
        }, updateMotion: function() {
          var Q = this.position.x, H = this.position.y, N = this.midPoint.x, W = this.midPoint.y;
          if (Q === N && H === W)
            return;
          var R = K(this.motionFactor, N, Q), Y = K(this.motionFactor, W, H);
          if (U(R, Q, 0.1))
            R = Q;
          if (U(Y, H, 0.1))
            Y = H;
          this.midPoint.set(R, Y);
          var I = Q - R, P = H - Y;
          this.velocity.set(I, P), this.angle = E(R, Y, Q, H), this.distance = Math.sqrt(I * I + P * P);
        }, up: function(Q) {
          if ("buttons" in Q)
            this.buttons = Q.buttons;
          if (this.event = Q, this.button = Q.button, this.upElement = Q.target, this.manager.transformPointer(this, Q.pageX, Q.pageY, false), Q.button === 0)
            this.primaryDown = false, this.upX = this.x, this.upY = this.y;
          if (this.buttons === 0)
            this.isDown = false, this.upTime = Q.timeStamp, this.wasTouch = false;
        }, down: function(Q) {
          if ("buttons" in Q)
            this.buttons = Q.buttons;
          if (this.event = Q, this.button = Q.button, this.downElement = Q.target, this.manager.transformPointer(this, Q.pageX, Q.pageY, false), Q.button === 0)
            this.primaryDown = true, this.downX = this.x, this.downY = this.y;
          if (Z.macOS && Q.ctrlKey)
            this.buttons = 2, this.primaryDown = false;
          if (!this.isDown)
            this.isDown = true, this.downTime = Q.timeStamp;
          this.wasTouch = false;
        }, move: function(Q) {
          if ("buttons" in Q)
            this.buttons = Q.buttons;
          if (this.event = Q, this.manager.transformPointer(this, Q.pageX, Q.pageY, true), this.locked)
            this.movementX = Q.movementX || Q.mozMovementX || Q.webkitMovementX || 0, this.movementY = Q.movementY || Q.mozMovementY || Q.webkitMovementY || 0;
          this.moveTime = Q.timeStamp, this.wasTouch = false;
        }, wheel: function(Q) {
          if ("buttons" in Q)
            this.buttons = Q.buttons;
          this.event = Q, this.manager.transformPointer(this, Q.pageX, Q.pageY, false), this.deltaX = Q.deltaX, this.deltaY = Q.deltaY, this.deltaZ = Q.deltaZ, this.wasTouch = false;
        }, touchstart: function(Q, H) {
          if (Q.pointerId)
            this.pointerId = Q.pointerId;
          this.identifier = Q.identifier, this.target = Q.target, this.active = true, this.buttons = 1, this.event = H, this.downElement = Q.target, this.manager.transformPointer(this, Q.pageX, Q.pageY, false), this.primaryDown = true, this.downX = this.x, this.downY = this.y, this.downTime = H.timeStamp, this.isDown = true, this.wasTouch = true, this.wasCanceled = false, this.updateMotion();
        }, touchmove: function(Q, H) {
          this.event = H, this.manager.transformPointer(this, Q.pageX, Q.pageY, true), this.moveTime = H.timeStamp, this.wasTouch = true, this.updateMotion();
        }, touchend: function(Q, H) {
          this.buttons = 0, this.event = H, this.upElement = Q.target, this.manager.transformPointer(this, Q.pageX, Q.pageY, false), this.primaryDown = false, this.upX = this.x, this.upY = this.y, this.upTime = H.timeStamp, this.isDown = false, this.wasTouch = true, this.wasCanceled = false, this.active = false, this.updateMotion();
        }, touchcancel: function(Q, H) {
          this.buttons = 0, this.event = H, this.upElement = Q.target, this.manager.transformPointer(this, Q.pageX, Q.pageY, false), this.primaryDown = false, this.upX = this.x, this.upY = this.y, this.upTime = H.timeStamp, this.isDown = false, this.wasTouch = true, this.wasCanceled = true, this.active = false;
        }, noButtonDown: function() {
          return this.buttons === 0;
        }, leftButtonDown: function() {
          return this.buttons & 1 ? true : false;
        }, rightButtonDown: function() {
          return this.buttons & 2 ? true : false;
        }, middleButtonDown: function() {
          return this.buttons & 4 ? true : false;
        }, backButtonDown: function() {
          return this.buttons & 8 ? true : false;
        }, forwardButtonDown: function() {
          return this.buttons & 16 ? true : false;
        }, leftButtonReleased: function() {
          return this.button === 0 && !this.isDown;
        }, rightButtonReleased: function() {
          return this.button === 2 && !this.isDown;
        }, middleButtonReleased: function() {
          return this.button === 1 && !this.isDown;
        }, backButtonReleased: function() {
          return this.button === 3 && !this.isDown;
        }, forwardButtonReleased: function() {
          return this.button === 4 && !this.isDown;
        }, getDistance: function() {
          if (this.isDown)
            return z(this.downX, this.downY, this.x, this.y);
          else
            return z(this.downX, this.downY, this.upX, this.upY);
        }, getDistanceX: function() {
          if (this.isDown)
            return Math.abs(this.downX - this.x);
          else
            return Math.abs(this.downX - this.upX);
        }, getDistanceY: function() {
          if (this.isDown)
            return Math.abs(this.downY - this.y);
          else
            return Math.abs(this.downY - this.upY);
        }, getDuration: function() {
          if (this.isDown)
            return this.manager.time - this.downTime;
          else
            return this.upTime - this.downTime;
        }, getAngle: function() {
          if (this.isDown)
            return E(this.downX, this.downY, this.x, this.y);
          else
            return E(this.downX, this.downY, this.upX, this.upY);
        }, getInterpolatedPosition: function(Q, H) {
          if (Q === undefined)
            Q = 10;
          if (H === undefined)
            H = [];
          var N = this.prevPosition.x, W = this.prevPosition.y, R = this.position.x, Y = this.position.y;
          for (var I = 0;I < Q; I++) {
            var P = 1 / Q * I;
            H[I] = { x: K(P, N, R), y: K(P, W, Y) };
          }
          return H;
        }, reset: function() {
          this.event = null, this.downElement = null, this.upElement = null, this.button = 0, this.buttons = 0, this.position.set(0, 0), this.prevPosition.set(0, 0), this.midPoint.set(-1, -1), this.velocity.set(0, 0), this.angle = 0, this.distance = 0, this.worldX = 0, this.worldY = 0, this.downX = 0, this.downY = 0, this.upX = 0, this.upY = 0, this.moveTime = 0, this.upTime = 0, this.downTime = 0, this.primaryDown = false, this.isDown = false, this.wasTouch = false, this.wasCanceled = false, this.movementX = 0, this.movementY = 0, this.identifier = 0, this.pointerId = null, this.deltaX = 0, this.deltaY = 0, this.deltaZ = 0, this.active = this.id === 0 ? true : false;
        }, destroy: function() {
          this.camera = null, this.manager = null, this.position = null;
        }, x: { get: function() {
          return this.position.x;
        }, set: function(Q) {
          this.position.x = Q;
        } }, y: { get: function() {
          return this.position.y;
        }, set: function(Q) {
          this.position.y = Q;
        } }, time: { get: function() {
          return this.event ? this.event.timeStamp : 0;
        } } });
        M.exports = D;
      }, 93301: (M) => {
        var B = { MOUSE_DOWN: 0, MOUSE_MOVE: 1, MOUSE_UP: 2, TOUCH_START: 3, TOUCH_MOVE: 4, TOUCH_END: 5, POINTER_LOCK_CHANGE: 6, TOUCH_CANCEL: 7, MOUSE_WHEEL: 8 };
        M.exports = B;
      }, 7179: (M) => {
        M.exports = "boot";
      }, 85375: (M) => {
        M.exports = "destroy";
      }, 39843: (M) => {
        M.exports = "dragend";
      }, 23388: (M) => {
        M.exports = "dragenter";
      }, 16133: (M) => {
        M.exports = "drag";
      }, 27829: (M) => {
        M.exports = "dragleave";
      }, 53904: (M) => {
        M.exports = "dragover";
      }, 56058: (M) => {
        M.exports = "dragstart";
      }, 2642: (M) => {
        M.exports = "drop";
      }, 88171: (M) => {
        M.exports = "gameobjectdown";
      }, 36147: (M) => {
        M.exports = "dragend";
      }, 71692: (M) => {
        M.exports = "dragenter";
      }, 96149: (M) => {
        M.exports = "drag";
      }, 81285: (M) => {
        M.exports = "dragleave";
      }, 74048: (M) => {
        M.exports = "dragover";
      }, 21322: (M) => {
        M.exports = "dragstart";
      }, 49378: (M) => {
        M.exports = "drop";
      }, 86754: (M) => {
        M.exports = "gameobjectmove";
      }, 86433: (M) => {
        M.exports = "gameobjectout";
      }, 60709: (M) => {
        M.exports = "gameobjectover";
      }, 24081: (M) => {
        M.exports = "pointerdown";
      }, 11172: (M) => {
        M.exports = "pointermove";
      }, 18907: (M) => {
        M.exports = "pointerout";
      }, 95579: (M) => {
        M.exports = "pointerover";
      }, 35368: (M) => {
        M.exports = "pointerup";
      }, 26972: (M) => {
        M.exports = "wheel";
      }, 47078: (M) => {
        M.exports = "gameobjectup";
      }, 73802: (M) => {
        M.exports = "gameobjectwheel";
      }, 56718: (M) => {
        M.exports = "gameout";
      }, 25936: (M) => {
        M.exports = "gameover";
      }, 27503: (M) => {
        M.exports = "boot";
      }, 50852: (M) => {
        M.exports = "process";
      }, 96438: (M) => {
        M.exports = "update";
      }, 59152: (M) => {
        M.exports = "pointerlockchange";
      }, 47777: (M) => {
        M.exports = "pointerdown";
      }, 27957: (M) => {
        M.exports = "pointerdownoutside";
      }, 19444: (M) => {
        M.exports = "pointermove";
      }, 54251: (M) => {
        M.exports = "pointerout";
      }, 18667: (M) => {
        M.exports = "pointerover";
      }, 27192: (M) => {
        M.exports = "pointerup";
      }, 24652: (M) => {
        M.exports = "pointerupoutside";
      }, 45132: (M) => {
        M.exports = "wheel";
      }, 44512: (M) => {
        M.exports = "preupdate";
      }, 15757: (M) => {
        M.exports = "shutdown";
      }, 41637: (M) => {
        M.exports = "start";
      }, 93802: (M) => {
        M.exports = "update";
      }, 8214: (M, B, $) => {
        M.exports = { BOOT: $(7179), DESTROY: $(85375), DRAG_END: $(39843), DRAG_ENTER: $(23388), DRAG: $(16133), DRAG_LEAVE: $(27829), DRAG_OVER: $(53904), DRAG_START: $(56058), DROP: $(2642), GAME_OUT: $(56718), GAME_OVER: $(25936), GAMEOBJECT_DOWN: $(88171), GAMEOBJECT_DRAG_END: $(36147), GAMEOBJECT_DRAG_ENTER: $(71692), GAMEOBJECT_DRAG: $(96149), GAMEOBJECT_DRAG_LEAVE: $(81285), GAMEOBJECT_DRAG_OVER: $(74048), GAMEOBJECT_DRAG_START: $(21322), GAMEOBJECT_DROP: $(49378), GAMEOBJECT_MOVE: $(86754), GAMEOBJECT_OUT: $(86433), GAMEOBJECT_OVER: $(60709), GAMEOBJECT_POINTER_DOWN: $(24081), GAMEOBJECT_POINTER_MOVE: $(11172), GAMEOBJECT_POINTER_OUT: $(18907), GAMEOBJECT_POINTER_OVER: $(95579), GAMEOBJECT_POINTER_UP: $(35368), GAMEOBJECT_POINTER_WHEEL: $(26972), GAMEOBJECT_UP: $(47078), GAMEOBJECT_WHEEL: $(73802), MANAGER_BOOT: $(27503), MANAGER_PROCESS: $(50852), MANAGER_UPDATE: $(96438), POINTER_DOWN: $(47777), POINTER_DOWN_OUTSIDE: $(27957), POINTER_MOVE: $(19444), POINTER_OUT: $(54251), POINTER_OVER: $(18667), POINTER_UP: $(27192), POINTER_UP_OUTSIDE: $(24652), POINTER_WHEEL: $(45132), POINTERLOCK_CHANGE: $(59152), PRE_UPDATE: $(44512), SHUTDOWN: $(15757), START: $(41637), UPDATE: $(93802) };
      }, 97421: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U, K) {
          this.pad = U, this.events = U.events, this.index = K, this.value = 0, this.threshold = 0.1;
        }, update: function(z) {
          this.value = z;
        }, getValue: function() {
          return Math.abs(this.value) < this.threshold ? 0 : this.value;
        }, destroy: function() {
          this.pad = null, this.events = null;
        } });
        M.exports = L;
      }, 28884: (M, B, $) => {
        var E = $(83419), L = $(92734), z = new E({ initialize: function U(K, J) {
          this.pad = K, this.events = K.manager, this.index = J, this.value = 0, this.threshold = 1, this.pressed = false;
        }, update: function(U) {
          this.value = U;
          var K = this.pad, J = this.index;
          if (U >= this.threshold) {
            if (!this.pressed)
              this.pressed = true, this.events.emit(L.BUTTON_DOWN, K, this, U), this.pad.emit(L.GAMEPAD_BUTTON_DOWN, J, U, this);
          } else if (this.pressed)
            this.pressed = false, this.events.emit(L.BUTTON_UP, K, this, U), this.pad.emit(L.GAMEPAD_BUTTON_UP, J, U, this);
        }, destroy: function() {
          this.pad = null, this.events = null;
        } });
        M.exports = z;
      }, 99125: (M, B, $) => {
        var E = $(97421), L = $(28884), z = $(83419), U = $(50792), K = $(26099), J = new z({ Extends: U, initialize: function Z(D, Q) {
          U.call(this), this.manager = D, this.pad = Q, this.id = Q.id, this.index = Q.index;
          var H = [];
          for (var N = 0;N < Q.buttons.length; N++)
            H.push(new L(this, N));
          this.buttons = H;
          var W = [];
          for (N = 0;N < Q.axes.length; N++)
            W.push(new E(this, N));
          this.axes = W, this.vibration = Q.vibrationActuator;
          var R = { value: 0, pressed: false };
          this._LCLeft = H[14] ? H[14] : R, this._LCRight = H[15] ? H[15] : R, this._LCTop = H[12] ? H[12] : R, this._LCBottom = H[13] ? H[13] : R, this._RCLeft = H[2] ? H[2] : R, this._RCRight = H[1] ? H[1] : R, this._RCTop = H[3] ? H[3] : R, this._RCBottom = H[0] ? H[0] : R, this._FBLeftTop = H[4] ? H[4] : R, this._FBLeftBottom = H[6] ? H[6] : R, this._FBRightTop = H[5] ? H[5] : R, this._FBRightBottom = H[7] ? H[7] : R;
          var Y = { value: 0 };
          this._HAxisLeft = W[0] ? W[0] : Y, this._VAxisLeft = W[1] ? W[1] : Y, this._HAxisRight = W[2] ? W[2] : Y, this._VAxisRight = W[3] ? W[3] : Y, this.leftStick = new K, this.rightStick = new K, this._created = performance.now();
        }, getAxisTotal: function() {
          return this.axes.length;
        }, getAxisValue: function(Z) {
          return this.axes[Z].getValue();
        }, setAxisThreshold: function(Z) {
          for (var D = 0;D < this.axes.length; D++)
            this.axes[D].threshold = Z;
        }, getButtonTotal: function() {
          return this.buttons.length;
        }, getButtonValue: function(Z) {
          return this.buttons[Z].value;
        }, isButtonDown: function(Z) {
          return this.buttons[Z].pressed;
        }, update: function(Z) {
          if (Z.timestamp < this._created)
            return;
          var D, Q = this.buttons, H = Z.buttons, N = Q.length;
          for (D = 0;D < N; D++)
            Q[D].update(H[D].value);
          var W = this.axes, R = Z.axes;
          N = W.length;
          for (D = 0;D < N; D++)
            W[D].update(R[D]);
          if (N >= 2) {
            if (this.leftStick.set(W[0].getValue(), W[1].getValue()), N >= 4)
              this.rightStick.set(W[2].getValue(), W[3].getValue());
          }
        }, destroy: function() {
          this.removeAllListeners(), this.manager = null, this.pad = null;
          var Z;
          for (Z = 0;Z < this.buttons.length; Z++)
            this.buttons[Z].destroy();
          for (Z = 0;Z < this.axes.length; Z++)
            this.axes[Z].destroy();
          this.buttons = [], this.axes = [];
        }, connected: { get: function() {
          return this.pad.connected;
        } }, timestamp: { get: function() {
          return this.pad.timestamp;
        } }, left: { get: function() {
          return this._LCLeft.pressed;
        } }, right: { get: function() {
          return this._LCRight.pressed;
        } }, up: { get: function() {
          return this._LCTop.pressed;
        } }, down: { get: function() {
          return this._LCBottom.pressed;
        } }, A: { get: function() {
          return this._RCBottom.pressed;
        } }, Y: { get: function() {
          return this._RCTop.pressed;
        } }, X: { get: function() {
          return this._RCLeft.pressed;
        } }, B: { get: function() {
          return this._RCRight.pressed;
        } }, L1: { get: function() {
          return this._FBLeftTop.value;
        } }, L2: { get: function() {
          return this._FBLeftBottom.value;
        } }, R1: { get: function() {
          return this._FBRightTop.value;
        } }, R2: { get: function() {
          return this._FBRightBottom.value;
        } } });
        M.exports = J;
      }, 56654: (M, B, $) => {
        var E = $(83419), L = $(50792), z = $(92734), U = $(99125), K = $(35154), J = $(89639), Z = $(8214), D = new E({ Extends: L, initialize: function Q(H) {
          L.call(this), this.scene = H.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin = H, this.enabled = true, this.target, this.gamepads = [], this.queue = [], this.onGamepadHandler, this._pad1, this._pad2, this._pad3, this._pad4, H.pluginEvents.once(Z.BOOT, this.boot, this), H.pluginEvents.on(Z.START, this.start, this);
        }, boot: function() {
          var Q = this.scene.sys.game, H = this.settings.input, N = Q.config;
          this.enabled = K(H, "gamepad", N.inputGamepad) && Q.device.input.gamepads, this.target = K(H, "gamepad.target", N.inputGamepadEventTarget), this.sceneInputPlugin.pluginEvents.once(Z.DESTROY, this.destroy, this);
        }, start: function() {
          if (this.enabled)
            this.startListeners(), this.refreshPads();
          this.sceneInputPlugin.pluginEvents.once(Z.SHUTDOWN, this.shutdown, this);
        }, isActive: function() {
          return this.enabled && this.scene.sys.isActive();
        }, startListeners: function() {
          var Q = this, H = this.target, N = function(W) {
            if (W.defaultPrevented || !Q.isActive())
              return;
            Q.refreshPads(), Q.queue.push(W);
          };
          this.onGamepadHandler = N, H.addEventListener("gamepadconnected", N, false), H.addEventListener("gamepaddisconnected", N, false), this.sceneInputPlugin.pluginEvents.on(Z.UPDATE, this.update, this);
        }, stopListeners: function() {
          this.target.removeEventListener("gamepadconnected", this.onGamepadHandler), this.target.removeEventListener("gamepaddisconnected", this.onGamepadHandler), this.sceneInputPlugin.pluginEvents.off(Z.UPDATE, this.update);
          for (var Q = 0;Q < this.gamepads.length; Q++)
            this.gamepads[Q].removeAllListeners();
        }, disconnectAll: function() {
          for (var Q = 0;Q < this.gamepads.length; Q++)
            this.gamepads[Q].pad.connected = false;
        }, refreshPads: function() {
          var Q = navigator.getGamepads();
          if (!Q)
            this.disconnectAll();
          else {
            var H = this.gamepads;
            for (var N = 0;N < Q.length; N++) {
              var W = Q[N];
              if (!W)
                continue;
              var { id: R, index: Y } = W, I = H[Y];
              if (!I) {
                var P = new U(this, W);
                if (H[Y] = P, !this._pad1)
                  this._pad1 = P;
                else if (!this._pad2)
                  this._pad2 = P;
                else if (!this._pad3)
                  this._pad3 = P;
                else if (!this._pad4)
                  this._pad4 = P;
              } else if (I.id !== R)
                I.destroy(), H[Y] = new U(this, W);
              else
                I.update(W);
            }
          }
        }, getAll: function() {
          var Q = [], H = this.gamepads;
          for (var N = 0;N < H.length; N++)
            if (H[N])
              Q.push(H[N]);
          return Q;
        }, getPad: function(Q) {
          var H = this.gamepads;
          for (var N = 0;N < H.length; N++)
            if (H[N] && H[N].index === Q)
              return H[N];
        }, update: function() {
          if (!this.enabled)
            return;
          this.refreshPads();
          var Q = this.queue.length;
          if (Q === 0)
            return;
          var H = this.queue.splice(0, Q);
          for (var N = 0;N < Q; N++) {
            var W = H[N], R = this.getPad(W.gamepad.index);
            if (W.type === "gamepadconnected")
              this.emit(z.CONNECTED, R, W);
            else if (W.type === "gamepaddisconnected")
              this.emit(z.DISCONNECTED, R, W);
          }
        }, shutdown: function() {
          this.stopListeners(), this.removeAllListeners();
        }, destroy: function() {
          this.shutdown();
          for (var Q = 0;Q < this.gamepads.length; Q++)
            if (this.gamepads[Q])
              this.gamepads[Q].destroy();
          this.gamepads = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null, this.target = null;
        }, total: { get: function() {
          return this.gamepads.length;
        } }, pad1: { get: function() {
          return this._pad1;
        } }, pad2: { get: function() {
          return this._pad2;
        } }, pad3: { get: function() {
          return this._pad3;
        } }, pad4: { get: function() {
          return this._pad4;
        } } });
        J.register("GamepadPlugin", D, "gamepad", "gamepad", "inputGamepad"), M.exports = D;
      }, 89651: (M) => {
        M.exports = { UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, SELECT: 8, START: 9, B: 0, A: 1, Y: 2, X: 3, LEFT_SHOULDER: 4, RIGHT_SHOULDER: 5 };
      }, 65294: (M) => {
        M.exports = { UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, SHARE: 8, OPTIONS: 9, PS: 16, TOUCHBAR: 17, X: 0, CIRCLE: 1, SQUARE: 2, TRIANGLE: 3, L1: 4, R1: 5, L2: 6, R2: 7, L3: 10, R3: 11, LEFT_STICK_H: 0, LEFT_STICK_V: 1, RIGHT_STICK_H: 2, RIGHT_STICK_V: 3 };
      }, 90089: (M) => {
        M.exports = { UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, MENU: 16, A: 0, B: 1, X: 2, Y: 3, LB: 4, RB: 5, LT: 6, RT: 7, BACK: 8, START: 9, LS: 10, RS: 11, LEFT_STICK_H: 0, LEFT_STICK_V: 1, RIGHT_STICK_H: 2, RIGHT_STICK_V: 3 };
      }, 64894: (M, B, $) => {
        M.exports = { DUALSHOCK_4: $(65294), SNES_USB: $(89651), XBOX_360: $(90089) };
      }, 46008: (M) => {
        M.exports = "down";
      }, 7629: (M) => {
        M.exports = "up";
      }, 42206: (M) => {
        M.exports = "connected";
      }, 86544: (M) => {
        M.exports = "disconnected";
      }, 94784: (M) => {
        M.exports = "down";
      }, 14325: (M) => {
        M.exports = "up";
      }, 92734: (M, B, $) => {
        M.exports = { BUTTON_DOWN: $(46008), BUTTON_UP: $(7629), CONNECTED: $(42206), DISCONNECTED: $(86544), GAMEPAD_BUTTON_DOWN: $(94784), GAMEPAD_BUTTON_UP: $(14325) };
      }, 48646: (M, B, $) => {
        M.exports = { Axis: $(97421), Button: $(28884), Events: $(92734), Gamepad: $(99125), GamepadPlugin: $(56654), Configs: $(64894) };
      }, 14350: (M, B, $) => {
        var E = $(93301), L = $(79291), z = { CreatePixelPerfectHandler: $(84409), CreateInteractiveObject: $(74457), Events: $(8214), Gamepad: $(48646), InputManager: $(7003), InputPlugin: $(48205), InputPluginCache: $(89639), Keyboard: $(51442), Mouse: $(87078), Pointer: $(42515), Touch: $(95618) };
        z = L(false, z, E), M.exports = z;
      }, 78970: (M, B, $) => {
        var E = $(72905), L = $(83419), z = $(8443), U = $(8214), K = $(46032), J = $(29747), Z = new L({ initialize: function D(Q) {
          this.manager = Q, this.queue = [], this.preventDefault = true, this.captures = [], this.enabled = false, this.target, this.onKeyDown = J, this.onKeyUp = J, Q.events.once(U.MANAGER_BOOT, this.boot, this);
        }, boot: function() {
          var D = this.manager.config;
          if (this.enabled = D.inputKeyboard, this.target = D.inputKeyboardEventTarget, this.addCapture(D.inputKeyboardCapture), !this.target && window)
            this.target = window;
          if (this.enabled && this.target)
            this.startListeners();
          this.manager.game.events.on(z.POST_STEP, this.postUpdate, this);
        }, startListeners: function() {
          var D = this;
          this.onKeyDown = function(H) {
            if (H.defaultPrevented || !D.enabled || !D.manager)
              return;
            D.queue.push(H), D.manager.events.emit(U.MANAGER_PROCESS);
            var N = H.altKey || H.ctrlKey || H.shiftKey || H.metaKey;
            if (D.preventDefault && !N && D.captures.indexOf(H.keyCode) > -1)
              H.preventDefault();
          }, this.onKeyUp = function(H) {
            if (H.defaultPrevented || !D.enabled || !D.manager)
              return;
            D.queue.push(H), D.manager.events.emit(U.MANAGER_PROCESS);
            var N = H.altKey || H.ctrlKey || H.shiftKey || H.metaKey;
            if (D.preventDefault && !N && D.captures.indexOf(H.keyCode) > -1)
              H.preventDefault();
          };
          var Q = this.target;
          if (Q)
            Q.addEventListener("keydown", this.onKeyDown, false), Q.addEventListener("keyup", this.onKeyUp, false), this.enabled = true;
        }, stopListeners: function() {
          var D = this.target;
          D.removeEventListener("keydown", this.onKeyDown, false), D.removeEventListener("keyup", this.onKeyUp, false), this.enabled = false;
        }, postUpdate: function() {
          this.queue = [];
        }, addCapture: function(D) {
          if (typeof D === "string")
            D = D.split(",");
          if (!Array.isArray(D))
            D = [D];
          var Q = this.captures;
          for (var H = 0;H < D.length; H++) {
            var N = D[H];
            if (typeof N === "string")
              N = K[N.trim().toUpperCase()];
            if (Q.indexOf(N) === -1)
              Q.push(N);
          }
          this.preventDefault = Q.length > 0;
        }, removeCapture: function(D) {
          if (typeof D === "string")
            D = D.split(",");
          if (!Array.isArray(D))
            D = [D];
          var Q = this.captures;
          for (var H = 0;H < D.length; H++) {
            var N = D[H];
            if (typeof N === "string")
              N = K[N.toUpperCase()];
            E(Q, N);
          }
          this.preventDefault = Q.length > 0;
        }, clearCaptures: function() {
          this.captures = [], this.preventDefault = false;
        }, destroy: function() {
          this.stopListeners(), this.clearCaptures(), this.queue = [], this.manager.game.events.off(z.POST_RENDER, this.postUpdate, this), this.target = null, this.enabled = false, this.manager = null;
        } });
        M.exports = Z;
      }, 28846: (M, B, $) => {
        var E = $(83419), L = $(50792), z = $(95922), U = $(8443), K = $(35154), J = $(8214), Z = $(89639), D = $(30472), Q = $(46032), H = $(87960), N = $(74600), W = $(44594), R = $(56583), Y = new E({ Extends: L, initialize: function I(P) {
          L.call(this), this.game = P.systems.game, this.scene = P.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin = P, this.manager = P.manager.keyboard, this.enabled = true, this.keys = [], this.combos = [], this.prevCode = null, this.prevTime = 0, this.prevType = null, P.pluginEvents.once(J.BOOT, this.boot, this), P.pluginEvents.on(J.START, this.start, this);
        }, boot: function() {
          var I = this.settings.input;
          this.enabled = K(I, "keyboard", true);
          var P = K(I, "keyboard.capture", null);
          if (P)
            this.addCaptures(P);
          this.sceneInputPlugin.pluginEvents.once(J.DESTROY, this.destroy, this);
        }, start: function() {
          this.sceneInputPlugin.manager.events.on(J.MANAGER_PROCESS, this.update, this), this.sceneInputPlugin.pluginEvents.once(J.SHUTDOWN, this.shutdown, this), this.game.events.on(U.BLUR, this.resetKeys, this), this.scene.sys.events.on(W.PAUSE, this.resetKeys, this), this.scene.sys.events.on(W.SLEEP, this.resetKeys, this);
        }, isActive: function() {
          return this.enabled && this.scene.sys.canInput();
        }, addCapture: function(I) {
          return this.manager.addCapture(I), this;
        }, removeCapture: function(I) {
          return this.manager.removeCapture(I), this;
        }, getCaptures: function() {
          return this.manager.captures;
        }, enableGlobalCapture: function() {
          return this.manager.preventDefault = true, this;
        }, disableGlobalCapture: function() {
          return this.manager.preventDefault = false, this;
        }, clearCaptures: function() {
          return this.manager.clearCaptures(), this;
        }, createCursorKeys: function() {
          return this.addKeys({ up: Q.UP, down: Q.DOWN, left: Q.LEFT, right: Q.RIGHT, space: Q.SPACE, shift: Q.SHIFT });
        }, addKeys: function(I, P, X) {
          if (P === undefined)
            P = true;
          if (X === undefined)
            X = false;
          var G = {};
          if (typeof I === "string") {
            I = I.split(",");
            for (var V = 0;V < I.length; V++) {
              var A = I[V].trim();
              if (A)
                G[A] = this.addKey(A, P, X);
            }
          } else
            for (var F in I)
              G[F] = this.addKey(I[F], P, X);
          return G;
        }, addKey: function(I, P, X) {
          if (P === undefined)
            P = true;
          if (X === undefined)
            X = false;
          var G = this.keys;
          if (I instanceof D) {
            var V = G.indexOf(I);
            if (V > -1)
              G[V] = I;
            else
              G[I.keyCode] = I;
            if (P)
              this.addCapture(I.keyCode);
            return I.setEmitOnRepeat(X), I;
          }
          if (typeof I === "string")
            I = Q[I.toUpperCase()];
          if (!G[I]) {
            if (G[I] = new D(this, I), P)
              this.addCapture(I);
            G[I].setEmitOnRepeat(X);
          }
          return G[I];
        }, removeKey: function(I, P, X) {
          if (P === undefined)
            P = false;
          if (X === undefined)
            X = false;
          var G = this.keys, V;
          if (I instanceof D) {
            var A = G.indexOf(I);
            if (A > -1)
              V = this.keys[A], this.keys[A] = undefined;
          } else if (typeof I === "string")
            I = Q[I.toUpperCase()];
          if (G[I])
            V = G[I], G[I] = undefined;
          if (V) {
            if (V.plugin = null, X)
              this.removeCapture(V.keyCode);
            if (P)
              V.destroy();
          }
          return this;
        }, removeAllKeys: function(I, P) {
          if (I === undefined)
            I = false;
          if (P === undefined)
            P = false;
          var X = this.keys;
          for (var G = 0;G < X.length; G++) {
            var V = X[G];
            if (V) {
              if (X[G] = undefined, P)
                this.removeCapture(V.keyCode);
              if (I)
                V.destroy();
            }
          }
          return this;
        }, createCombo: function(I, P) {
          return new H(this, I, P);
        }, checkDown: function(I, P) {
          if (P === undefined)
            P = 0;
          if (this.enabled && I.isDown) {
            var X = R(this.time - I.timeDown, P);
            if (X > I._tick)
              return I._tick = X, true;
          }
          return false;
        }, update: function() {
          var I = this.manager.queue, P = I.length;
          if (!this.isActive() || P === 0)
            return;
          var X = this.keys;
          for (var G = 0;G < P; G++) {
            var V = I[G], A = V.keyCode, F = X[A], j = false;
            if (V.cancelled === undefined)
              V.cancelled = 0, V.stopImmediatePropagation = function() {
                V.cancelled = 1;
              }, V.stopPropagation = function() {
                V.cancelled = -1;
              };
            if (V.cancelled === -1)
              continue;
            if (A === this.prevCode && V.timeStamp === this.prevTime && V.type === this.prevType)
              continue;
            if (this.prevCode = A, this.prevTime = V.timeStamp, this.prevType = V.type, V.type === "keydown") {
              if (F)
                j = F.isDown, F.onDown(V);
              if (!V.cancelled && (!F || !j)) {
                if (N[A])
                  this.emit(z.KEY_DOWN + N[A], V);
                if (!V.cancelled)
                  this.emit(z.ANY_KEY_DOWN, V);
              }
            } else {
              if (F)
                F.onUp(V);
              if (!V.cancelled) {
                if (N[A])
                  this.emit(z.KEY_UP + N[A], V);
                if (!V.cancelled)
                  this.emit(z.ANY_KEY_UP, V);
              }
            }
            if (V.cancelled === 1)
              V.cancelled = 0;
          }
        }, resetKeys: function() {
          var I = this.keys;
          for (var P = 0;P < I.length; P++)
            if (I[P])
              I[P].reset();
          return this;
        }, shutdown: function() {
          this.removeAllKeys(true), this.removeAllListeners(), this.sceneInputPlugin.manager.events.off(J.MANAGER_PROCESS, this.update, this), this.game.events.off(U.BLUR, this.resetKeys), this.scene.sys.events.off(W.PAUSE, this.resetKeys, this), this.scene.sys.events.off(W.SLEEP, this.resetKeys, this), this.queue = [];
        }, destroy: function() {
          this.shutdown();
          var I = this.keys;
          for (var P = 0;P < I.length; P++)
            if (I[P])
              I[P].destroy();
          this.keys = [], this.combos = [], this.queue = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null, this.manager = null;
        }, time: { get: function() {
          return this.sceneInputPlugin.manager.time;
        } } });
        Z.register("KeyboardPlugin", Y, "keyboard", "keyboard", "inputKeyboard"), M.exports = Y;
      }, 66970: (M) => {
        var B = function($, E) {
          if (E.timeLastMatched = $.timeStamp, E.index++, E.index === E.size)
            return true;
          else
            return E.current = E.keyCodes[E.index], false;
        };
        M.exports = B;
      }, 87960: (M, B, $) => {
        var E = $(83419), L = $(95922), z = $(95540), U = $(68769), K = $(92803), J = new E({ initialize: function Z(D, Q, H) {
          if (H === undefined)
            H = {};
          if (Q.length < 2)
            return false;
          this.manager = D, this.enabled = true, this.keyCodes = [];
          for (var N = 0;N < Q.length; N++) {
            var W = Q[N];
            if (typeof W === "string")
              this.keyCodes.push(W.toUpperCase().charCodeAt(0));
            else if (typeof W === "number")
              this.keyCodes.push(W);
            else if (W.hasOwnProperty("keyCode"))
              this.keyCodes.push(W.keyCode);
          }
          this.current = this.keyCodes[0], this.index = 0, this.size = this.keyCodes.length, this.timeLastMatched = 0, this.matched = false, this.timeMatched = 0, this.resetOnWrongKey = z(H, "resetOnWrongKey", true), this.maxKeyDelay = z(H, "maxKeyDelay", 0), this.resetOnMatch = z(H, "resetOnMatch", false), this.deleteOnMatch = z(H, "deleteOnMatch", false);
          var R = this, Y = function(I) {
            if (R.matched || !R.enabled)
              return;
            var P = U(I, R);
            if (P) {
              if (R.manager.emit(L.COMBO_MATCH, R, I), R.resetOnMatch)
                K(R);
              else if (R.deleteOnMatch)
                R.destroy();
            }
          };
          this.onKeyDown = Y, this.manager.on(L.ANY_KEY_DOWN, this.onKeyDown);
        }, progress: { get: function() {
          return this.index / this.size;
        } }, destroy: function() {
          this.enabled = false, this.keyCodes = [], this.manager.off(L.ANY_KEY_DOWN, this.onKeyDown), this.manager = null;
        } });
        M.exports = J;
      }, 68769: (M, B, $) => {
        var E = $(66970), L = function(z, U) {
          if (U.matched)
            return true;
          var K = false, J = false;
          if (z.keyCode === U.current)
            if (U.index > 0 && U.maxKeyDelay > 0) {
              var Z = U.timeLastMatched + U.maxKeyDelay;
              if (z.timeStamp <= Z)
                J = true, K = E(z, U);
            } else
              J = true, K = E(z, U);
          if (!J && U.resetOnWrongKey)
            U.index = 0, U.current = U.keyCodes[0];
          if (K)
            U.timeLastMatched = z.timeStamp, U.matched = true, U.timeMatched = z.timeStamp;
          return K;
        };
        M.exports = L;
      }, 92803: (M) => {
        var B = function($) {
          return $.current = $.keyCodes[0], $.index = 0, $.timeLastMatched = 0, $.matched = false, $.timeMatched = 0, $;
        };
        M.exports = B;
      }, 92612: (M) => {
        M.exports = "keydown";
      }, 23345: (M) => {
        M.exports = "keyup";
      }, 21957: (M) => {
        M.exports = "keycombomatch";
      }, 44743: (M) => {
        M.exports = "down";
      }, 3771: (M) => {
        M.exports = "keydown-";
      }, 46358: (M) => {
        M.exports = "keyup-";
      }, 75674: (M) => {
        M.exports = "up";
      }, 95922: (M, B, $) => {
        M.exports = { ANY_KEY_DOWN: $(92612), ANY_KEY_UP: $(23345), COMBO_MATCH: $(21957), DOWN: $(44743), KEY_DOWN: $(3771), KEY_UP: $(46358), UP: $(75674) };
      }, 51442: (M, B, $) => {
        M.exports = { Events: $(95922), KeyboardManager: $(78970), KeyboardPlugin: $(28846), Key: $(30472), KeyCodes: $(46032), KeyCombo: $(87960), AdvanceKeyCombo: $(66970), ProcessKeyCombo: $(68769), ResetKeyCombo: $(92803), JustDown: $(90229), JustUp: $(38796), DownDuration: $(37015), UpDuration: $(41170) };
      }, 37015: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = 50;
          var L = $.plugin.game.loop.time - $.timeDown;
          return $.isDown && L < E;
        };
        M.exports = B;
      }, 90229: (M) => {
        var B = function($) {
          if ($._justDown)
            return $._justDown = false, true;
          else
            return false;
        };
        M.exports = B;
      }, 38796: (M) => {
        var B = function($) {
          if ($._justUp)
            return $._justUp = false, true;
          else
            return false;
        };
        M.exports = B;
      }, 30472: (M, B, $) => {
        var E = $(83419), L = $(50792), z = $(95922), U = new E({ Extends: L, initialize: function K(J, Z) {
          L.call(this), this.plugin = J, this.keyCode = Z, this.originalEvent = undefined, this.enabled = true, this.isDown = false, this.isUp = true, this.altKey = false, this.ctrlKey = false, this.shiftKey = false, this.metaKey = false, this.location = 0, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.emitOnRepeat = false, this.repeats = 0, this._justDown = false, this._justUp = false, this._tick = -1;
        }, setEmitOnRepeat: function(K) {
          return this.emitOnRepeat = K, this;
        }, onDown: function(K) {
          if (this.originalEvent = K, !this.enabled)
            return;
          if (this.altKey = K.altKey, this.ctrlKey = K.ctrlKey, this.shiftKey = K.shiftKey, this.metaKey = K.metaKey, this.location = K.location, this.repeats++, !this.isDown)
            this.isDown = true, this.isUp = false, this.timeDown = K.timeStamp, this.duration = 0, this._justDown = true, this._justUp = false, this.emit(z.DOWN, this, K);
          else if (this.emitOnRepeat)
            this.emit(z.DOWN, this, K);
        }, onUp: function(K) {
          if (this.originalEvent = K, !this.enabled)
            return;
          this.isDown = false, this.isUp = true, this.timeUp = K.timeStamp, this.duration = this.timeUp - this.timeDown, this.repeats = 0, this._justDown = false, this._justUp = true, this._tick = -1, this.emit(z.UP, this, K);
        }, reset: function() {
          return this.isDown = false, this.isUp = true, this.altKey = false, this.ctrlKey = false, this.shiftKey = false, this.metaKey = false, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.repeats = 0, this._justDown = false, this._justUp = false, this._tick = -1, this;
        }, getDuration: function() {
          if (this.isDown)
            return this.plugin.game.loop.time - this.timeDown;
          else
            return 0;
        }, destroy: function() {
          this.removeAllListeners(), this.originalEvent = null, this.plugin = null;
        } });
        M.exports = U;
      }, 46032: (M) => {
        var B = { BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, PAUSE: 19, CAPS_LOCK: 20, ESC: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, PRINT_SCREEN: 42, INSERT: 45, DELETE: 46, ZERO: 48, ONE: 49, TWO: 50, THREE: 51, FOUR: 52, FIVE: 53, SIX: 54, SEVEN: 55, EIGHT: 56, NINE: 57, NUMPAD_ZERO: 96, NUMPAD_ONE: 97, NUMPAD_TWO: 98, NUMPAD_THREE: 99, NUMPAD_FOUR: 100, NUMPAD_FIVE: 101, NUMPAD_SIX: 102, NUMPAD_SEVEN: 103, NUMPAD_EIGHT: 104, NUMPAD_NINE: 105, NUMPAD_ADD: 107, NUMPAD_SUBTRACT: 109, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, SEMICOLON: 186, PLUS: 187, COMMA: 188, MINUS: 189, PERIOD: 190, FORWARD_SLASH: 191, BACK_SLASH: 220, QUOTES: 222, BACKTICK: 192, OPEN_BRACKET: 219, CLOSED_BRACKET: 221, SEMICOLON_FIREFOX: 59, COLON: 58, COMMA_FIREFOX_WINDOWS: 60, COMMA_FIREFOX: 62, BRACKET_RIGHT_FIREFOX: 174, BRACKET_LEFT_FIREFOX: 175 };
        M.exports = B;
      }, 74600: (M, B, $) => {
        var E = $(46032), L = {};
        for (var z in E)
          L[E[z]] = z;
        M.exports = L;
      }, 41170: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = 50;
          var L = $.plugin.game.loop.time - $.timeUp;
          return $.isUp && L < E;
        };
        M.exports = B;
      }, 85098: (M, B, $) => {
        var E = $(83419), L = $(89357), z = $(8214), U = $(29747), K = new E({ initialize: function J(Z) {
          this.manager = Z, this.preventDefaultDown = true, this.preventDefaultUp = true, this.preventDefaultMove = true, this.preventDefaultWheel = false, this.enabled = false, this.target, this.locked = false, this.onMouseMove = U, this.onMouseDown = U, this.onMouseUp = U, this.onMouseDownWindow = U, this.onMouseUpWindow = U, this.onMouseOver = U, this.onMouseOut = U, this.onMouseWheel = U, this.pointerLockChange = U, this.isTop = true, Z.events.once(z.MANAGER_BOOT, this.boot, this);
        }, boot: function() {
          var J = this.manager.config;
          if (this.enabled = J.inputMouse, this.target = J.inputMouseEventTarget, this.passive = J.inputMousePassive, this.preventDefaultDown = J.inputMousePreventDefaultDown, this.preventDefaultUp = J.inputMousePreventDefaultUp, this.preventDefaultMove = J.inputMousePreventDefaultMove, this.preventDefaultWheel = J.inputMousePreventDefaultWheel, !this.target)
            this.target = this.manager.game.canvas;
          else if (typeof this.target === "string")
            this.target = document.getElementById(this.target);
          if (J.disableContextMenu)
            this.disableContextMenu();
          if (this.enabled && this.target)
            this.startListeners();
        }, disableContextMenu: function() {
          return this.target.addEventListener("contextmenu", function(J) {
            return J.preventDefault(), false;
          }), this;
        }, requestPointerLock: function() {
          if (L.pointerLock) {
            var J = this.target;
            J.requestPointerLock = J.requestPointerLock || J.mozRequestPointerLock || J.webkitRequestPointerLock, J.requestPointerLock();
          }
        }, releasePointerLock: function() {
          if (L.pointerLock)
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock();
        }, startListeners: function() {
          var J = this.target;
          if (!J)
            return;
          var Z = this, D = this.manager, Q = D.canvas, H = window && window.focus && D.game.config.autoFocus;
          this.onMouseMove = function(W) {
            if (!W.defaultPrevented && Z.enabled && D && D.enabled) {
              if (D.onMouseMove(W), Z.preventDefaultMove)
                W.preventDefault();
            }
          }, this.onMouseDown = function(W) {
            if (H)
              window.focus();
            if (!W.defaultPrevented && Z.enabled && D && D.enabled) {
              if (D.onMouseDown(W), Z.preventDefaultDown && W.target === Q)
                W.preventDefault();
            }
          }, this.onMouseDownWindow = function(W) {
            if (W.sourceCapabilities && W.sourceCapabilities.firesTouchEvents)
              return;
            if (!W.defaultPrevented && Z.enabled && D && D.enabled && W.target !== Q)
              D.onMouseDown(W);
          }, this.onMouseUp = function(W) {
            if (!W.defaultPrevented && Z.enabled && D && D.enabled) {
              if (D.onMouseUp(W), Z.preventDefaultUp && W.target === Q)
                W.preventDefault();
            }
          }, this.onMouseUpWindow = function(W) {
            if (W.sourceCapabilities && W.sourceCapabilities.firesTouchEvents)
              return;
            if (!W.defaultPrevented && Z.enabled && D && D.enabled && W.target !== Q)
              D.onMouseUp(W);
          }, this.onMouseOver = function(W) {
            if (!W.defaultPrevented && Z.enabled && D && D.enabled)
              D.setCanvasOver(W);
          }, this.onMouseOut = function(W) {
            if (!W.defaultPrevented && Z.enabled && D && D.enabled)
              D.setCanvasOut(W);
          }, this.onMouseWheel = function(W) {
            if (!W.defaultPrevented && Z.enabled && D && D.enabled)
              D.onMouseWheel(W);
            if (Z.preventDefaultWheel && W.target === Q)
              W.preventDefault();
          };
          var N = { passive: true };
          if (J.addEventListener("mousemove", this.onMouseMove), J.addEventListener("mousedown", this.onMouseDown), J.addEventListener("mouseup", this.onMouseUp), J.addEventListener("mouseover", this.onMouseOver, N), J.addEventListener("mouseout", this.onMouseOut, N), this.preventDefaultWheel)
            J.addEventListener("wheel", this.onMouseWheel, { passive: false });
          else
            J.addEventListener("wheel", this.onMouseWheel, N);
          if (window && D.game.config.inputWindowEvents)
            try {
              window.top.addEventListener("mousedown", this.onMouseDownWindow, N), window.top.addEventListener("mouseup", this.onMouseUpWindow, N);
            } catch (W) {
              window.addEventListener("mousedown", this.onMouseDownWindow, N), window.addEventListener("mouseup", this.onMouseUpWindow, N), this.isTop = false;
            }
          if (L.pointerLock)
            this.pointerLockChange = function(W) {
              var R = Z.target;
              Z.locked = document.pointerLockElement === R || document.mozPointerLockElement === R || document.webkitPointerLockElement === R ? true : false, D.onPointerLockChange(W);
            }, document.addEventListener("pointerlockchange", this.pointerLockChange, true), document.addEventListener("mozpointerlockchange", this.pointerLockChange, true), document.addEventListener("webkitpointerlockchange", this.pointerLockChange, true);
          this.enabled = true;
        }, stopListeners: function() {
          var J = this.target;
          if (J.removeEventListener("mousemove", this.onMouseMove), J.removeEventListener("mousedown", this.onMouseDown), J.removeEventListener("mouseup", this.onMouseUp), J.removeEventListener("mouseover", this.onMouseOver), J.removeEventListener("mouseout", this.onMouseOut), window)
            J = this.isTop ? window.top : window, J.removeEventListener("mousedown", this.onMouseDownWindow), J.removeEventListener("mouseup", this.onMouseUpWindow);
          if (L.pointerLock)
            document.removeEventListener("pointerlockchange", this.pointerLockChange, true), document.removeEventListener("mozpointerlockchange", this.pointerLockChange, true), document.removeEventListener("webkitpointerlockchange", this.pointerLockChange, true);
        }, destroy: function() {
          this.stopListeners(), this.target = null, this.enabled = false, this.manager = null;
        } });
        M.exports = K;
      }, 87078: (M, B, $) => {
        M.exports = { MouseManager: $(85098) };
      }, 36210: (M, B, $) => {
        var E = $(83419), L = $(8214), z = $(29747), U = new E({ initialize: function K(J) {
          this.manager = J, this.capture = true, this.enabled = false, this.target, this.onTouchStart = z, this.onTouchStartWindow = z, this.onTouchMove = z, this.onTouchEnd = z, this.onTouchEndWindow = z, this.onTouchCancel = z, this.onTouchCancelWindow = z, this.isTop = true, J.events.once(L.MANAGER_BOOT, this.boot, this);
        }, boot: function() {
          var K = this.manager.config;
          if (this.enabled = K.inputTouch, this.target = K.inputTouchEventTarget, this.capture = K.inputTouchCapture, !this.target)
            this.target = this.manager.game.canvas;
          else if (typeof this.target === "string")
            this.target = document.getElementById(this.target);
          if (K.disableContextMenu)
            this.disableContextMenu();
          if (this.enabled && this.target)
            this.startListeners();
        }, disableContextMenu: function() {
          return this.target.addEventListener("contextmenu", function(K) {
            return K.preventDefault(), false;
          }), this;
        }, startListeners: function() {
          var K = this.target;
          if (!K)
            return;
          var J = this, Z = this.manager, D = Z.canvas, Q = window && window.focus && Z.game.config.autoFocus;
          this.onTouchMove = function(R) {
            if (!R.defaultPrevented && J.enabled && Z && Z.enabled) {
              if (Z.onTouchMove(R), J.capture && R.cancelable)
                R.preventDefault();
            }
          }, this.onTouchStart = function(R) {
            if (Q)
              window.focus();
            if (!R.defaultPrevented && J.enabled && Z && Z.enabled) {
              if (Z.onTouchStart(R), J.capture && R.cancelable && R.target === D)
                R.preventDefault();
            }
          }, this.onTouchStartWindow = function(R) {
            if (!R.defaultPrevented && J.enabled && Z && Z.enabled && R.target !== D)
              Z.onTouchStart(R);
          }, this.onTouchEnd = function(R) {
            if (!R.defaultPrevented && J.enabled && Z && Z.enabled) {
              if (Z.onTouchEnd(R), J.capture && R.cancelable && R.target === D)
                R.preventDefault();
            }
          }, this.onTouchEndWindow = function(R) {
            if (!R.defaultPrevented && J.enabled && Z && Z.enabled && R.target !== D)
              Z.onTouchEnd(R);
          }, this.onTouchCancel = function(R) {
            if (!R.defaultPrevented && J.enabled && Z && Z.enabled) {
              if (Z.onTouchCancel(R), J.capture)
                R.preventDefault();
            }
          }, this.onTouchCancelWindow = function(R) {
            if (!R.defaultPrevented && J.enabled && Z && Z.enabled)
              Z.onTouchCancel(R);
          };
          var H = this.capture, N = { passive: true }, W = { passive: false };
          if (K.addEventListener("touchstart", this.onTouchStart, H ? W : N), K.addEventListener("touchmove", this.onTouchMove, H ? W : N), K.addEventListener("touchend", this.onTouchEnd, H ? W : N), K.addEventListener("touchcancel", this.onTouchCancel, H ? W : N), window && Z.game.config.inputWindowEvents)
            try {
              window.top.addEventListener("touchstart", this.onTouchStartWindow, W), window.top.addEventListener("touchend", this.onTouchEndWindow, W), window.top.addEventListener("touchcancel", this.onTouchCancelWindow, W);
            } catch (R) {
              window.addEventListener("touchstart", this.onTouchStartWindow, W), window.addEventListener("touchend", this.onTouchEndWindow, W), window.addEventListener("touchcancel", this.onTouchCancelWindow, W), this.isTop = false;
            }
          this.enabled = true;
        }, stopListeners: function() {
          var K = this.target;
          if (K.removeEventListener("touchstart", this.onTouchStart), K.removeEventListener("touchmove", this.onTouchMove), K.removeEventListener("touchend", this.onTouchEnd), K.removeEventListener("touchcancel", this.onTouchCancel), window)
            K = this.isTop ? window.top : window, K.removeEventListener("touchstart", this.onTouchStartWindow), K.removeEventListener("touchend", this.onTouchEndWindow), K.removeEventListener("touchcancel", this.onTouchCancelWindow);
        }, destroy: function() {
          this.stopListeners(), this.target = null, this.enabled = false, this.manager = null;
        } });
        M.exports = U;
      }, 95618: (M, B, $) => {
        M.exports = { TouchManager: $(36210) };
      }, 41299: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(54899), U = $(95540), K = $(98356), J = $(3374), Z = $(84376), D = $(92638), Q = new E({ initialize: function H(N, W) {
          if (this.loader = N, this.cache = U(W, "cache", false), this.type = U(W, "type", false), !this.type)
            throw new Error("Invalid File type: " + this.type);
          this.key = U(W, "key", false);
          var R = this.key;
          if (N.prefix && N.prefix !== "")
            this.key = N.prefix + R;
          if (!this.key)
            throw new Error("Invalid File key: " + this.key);
          var Y = U(W, "url");
          if (Y === undefined)
            Y = N.path + R + "." + U(W, "extension", "");
          else if (typeof Y === "string" && !Y.match(/^(?:blob:|data:|capacitor:\/\/|http:\/\/|https:\/\/|\/\/)/))
            Y = N.path + Y;
          if (this.url = Y, this.src = "", this.xhrSettings = D(U(W, "responseType", undefined)), U(W, "xhrSettings", false))
            this.xhrSettings = J(this.xhrSettings, U(W, "xhrSettings", {}));
          this.xhrLoader = null, this.state = typeof this.url === "function" ? L.FILE_POPULATED : L.FILE_PENDING, this.bytesTotal = 0, this.bytesLoaded = -1, this.percentComplete = -1, this.crossOrigin = undefined, this.data = undefined, this.config = U(W, "config", {}), this.multiFile, this.linkFile, this.base64 = typeof Y === "string" && Y.indexOf("data:") === 0;
        }, setLink: function(H) {
          this.linkFile = H, H.linkFile = this;
        }, resetXHR: function() {
          if (this.xhrLoader)
            this.xhrLoader.onload = undefined, this.xhrLoader.onerror = undefined, this.xhrLoader.onprogress = undefined;
        }, load: function() {
          if (this.state === L.FILE_POPULATED)
            this.loader.nextFile(this, true);
          else {
            if (this.state = L.FILE_LOADING, this.src = K(this, this.loader.baseURL), this.src.indexOf("data:") === 0)
              this.base64 = true;
            this.xhrLoader = Z(this, this.loader.xhr);
          }
        }, onLoad: function(H, N) {
          var W = H.responseURL && this.loader.localSchemes.some(function(I) {
            return H.responseURL.indexOf(I) === 0;
          }), R = W && N.target.status === 0, Y = !(N.target && N.target.status !== 200) || R;
          if (H.readyState === 4 && H.status >= 400 && H.status <= 599)
            Y = false;
          this.state = L.FILE_LOADED, this.resetXHR(), this.loader.nextFile(this, Y);
        }, onBase64Load: function(H) {
          this.xhrLoader = H, this.state = L.FILE_LOADED, this.percentComplete = 1, this.loader.emit(z.FILE_PROGRESS, this, this.percentComplete), this.loader.nextFile(this, true);
        }, onError: function() {
          this.resetXHR(), this.loader.nextFile(this, false);
        }, onProgress: function(H) {
          if (H.lengthComputable)
            this.bytesLoaded = H.loaded, this.bytesTotal = H.total, this.percentComplete = Math.min(this.bytesLoaded / this.bytesTotal, 1), this.loader.emit(z.FILE_PROGRESS, this, this.percentComplete);
        }, onProcess: function() {
          this.state = L.FILE_PROCESSING, this.onProcessComplete();
        }, onProcessComplete: function() {
          if (this.state = L.FILE_COMPLETE, this.multiFile)
            this.multiFile.onFileComplete(this);
          this.loader.fileProcessComplete(this);
        }, onProcessError: function() {
          if (console.error('Failed to process file: %s "%s"', this.type, this.key), this.state = L.FILE_ERRORED, this.multiFile)
            this.multiFile.onFileFailed(this);
          this.loader.fileProcessComplete(this);
        }, hasCacheConflict: function() {
          return this.cache && this.cache.exists(this.key);
        }, addToCache: function() {
          if (this.cache && this.data)
            this.cache.add(this.key, this.data);
        }, pendingDestroy: function(H) {
          if (this.state === L.FILE_PENDING_DESTROY)
            return;
          if (H === undefined)
            H = this.data;
          var N = this.key, W = this.type;
          this.loader.emit(z.FILE_COMPLETE, N, W, H), this.loader.emit(z.FILE_KEY_COMPLETE + W + "-" + N, N, W, H), this.loader.flagForRemoval(this), this.state = L.FILE_PENDING_DESTROY;
        }, destroy: function() {
          this.loader = null, this.cache = null, this.xhrSettings = null, this.multiFile = null, this.linkFile = null, this.data = null;
        } });
        Q.createObjectURL = function(H, N, W) {
          if (typeof URL === "function")
            H.src = URL.createObjectURL(N);
          else {
            var R = new FileReader;
            R.onload = function() {
              H.removeAttribute("crossOrigin"), H.src = "data:" + (N.type || W) + ";base64," + R.result.split(",")[1];
            }, R.onerror = H.onerror, R.readAsDataURL(N);
          }
        }, Q.revokeObjectURL = function(H) {
          if (typeof URL === "function")
            URL.revokeObjectURL(H.src);
        }, M.exports = Q;
      }, 74099: (M) => {
        var B = {}, $ = { install: function(E) {
          for (var L in B)
            E[L] = B[L];
        }, register: function(E, L) {
          B[E] = L;
        }, destroy: function() {
          B = {};
        } };
        M.exports = $;
      }, 98356: (M) => {
        var B = function($, E) {
          if (!$.url)
            return false;
          if ($.url.match(/^(?:blob:|data:|capacitor:\/\/|http:\/\/|https:\/\/|\/\/)/))
            return $.url;
          else
            return E + $.url;
        };
        M.exports = B;
      }, 74261: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(35072), U = $(50792), K = $(54899), J = $(74099), Z = $(95540), D = $(35154), Q = $(37277), H = $(44594), N = $(92638), W = new E({ Extends: U, initialize: function R(Y) {
          U.call(this);
          var I = Y.sys.game.config, P = Y.sys.settings.loader;
          this.scene = Y, this.systems = Y.sys, this.cacheManager = Y.sys.cache, this.textureManager = Y.sys.textures, this.sceneManager = Y.sys.game.scene, J.install(this), this.prefix = "", this.path = "", this.baseURL = "", this.setBaseURL(Z(P, "baseURL", I.loaderBaseURL)), this.setPath(Z(P, "path", I.loaderPath)), this.setPrefix(Z(P, "prefix", I.loaderPrefix)), this.maxParallelDownloads = Z(P, "maxParallelDownloads", I.loaderMaxParallelDownloads), this.xhr = N(Z(P, "responseType", I.loaderResponseType), Z(P, "async", I.loaderAsync), Z(P, "user", I.loaderUser), Z(P, "password", I.loaderPassword), Z(P, "timeout", I.loaderTimeout), Z(P, "withCredentials", I.loaderWithCredentials)), this.crossOrigin = Z(P, "crossOrigin", I.loaderCrossOrigin), this.imageLoadType = Z(P, "imageLoadType", I.loaderImageLoadType), this.localSchemes = Z(P, "localScheme", I.loaderLocalScheme), this.totalToLoad = 0, this.progress = 0, this.list = new z, this.inflight = new z, this.queue = new z, this._deleteQueue = new z, this.totalFailed = 0, this.totalComplete = 0, this.state = L.LOADER_IDLE, this.multiKeyIndex = 0, Y.sys.events.once(H.BOOT, this.boot, this), Y.sys.events.on(H.START, this.pluginStart, this);
        }, boot: function() {
          this.systems.events.once(H.DESTROY, this.destroy, this);
        }, pluginStart: function() {
          this.systems.events.once(H.SHUTDOWN, this.shutdown, this);
        }, setBaseURL: function(R) {
          if (R === undefined)
            R = "";
          if (R !== "" && R.substr(-1) !== "/")
            R = R.concat("/");
          return this.baseURL = R, this;
        }, setPath: function(R) {
          if (R === undefined)
            R = "";
          if (R !== "" && R.substr(-1) !== "/")
            R = R.concat("/");
          return this.path = R, this;
        }, setPrefix: function(R) {
          if (R === undefined)
            R = "";
          return this.prefix = R, this;
        }, setCORS: function(R) {
          return this.crossOrigin = R, this;
        }, addFile: function(R) {
          if (!Array.isArray(R))
            R = [R];
          for (var Y = 0;Y < R.length; Y++) {
            var I = R[Y];
            if (!this.keyExists(I)) {
              if (this.list.set(I), this.emit(K.ADD, I.key, I.type, this, I), this.isLoading())
                this.totalToLoad++, this.updateProgress();
            }
          }
        }, keyExists: function(R) {
          var Y = R.hasCacheConflict();
          if (!Y)
            this.list.iterate(function(I) {
              if (I.type === R.type && I.key === R.key)
                return Y = true, false;
            });
          if (!Y && this.isLoading())
            this.inflight.iterate(function(I) {
              if (I.type === R.type && I.key === R.key)
                return Y = true, false;
            }), this.queue.iterate(function(I) {
              if (I.type === R.type && I.key === R.key)
                return Y = true, false;
            });
          return Y;
        }, addPack: function(R, Y) {
          if (typeof Y === "string") {
            var I = D(R, Y);
            if (I)
              R = { packKey: I };
          }
          var P = 0, X = this.baseURL, G = this.path, V = this.prefix;
          for (var A in R) {
            if (!Object.prototype.hasOwnProperty.call(R, A))
              continue;
            var F = R[A], j = Z(F, "baseURL", X), T = Z(F, "path", G), C = Z(F, "prefix", V), v = Z(F, "files", null), O = Z(F, "defaultType", "void");
            if (Array.isArray(v)) {
              this.setBaseURL(j), this.setPath(T), this.setPrefix(C);
              for (var q = 0;q < v.length; q++) {
                var w = v[q], g = w.hasOwnProperty("type") ? w.type : O;
                if (this[g])
                  this[g](w), P++;
              }
            }
          }
          return this.setBaseURL(X), this.setPath(G), this.setPrefix(V), P > 0;
        }, isLoading: function() {
          return this.state === L.LOADER_LOADING || this.state === L.LOADER_PROCESSING;
        }, isReady: function() {
          return this.state === L.LOADER_IDLE || this.state === L.LOADER_COMPLETE;
        }, start: function() {
          if (!this.isReady())
            return;
          if (this.progress = 0, this.totalFailed = 0, this.totalComplete = 0, this.totalToLoad = this.list.size, this.emit(K.START, this), this.list.size === 0)
            this.loadComplete();
          else
            this.state = L.LOADER_LOADING, this.inflight.clear(), this.queue.clear(), this.updateProgress(), this.checkLoadQueue(), this.systems.events.on(H.UPDATE, this.update, this);
        }, updateProgress: function() {
          this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad, this.emit(K.PROGRESS, this.progress);
        }, update: function() {
          if (this.state === L.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads)
            this.checkLoadQueue();
        }, checkLoadQueue: function() {
          this.list.each(function(R) {
            if (R.state === L.FILE_POPULATED || R.state === L.FILE_PENDING && this.inflight.size < this.maxParallelDownloads) {
              if (this.inflight.set(R), this.list.delete(R), !R.crossOrigin)
                R.crossOrigin = this.crossOrigin;
              R.load();
            }
            if (this.inflight.size === this.maxParallelDownloads)
              return false;
          }, this);
        }, nextFile: function(R, Y) {
          if (!this.inflight)
            return;
          if (this.inflight.delete(R), this.updateProgress(), Y)
            this.totalComplete++, this.queue.set(R), this.emit(K.FILE_LOAD, R), R.onProcess();
          else
            this.totalFailed++, this._deleteQueue.set(R), this.emit(K.FILE_LOAD_ERROR, R), this.fileProcessComplete(R);
        }, fileProcessComplete: function(R) {
          if (!this.scene || !this.systems || !this.systems.game || this.systems.game.pendingDestroy)
            return;
          if (R.state === L.FILE_ERRORED) {
            if (R.multiFile)
              R.multiFile.onFileFailed(R);
          } else if (R.state === L.FILE_COMPLETE)
            if (R.multiFile) {
              if (R.multiFile.isReadyToProcess())
                R.multiFile.addToCache(), R.multiFile.pendingDestroy();
            } else
              R.addToCache(), R.pendingDestroy();
          if (this.queue.delete(R), this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0)
            this.loadComplete();
        }, loadComplete: function() {
          this.emit(K.POST_PROCESS, this), this.list.clear(), this.inflight.clear(), this.queue.clear(), this.progress = 1, this.state = L.LOADER_COMPLETE, this.systems.events.off(H.UPDATE, this.update, this), this._deleteQueue.iterateLocal("destroy"), this._deleteQueue.clear(), this.emit(K.COMPLETE, this, this.totalComplete, this.totalFailed);
        }, flagForRemoval: function(R) {
          this._deleteQueue.set(R);
        }, saveJSON: function(R, Y) {
          return this.save(JSON.stringify(R), Y);
        }, save: function(R, Y, I) {
          if (Y === undefined)
            Y = "file.json";
          if (I === undefined)
            I = "application/json";
          var P = new Blob([R], { type: I }), X = URL.createObjectURL(P), G = document.createElement("a");
          return G.download = Y, G.textContent = "Download " + Y, G.href = X, G.click(), this;
        }, reset: function() {
          this.list.clear(), this.inflight.clear(), this.queue.clear();
          var R = this.systems.game.config, Y = this.systems.settings.loader;
          this.setBaseURL(Z(Y, "baseURL", R.loaderBaseURL)), this.setPath(Z(Y, "path", R.loaderPath)), this.setPrefix(Z(Y, "prefix", R.loaderPrefix)), this.state = L.LOADER_IDLE;
        }, shutdown: function() {
          this.reset(), this.state = L.LOADER_SHUTDOWN, this.removeAllListeners(), this.systems.events.off(H.UPDATE, this.update, this), this.systems.events.off(H.SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          this.shutdown(), this.state = L.LOADER_DESTROYED, this.systems.events.off(H.UPDATE, this.update, this), this.systems.events.off(H.START, this.pluginStart, this), this.list = null, this.inflight = null, this.queue = null, this.scene = null, this.systems = null, this.textureManager = null, this.cacheManager = null, this.sceneManager = null;
        } });
        Q.register("Loader", W, "load"), M.exports = W;
      }, 3374: (M, B, $) => {
        var E = $(79291), L = $(92638), z = function(U, K) {
          var J = U === undefined ? L() : E({}, U);
          if (K) {
            for (var Z in K)
              if (K[Z] !== undefined)
                J[Z] = K[Z];
          }
          return J;
        };
        M.exports = z;
      }, 26430: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(54899), U = new E({ initialize: function K(J, Z, D, Q) {
          var H = [];
          Q.forEach(function(R) {
            if (R)
              H.push(R);
          }), this.loader = J, this.type = Z, this.key = D;
          var N = this.key;
          if (J.prefix && J.prefix !== "")
            this.key = J.prefix + N;
          this.multiKeyIndex = J.multiKeyIndex++, this.files = H, this.state = L.FILE_PENDING, this.complete = false, this.pending = H.length, this.failed = 0, this.config = {}, this.baseURL = J.baseURL, this.path = J.path, this.prefix = J.prefix;
          for (var W = 0;W < H.length; W++)
            H[W].multiFile = this;
        }, isReadyToProcess: function() {
          return this.pending === 0 && this.failed === 0 && !this.complete;
        }, addToMultiFile: function(K) {
          return this.files.push(K), K.multiFile = this, this.pending++, this.complete = false, this;
        }, onFileComplete: function(K) {
          var J = this.files.indexOf(K);
          if (J !== -1)
            this.pending--;
        }, onFileFailed: function(K) {
          var J = this.files.indexOf(K);
          if (J !== -1)
            this.failed++, console.error('File failed: %s "%s" (via %s "%s")', this.type, this.key, K.type, K.key);
        }, pendingDestroy: function() {
          if (this.state === L.FILE_PENDING_DESTROY)
            return;
          var K = this.key, J = this.type;
          this.loader.emit(z.FILE_COMPLETE, K, J), this.loader.emit(z.FILE_KEY_COMPLETE + J + "-" + K, K, J), this.loader.flagForRemoval(this);
          for (var Z = 0;Z < this.files.length; Z++)
            this.files[Z].pendingDestroy();
          this.state = L.FILE_PENDING_DESTROY;
        }, destroy: function() {
          this.loader = null, this.files = null, this.config = null;
        } });
        M.exports = U;
      }, 84376: (M, B, $) => {
        var E = $(3374), L = function(z, U) {
          var K = E(U, z.xhrSettings);
          if (z.base64) {
            var J = z.url.split(";base64,").pop() || z.url.split(",").pop(), Z = { responseText: atob(J) };
            z.onBase64Load(Z);
            return;
          }
          var D = new XMLHttpRequest;
          if (D.open("GET", z.src, K.async, K.user, K.password), D.responseType = z.xhrSettings.responseType, D.timeout = K.timeout, K.headers)
            for (var Q in K.headers)
              D.setRequestHeader(Q, K.headers[Q]);
          if (K.header && K.headerValue)
            D.setRequestHeader(K.header, K.headerValue);
          if (K.requestedWith)
            D.setRequestHeader("X-Requested-With", K.requestedWith);
          if (K.overrideMimeType)
            D.overrideMimeType(K.overrideMimeType);
          if (K.withCredentials)
            D.withCredentials = true;
          return D.onload = z.onLoad.bind(z, D), D.onerror = z.onError.bind(z, D), D.onprogress = z.onProgress.bind(z), D.ontimeout = z.onError.bind(z, D), D.send(), D;
        };
        M.exports = L;
      }, 92638: (M) => {
        var B = function($, E, L, z, U, K) {
          if ($ === undefined)
            $ = "";
          if (E === undefined)
            E = true;
          if (L === undefined)
            L = "";
          if (z === undefined)
            z = "";
          if (U === undefined)
            U = 0;
          if (K === undefined)
            K = false;
          return { responseType: $, async: E, user: L, password: z, timeout: U, headers: undefined, header: undefined, headerValue: undefined, requestedWith: false, overrideMimeType: undefined, withCredentials: K };
        };
        M.exports = B;
      }, 23906: (M) => {
        var B = { LOADER_IDLE: 0, LOADER_LOADING: 1, LOADER_PROCESSING: 2, LOADER_COMPLETE: 3, LOADER_SHUTDOWN: 4, LOADER_DESTROYED: 5, FILE_PENDING: 10, FILE_LOADING: 11, FILE_LOADED: 12, FILE_FAILED: 13, FILE_PROCESSING: 14, FILE_ERRORED: 16, FILE_COMPLETE: 17, FILE_DESTROYED: 18, FILE_POPULATED: 19, FILE_PENDING_DESTROY: 20 };
        M.exports = B;
      }, 42155: (M) => {
        M.exports = "addfile";
      }, 38991: (M) => {
        M.exports = "complete";
      }, 27540: (M) => {
        M.exports = "filecomplete";
      }, 87464: (M) => {
        M.exports = "filecomplete-";
      }, 94486: (M) => {
        M.exports = "loaderror";
      }, 13035: (M) => {
        M.exports = "load";
      }, 38144: (M) => {
        M.exports = "fileprogress";
      }, 97520: (M) => {
        M.exports = "postprocess";
      }, 85595: (M) => {
        M.exports = "progress";
      }, 55680: (M) => {
        M.exports = "start";
      }, 54899: (M, B, $) => {
        M.exports = { ADD: $(42155), COMPLETE: $(38991), FILE_COMPLETE: $(27540), FILE_KEY_COMPLETE: $(87464), FILE_LOAD_ERROR: $(94486), FILE_LOAD: $(13035), FILE_PROGRESS: $(38144), POST_PROCESS: $(97520), PROGRESS: $(85595), START: $(55680) };
      }, 14135: (M, B, $) => {
        var E = $(83419), L = $(74099), z = $(518), U = $(54899), K = new E({ Extends: z, initialize: function J(Z, D, Q, H, N) {
          z.call(this, Z, D, Q, H, N), this.type = "animationJSON";
        }, onProcess: function() {
          this.loader.once(U.POST_PROCESS, this.onLoadComplete, this), z.prototype.onProcess.call(this);
        }, onLoadComplete: function() {
          this.loader.systems.anims.fromJSON(this.data);
        } });
        L.register("animation", function(J, Z, D, Q) {
          if (Array.isArray(J))
            for (var H = 0;H < J.length; H++)
              this.addFile(new K(this, J[H]));
          else
            this.addFile(new K(this, J, Z, Q, D));
          return this;
        }), M.exports = K;
      }, 76272: (M, B, $) => {
        var E = $(83419), L = $(74099), z = $(95540), U = $(19550), K = $(41212), J = $(518), Z = $(26430), D = new E({ Extends: Z, initialize: function Q(H, N, W, R, Y, I) {
          var P, X;
          if (K(N)) {
            var G = N;
            N = z(G, "key"), P = new U(H, { key: N, url: z(G, "textureURL"), extension: z(G, "textureExtension", "png"), normalMap: z(G, "normalMap"), xhrSettings: z(G, "textureXhrSettings") }), X = new J(H, { key: N, url: z(G, "atlasURL"), extension: z(G, "atlasExtension", "json"), xhrSettings: z(G, "atlasXhrSettings") });
          } else
            P = new U(H, N, W, Y), X = new J(H, N, R, I);
          if (P.linkFile)
            Z.call(this, H, "atlasjson", N, [P, X, P.linkFile]);
          else
            Z.call(this, H, "atlasjson", N, [P, X]);
        }, addToCache: function() {
          if (this.isReadyToProcess()) {
            var Q = this.files[0], H = this.files[1], N = this.files[2] ? this.files[2].data : null;
            this.loader.textureManager.addAtlas(Q.key, Q.data, H.data, N), H.addToCache(), this.complete = true;
          }
        } });
        L.register("aseprite", function(Q, H, N, W, R) {
          var Y;
          if (Array.isArray(Q))
            for (var I = 0;I < Q.length; I++)
              Y = new D(this, Q[I]), this.addFile(Y.files);
          else
            Y = new D(this, Q, H, N, W, R), this.addFile(Y.files);
          return this;
        }), M.exports = D;
      }, 38734: (M, B, $) => {
        var E = $(83419), L = $(74099), z = $(95540), U = $(19550), K = $(41212), J = $(518), Z = $(26430), D = new E({ Extends: Z, initialize: function Q(H, N, W, R, Y, I) {
          var P, X;
          if (K(N)) {
            var G = N;
            N = z(G, "key"), P = new U(H, { key: N, url: z(G, "textureURL"), extension: z(G, "textureExtension", "png"), normalMap: z(G, "normalMap"), xhrSettings: z(G, "textureXhrSettings") }), X = new J(H, { key: N, url: z(G, "atlasURL"), extension: z(G, "atlasExtension", "json"), xhrSettings: z(G, "atlasXhrSettings") });
          } else
            P = new U(H, N, W, Y), X = new J(H, N, R, I);
          if (P.linkFile)
            Z.call(this, H, "atlasjson", N, [P, X, P.linkFile]);
          else
            Z.call(this, H, "atlasjson", N, [P, X]);
        }, addToCache: function() {
          if (this.isReadyToProcess()) {
            var Q = this.files[0], H = this.files[1], N = this.files[2] ? this.files[2].data : null;
            this.loader.textureManager.addAtlas(Q.key, Q.data, H.data, N), this.complete = true;
          }
        } });
        L.register("atlas", function(Q, H, N, W, R) {
          var Y;
          if (Array.isArray(Q))
            for (var I = 0;I < Q.length; I++)
              Y = new D(this, Q[I]), this.addFile(Y.files);
          else
            Y = new D(this, Q, H, N, W, R), this.addFile(Y.files);
          return this;
        }), M.exports = D;
      }, 74599: (M, B, $) => {
        var E = $(83419), L = $(74099), z = $(95540), U = $(19550), K = $(41212), J = $(26430), Z = $(57318), D = new E({ Extends: J, initialize: function Q(H, N, W, R, Y, I) {
          var P, X;
          if (K(N)) {
            var G = N;
            N = z(G, "key"), P = new U(H, { key: N, url: z(G, "textureURL"), extension: z(G, "textureExtension", "png"), normalMap: z(G, "normalMap"), xhrSettings: z(G, "textureXhrSettings") }), X = new Z(H, { key: N, url: z(G, "atlasURL"), extension: z(G, "atlasExtension", "xml"), xhrSettings: z(G, "atlasXhrSettings") });
          } else
            P = new U(H, N, W, Y), X = new Z(H, N, R, I);
          if (P.linkFile)
            J.call(this, H, "atlasxml", N, [P, X, P.linkFile]);
          else
            J.call(this, H, "atlasxml", N, [P, X]);
        }, addToCache: function() {
          if (this.isReadyToProcess()) {
            var Q = this.files[0], H = this.files[1], N = this.files[2] ? this.files[2].data : null;
            this.loader.textureManager.addAtlasXML(Q.key, Q.data, H.data, N), this.complete = true;
          }
        } });
        L.register("atlasXML", function(Q, H, N, W, R) {
          var Y;
          if (Array.isArray(Q))
            for (var I = 0;I < Q.length; I++)
              Y = new D(this, Q[I]), this.addFile(Y.files);
          else
            Y = new D(this, Q, H, N, W, R), this.addFile(Y.files);
          return this;
        }), M.exports = D;
      }, 21097: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(95540), J = $(89749), Z = $(41212), D = new E({ Extends: z, initialize: function Q(H, N, W, R, Y) {
          if (Z(N)) {
            var I = N;
            N = K(I, "key"), R = K(I, "xhrSettings"), Y = K(I, "context", Y);
          }
          var P = { type: "audio", cache: H.cacheManager.audio, extension: W.type, responseType: "arraybuffer", key: N, url: W.url, xhrSettings: R, config: { context: Y } };
          z.call(this, H, P);
        }, onProcess: function() {
          this.state = L.FILE_PROCESSING;
          var Q = this;
          this.config.context.decodeAudioData(this.xhrLoader.response, function(H) {
            Q.data = H, Q.onProcessComplete();
          }, function(H) {
            console.error("Error decoding audio: " + Q.key + " - ", H ? H.message : null), Q.onProcessError();
          }), this.config.context = null;
        } });
        D.create = function(Q, H, N, W, R) {
          var Y = Q.systems.game, I = Y.config.audio, P = Y.device.audio;
          if (Z(H))
            N = K(H, "url", []), W = K(H, "config", {});
          var X = D.getAudioURL(Y, N);
          if (!X)
            return console.warn('No audio URLs for "%s" matched this device', H), null;
          if (P.webAudio && !I.disableWebAudio)
            return new D(Q, H, X, R, Y.sound.context);
          else
            return new J(Q, H, X, W);
        }, D.getAudioURL = function(Q, H) {
          if (!Array.isArray(H))
            H = [H];
          for (var N = 0;N < H.length; N++) {
            var W = K(H[N], "url", H[N]);
            if (W.indexOf("blob:") === 0 || W.indexOf("data:") === 0)
              return { url: W, type: "" };
            var R = W.match(/\.([a-zA-Z0-9]+)($|\?)/);
            if (R = K(H[N], "type", R ? R[1] : "").toLowerCase(), Q.device.audio[R])
              return { url: W, type: R };
          }
          return null;
        }, U.register("audio", function(Q, H, N, W) {
          var R = this.systems.game, Y = R.config.audio, I = R.device.audio;
          if (Y.noAudio || !I.webAudio && !I.audioData)
            return this;
          var P;
          if (Array.isArray(Q)) {
            for (var X = 0;X < Q.length; X++)
              if (P = D.create(this, Q[X]), P)
                this.addFile(P);
          } else if (P = D.create(this, Q, H, N, W), P)
            this.addFile(P);
          return this;
        }), M.exports = D;
      }, 89524: (M, B, $) => {
        var E = $(21097), L = $(83419), z = $(74099), U = $(95540), K = $(41212), J = $(518), Z = $(26430), D = new L({ Extends: Z, initialize: function Q(H, N, W, R, Y, I, P) {
          if (K(N)) {
            var X = N;
            N = U(X, "key"), W = U(X, "jsonURL"), R = U(X, "audioURL"), Y = U(X, "audioConfig"), I = U(X, "audioXhrSettings"), P = U(X, "jsonXhrSettings");
          }
          var G;
          if (!R)
            G = new J(H, N, W, P), Z.call(this, H, "audiosprite", N, [G]), this.config.resourceLoad = true, this.config.audioConfig = Y, this.config.audioXhrSettings = I;
          else {
            var V = E.create(H, N, R, Y, I);
            if (V)
              G = new J(H, N, W, P), Z.call(this, H, "audiosprite", N, [V, G]), this.config.resourceLoad = false;
          }
        }, onFileComplete: function(Q) {
          var H = this.files.indexOf(Q);
          if (H !== -1) {
            if (this.pending--, this.config.resourceLoad && Q.type === "json" && Q.data.hasOwnProperty("resources")) {
              var N = Q.data.resources, W = U(this.config, "audioConfig"), R = U(this.config, "audioXhrSettings"), Y = E.create(this.loader, Q.key, N, W, R);
              if (Y)
                this.addToMultiFile(Y), this.loader.addFile(Y);
            }
          }
        }, addToCache: function() {
          if (this.isReadyToProcess()) {
            var Q = this.files[0], H = this.files[1];
            Q.addToCache(), H.addToCache(), this.complete = true;
          }
        } });
        z.register("audioSprite", function(Q, H, N, W, R, Y) {
          var I = this.systems.game, P = I.config.audio, X = I.device.audio;
          if (P && P.noAudio || !X.webAudio && !X.audioData)
            return this;
          var G;
          if (Array.isArray(Q)) {
            for (var V = 0;V < Q.length; V++)
              if (G = new D(this, Q[V]), G.files)
                this.addFile(G.files);
          } else if (G = new D(this, Q, H, N, W, R, Y), G.files)
            this.addFile(G.files);
          return this;
        });
      }, 85722: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(95540), J = $(41212), Z = new E({ Extends: z, initialize: function D(Q, H, N, W, R) {
          var Y = "bin";
          if (J(H)) {
            var I = H;
            H = K(I, "key"), N = K(I, "url"), W = K(I, "xhrSettings"), Y = K(I, "extension", Y), R = K(I, "dataType", R);
          }
          var P = { type: "binary", cache: Q.cacheManager.binary, extension: Y, responseType: "arraybuffer", key: H, url: N, xhrSettings: W, config: { dataType: R } };
          z.call(this, Q, P);
        }, onProcess: function() {
          this.state = L.FILE_PROCESSING;
          var D = this.config.dataType;
          this.data = D ? new D(this.xhrLoader.response) : this.xhrLoader.response, this.onProcessComplete();
        } });
        U.register("binary", function(D, Q, H, N) {
          if (Array.isArray(D))
            for (var W = 0;W < D.length; W++)
              this.addFile(new Z(this, D[W]));
          else
            this.addFile(new Z(this, D, Q, N, H));
          return this;
        }), M.exports = Z;
      }, 97025: (M, B, $) => {
        var E = $(83419), L = $(74099), z = $(95540), U = $(19550), K = $(41212), J = $(26430), Z = $(21859), D = $(57318), Q = new E({ Extends: J, initialize: function H(N, W, R, Y, I, P) {
          var X, G;
          if (K(W)) {
            var V = W;
            W = z(V, "key"), X = new U(N, { key: W, url: z(V, "textureURL"), extension: z(V, "textureExtension", "png"), normalMap: z(V, "normalMap"), xhrSettings: z(V, "textureXhrSettings") }), G = new D(N, { key: W, url: z(V, "fontDataURL"), extension: z(V, "fontDataExtension", "xml"), xhrSettings: z(V, "fontDataXhrSettings") });
          } else
            X = new U(N, W, R, I), G = new D(N, W, Y, P);
          if (X.linkFile)
            J.call(this, N, "bitmapfont", W, [X, G, X.linkFile]);
          else
            J.call(this, N, "bitmapfont", W, [X, G]);
        }, addToCache: function() {
          if (this.isReadyToProcess()) {
            var H = this.files[0], N = this.files[1];
            H.addToCache();
            var W = H.cache.get(H.key), R = Z(N.data, H.cache.getFrame(H.key), 0, 0, W);
            this.loader.cacheManager.bitmapFont.add(H.key, { data: R, texture: H.key, frame: null }), this.complete = true;
          }
        } });
        L.register("bitmapFont", function(H, N, W, R, Y) {
          var I;
          if (Array.isArray(H))
            for (var P = 0;P < H.length; P++)
              I = new Q(this, H[P]), this.addFile(I.files);
          else
            I = new Q(this, H, N, W, R, Y), this.addFile(I.files);
          return this;
        }), M.exports = Q;
      }, 16024: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(95540), J = $(41212), Z = new E({ Extends: z, initialize: function D(Q, H, N, W) {
          var R = "css";
          if (J(H)) {
            var Y = H;
            H = K(Y, "key"), N = K(Y, "url"), W = K(Y, "xhrSettings"), R = K(Y, "extension", R);
          }
          var I = { type: "script", cache: false, extension: R, responseType: "text", key: H, url: N, xhrSettings: W };
          z.call(this, Q, I);
        }, onProcess: function() {
          this.state = L.FILE_PROCESSING, this.data = document.createElement("style"), this.data.defer = false, this.data.innerHTML = this.xhrLoader.responseText, document.head.appendChild(this.data), this.onProcessComplete();
        } });
        U.register("css", function(D, Q, H) {
          if (Array.isArray(D))
            for (var N = 0;N < D.length; N++)
              this.addFile(new Z(this, D[N]));
          else
            this.addFile(new Z(this, D, Q, H));
          return this;
        }), M.exports = Z;
      }, 69559: (M, B, $) => {
        var E = $(38734), L = $(85722), z = $(83419), U = $(74099), K = $(95540), J = $(19550), Z = $(41212), D = $(518), Q = $(31403), H = $(46975), N = $(59327), W = $(26430), R = $(82038), Y = $(55222), I = new z({ Extends: W, initialize: function P(X, G, V, A) {
          if (V.multiAtlasURL) {
            var F = new D(X, { key: G, url: V.multiAtlasURL, xhrSettings: A, config: V });
            W.call(this, X, "texture", G, [F]);
          } else {
            var j = V.textureURL.substr(V.textureURL.length - 3);
            if (!V.type)
              V.type = j.toLowerCase() === "ktx" ? "KTX" : "PVR";
            var T = new L(X, { key: G, url: V.textureURL, extension: j, xhrSettings: A, config: V });
            if (V.atlasURL) {
              var C = new D(X, { key: G, url: V.atlasURL, xhrSettings: A, config: V });
              W.call(this, X, "texture", G, [T, C]);
            } else
              W.call(this, X, "texture", G, [T]);
          }
          this.config = V;
        }, onFileComplete: function(P) {
          var X = this.files.indexOf(P);
          if (X !== -1) {
            if (this.pending--, !this.config.multiAtlasURL)
              return;
            if (P.type === "json" && P.data.hasOwnProperty("textures")) {
              var G = P.data.textures, V = this.config, A = this.loader, F = A.baseURL, j = A.path, T = A.prefix, C = K(V, "multiBaseURL", this.baseURL), v = K(V, "multiPath", this.path), O = K(V, "prefix", this.prefix), q = K(V, "textureXhrSettings");
              if (C)
                A.setBaseURL(C);
              if (v)
                A.setPath(v);
              if (O)
                A.setPrefix(O);
              for (var w = 0;w < G.length; w++) {
                var g = G[w].image, b = "CMA" + this.multiKeyIndex + "_" + g, x = new L(A, b, g, q);
                if (this.addToMultiFile(x), A.addFile(x), G[w].normalMap) {
                  var k = new L(A, b, G[w].normalMap, q);
                  k.type = "normalMap", x.setLink(k), this.addToMultiFile(k), A.addFile(k);
                }
              }
              A.setBaseURL(F), A.setPath(j), A.setPrefix(T);
            }
          }
        }, addToCache: function() {
          function P(C) {
            console.warn('Compressed Texture Invalid: "' + F.key + '". ' + C);
          }
          if (this.isReadyToProcess()) {
            var X = this.config;
            if (X.multiAtlasURL)
              this.addMultiToCache();
            else {
              var G = this.loader.systems.renderer, V = this.loader.textureManager, A, F = this.files[0], j = this.files[1];
              if (X.type === "PVR")
                A = R(F.data);
              else if (X.type === "KTX") {
                if (A = Q(F.data), !A)
                  P("KTX file contains unsupported format.");
              }
              if (A && !Y(A))
                P("Texture dimensions failed verification. Check the texture format specifications for " + X.format + " 0x" + A.internalFormat.toString(16) + "."), A = null;
              if (A && !G.supportsCompressedTexture(X.format, A.internalFormat))
                P("Texture format " + X.format + " with internal format " + A.internalFormat + " not supported by the GPU. Texture invalid. This is often due to the texture using sRGB instead of linear RGB."), A = null;
              if (A) {
                A.format = G.getCompressedTextureName(X.format, A.internalFormat);
                var T = j && j.data ? j.data : null;
                V.addCompressedTexture(F.key, A, T);
              }
            }
            this.complete = true;
          }
        }, addMultiToCache: function() {
          var P = this.config, X = this.files[0], G = [], V = [], A = [], F = this.loader.systems.renderer, j = this.loader.textureManager, T;
          for (var C = 1;C < this.files.length; C++) {
            var v = this.files[C];
            if (v.type === "normalMap")
              continue;
            var O = v.key.indexOf("_"), q = v.key.substr(O + 1), w = v.data;
            for (var g = 0;g < X.data.textures.length; g++) {
              var b = X.data.textures[g];
              if (b.image === q) {
                if (P.type === "PVR")
                  T = R(w);
                else if (P.type === "KTX")
                  T = Q(w);
                if (T && F.supportsCompressedTexture(P.format, T.internalFormat)) {
                  if (T.format = F.getCompressedTextureName(P.format, T.internalFormat), V.push(T), G.push(b), v.linkFile)
                    A.push(v.linkFile.data);
                }
                break;
              }
            }
          }
          if (A.length === 0)
            A = undefined;
          j.addAtlasJSONArray(this.key, V, G, A), this.complete = true;
        } });
        U.register("texture", function(P, X, G) {
          var V = this.systems.renderer, A = function(j, T, C, v) {
            var O = { format: null, type: null, textureURL: undefined, atlasURL: undefined, multiAtlasURL: undefined, multiPath: undefined, multiBaseURL: undefined };
            if (Z(T)) {
              var q = T;
              T = K(q, "key"), C = K(q, "url"), v = K(q, "xhrSettings");
            }
            var w = false;
            for (var g in C)
              if (V.supportsCompressedTexture(g)) {
                var b = C[g];
                if (typeof b === "string")
                  O.textureURL = b;
                else
                  O = H(b, O);
                O.format = g.toUpperCase(), w = true;
                break;
              }
            if (!w)
              console.warn("No supported compressed texture format or IMG fallback", T);
            else if (O.format === "IMG") {
              var x, k;
              if (O.multiAtlasURL)
                k = new N(j, T, O.multiAtlasURL, O.multiPath, O.multiBaseURL, v), x = k.files;
              else if (O.atlasURL)
                k = new E(j, T, O.textureURL, O.atlasURL, v), x = k.files;
              else
                x = new J(j, T, O.textureURL, v);
              j.addFile(x);
            } else {
              var S = new I(j, T, O, v);
              j.addFile(S.files);
            }
          };
          if (Array.isArray(P))
            for (var F = 0;F < P.length; F++)
              A(this, P[F]);
          else
            A(this, P, X, G);
          return this;
        }), M.exports = I;
      }, 47931: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(95540), J = $(41212), Z = $(73894), D = new E({ Extends: z, initialize: function Q(H, N, W, R, Y) {
          var I = "glsl";
          if (J(N)) {
            var P = N;
            N = K(P, "key"), W = K(P, "url"), R = K(P, "shaderType", "fragment"), Y = K(P, "xhrSettings"), I = K(P, "extension", I);
          } else if (R === undefined)
            R = "fragment";
          var X = { type: "glsl", cache: H.cacheManager.shader, extension: I, responseType: "text", key: N, url: W, config: { shaderType: R }, xhrSettings: Y };
          z.call(this, H, X);
        }, onProcess: function() {
          this.state = L.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete();
        }, addToCache: function() {
          var Q = this.data.split("\n"), H = this.extractBlock(Q, 0);
          if (H)
            while (H) {
              var N = this.getShaderName(H.header), W = this.getShaderType(H.header), R = this.getShaderUniforms(H.header), Y = H.shader;
              if (this.cache.has(N)) {
                var I = this.cache.get(N);
                if (W === "fragment")
                  I.fragmentSrc = Y;
                else
                  I.vertexSrc = Y;
                if (!I.uniforms)
                  I.uniforms = R;
              } else if (W === "fragment")
                this.cache.add(N, new Z(N, Y, "", R));
              else
                this.cache.add(N, new Z(N, "", Y, R));
              H = this.extractBlock(Q, H.offset);
            }
          else if (this.config.shaderType === "fragment")
            this.cache.add(this.key, new Z(this.key, this.data));
          else
            this.cache.add(this.key, new Z(this.key, "", this.data));
        }, getShaderName: function(Q) {
          for (var H = 0;H < Q.length; H++) {
            var N = Q[H].trim();
            if (N.substring(0, 5) === "name:")
              return N.substring(5).trim();
          }
          return this.key;
        }, getShaderType: function(Q) {
          for (var H = 0;H < Q.length; H++) {
            var N = Q[H].trim();
            if (N.substring(0, 5) === "type:")
              return N.substring(5).trim();
          }
          return this.config.shaderType;
        }, getShaderUniforms: function(Q) {
          var H = {};
          for (var N = 0;N < Q.length; N++) {
            var W = Q[N].trim();
            if (W.substring(0, 8) === "uniform.") {
              var R = W.indexOf(":");
              if (R) {
                var Y = W.substring(8, R);
                try {
                  H[Y] = JSON.parse(W.substring(R + 1));
                } catch (I) {
                  console.warn("Invalid uniform JSON: " + Y);
                }
              }
            }
          }
          return H;
        }, extractBlock: function(Q, H) {
          var N = -1, W = -1, R = -1, Y = false, I = false, P = [], X = [];
          for (var G = H;G < Q.length; G++) {
            var V = Q[G].trim();
            if (V === "---")
              if (N === -1)
                N = G, Y = true;
              else if (Y)
                W = G, Y = false, I = true;
              else {
                I = false;
                break;
              }
            else if (Y)
              P.push(V);
            else if (I)
              X.push(V), R = G;
          }
          if (!Y && W !== -1)
            return { header: P, shader: X.join("\n"), offset: R };
          else
            return null;
        } });
        U.register("glsl", function(Q, H, N, W) {
          if (Array.isArray(Q))
            for (var R = 0;R < Q.length; R++)
              this.addFile(new D(this, Q[R]));
          else
            this.addFile(new D(this, Q, H, N, W));
          return this;
        }), M.exports = D;
      }, 89749: (M, B, $) => {
        var E = $(83419), L = $(54899), z = $(41299), U = $(95540), K = $(98356), J = $(41212), Z = new E({ Extends: z, initialize: function D(Q, H, N, W) {
          if (J(H)) {
            var R = H;
            H = U(R, "key"), W = U(R, "config", W);
          }
          var Y = { type: "audio", cache: Q.cacheManager.audio, extension: N.type, key: H, url: N.url, config: W };
          z.call(this, Q, Y), this.locked = "ontouchstart" in window, this.loaded = false, this.filesLoaded = 0, this.filesTotal = 0;
        }, onLoad: function() {
          if (this.loaded)
            return;
          this.loaded = true, this.loader.nextFile(this, true);
        }, onError: function() {
          for (var D = 0;D < this.data.length; D++) {
            var Q = this.data[D];
            Q.oncanplaythrough = null, Q.onerror = null;
          }
          this.loader.nextFile(this, false);
        }, onProgress: function(D) {
          var Q = D.target;
          if (Q.oncanplaythrough = null, Q.onerror = null, this.filesLoaded++, this.percentComplete = Math.min(this.filesLoaded / this.filesTotal, 1), this.loader.emit(L.FILE_PROGRESS, this, this.percentComplete), this.filesLoaded === this.filesTotal)
            this.onLoad();
        }, load: function() {
          this.data = [];
          var D = this.config && this.config.instances || 1;
          this.filesTotal = D, this.filesLoaded = 0, this.percentComplete = 0;
          for (var Q = 0;Q < D; Q++) {
            var H = new Audio;
            if (!H.dataset)
              H.dataset = {};
            if (H.dataset.name = this.key + ("0" + Q).slice(-2), H.dataset.used = "false", this.locked)
              H.dataset.locked = "true";
            else
              H.dataset.locked = "false", H.preload = "auto", H.oncanplaythrough = this.onProgress.bind(this), H.onerror = this.onError.bind(this);
            this.data.push(H);
          }
          for (Q = 0;Q < this.data.length; Q++)
            if (H = this.data[Q], H.src = K(this, this.loader.baseURL), !this.locked)
              H.load();
          if (this.locked)
            setTimeout(this.onLoad.bind(this));
        } });
        M.exports = Z;
      }, 88470: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(95540), J = $(41212), Z = new E({ Extends: z, initialize: function D(Q, H, N, W) {
          var R = "html";
          if (J(H)) {
            var Y = H;
            H = K(Y, "key"), N = K(Y, "url"), W = K(Y, "xhrSettings"), R = K(Y, "extension", R);
          }
          var I = { type: "text", cache: Q.cacheManager.html, extension: R, responseType: "text", key: H, url: N, xhrSettings: W };
          z.call(this, Q, I);
        }, onProcess: function() {
          this.state = L.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete();
        } });
        U.register("html", function(D, Q, H) {
          if (Array.isArray(D))
            for (var N = 0;N < D.length; N++)
              this.addFile(new Z(this, D[N]));
          else
            this.addFile(new Z(this, D, Q, H));
          return this;
        }), M.exports = Z;
      }, 14643: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(95540), J = $(41212), Z = new E({ Extends: z, initialize: function D(Q, H, N, W, R, Y) {
          if (W === undefined)
            W = 512;
          if (R === undefined)
            R = 512;
          var I = "html";
          if (J(H)) {
            var P = H;
            H = K(P, "key"), N = K(P, "url"), Y = K(P, "xhrSettings"), I = K(P, "extension", I), W = K(P, "width", W), R = K(P, "height", R);
          }
          var X = { type: "html", cache: Q.textureManager, extension: I, responseType: "text", key: H, url: N, xhrSettings: Y, config: { width: W, height: R } };
          z.call(this, Q, X);
        }, onProcess: function() {
          this.state = L.FILE_PROCESSING;
          var D = this.config.width, Q = this.config.height, H = [];
          H.push('<svg width="' + D + 'px" height="' + Q + 'px" viewBox="0 0 ' + D + " " + Q + '" xmlns="http://www.w3.org/2000/svg">'), H.push('<foreignObject width="100%" height="100%">'), H.push('<body xmlns="http://www.w3.org/1999/xhtml">'), H.push(this.xhrLoader.responseText), H.push("</body>"), H.push("</foreignObject>"), H.push("</svg>");
          var N = [H.join("\n")], W = this;
          try {
            var R = new window.Blob(N, { type: "image/svg+xml;charset=utf-8" });
          } catch (Y) {
            W.state = L.FILE_ERRORED, W.onProcessComplete();
            return;
          }
          this.data = new Image, this.data.crossOrigin = this.crossOrigin, this.data.onload = function() {
            z.revokeObjectURL(W.data), W.onProcessComplete();
          }, this.data.onerror = function() {
            z.revokeObjectURL(W.data), W.onProcessError();
          }, z.createObjectURL(this.data, R, "image/svg+xml");
        }, addToCache: function() {
          this.cache.addImage(this.key, this.data);
        } });
        U.register("htmlTexture", function(D, Q, H, N, W) {
          if (Array.isArray(D))
            for (var R = 0;R < D.length; R++)
              this.addFile(new Z(this, D[R]));
          else
            this.addFile(new Z(this, D, Q, H, N, W));
          return this;
        }), M.exports = Z;
      }, 19550: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(95540), J = $(41212), Z = $(98356), D = new E({ Extends: z, initialize: function Q(H, N, W, R, Y) {
          var I = "png", P;
          if (J(N)) {
            var X = N;
            N = K(X, "key"), W = K(X, "url"), P = K(X, "normalMap"), R = K(X, "xhrSettings"), I = K(X, "extension", I), Y = K(X, "frameConfig");
          }
          if (Array.isArray(W))
            P = W[1], W = W[0];
          var G = { type: "image", cache: H.textureManager, extension: I, responseType: "blob", key: N, url: W, xhrSettings: R, config: Y };
          if (z.call(this, H, G), P) {
            var V = new Q(H, this.key, P, R, Y);
            V.type = "normalMap", this.setLink(V), H.addFile(V);
          }
          if (this.useImageElementLoad = H.imageLoadType === "HTMLImageElement" || this.base64, this.useImageElementLoad)
            this.load = this.loadImage, this.onProcess = this.onProcessImage;
        }, onProcess: function() {
          this.state = L.FILE_PROCESSING, this.data = new Image, this.data.crossOrigin = this.crossOrigin;
          var Q = this;
          this.data.onload = function() {
            z.revokeObjectURL(Q.data), Q.onProcessComplete();
          }, this.data.onerror = function() {
            z.revokeObjectURL(Q.data), Q.onProcessError();
          }, z.createObjectURL(this.data, this.xhrLoader.response, "image/png");
        }, onProcessImage: function() {
          var Q = this.state;
          if (this.state = L.FILE_PROCESSING, Q === L.FILE_LOADED)
            this.onProcessComplete();
          else
            this.onProcessError();
        }, loadImage: function() {
          this.state = L.FILE_LOADING, this.src = Z(this, this.loader.baseURL), this.data = new Image, this.data.crossOrigin = this.crossOrigin;
          var Q = this;
          this.data.onload = function() {
            Q.state = L.FILE_LOADED, Q.loader.nextFile(Q, true);
          }, this.data.onerror = function() {
            Q.loader.nextFile(Q, false);
          }, this.data.src = this.src;
        }, addToCache: function() {
          var Q = this.linkFile;
          if (Q) {
            if (Q.state >= L.FILE_COMPLETE)
              if (Q.type === "spritesheet")
                Q.addToCache();
              else if (this.type === "normalMap")
                this.cache.addImage(this.key, Q.data, this.data);
              else
                this.cache.addImage(this.key, this.data, Q.data);
          } else
            this.cache.addImage(this.key, this.data);
        } });
        U.register("image", function(Q, H, N) {
          if (Array.isArray(Q))
            for (var W = 0;W < Q.length; W++)
              this.addFile(new D(this, Q[W]));
          else
            this.addFile(new D(this, Q, H, N));
          return this;
        }), M.exports = D;
      }, 518: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(95540), J = $(35154), Z = $(41212), D = new E({ Extends: z, initialize: function Q(H, N, W, R, Y) {
          var I = "json";
          if (Z(N)) {
            var P = N;
            N = K(P, "key"), W = K(P, "url"), R = K(P, "xhrSettings"), I = K(P, "extension", I), Y = K(P, "dataKey", Y);
          }
          var X = { type: "json", cache: H.cacheManager.json, extension: I, responseType: "text", key: N, url: W, xhrSettings: R, config: Y };
          if (z.call(this, H, X), Z(W)) {
            if (Y)
              this.data = J(W, Y);
            else
              this.data = W;
            this.state = L.FILE_POPULATED;
          }
        }, onProcess: function() {
          if (this.state !== L.FILE_POPULATED) {
            this.state = L.FILE_PROCESSING;
            try {
              var Q = JSON.parse(this.xhrLoader.responseText);
            } catch (N) {
              throw this.onProcessError(), N;
            }
            var H = this.config;
            if (typeof H === "string")
              this.data = J(Q, H, Q);
            else
              this.data = Q;
          }
          this.onProcessComplete();
        } });
        U.register("json", function(Q, H, N, W) {
          if (Array.isArray(Q))
            for (var R = 0;R < Q.length; R++)
              this.addFile(new D(this, Q[R]));
          else
            this.addFile(new D(this, Q, H, W, N));
          return this;
        }), M.exports = D;
      }, 59327: (M, B, $) => {
        var E = $(83419), L = $(74099), z = $(95540), U = $(19550), K = $(41212), J = $(518), Z = $(26430), D = new E({ Extends: Z, initialize: function Q(H, N, W, R, Y, I, P) {
          if (K(N)) {
            var X = N;
            if (N = z(X, "key"), z(X, "url", false))
              W = z(X, "url");
            else
              W = z(X, "atlasURL");
            I = z(X, "xhrSettings"), R = z(X, "path"), Y = z(X, "baseURL"), P = z(X, "textureXhrSettings");
          }
          var G = new J(H, N, W, I);
          Z.call(this, H, "multiatlas", N, [G]), this.config.path = R, this.config.baseURL = Y, this.config.textureXhrSettings = P;
        }, onFileComplete: function(Q) {
          var H = this.files.indexOf(Q);
          if (H !== -1) {
            if (this.pending--, Q.type === "json" && Q.data.hasOwnProperty("textures")) {
              var N = Q.data.textures, W = this.config, R = this.loader, Y = R.baseURL, I = R.path, P = R.prefix, X = z(W, "baseURL", this.baseURL), G = z(W, "path", this.path), V = z(W, "prefix", this.prefix), A = z(W, "textureXhrSettings");
              R.setBaseURL(X), R.setPath(G), R.setPrefix(V);
              for (var F = 0;F < N.length; F++) {
                var j = N[F].image, T = "MA" + this.multiKeyIndex + "_" + j, C = new U(R, T, j, A);
                if (this.addToMultiFile(C), R.addFile(C), N[F].normalMap) {
                  var v = new U(R, T, N[F].normalMap, A);
                  v.type = "normalMap", C.setLink(v), this.addToMultiFile(v), R.addFile(v);
                }
              }
              R.setBaseURL(Y), R.setPath(I), R.setPrefix(P);
            }
          }
        }, addToCache: function() {
          if (this.isReadyToProcess()) {
            var Q = this.files[0], H = [], N = [], W = [];
            for (var R = 1;R < this.files.length; R++) {
              var Y = this.files[R];
              if (Y.type === "normalMap")
                continue;
              var I = Y.key.indexOf("_"), P = Y.key.substr(I + 1), X = Y.data;
              for (var G = 0;G < Q.data.textures.length; G++) {
                var V = Q.data.textures[G];
                if (V.image === P) {
                  if (N.push(X), H.push(V), Y.linkFile)
                    W.push(Y.linkFile.data);
                  break;
                }
              }
            }
            if (W.length === 0)
              W = undefined;
            this.loader.textureManager.addAtlasJSONArray(this.key, N, H, W), this.complete = true;
          }
        } });
        L.register("multiatlas", function(Q, H, N, W, R) {
          var Y;
          if (Array.isArray(Q))
            for (var I = 0;I < Q.length; I++)
              Y = new D(this, Q[I]), this.addFile(Y.files);
          else
            Y = new D(this, Q, H, N, W, R), this.addFile(Y.files);
          return this;
        }), M.exports = D;
      }, 99297: (M, B, $) => {
        var E = $(83419), L = $(74099), z = $(95540), U = $(41212), K = $(26430), J = $(34328), Z = new E({ Extends: K, initialize: function D(Q, H, N, W) {
          var R = "js", Y = [];
          if (U(H)) {
            var I = H;
            H = z(I, "key"), N = z(I, "url"), W = z(I, "xhrSettings"), R = z(I, "extension", R);
          }
          if (!Array.isArray(N))
            N = [N];
          for (var P = 0;P < N.length; P++) {
            var X = new J(Q, { key: H + "_" + P.toString(), url: N[P], extension: R, xhrSettings: W });
            X.onProcess = function() {
              this.onProcessComplete();
            }, Y.push(X);
          }
          K.call(this, Q, "scripts", H, Y);
        }, addToCache: function() {
          if (this.isReadyToProcess()) {
            for (var D = 0;D < this.files.length; D++) {
              var Q = this.files[D];
              Q.data = document.createElement("script"), Q.data.language = "javascript", Q.data.type = "text/javascript", Q.data.defer = false, Q.data.text = Q.xhrLoader.responseText, document.head.appendChild(Q.data);
            }
            this.complete = true;
          }
        } });
        L.register("scripts", function(D, Q, H) {
          var N;
          if (Array.isArray(D))
            for (var W = 0;W < D.length; W++)
              N = new Z(this, D[W]), this.addFile(N.files);
          else
            N = new Z(this, D, Q, H), this.addFile(N.files);
          return this;
        }), M.exports = Z;
      }, 41846: (M, B, $) => {
        var E = $(83419), L = $(74099), z = $(95540), U = $(41212), K = $(26430), J = $(85048), Z = $(61485), D = $(78776), Q = new E({ Extends: K, initialize: function H(N, W, R, Y, I, P) {
          var X, G, V = N.cacheManager.obj;
          if (U(W)) {
            var A = W;
            if (W = z(A, "key"), X = new D(N, { key: W, type: "obj", cache: V, url: z(A, "url"), extension: z(A, "extension", "obj"), xhrSettings: z(A, "xhrSettings"), config: { flipUV: z(A, "flipUV", I) } }), Y = z(A, "matURL"), Y)
              G = new D(N, { key: W, type: "mat", cache: V, url: Y, extension: z(A, "matExtension", "mat"), xhrSettings: z(A, "xhrSettings") });
          } else if (X = new D(N, { key: W, url: R, type: "obj", cache: V, extension: "obj", xhrSettings: P, config: { flipUV: I } }), Y)
            G = new D(N, { key: W, url: Y, type: "mat", cache: V, extension: "mat", xhrSettings: P });
          K.call(this, N, "obj", W, [X, G]);
        }, addToCache: function() {
          if (this.isReadyToProcess()) {
            var H = this.files[0], N = this.files[1], W = J(H.data, H.config.flipUV);
            if (N)
              W.materials = Z(N.data);
            H.cache.add(H.key, W), this.complete = true;
          }
        } });
        L.register("obj", function(H, N, W, R, Y) {
          var I;
          if (Array.isArray(H))
            for (var P = 0;P < H.length; P++)
              I = new Q(this, H[P]), this.addFile(I.files);
          else
            I = new Q(this, H, N, W, R, Y), this.addFile(I.files);
          return this;
        }), M.exports = Q;
      }, 58610: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(74099), U = $(518), K = new E({ Extends: U, initialize: function J(Z, D, Q, H, N) {
          U.call(this, Z, D, Q, H, N), this.type = "packfile";
        }, onProcess: function() {
          if (this.state !== L.FILE_POPULATED)
            this.state = L.FILE_PROCESSING, this.data = JSON.parse(this.xhrLoader.responseText);
          if (this.data.hasOwnProperty("files") && this.config) {
            var J = {};
            J[this.config] = this.data, this.data = J;
          }
          this.loader.addPack(this.data, this.config), this.onProcessComplete();
        } });
        z.register("pack", function(J, Z, D, Q) {
          if (Array.isArray(J))
            for (var H = 0;H < J.length; H++)
              this.addFile(new K(this, J[H]));
          else
            this.addFile(new K(this, J, Z, Q, D));
          return this;
        }), M.exports = K;
      }, 48988: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(95540), J = $(41212), Z = new E({ Extends: z, initialize: function D(Q, H, N, W, R, Y) {
          var I = "js";
          if (J(H)) {
            var P = H;
            H = K(P, "key"), N = K(P, "url"), Y = K(P, "xhrSettings"), I = K(P, "extension", I), W = K(P, "start"), R = K(P, "mapping");
          }
          var X = { type: "plugin", cache: false, extension: I, responseType: "text", key: H, url: N, xhrSettings: Y, config: { start: W, mapping: R } };
          if (z.call(this, Q, X), typeof N === "function")
            this.data = N, this.state = L.FILE_POPULATED;
        }, onProcess: function() {
          var D = this.loader.systems.plugins, Q = this.config, H = K(Q, "start", false), N = K(Q, "mapping", null);
          if (this.state === L.FILE_POPULATED)
            D.install(this.key, this.data, H, N);
          else {
            this.state = L.FILE_PROCESSING, this.data = document.createElement("script"), this.data.language = "javascript", this.data.type = "text/javascript", this.data.defer = false, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data);
            var W = D.install(this.key, window[this.key], H, N);
            if (H || N)
              this.loader.systems[N] = W, this.loader.scene[N] = W;
          }
          this.onProcessComplete();
        } });
        U.register("plugin", function(D, Q, H, N, W) {
          if (Array.isArray(D))
            for (var R = 0;R < D.length; R++)
              this.addFile(new Z(this, D[R]));
          else
            this.addFile(new Z(this, D, Q, H, N, W));
          return this;
        }), M.exports = Z;
      }, 67397: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(95540), J = $(41212), Z = new E({ Extends: z, initialize: function D(Q, H, N, W, R) {
          var Y = "svg";
          if (J(H)) {
            var I = H;
            H = K(I, "key"), N = K(I, "url"), W = K(I, "svgConfig", {}), R = K(I, "xhrSettings"), Y = K(I, "extension", Y);
          }
          var P = { type: "svg", cache: Q.textureManager, extension: Y, responseType: "text", key: H, url: N, xhrSettings: R, config: { width: K(W, "width"), height: K(W, "height"), scale: K(W, "scale") } };
          z.call(this, Q, P);
        }, onProcess: function() {
          this.state = L.FILE_PROCESSING;
          var D = this.xhrLoader.responseText, Q = [D], H = this.config.width, N = this.config.height, W = this.config.scale;
          $:
            if (H && N || W) {
              var R = null, Y = new DOMParser;
              R = Y.parseFromString(D, "text/xml");
              var I = R.getElementsByTagName("svg")[0], P = I.hasAttribute("viewBox"), X = parseFloat(I.getAttribute("width")), G = parseFloat(I.getAttribute("height"));
              if (!P && X && G)
                I.setAttribute("viewBox", "0  0 " + X + " " + G);
              else if (P && !X && !G) {
                var V = I.getAttribute("viewBox").split(/\s+|,/);
                X = V[2], G = V[3];
              }
              if (W)
                if (X && G)
                  H = X * W, N = G * W;
                else
                  break $;
              I.setAttribute("width", H.toString() + "px"), I.setAttribute("height", N.toString() + "px"), Q = [new XMLSerializer().serializeToString(I)];
            }
          try {
            var A = new window.Blob(Q, { type: "image/svg+xml;charset=utf-8" });
          } catch (T) {
            this.onProcessError();
            return;
          }
          this.data = new Image, this.data.crossOrigin = this.crossOrigin;
          var F = this, j = false;
          this.data.onload = function() {
            if (!j)
              z.revokeObjectURL(F.data);
            F.onProcessComplete();
          }, this.data.onerror = function() {
            if (!j)
              j = true, z.revokeObjectURL(F.data), F.data.src = "data:image/svg+xml," + encodeURIComponent(Q.join(""));
            else
              F.onProcessError();
          }, z.createObjectURL(this.data, A, "image/svg+xml");
        }, addToCache: function() {
          this.cache.addImage(this.key, this.data);
        } });
        U.register("svg", function(D, Q, H, N) {
          if (Array.isArray(D))
            for (var W = 0;W < D.length; W++)
              this.addFile(new Z(this, D[W]));
          else
            this.addFile(new Z(this, D, Q, H, N));
          return this;
        }), M.exports = Z;
      }, 88423: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(95540), J = $(41212), Z = new E({ Extends: z, initialize: function D(Q, H, N, W) {
          var R = "js";
          if (J(H)) {
            var Y = H;
            H = K(Y, "key"), N = K(Y, "url"), W = K(Y, "xhrSettings"), R = K(Y, "extension", R);
          }
          var I = { type: "text", extension: R, responseType: "text", key: H, url: N, xhrSettings: W };
          z.call(this, Q, I);
        }, onProcess: function() {
          this.state = L.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete();
        }, addToCache: function() {
          var D = this.data.concat("(function(){\nreturn new " + this.key + "();\n}).call(this);"), Q = eval;
          this.loader.sceneManager.add(this.key, Q(D)), this.complete = true;
        } });
        U.register("sceneFile", function(D, Q, H) {
          if (Array.isArray(D))
            for (var N = 0;N < D.length; N++)
              this.addFile(new Z(this, D[N]));
          else
            this.addFile(new Z(this, D, Q, H));
          return this;
        }), M.exports = Z;
      }, 56812: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(95540), J = $(41212), Z = new E({ Extends: z, initialize: function D(Q, H, N, W, R, Y) {
          var I = "js";
          if (J(H)) {
            var P = H;
            H = K(P, "key"), N = K(P, "url"), Y = K(P, "xhrSettings"), I = K(P, "extension", I), W = K(P, "systemKey"), R = K(P, "sceneKey");
          }
          var X = { type: "scenePlugin", cache: false, extension: I, responseType: "text", key: H, url: N, xhrSettings: Y, config: { systemKey: W, sceneKey: R } };
          if (z.call(this, Q, X), typeof N === "function")
            this.data = N, this.state = L.FILE_POPULATED;
        }, onProcess: function() {
          var D = this.loader.systems.plugins, Q = this.config, H = this.key, N = K(Q, "systemKey", H), W = K(Q, "sceneKey", H);
          if (this.state === L.FILE_POPULATED)
            D.installScenePlugin(N, this.data, W, this.loader.scene, true);
          else
            this.state = L.FILE_PROCESSING, this.data = document.createElement("script"), this.data.language = "javascript", this.data.type = "text/javascript", this.data.defer = false, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), D.installScenePlugin(N, window[this.key], W, this.loader.scene, true);
          this.onProcessComplete();
        } });
        U.register("scenePlugin", function(D, Q, H, N, W) {
          if (Array.isArray(D))
            for (var R = 0;R < D.length; R++)
              this.addFile(new Z(this, D[R]));
          else
            this.addFile(new Z(this, D, Q, H, N, W));
          return this;
        }), M.exports = Z;
      }, 34328: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(95540), J = $(41212), Z = new E({ Extends: z, initialize: function D(Q, H, N, W, R) {
          var Y = "js";
          if (J(H)) {
            var I = H;
            H = K(I, "key"), N = K(I, "url"), W = K(I, "type", "script"), R = K(I, "xhrSettings"), Y = K(I, "extension", Y);
          } else if (W === undefined)
            W = "script";
          var P = { type: W, cache: false, extension: Y, responseType: "text", key: H, url: N, xhrSettings: R };
          z.call(this, Q, P);
        }, onProcess: function() {
          this.state = L.FILE_PROCESSING, this.data = document.createElement("script"), this.data.language = "javascript", this.data.type = "text/javascript", this.data.defer = false, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), this.onProcessComplete();
        } });
        U.register("script", function(D, Q, H, N) {
          if (Array.isArray(D))
            for (var W = 0;W < D.length; W++)
              this.addFile(new Z(this, D[W]));
          else
            this.addFile(new Z(this, D, Q, H, N));
          return this;
        }), M.exports = Z;
      }, 85035: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(74099), U = $(19550), K = new E({ Extends: U, initialize: function J(Z, D, Q, H, N) {
          U.call(this, Z, D, Q, N, H), this.type = "spritesheet";
        }, addToCache: function() {
          var J = this.linkFile;
          if (J) {
            if (J.state >= L.FILE_COMPLETE)
              if (this.type === "normalMap")
                this.cache.addSpriteSheet(this.key, J.data, this.config, this.data);
              else
                this.cache.addSpriteSheet(this.key, this.data, this.config, J.data);
          } else
            this.cache.addSpriteSheet(this.key, this.data, this.config);
        } });
        z.register("spritesheet", function(J, Z, D, Q) {
          if (Array.isArray(J))
            for (var H = 0;H < J.length; H++)
              this.addFile(new K(this, J[H]));
          else
            this.addFile(new K(this, J, Z, D, Q));
          return this;
        }), M.exports = K;
      }, 78776: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(95540), J = $(41212), Z = new E({ Extends: z, initialize: function D(Q, H, N, W) {
          var R = "text", Y = "txt", I = Q.cacheManager.text;
          if (J(H)) {
            var P = H;
            H = K(P, "key"), N = K(P, "url"), W = K(P, "xhrSettings"), Y = K(P, "extension", Y), R = K(P, "type", R), I = K(P, "cache", I);
          }
          var X = { type: R, cache: I, extension: Y, responseType: "text", key: H, url: N, xhrSettings: W };
          z.call(this, Q, X);
        }, onProcess: function() {
          this.state = L.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete();
        } });
        U.register("text", function(D, Q, H) {
          if (Array.isArray(D))
            for (var N = 0;N < D.length; N++)
              this.addFile(new Z(this, D[N]));
          else
            this.addFile(new Z(this, D, Q, H));
          return this;
        }), M.exports = Z;
      }, 49477: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(95540), J = $(41212), Z = $(80341), D = new E({ Extends: z, initialize: function Q(H, N, W, R) {
          var Y = "csv";
          if (J(N)) {
            var I = N;
            N = K(I, "key"), W = K(I, "url"), R = K(I, "xhrSettings"), Y = K(I, "extension", Y);
          }
          var P = { type: "tilemapCSV", cache: H.cacheManager.tilemap, extension: Y, responseType: "text", key: N, url: W, xhrSettings: R };
          z.call(this, H, P), this.tilemapFormat = Z.CSV;
        }, onProcess: function() {
          this.state = L.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete();
        }, addToCache: function() {
          var Q = { format: this.tilemapFormat, data: this.data };
          this.cache.add(this.key, Q);
        } });
        U.register("tilemapCSV", function(Q, H, N) {
          if (Array.isArray(Q))
            for (var W = 0;W < Q.length; W++)
              this.addFile(new D(this, Q[W]));
          else
            this.addFile(new D(this, Q, H, N));
          return this;
        }), M.exports = D;
      }, 40807: (M, B, $) => {
        var E = $(83419), L = $(74099), z = $(518), U = $(80341), K = new E({ Extends: z, initialize: function J(Z, D, Q, H) {
          z.call(this, Z, D, Q, H), this.type = "tilemapJSON", this.cache = Z.cacheManager.tilemap;
        }, addToCache: function() {
          var J = { format: U.WELTMEISTER, data: this.data };
          this.cache.add(this.key, J);
        } });
        L.register("tilemapImpact", function(J, Z, D) {
          if (Array.isArray(J))
            for (var Q = 0;Q < J.length; Q++)
              this.addFile(new K(this, J[Q]));
          else
            this.addFile(new K(this, J, Z, D));
          return this;
        }), M.exports = K;
      }, 56775: (M, B, $) => {
        var E = $(83419), L = $(74099), z = $(518), U = $(80341), K = new E({ Extends: z, initialize: function J(Z, D, Q, H) {
          z.call(this, Z, D, Q, H), this.type = "tilemapJSON", this.cache = Z.cacheManager.tilemap;
        }, addToCache: function() {
          var J = { format: U.TILED_JSON, data: this.data };
          this.cache.add(this.key, J);
        } });
        L.register("tilemapTiledJSON", function(J, Z, D) {
          if (Array.isArray(J))
            for (var Q = 0;Q < J.length; Q++)
              this.addFile(new K(this, J[Q]));
          else
            this.addFile(new K(this, J, Z, D));
          return this;
        }), M.exports = K;
      }, 25771: (M, B, $) => {
        var E = $(83419), L = $(74099), z = $(95540), U = $(19550), K = $(41212), J = $(26430), Z = $(78776), D = new E({ Extends: J, initialize: function Q(H, N, W, R, Y, I) {
          var P, X;
          if (K(N)) {
            var G = N;
            N = z(G, "key"), P = new U(H, { key: N, url: z(G, "textureURL"), extension: z(G, "textureExtension", "png"), normalMap: z(G, "normalMap"), xhrSettings: z(G, "textureXhrSettings") }), X = new Z(H, { key: N, url: z(G, "atlasURL"), extension: z(G, "atlasExtension", "txt"), xhrSettings: z(G, "atlasXhrSettings") });
          } else
            P = new U(H, N, W, Y), X = new Z(H, N, R, I);
          if (P.linkFile)
            J.call(this, H, "unityatlas", N, [P, X, P.linkFile]);
          else
            J.call(this, H, "unityatlas", N, [P, X]);
        }, addToCache: function() {
          if (this.isReadyToProcess()) {
            var Q = this.files[0], H = this.files[1], N = this.files[2] ? this.files[2].data : null;
            this.loader.textureManager.addUnityAtlas(Q.key, Q.data, H.data, N), this.complete = true;
          }
        } });
        L.register("unityAtlas", function(Q, H, N, W, R) {
          var Y;
          if (Array.isArray(Q))
            for (var I = 0;I < Q.length; I++)
              Y = new D(this, Q[I]), this.addFile(Y.files);
          else
            Y = new D(this, Q, H, N, W, R), this.addFile(Y.files);
          return this;
        }), M.exports = D;
      }, 33720: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(98356), J = $(95540), Z = $(41212), D = new E({ Extends: z, initialize: function Q(H, N, W, R) {
          if (R === undefined)
            R = false;
          if (Z(N)) {
            var Y = N;
            N = J(Y, "key"), W = J(Y, "url", []), R = J(Y, "noAudio", false);
          }
          var I = H.systems.game.device.video.getVideoURL(W);
          if (!I)
            console.warn("VideoFile: No supported format for " + N);
          var P = { type: "video", cache: H.cacheManager.video, extension: I.type, key: N, url: I.url, config: { noAudio: R } };
          z.call(this, H, P);
        }, onProcess: function() {
          this.data = { url: this.src, noAudio: this.config.noAudio, crossOrigin: this.crossOrigin }, this.onProcessComplete();
        }, load: function() {
          this.src = K(this, this.loader.baseURL), this.state = L.FILE_LOADED, this.loader.nextFile(this, true);
        } });
        U.register("video", function(Q, H, N) {
          if (Array.isArray(Q))
            for (var W = 0;W < Q.length; W++)
              this.addFile(new D(this, Q[W]));
          else
            this.addFile(new D(this, Q, H, N));
          return this;
        }), M.exports = D;
      }, 57318: (M, B, $) => {
        var E = $(83419), L = $(23906), z = $(41299), U = $(74099), K = $(95540), J = $(41212), Z = $(56836), D = new E({ Extends: z, initialize: function Q(H, N, W, R) {
          var Y = "xml";
          if (J(N)) {
            var I = N;
            N = K(I, "key"), W = K(I, "url"), R = K(I, "xhrSettings"), Y = K(I, "extension", Y);
          }
          var P = { type: "xml", cache: H.cacheManager.xml, extension: Y, responseType: "text", key: N, url: W, xhrSettings: R };
          z.call(this, H, P);
        }, onProcess: function() {
          if (this.state = L.FILE_PROCESSING, this.data = Z(this.xhrLoader.responseText), this.data)
            this.onProcessComplete();
          else
            this.onProcessError();
        } });
        U.register("xml", function(Q, H, N) {
          if (Array.isArray(Q))
            for (var W = 0;W < Q.length; W++)
              this.addFile(new D(this, Q[W]));
          else
            this.addFile(new D(this, Q, H, N));
          return this;
        }), M.exports = D;
      }, 64589: (M, B, $) => {
        M.exports = { AnimationJSONFile: $(14135), AsepriteFile: $(76272), AtlasJSONFile: $(38734), AtlasXMLFile: $(74599), AudioFile: $(21097), AudioSpriteFile: $(89524), BinaryFile: $(85722), BitmapFontFile: $(97025), CompressedTextureFile: $(69559), CSSFile: $(16024), GLSLFile: $(47931), HTML5AudioFile: $(89749), HTMLFile: $(88470), HTMLTextureFile: $(14643), ImageFile: $(19550), JSONFile: $(518), MultiAtlasFile: $(59327), MultiScriptFile: $(99297), OBJFile: $(41846), PackFile: $(58610), PluginFile: $(48988), SceneFile: $(88423), ScenePluginFile: $(56812), ScriptFile: $(34328), SpriteSheetFile: $(85035), SVGFile: $(67397), TextFile: $(78776), TilemapCSVFile: $(49477), TilemapImpactFile: $(40807), TilemapJSONFile: $(56775), UnityAtlasFile: $(25771), VideoFile: $(33720), XMLFile: $(57318) };
      }, 57777: (M, B, $) => {
        var E = $(23906), L = $(79291), z = { Events: $(54899), FileTypes: $(64589), File: $(41299), FileTypesManager: $(74099), GetURL: $(98356), LoaderPlugin: $(74261), MergeXHRSettings: $(3374), MultiFile: $(26430), XHRLoader: $(84376), XHRSettings: $(92638) };
        z = L(false, z, E), M.exports = z;
      }, 53307: (M) => {
        var B = function($) {
          var E = 0;
          for (var L = 0;L < $.length; L++)
            E += +$[L];
          return E / $.length;
        };
        M.exports = B;
      }, 85710: (M, B, $) => {
        var E = $(6411), L = function(z, U) {
          return E(z) / E(U) / E(z - U);
        };
        M.exports = L;
      }, 30976: (M) => {
        var B = function($, E) {
          return Math.floor(Math.random() * (E - $ + 1) + $);
        };
        M.exports = B;
      }, 87842: (M) => {
        var B = function($, E, L, z, U) {
          var K = (z - E) * 0.5, J = (U - L) * 0.5, Z = $ * $, D = $ * Z;
          return (2 * L - 2 * z + K + J) * D + (-3 * L + 3 * z - 2 * K - J) * Z + K * $ + L;
        };
        M.exports = B;
      }, 26302: (M) => {
        var B = function($, E, L) {
          if (E === undefined)
            E = 0;
          if (L === undefined)
            L = 10;
          var z = Math.pow(L, -E);
          return Math.ceil($ * z) / z;
        };
        M.exports = B;
      }, 45319: (M) => {
        var B = function($, E, L) {
          return Math.max(E, Math.min(L, $));
        };
        M.exports = B;
      }, 39506: (M, B, $) => {
        var E = $(36383), L = function(z) {
          return z * E.DEG_TO_RAD;
        };
        M.exports = L;
      }, 61241: (M) => {
        var B = function($, E) {
          return Math.abs($ - E);
        };
        M.exports = B;
      }, 38857: (M, B, $) => {
        var E = $(45319), L = $(83419), z = $(37867), U = $(29747), K = new z, J = new L({ initialize: function Z(D, Q, H, N) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = Z.DefaultOrder;
          this._x = D, this._y = Q, this._z = H, this._order = N, this.onChangeCallback = U;
        }, x: { get: function() {
          return this._x;
        }, set: function(Z) {
          this._x = Z, this.onChangeCallback(this);
        } }, y: { get: function() {
          return this._y;
        }, set: function(Z) {
          this._y = Z, this.onChangeCallback(this);
        } }, z: { get: function() {
          return this._z;
        }, set: function(Z) {
          this._z = Z, this.onChangeCallback(this);
        } }, order: { get: function() {
          return this._order;
        }, set: function(Z) {
          this._order = Z, this.onChangeCallback(this);
        } }, set: function(Z, D, Q, H) {
          if (H === undefined)
            H = this._order;
          return this._x = Z, this._y = D, this._z = Q, this._order = H, this.onChangeCallback(this), this;
        }, copy: function(Z) {
          return this.set(Z.x, Z.y, Z.z, Z.order);
        }, setFromQuaternion: function(Z, D, Q) {
          if (D === undefined)
            D = this._order;
          if (Q === undefined)
            Q = false;
          return K.fromQuat(Z), this.setFromRotationMatrix(K, D, Q);
        }, setFromRotationMatrix: function(Z, D, Q) {
          if (D === undefined)
            D = this._order;
          if (Q === undefined)
            Q = false;
          var H = Z.val, N = H[0], W = H[4], R = H[8], Y = H[1], I = H[5], P = H[9], X = H[2], G = H[6], V = H[10], A = 0, F = 0, j = 0, T = 0.99999;
          switch (D) {
            case "XYZ": {
              if (F = Math.asin(E(R, -1, 1)), Math.abs(R) < T)
                A = Math.atan2(-P, V), j = Math.atan2(-W, N);
              else
                A = Math.atan2(G, I);
              break;
            }
            case "YXZ": {
              if (A = Math.asin(-E(P, -1, 1)), Math.abs(P) < T)
                F = Math.atan2(R, V), j = Math.atan2(Y, I);
              else
                F = Math.atan2(-X, N);
              break;
            }
            case "ZXY": {
              if (A = Math.asin(E(G, -1, 1)), Math.abs(G) < T)
                F = Math.atan2(-X, V), j = Math.atan2(-W, I);
              else
                j = Math.atan2(Y, N);
              break;
            }
            case "ZYX": {
              if (F = Math.asin(-E(X, -1, 1)), Math.abs(X) < T)
                A = Math.atan2(G, V), j = Math.atan2(Y, N);
              else
                j = Math.atan2(-W, I);
              break;
            }
            case "YZX": {
              if (j = Math.asin(E(Y, -1, 1)), Math.abs(Y) < T)
                A = Math.atan2(-P, I), F = Math.atan2(-X, N);
              else
                F = Math.atan2(R, V);
              break;
            }
            case "XZY": {
              if (j = Math.asin(-E(W, -1, 1)), Math.abs(W) < T)
                A = Math.atan2(G, I), F = Math.atan2(R, N);
              else
                A = Math.atan2(-P, V);
              break;
            }
          }
          if (this._x = A, this._y = F, this._z = j, this._order = D, Q)
            this.onChangeCallback(this);
          return this;
        } });
        J.RotationOrders = ["XYZ", "YXZ", "ZXY", "ZYX", "YZX", "XZY"], J.DefaultOrder = "XYZ", M.exports = J;
      }, 6411: (M) => {
        var B = function($) {
          if ($ === 0)
            return 1;
          var E = $;
          while (--$)
            E *= $;
          return E;
        };
        M.exports = B;
      }, 99472: (M) => {
        var B = function($, E) {
          return Math.random() * (E - $) + $;
        };
        M.exports = B;
      }, 77623: (M) => {
        var B = function($, E, L) {
          if (E === undefined)
            E = 0;
          if (L === undefined)
            L = 10;
          var z = Math.pow(L, -E);
          return Math.floor($ * z) / z;
        };
        M.exports = B;
      }, 62945: (M, B, $) => {
        var E = $(45319), L = function(z, U, K) {
          return z = E(z, 0, 1), (K - U) * z + U;
        };
        M.exports = L;
      }, 38265: (M) => {
        var B = function($, E) {
          return $ / E / 1000;
        };
        M.exports = B;
      }, 78702: (M) => {
        var B = function($) {
          return $ == parseFloat($) ? !($ % 2) : undefined;
        };
        M.exports = B;
      }, 94883: (M) => {
        var B = function($) {
          return $ === parseFloat($) ? !($ % 2) : undefined;
        };
        M.exports = B;
      }, 28915: (M) => {
        var B = function($, E, L) {
          return (E - $) * L + $;
        };
        M.exports = B;
      }, 94908: (M) => {
        var B = function($, E, L) {
          if (L === undefined)
            L = 0;
          return $.clone().lerp(E, L);
        };
        M.exports = B;
      }, 94434: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U) {
          if (this.val = new Float32Array(9), U)
            this.copy(U);
          else
            this.identity();
        }, clone: function() {
          return new L(this);
        }, set: function(z) {
          return this.copy(z);
        }, copy: function(z) {
          var U = this.val, K = z.val;
          return U[0] = K[0], U[1] = K[1], U[2] = K[2], U[3] = K[3], U[4] = K[4], U[5] = K[5], U[6] = K[6], U[7] = K[7], U[8] = K[8], this;
        }, fromMat4: function(z) {
          var U = z.val, K = this.val;
          return K[0] = U[0], K[1] = U[1], K[2] = U[2], K[3] = U[4], K[4] = U[5], K[5] = U[6], K[6] = U[8], K[7] = U[9], K[8] = U[10], this;
        }, fromArray: function(z) {
          var U = this.val;
          return U[0] = z[0], U[1] = z[1], U[2] = z[2], U[3] = z[3], U[4] = z[4], U[5] = z[5], U[6] = z[6], U[7] = z[7], U[8] = z[8], this;
        }, identity: function() {
          var z = this.val;
          return z[0] = 1, z[1] = 0, z[2] = 0, z[3] = 0, z[4] = 1, z[5] = 0, z[6] = 0, z[7] = 0, z[8] = 1, this;
        }, transpose: function() {
          var z = this.val, U = z[1], K = z[2], J = z[5];
          return z[1] = z[3], z[2] = z[6], z[3] = U, z[5] = z[7], z[6] = K, z[7] = J, this;
        }, invert: function() {
          var z = this.val, U = z[0], K = z[1], J = z[2], Z = z[3], D = z[4], Q = z[5], H = z[6], N = z[7], W = z[8], R = W * D - Q * N, Y = -W * Z + Q * H, I = N * Z - D * H, P = U * R + K * Y + J * I;
          if (!P)
            return null;
          return P = 1 / P, z[0] = R * P, z[1] = (-W * K + J * N) * P, z[2] = (Q * K - J * D) * P, z[3] = Y * P, z[4] = (W * U - J * H) * P, z[5] = (-Q * U + J * Z) * P, z[6] = I * P, z[7] = (-N * U + K * H) * P, z[8] = (D * U - K * Z) * P, this;
        }, adjoint: function() {
          var z = this.val, U = z[0], K = z[1], J = z[2], Z = z[3], D = z[4], Q = z[5], H = z[6], N = z[7], W = z[8];
          return z[0] = D * W - Q * N, z[1] = J * N - K * W, z[2] = K * Q - J * D, z[3] = Q * H - Z * W, z[4] = U * W - J * H, z[5] = J * Z - U * Q, z[6] = Z * N - D * H, z[7] = K * H - U * N, z[8] = U * D - K * Z, this;
        }, determinant: function() {
          var z = this.val, U = z[0], K = z[1], J = z[2], Z = z[3], D = z[4], Q = z[5], H = z[6], N = z[7], W = z[8];
          return U * (W * D - Q * N) + K * (-W * Z + Q * H) + J * (N * Z - D * H);
        }, multiply: function(z) {
          var U = this.val, K = U[0], J = U[1], Z = U[2], D = U[3], Q = U[4], H = U[5], N = U[6], W = U[7], R = U[8], Y = z.val, I = Y[0], P = Y[1], X = Y[2], G = Y[3], V = Y[4], A = Y[5], F = Y[6], j = Y[7], T = Y[8];
          return U[0] = I * K + P * D + X * N, U[1] = I * J + P * Q + X * W, U[2] = I * Z + P * H + X * R, U[3] = G * K + V * D + A * N, U[4] = G * J + V * Q + A * W, U[5] = G * Z + V * H + A * R, U[6] = F * K + j * D + T * N, U[7] = F * J + j * Q + T * W, U[8] = F * Z + j * H + T * R, this;
        }, translate: function(z) {
          var U = this.val, K = z.x, J = z.y;
          return U[6] = K * U[0] + J * U[3] + U[6], U[7] = K * U[1] + J * U[4] + U[7], U[8] = K * U[2] + J * U[5] + U[8], this;
        }, rotate: function(z) {
          var U = this.val, K = U[0], J = U[1], Z = U[2], D = U[3], Q = U[4], H = U[5], N = Math.sin(z), W = Math.cos(z);
          return U[0] = W * K + N * D, U[1] = W * J + N * Q, U[2] = W * Z + N * H, U[3] = W * D - N * K, U[4] = W * Q - N * J, U[5] = W * H - N * Z, this;
        }, scale: function(z) {
          var U = this.val, K = z.x, J = z.y;
          return U[0] = K * U[0], U[1] = K * U[1], U[2] = K * U[2], U[3] = J * U[3], U[4] = J * U[4], U[5] = J * U[5], this;
        }, fromQuat: function(z) {
          var { x: U, y: K, z: J, w: Z } = z, D = U + U, Q = K + K, H = J + J, N = U * D, W = U * Q, R = U * H, Y = K * Q, I = K * H, P = J * H, X = Z * D, G = Z * Q, V = Z * H, A = this.val;
          return A[0] = 1 - (Y + P), A[3] = W + V, A[6] = R - G, A[1] = W - V, A[4] = 1 - (N + P), A[7] = I + X, A[2] = R + G, A[5] = I - X, A[8] = 1 - (N + Y), this;
        }, normalFromMat4: function(z) {
          var U = z.val, K = this.val, J = U[0], Z = U[1], D = U[2], Q = U[3], H = U[4], N = U[5], W = U[6], R = U[7], Y = U[8], I = U[9], P = U[10], X = U[11], G = U[12], V = U[13], A = U[14], F = U[15], j = J * N - Z * H, T = J * W - D * H, C = J * R - Q * H, v = Z * W - D * N, O = Z * R - Q * N, q = D * R - Q * W, w = Y * V - I * G, g = Y * A - P * G, b = Y * F - X * G, x = I * A - P * V, k = I * F - X * V, S = P * F - X * A, f = j * S - T * k + C * x + v * b - O * g + q * w;
          if (!f)
            return null;
          return f = 1 / f, K[0] = (N * S - W * k + R * x) * f, K[1] = (W * b - H * S - R * g) * f, K[2] = (H * k - N * b + R * w) * f, K[3] = (D * k - Z * S - Q * x) * f, K[4] = (J * S - D * b + Q * g) * f, K[5] = (Z * b - J * k - Q * w) * f, K[6] = (V * q - A * O + F * v) * f, K[7] = (A * C - G * q - F * T) * f, K[8] = (G * O - V * C + F * j) * f, this;
        } });
        M.exports = L;
      }, 37867: (M, B, $) => {
        var E = $(83419), L = $(25836), z = 0.000001, U = new E({ initialize: function H(N) {
          if (this.val = new Float32Array(16), N)
            this.copy(N);
          else
            this.identity();
        }, clone: function() {
          return new U(this);
        }, set: function(H) {
          return this.copy(H);
        }, setValues: function(H, N, W, R, Y, I, P, X, G, V, A, F, j, T, C, v) {
          var O = this.val;
          return O[0] = H, O[1] = N, O[2] = W, O[3] = R, O[4] = Y, O[5] = I, O[6] = P, O[7] = X, O[8] = G, O[9] = V, O[10] = A, O[11] = F, O[12] = j, O[13] = T, O[14] = C, O[15] = v, this;
        }, copy: function(H) {
          var N = H.val;
          return this.setValues(N[0], N[1], N[2], N[3], N[4], N[5], N[6], N[7], N[8], N[9], N[10], N[11], N[12], N[13], N[14], N[15]);
        }, fromArray: function(H) {
          return this.setValues(H[0], H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8], H[9], H[10], H[11], H[12], H[13], H[14], H[15]);
        }, zero: function() {
          return this.setValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }, transform: function(H, N, W) {
          var R = K.fromQuat(W), Y = R.val, I = N.x, P = N.y, X = N.z;
          return this.setValues(Y[0] * I, Y[1] * I, Y[2] * I, 0, Y[4] * P, Y[5] * P, Y[6] * P, 0, Y[8] * X, Y[9] * X, Y[10] * X, 0, H.x, H.y, H.z, 1);
        }, xyz: function(H, N, W) {
          this.identity();
          var R = this.val;
          return R[12] = H, R[13] = N, R[14] = W, this;
        }, scaling: function(H, N, W) {
          this.zero();
          var R = this.val;
          return R[0] = H, R[5] = N, R[10] = W, R[15] = 1, this;
        }, identity: function() {
          return this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }, transpose: function() {
          var H = this.val, N = H[1], W = H[2], R = H[3], Y = H[6], I = H[7], P = H[11];
          return H[1] = H[4], H[2] = H[8], H[3] = H[12], H[4] = N, H[6] = H[9], H[7] = H[13], H[8] = W, H[9] = Y, H[11] = H[14], H[12] = R, H[13] = I, H[14] = P, this;
        }, getInverse: function(H) {
          return this.copy(H), this.invert();
        }, invert: function() {
          var H = this.val, N = H[0], W = H[1], R = H[2], Y = H[3], I = H[4], P = H[5], X = H[6], G = H[7], V = H[8], A = H[9], F = H[10], j = H[11], T = H[12], C = H[13], v = H[14], O = H[15], q = N * P - W * I, w = N * X - R * I, g = N * G - Y * I, b = W * X - R * P, x = W * G - Y * P, k = R * G - Y * X, S = V * C - A * T, f = V * v - F * T, h = V * O - j * T, m = A * v - F * C, y = A * O - j * C, d = F * O - j * v, p = q * d - w * y + g * m + b * h - x * f + k * S;
          if (!p)
            return this;
          return p = 1 / p, this.setValues((P * d - X * y + G * m) * p, (R * y - W * d - Y * m) * p, (C * k - v * x + O * b) * p, (F * x - A * k - j * b) * p, (X * h - I * d - G * f) * p, (N * d - R * h + Y * f) * p, (v * g - T * k - O * w) * p, (V * k - F * g + j * w) * p, (I * y - P * h + G * S) * p, (W * h - N * y - Y * S) * p, (T * x - C * g + O * q) * p, (A * g - V * x - j * q) * p, (P * f - I * m - X * S) * p, (N * m - W * f + R * S) * p, (C * w - T * b - v * q) * p, (V * b - A * w + F * q) * p);
        }, adjoint: function() {
          var H = this.val, N = H[0], W = H[1], R = H[2], Y = H[3], I = H[4], P = H[5], X = H[6], G = H[7], V = H[8], A = H[9], F = H[10], j = H[11], T = H[12], C = H[13], v = H[14], O = H[15];
          return this.setValues(P * (F * O - j * v) - A * (X * O - G * v) + C * (X * j - G * F), -(W * (F * O - j * v) - A * (R * O - Y * v) + C * (R * j - Y * F)), W * (X * O - G * v) - P * (R * O - Y * v) + C * (R * G - Y * X), -(W * (X * j - G * F) - P * (R * j - Y * F) + A * (R * G - Y * X)), -(I * (F * O - j * v) - V * (X * O - G * v) + T * (X * j - G * F)), N * (F * O - j * v) - V * (R * O - Y * v) + T * (R * j - Y * F), -(N * (X * O - G * v) - I * (R * O - Y * v) + T * (R * G - Y * X)), N * (X * j - G * F) - I * (R * j - Y * F) + V * (R * G - Y * X), I * (A * O - j * C) - V * (P * O - G * C) + T * (P * j - G * A), -(N * (A * O - j * C) - V * (W * O - Y * C) + T * (W * j - Y * A)), N * (P * O - G * C) - I * (W * O - Y * C) + T * (W * G - Y * P), -(N * (P * j - G * A) - I * (W * j - Y * A) + V * (W * G - Y * P)), -(I * (A * v - F * C) - V * (P * v - X * C) + T * (P * F - X * A)), N * (A * v - F * C) - V * (W * v - R * C) + T * (W * F - R * A), -(N * (P * v - X * C) - I * (W * v - R * C) + T * (W * X - R * P)), N * (P * F - X * A) - I * (W * F - R * A) + V * (W * X - R * P));
        }, determinant: function() {
          var H = this.val, N = H[0], W = H[1], R = H[2], Y = H[3], I = H[4], P = H[5], X = H[6], G = H[7], V = H[8], A = H[9], F = H[10], j = H[11], T = H[12], C = H[13], v = H[14], O = H[15], q = N * P - W * I, w = N * X - R * I, g = N * G - Y * I, b = W * X - R * P, x = W * G - Y * P, k = R * G - Y * X, S = V * C - A * T, f = V * v - F * T, h = V * O - j * T, m = A * v - F * C, y = A * O - j * C, d = F * O - j * v;
          return q * d - w * y + g * m + b * h - x * f + k * S;
        }, multiply: function(H) {
          var N = this.val, W = N[0], R = N[1], Y = N[2], I = N[3], P = N[4], X = N[5], G = N[6], V = N[7], A = N[8], F = N[9], j = N[10], T = N[11], C = N[12], v = N[13], O = N[14], q = N[15], w = H.val, g = w[0], b = w[1], x = w[2], k = w[3];
          return N[0] = g * W + b * P + x * A + k * C, N[1] = g * R + b * X + x * F + k * v, N[2] = g * Y + b * G + x * j + k * O, N[3] = g * I + b * V + x * T + k * q, g = w[4], b = w[5], x = w[6], k = w[7], N[4] = g * W + b * P + x * A + k * C, N[5] = g * R + b * X + x * F + k * v, N[6] = g * Y + b * G + x * j + k * O, N[7] = g * I + b * V + x * T + k * q, g = w[8], b = w[9], x = w[10], k = w[11], N[8] = g * W + b * P + x * A + k * C, N[9] = g * R + b * X + x * F + k * v, N[10] = g * Y + b * G + x * j + k * O, N[11] = g * I + b * V + x * T + k * q, g = w[12], b = w[13], x = w[14], k = w[15], N[12] = g * W + b * P + x * A + k * C, N[13] = g * R + b * X + x * F + k * v, N[14] = g * Y + b * G + x * j + k * O, N[15] = g * I + b * V + x * T + k * q, this;
        }, multiplyLocal: function(H) {
          var N = this.val, W = H.val;
          return this.setValues(N[0] * W[0] + N[1] * W[4] + N[2] * W[8] + N[3] * W[12], N[0] * W[1] + N[1] * W[5] + N[2] * W[9] + N[3] * W[13], N[0] * W[2] + N[1] * W[6] + N[2] * W[10] + N[3] * W[14], N[0] * W[3] + N[1] * W[7] + N[2] * W[11] + N[3] * W[15], N[4] * W[0] + N[5] * W[4] + N[6] * W[8] + N[7] * W[12], N[4] * W[1] + N[5] * W[5] + N[6] * W[9] + N[7] * W[13], N[4] * W[2] + N[5] * W[6] + N[6] * W[10] + N[7] * W[14], N[4] * W[3] + N[5] * W[7] + N[6] * W[11] + N[7] * W[15], N[8] * W[0] + N[9] * W[4] + N[10] * W[8] + N[11] * W[12], N[8] * W[1] + N[9] * W[5] + N[10] * W[9] + N[11] * W[13], N[8] * W[2] + N[9] * W[6] + N[10] * W[10] + N[11] * W[14], N[8] * W[3] + N[9] * W[7] + N[10] * W[11] + N[11] * W[15], N[12] * W[0] + N[13] * W[4] + N[14] * W[8] + N[15] * W[12], N[12] * W[1] + N[13] * W[5] + N[14] * W[9] + N[15] * W[13], N[12] * W[2] + N[13] * W[6] + N[14] * W[10] + N[15] * W[14], N[12] * W[3] + N[13] * W[7] + N[14] * W[11] + N[15] * W[15]);
        }, premultiply: function(H) {
          return this.multiplyMatrices(H, this);
        }, multiplyMatrices: function(H, N) {
          var W = H.val, R = N.val, Y = W[0], I = W[4], P = W[8], X = W[12], G = W[1], V = W[5], A = W[9], F = W[13], j = W[2], T = W[6], C = W[10], v = W[14], O = W[3], q = W[7], w = W[11], g = W[15], b = R[0], x = R[4], k = R[8], S = R[12], f = R[1], h = R[5], m = R[9], y = R[13], d = R[2], p = R[6], u = R[10], s = R[14], c = R[3], n = R[7], _ = R[11], l = R[15];
          return this.setValues(Y * b + I * f + P * d + X * c, G * b + V * f + A * d + F * c, j * b + T * f + C * d + v * c, O * b + q * f + w * d + g * c, Y * x + I * h + P * p + X * n, G * x + V * h + A * p + F * n, j * x + T * h + C * p + v * n, O * x + q * h + w * p + g * n, Y * k + I * m + P * u + X * _, G * k + V * m + A * u + F * _, j * k + T * m + C * u + v * _, O * k + q * m + w * u + g * _, Y * S + I * y + P * s + X * l, G * S + V * y + A * s + F * l, j * S + T * y + C * s + v * l, O * S + q * y + w * s + g * l);
        }, translate: function(H) {
          return this.translateXYZ(H.x, H.y, H.z);
        }, translateXYZ: function(H, N, W) {
          var R = this.val;
          return R[12] = R[0] * H + R[4] * N + R[8] * W + R[12], R[13] = R[1] * H + R[5] * N + R[9] * W + R[13], R[14] = R[2] * H + R[6] * N + R[10] * W + R[14], R[15] = R[3] * H + R[7] * N + R[11] * W + R[15], this;
        }, scale: function(H) {
          return this.scaleXYZ(H.x, H.y, H.z);
        }, scaleXYZ: function(H, N, W) {
          var R = this.val;
          return R[0] = R[0] * H, R[1] = R[1] * H, R[2] = R[2] * H, R[3] = R[3] * H, R[4] = R[4] * N, R[5] = R[5] * N, R[6] = R[6] * N, R[7] = R[7] * N, R[8] = R[8] * W, R[9] = R[9] * W, R[10] = R[10] * W, R[11] = R[11] * W, this;
        }, makeRotationAxis: function(H, N) {
          var W = Math.cos(N), R = Math.sin(N), Y = 1 - W, I = H.x, P = H.y, X = H.z, G = Y * I, V = Y * P;
          return this.setValues(G * I + W, G * P - R * X, G * X + R * P, 0, G * P + R * X, V * P + W, V * X - R * I, 0, G * X - R * P, V * X + R * I, Y * X * X + W, 0, 0, 0, 0, 1);
        }, rotate: function(H, N) {
          var W = this.val, R = N.x, Y = N.y, I = N.z, P = Math.sqrt(R * R + Y * Y + I * I);
          if (Math.abs(P) < z)
            return this;
          P = 1 / P, R *= P, Y *= P, I *= P;
          var X = Math.sin(H), G = Math.cos(H), V = 1 - G, A = W[0], F = W[1], j = W[2], T = W[3], C = W[4], v = W[5], O = W[6], q = W[7], w = W[8], g = W[9], b = W[10], x = W[11], k = W[12], S = W[13], f = W[14], h = W[15], m = R * R * V + G, y = Y * R * V + I * X, d = I * R * V - Y * X, p = R * Y * V - I * X, u = Y * Y * V + G, s = I * Y * V + R * X, c = R * I * V + Y * X, n = Y * I * V - R * X, _ = I * I * V + G;
          return this.setValues(A * m + C * y + w * d, F * m + v * y + g * d, j * m + O * y + b * d, T * m + q * y + x * d, A * p + C * u + w * s, F * p + v * u + g * s, j * p + O * u + b * s, T * p + q * u + x * s, A * c + C * n + w * _, F * c + v * n + g * _, j * c + O * n + b * _, T * c + q * n + x * _, k, S, f, h);
        }, rotateX: function(H) {
          var N = this.val, W = Math.sin(H), R = Math.cos(H), Y = N[4], I = N[5], P = N[6], X = N[7], G = N[8], V = N[9], A = N[10], F = N[11];
          return N[4] = Y * R + G * W, N[5] = I * R + V * W, N[6] = P * R + A * W, N[7] = X * R + F * W, N[8] = G * R - Y * W, N[9] = V * R - I * W, N[10] = A * R - P * W, N[11] = F * R - X * W, this;
        }, rotateY: function(H) {
          var N = this.val, W = Math.sin(H), R = Math.cos(H), Y = N[0], I = N[1], P = N[2], X = N[3], G = N[8], V = N[9], A = N[10], F = N[11];
          return N[0] = Y * R - G * W, N[1] = I * R - V * W, N[2] = P * R - A * W, N[3] = X * R - F * W, N[8] = Y * W + G * R, N[9] = I * W + V * R, N[10] = P * W + A * R, N[11] = X * W + F * R, this;
        }, rotateZ: function(H) {
          var N = this.val, W = Math.sin(H), R = Math.cos(H), Y = N[0], I = N[1], P = N[2], X = N[3], G = N[4], V = N[5], A = N[6], F = N[7];
          return N[0] = Y * R + G * W, N[1] = I * R + V * W, N[2] = P * R + A * W, N[3] = X * R + F * W, N[4] = G * R - Y * W, N[5] = V * R - I * W, N[6] = A * R - P * W, N[7] = F * R - X * W, this;
        }, fromRotationTranslation: function(H, N) {
          var { x: W, y: R, z: Y, w: I } = H, P = W + W, X = R + R, G = Y + Y, V = W * P, A = W * X, F = W * G, j = R * X, T = R * G, C = Y * G, v = I * P, O = I * X, q = I * G;
          return this.setValues(1 - (j + C), A + q, F - O, 0, A - q, 1 - (V + C), T + v, 0, F + O, T - v, 1 - (V + j), 0, N.x, N.y, N.z, 1);
        }, fromQuat: function(H) {
          var { x: N, y: W, z: R, w: Y } = H, I = N + N, P = W + W, X = R + R, G = N * I, V = N * P, A = N * X, F = W * P, j = W * X, T = R * X, C = Y * I, v = Y * P, O = Y * X;
          return this.setValues(1 - (F + T), V + O, A - v, 0, V - O, 1 - (G + T), j + C, 0, A + v, j - C, 1 - (G + F), 0, 0, 0, 0, 1);
        }, frustum: function(H, N, W, R, Y, I) {
          var P = 1 / (N - H), X = 1 / (R - W), G = 1 / (Y - I);
          return this.setValues(Y * 2 * P, 0, 0, 0, 0, Y * 2 * X, 0, 0, (N + H) * P, (R + W) * X, (I + Y) * G, -1, 0, 0, I * Y * 2 * G, 0);
        }, perspective: function(H, N, W, R) {
          var Y = 1 / Math.tan(H / 2), I = 1 / (W - R);
          return this.setValues(Y / N, 0, 0, 0, 0, Y, 0, 0, 0, 0, (R + W) * I, -1, 0, 0, 2 * R * W * I, 0);
        }, perspectiveLH: function(H, N, W, R) {
          return this.setValues(2 * W / H, 0, 0, 0, 0, 2 * W / N, 0, 0, 0, 0, -R / (W - R), 1, 0, 0, W * R / (W - R), 0);
        }, ortho: function(H, N, W, R, Y, I) {
          var P = H - N, X = W - R, G = Y - I;
          return P = P === 0 ? P : 1 / P, X = X === 0 ? X : 1 / X, G = G === 0 ? G : 1 / G, this.setValues(-2 * P, 0, 0, 0, 0, -2 * X, 0, 0, 0, 0, 2 * G, 0, (H + N) * P, (R + W) * X, (I + Y) * G, 1);
        }, lookAtRH: function(H, N, W) {
          var R = this.val;
          if (Q.subVectors(H, N), Q.getLengthSquared() === 0)
            Q.z = 1;
          if (Q.normalize(), Z.crossVectors(W, Q), Z.getLengthSquared() === 0) {
            if (Math.abs(W.z) === 1)
              Q.x += 0.0001;
            else
              Q.z += 0.0001;
            Q.normalize(), Z.crossVectors(W, Q);
          }
          return Z.normalize(), D.crossVectors(Q, Z), R[0] = Z.x, R[1] = Z.y, R[2] = Z.z, R[4] = D.x, R[5] = D.y, R[6] = D.z, R[8] = Q.x, R[9] = Q.y, R[10] = Q.z, this;
        }, lookAt: function(H, N, W) {
          var { x: R, y: Y, z: I } = H, P = W.x, X = W.y, G = W.z, V = N.x, A = N.y, F = N.z;
          if (Math.abs(R - V) < z && Math.abs(Y - A) < z && Math.abs(I - F) < z)
            return this.identity();
          var j = R - V, T = Y - A, C = I - F, v = 1 / Math.sqrt(j * j + T * T + C * C);
          j *= v, T *= v, C *= v;
          var O = X * C - G * T, q = G * j - P * C, w = P * T - X * j;
          if (v = Math.sqrt(O * O + q * q + w * w), !v)
            O = 0, q = 0, w = 0;
          else
            v = 1 / v, O *= v, q *= v, w *= v;
          var g = T * w - C * q, b = C * O - j * w, x = j * q - T * O;
          if (v = Math.sqrt(g * g + b * b + x * x), !v)
            g = 0, b = 0, x = 0;
          else
            v = 1 / v, g *= v, b *= v, x *= v;
          return this.setValues(O, g, j, 0, q, b, T, 0, w, x, C, 0, -(O * R + q * Y + w * I), -(g * R + b * Y + x * I), -(j * R + T * Y + C * I), 1);
        }, yawPitchRoll: function(H, N, W) {
          this.zero(), K.zero(), J.zero();
          var R = this.val, Y = K.val, I = J.val, P = Math.sin(W), X = Math.cos(W);
          return R[10] = 1, R[15] = 1, R[0] = X, R[1] = P, R[4] = -P, R[5] = X, P = Math.sin(N), X = Math.cos(N), Y[0] = 1, Y[15] = 1, Y[5] = X, Y[10] = X, Y[9] = -P, Y[6] = P, P = Math.sin(H), X = Math.cos(H), I[5] = 1, I[15] = 1, I[0] = X, I[2] = -P, I[8] = P, I[10] = X, this.multiplyLocal(K), this.multiplyLocal(J), this;
        }, setWorldMatrix: function(H, N, W, R, Y) {
          if (this.yawPitchRoll(H.y, H.x, H.z), K.scaling(W.x, W.y, W.z), J.xyz(N.x, N.y, N.z), this.multiplyLocal(K), this.multiplyLocal(J), R)
            this.multiplyLocal(R);
          if (Y)
            this.multiplyLocal(Y);
          return this;
        }, multiplyToMat4: function(H, N) {
          var W = this.val, R = H.val, Y = W[0], I = W[1], P = W[2], X = W[3], G = W[4], V = W[5], A = W[6], F = W[7], j = W[8], T = W[9], C = W[10], v = W[11], O = W[12], q = W[13], w = W[14], g = W[15], b = R[0], x = R[1], k = R[2], S = R[3], f = R[4], h = R[5], m = R[6], y = R[7], d = R[8], p = R[9], u = R[10], s = R[11], c = R[12], n = R[13], _ = R[14], l = R[15];
          return N.setValues(b * Y + x * G + k * j + S * O, x * I + x * V + k * T + S * q, k * P + x * A + k * C + S * w, S * X + x * F + k * v + S * g, f * Y + h * G + m * j + y * O, f * I + h * V + m * T + y * q, f * P + h * A + m * C + y * w, f * X + h * F + m * v + y * g, d * Y + p * G + u * j + s * O, d * I + p * V + u * T + s * q, d * P + p * A + u * C + s * w, d * X + p * F + u * v + s * g, c * Y + n * G + _ * j + l * O, c * I + n * V + _ * T + l * q, c * P + n * A + _ * C + l * w, c * X + n * F + _ * v + l * g);
        }, fromRotationXYTranslation: function(H, N, W) {
          var { x: R, y: Y, z: I } = N, P = Math.sin(H.x), X = Math.cos(H.x), G = Math.sin(H.y), V = Math.cos(H.y), A = R, F = Y, j = I, T = -P, C = 0 - T * G, v = 0 - X * G, O = T * V, q = X * V;
          if (!W)
            A = V * R + G * I, F = C * R + X * Y + O * I, j = v * R + P * Y + q * I;
          return this.setValues(V, C, v, 0, 0, X, P, 0, G, O, q, 0, A, F, j, 1);
        }, getMaxScaleOnAxis: function() {
          var H = this.val, N = H[0] * H[0] + H[1] * H[1] + H[2] * H[2], W = H[4] * H[4] + H[5] * H[5] + H[6] * H[6], R = H[8] * H[8] + H[9] * H[9] + H[10] * H[10];
          return Math.sqrt(Math.max(N, W, R));
        } }), K = new U, J = new U, Z = new L, D = new L, Q = new L;
        M.exports = U;
      }, 86883: (M) => {
        var B = function($, E, L) {
          return Math.min($ + E, L);
        };
        M.exports = B;
      }, 50040: (M) => {
        var B = function($) {
          var E = $.length;
          if (E === 0)
            return 0;
          $.sort(function(z, U) {
            return z - U;
          });
          var L = Math.floor(E / 2);
          return E % 2 === 0 ? ($[L] + $[L - 1]) / 2 : $[L];
        };
        M.exports = B;
      }, 37204: (M) => {
        var B = function($, E, L) {
          return Math.max($ - E, L);
        };
        M.exports = B;
      }, 65201: (M) => {
        var B = function($, E, L, z) {
          if (L === undefined)
            L = E + 1;
          var U = ($ - E) / (L - E);
          if (U > 1)
            if (z !== undefined) {
              if (U = (z - $) / (z - L), U < 0)
                U = 0;
            } else
              U = 1;
          else if (U < 0)
            U = 0;
          return U;
        };
        M.exports = B;
      }, 15746: (M, B, $) => {
        var E = $(83419), L = $(94434), z = $(29747), U = $(25836), K = 0.000001, J = new Int8Array([1, 2, 0]), Z = new Float32Array([0, 0, 0]), D = new U(1, 0, 0), Q = new U(0, 1, 0), H = new U, N = new L, W = new E({ initialize: function R(Y, I, P, X) {
          this.onChangeCallback = z, this.set(Y, I, P, X);
        }, x: { get: function() {
          return this._x;
        }, set: function(R) {
          this._x = R, this.onChangeCallback(this);
        } }, y: { get: function() {
          return this._y;
        }, set: function(R) {
          this._y = R, this.onChangeCallback(this);
        } }, z: { get: function() {
          return this._z;
        }, set: function(R) {
          this._z = R, this.onChangeCallback(this);
        } }, w: { get: function() {
          return this._w;
        }, set: function(R) {
          this._w = R, this.onChangeCallback(this);
        } }, copy: function(R) {
          return this.set(R);
        }, set: function(R, Y, I, P, X) {
          if (X === undefined)
            X = true;
          if (typeof R === "object")
            this._x = R.x || 0, this._y = R.y || 0, this._z = R.z || 0, this._w = R.w || 0;
          else
            this._x = R || 0, this._y = Y || 0, this._z = I || 0, this._w = P || 0;
          if (X)
            this.onChangeCallback(this);
          return this;
        }, add: function(R) {
          return this._x += R.x, this._y += R.y, this._z += R.z, this._w += R.w, this.onChangeCallback(this), this;
        }, subtract: function(R) {
          return this._x -= R.x, this._y -= R.y, this._z -= R.z, this._w -= R.w, this.onChangeCallback(this), this;
        }, scale: function(R) {
          return this._x *= R, this._y *= R, this._z *= R, this._w *= R, this.onChangeCallback(this), this;
        }, length: function() {
          var R = this.x, Y = this.y, I = this.z, P = this.w;
          return Math.sqrt(R * R + Y * Y + I * I + P * P);
        }, lengthSq: function() {
          var R = this.x, Y = this.y, I = this.z, P = this.w;
          return R * R + Y * Y + I * I + P * P;
        }, normalize: function() {
          var R = this.x, Y = this.y, I = this.z, P = this.w, X = R * R + Y * Y + I * I + P * P;
          if (X > 0)
            X = 1 / Math.sqrt(X), this._x = R * X, this._y = Y * X, this._z = I * X, this._w = P * X;
          return this.onChangeCallback(this), this;
        }, dot: function(R) {
          return this.x * R.x + this.y * R.y + this.z * R.z + this.w * R.w;
        }, lerp: function(R, Y) {
          if (Y === undefined)
            Y = 0;
          var I = this.x, P = this.y, X = this.z, G = this.w;
          return this.set(I + Y * (R.x - I), P + Y * (R.y - P), X + Y * (R.z - X), G + Y * (R.w - G));
        }, rotationTo: function(R, Y) {
          var I = R.x * Y.x + R.y * Y.y + R.z * Y.z;
          if (I < -0.999999) {
            if (H.copy(D).cross(R).length() < K)
              H.copy(Q).cross(R);
            return H.normalize(), this.setAxisAngle(H, Math.PI);
          } else if (I > 0.999999)
            return this.set(0, 0, 0, 1);
          else
            return H.copy(R).cross(Y), this._x = H.x, this._y = H.y, this._z = H.z, this._w = 1 + I, this.normalize();
        }, setAxes: function(R, Y, I) {
          var P = N.val;
          return P[0] = Y.x, P[3] = Y.y, P[6] = Y.z, P[1] = I.x, P[4] = I.y, P[7] = I.z, P[2] = -R.x, P[5] = -R.y, P[8] = -R.z, this.fromMat3(N).normalize();
        }, identity: function() {
          return this.set(0, 0, 0, 1);
        }, setAxisAngle: function(R, Y) {
          Y = Y * 0.5;
          var I = Math.sin(Y);
          return this.set(I * R.x, I * R.y, I * R.z, Math.cos(Y));
        }, multiply: function(R) {
          var Y = this.x, I = this.y, P = this.z, X = this.w, G = R.x, V = R.y, A = R.z, F = R.w;
          return this.set(Y * F + X * G + I * A - P * V, I * F + X * V + P * G - Y * A, P * F + X * A + Y * V - I * G, X * F - Y * G - I * V - P * A);
        }, slerp: function(R, Y) {
          var I = this.x, P = this.y, X = this.z, G = this.w, V = R.x, A = R.y, F = R.z, j = R.w, T = I * V + P * A + X * F + G * j;
          if (T < 0)
            T = -T, V = -V, A = -A, F = -F, j = -j;
          var C = 1 - Y, v = Y;
          if (1 - T > K) {
            var O = Math.acos(T), q = Math.sin(O);
            C = Math.sin((1 - Y) * O) / q, v = Math.sin(Y * O) / q;
          }
          return this.set(C * I + v * V, C * P + v * A, C * X + v * F, C * G + v * j);
        }, invert: function() {
          var R = this.x, Y = this.y, I = this.z, P = this.w, X = R * R + Y * Y + I * I + P * P, G = X ? 1 / X : 0;
          return this.set(-R * G, -Y * G, -I * G, P * G);
        }, conjugate: function() {
          return this._x = -this.x, this._y = -this.y, this._z = -this.z, this.onChangeCallback(this), this;
        }, rotateX: function(R) {
          R *= 0.5;
          var Y = this.x, I = this.y, P = this.z, X = this.w, G = Math.sin(R), V = Math.cos(R);
          return this.set(Y * V + X * G, I * V + P * G, P * V - I * G, X * V - Y * G);
        }, rotateY: function(R) {
          R *= 0.5;
          var Y = this.x, I = this.y, P = this.z, X = this.w, G = Math.sin(R), V = Math.cos(R);
          return this.set(Y * V - P * G, I * V + X * G, P * V + Y * G, X * V - I * G);
        }, rotateZ: function(R) {
          R *= 0.5;
          var Y = this.x, I = this.y, P = this.z, X = this.w, G = Math.sin(R), V = Math.cos(R);
          return this.set(Y * V + I * G, I * V - Y * G, P * V + X * G, X * V - P * G);
        }, calculateW: function() {
          var R = this.x, Y = this.y, I = this.z;
          return this.w = -Math.sqrt(1 - R * R - Y * Y - I * I), this;
        }, setFromEuler: function(R, Y) {
          var I = R.x / 2, P = R.y / 2, X = R.z / 2, G = Math.cos(I), V = Math.cos(P), A = Math.cos(X), F = Math.sin(I), j = Math.sin(P), T = Math.sin(X);
          switch (R.order) {
            case "XYZ": {
              this.set(F * V * A + G * j * T, G * j * A - F * V * T, G * V * T + F * j * A, G * V * A - F * j * T, Y);
              break;
            }
            case "YXZ": {
              this.set(F * V * A + G * j * T, G * j * A - F * V * T, G * V * T - F * j * A, G * V * A + F * j * T, Y);
              break;
            }
            case "ZXY": {
              this.set(F * V * A - G * j * T, G * j * A + F * V * T, G * V * T + F * j * A, G * V * A - F * j * T, Y);
              break;
            }
            case "ZYX": {
              this.set(F * V * A - G * j * T, G * j * A + F * V * T, G * V * T - F * j * A, G * V * A + F * j * T, Y);
              break;
            }
            case "YZX": {
              this.set(F * V * A + G * j * T, G * j * A + F * V * T, G * V * T - F * j * A, G * V * A - F * j * T, Y);
              break;
            }
            case "XZY": {
              this.set(F * V * A - G * j * T, G * j * A - F * V * T, G * V * T + F * j * A, G * V * A + F * j * T, Y);
              break;
            }
          }
          return this;
        }, setFromRotationMatrix: function(R) {
          var Y = R.val, I = Y[0], P = Y[4], X = Y[8], G = Y[1], V = Y[5], A = Y[9], F = Y[2], j = Y[6], T = Y[10], C = I + V + T, v;
          if (C > 0)
            v = 0.5 / Math.sqrt(C + 1), this.set((j - A) * v, (X - F) * v, (G - P) * v, 0.25 / v);
          else if (I > V && I > T)
            v = 2 * Math.sqrt(1 + I - V - T), this.set(0.25 * v, (P + G) / v, (X + F) / v, (j - A) / v);
          else if (V > T)
            v = 2 * Math.sqrt(1 + V - I - T), this.set((P + G) / v, 0.25 * v, (A + j) / v, (X - F) / v);
          else
            v = 2 * Math.sqrt(1 + T - I - V), this.set((X + F) / v, (A + j) / v, 0.25 * v, (G - P) / v);
          return this;
        }, fromMat3: function(R) {
          var Y = R.val, I = Y[0] + Y[4] + Y[8], P;
          if (I > 0)
            P = Math.sqrt(I + 1), this.w = 0.5 * P, P = 0.5 / P, this._x = (Y[7] - Y[5]) * P, this._y = (Y[2] - Y[6]) * P, this._z = (Y[3] - Y[1]) * P;
          else {
            var X = 0;
            if (Y[4] > Y[0])
              X = 1;
            if (Y[8] > Y[X * 3 + X])
              X = 2;
            var G = J[X], V = J[G];
            P = Math.sqrt(Y[X * 3 + X] - Y[G * 3 + G] - Y[V * 3 + V] + 1), Z[X] = 0.5 * P, P = 0.5 / P, Z[G] = (Y[G * 3 + X] + Y[X * 3 + G]) * P, Z[V] = (Y[V * 3 + X] + Y[X * 3 + V]) * P, this._x = Z[0], this._y = Z[1], this._z = Z[2], this._w = (Y[V * 3 + G] - Y[G * 3 + V]) * P;
          }
          return this.onChangeCallback(this), this;
        } });
        M.exports = W;
      }, 43396: (M, B, $) => {
        var E = $(36383), L = function(z) {
          return z * E.RAD_TO_DEG;
        };
        M.exports = L;
      }, 74362: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = 1;
          var L = Math.random() * 2 * Math.PI;
          return $.x = Math.cos(L) * E, $.y = Math.sin(L) * E, $;
        };
        M.exports = B;
      }, 60706: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = 1;
          var L = Math.random() * 2 * Math.PI, z = Math.random() * 2 - 1, U = Math.sqrt(1 - z * z) * E;
          return $.x = Math.cos(L) * U, $.y = Math.sin(L) * U, $.z = z * E, $;
        };
        M.exports = B;
      }, 67421: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = 1;
          return $.x = (Math.random() * 2 - 1) * E, $.y = (Math.random() * 2 - 1) * E, $.z = (Math.random() * 2 - 1) * E, $.w = (Math.random() * 2 - 1) * E, $;
        };
        M.exports = B;
      }, 36305: (M) => {
        var B = function($, E) {
          var { x: L, y: z } = $;
          return $.x = L * Math.cos(E) - z * Math.sin(E), $.y = L * Math.sin(E) + z * Math.cos(E), $;
        };
        M.exports = B;
      }, 11520: (M) => {
        var B = function($, E, L, z) {
          var U = Math.cos(z), K = Math.sin(z), J = $.x - E, Z = $.y - L;
          return $.x = J * U - Z * K + E, $.y = J * K + Z * U + L, $;
        };
        M.exports = B;
      }, 1163: (M) => {
        var B = function($, E, L, z, U) {
          var K = z + Math.atan2($.y - L, $.x - E);
          return $.x = E + U * Math.cos(K), $.y = L + U * Math.sin(K), $;
        };
        M.exports = B;
      }, 70336: (M) => {
        var B = function($, E, L, z, U) {
          return $.x = E + U * Math.cos(z), $.y = L + U * Math.sin(z), $;
        };
        M.exports = B;
      }, 72678: (M, B, $) => {
        var E = $(25836), L = $(37867), z = $(15746), U = new L, K = new z, J = new E, Z = function(D, Q, H) {
          return K.setAxisAngle(Q, H), U.fromRotationTranslation(K, J.set(0, 0, 0)), D.transformMat4(U);
        };
        M.exports = Z;
      }, 2284: (M) => {
        var B = function($) {
          return $ > 0 ? Math.ceil($) : Math.floor($);
        };
        M.exports = B;
      }, 41013: (M) => {
        var B = function($, E, L) {
          if (E === undefined)
            E = 0;
          if (L === undefined)
            L = 10;
          var z = Math.pow(L, -E);
          return Math.round($ * z) / z;
        };
        M.exports = B;
      }, 16922: (M) => {
        var B = function($, E, L, z) {
          if (E === undefined)
            E = 1;
          if (L === undefined)
            L = 1;
          if (z === undefined)
            z = 1;
          z *= Math.PI / $;
          var U = [], K = [];
          for (var J = 0;J < $; J++)
            L -= E * z, E += L * z, U[J] = L, K[J] = E;
          return { sin: K, cos: U, length: $ };
        };
        M.exports = B;
      }, 7602: (M) => {
        var B = function($, E, L) {
          if ($ <= E)
            return 0;
          if ($ >= L)
            return 1;
          return $ = ($ - E) / (L - E), $ * $ * (3 - 2 * $);
        };
        M.exports = B;
      }, 54261: (M) => {
        var B = function($, E, L) {
          return $ = Math.max(0, Math.min(1, ($ - E) / (L - E))), $ * $ * $ * ($ * ($ * 6 - 15) + 10);
        };
        M.exports = B;
      }, 44408: (M, B, $) => {
        var E = $(26099), L = function(z, U, K, J) {
          if (J === undefined)
            J = new E;
          var Z = 0, D = 0, Q = U * K;
          if (z > 0 && z <= Q)
            if (z > U - 1)
              D = Math.floor(z / U), Z = z - D * U;
            else
              Z = z;
          return J.set(Z, D);
        };
        M.exports = L;
      }, 85955: (M, B, $) => {
        var E = $(26099), L = function(z, U, K, J, Z, D, Q, H) {
          if (H === undefined)
            H = new E;
          var N = Math.sin(Z), W = Math.cos(Z), R = W * D, Y = N * D, I = -N * Q, P = W * Q, X = 1 / (R * P + I * -Y);
          return H.x = P * X * z + -I * X * U + (J * I - K * P) * X, H.y = R * X * U + -Y * X * z + (-J * R + K * Y) * X, H;
        };
        M.exports = L;
      }, 26099: (M, B, $) => {
        var E = $(83419), L = $(43855), z = new E({ initialize: function U(K, J) {
          if (this.x = 0, this.y = 0, typeof K === "object")
            this.x = K.x || 0, this.y = K.y || 0;
          else {
            if (J === undefined)
              J = K;
            this.x = K || 0, this.y = J || 0;
          }
        }, clone: function() {
          return new z(this.x, this.y);
        }, copy: function(U) {
          return this.x = U.x || 0, this.y = U.y || 0, this;
        }, setFromObject: function(U) {
          return this.x = U.x || 0, this.y = U.y || 0, this;
        }, set: function(U, K) {
          if (K === undefined)
            K = U;
          return this.x = U, this.y = K, this;
        }, setTo: function(U, K) {
          return this.set(U, K);
        }, setToPolar: function(U, K) {
          if (K == null)
            K = 1;
          return this.x = Math.cos(U) * K, this.y = Math.sin(U) * K, this;
        }, equals: function(U) {
          return this.x === U.x && this.y === U.y;
        }, fuzzyEquals: function(U, K) {
          return L(this.x, U.x, K) && L(this.y, U.y, K);
        }, angle: function() {
          var U = Math.atan2(this.y, this.x);
          if (U < 0)
            U += 2 * Math.PI;
          return U;
        }, setAngle: function(U) {
          return this.setToPolar(U, this.length());
        }, add: function(U) {
          return this.x += U.x, this.y += U.y, this;
        }, subtract: function(U) {
          return this.x -= U.x, this.y -= U.y, this;
        }, multiply: function(U) {
          return this.x *= U.x, this.y *= U.y, this;
        }, scale: function(U) {
          if (isFinite(U))
            this.x *= U, this.y *= U;
          else
            this.x = 0, this.y = 0;
          return this;
        }, divide: function(U) {
          return this.x /= U.x, this.y /= U.y, this;
        }, negate: function() {
          return this.x = -this.x, this.y = -this.y, this;
        }, distance: function(U) {
          var K = U.x - this.x, J = U.y - this.y;
          return Math.sqrt(K * K + J * J);
        }, distanceSq: function(U) {
          var K = U.x - this.x, J = U.y - this.y;
          return K * K + J * J;
        }, length: function() {
          var U = this.x, K = this.y;
          return Math.sqrt(U * U + K * K);
        }, setLength: function(U) {
          return this.normalize().scale(U);
        }, lengthSq: function() {
          var U = this.x, K = this.y;
          return U * U + K * K;
        }, normalize: function() {
          var U = this.x, K = this.y, J = U * U + K * K;
          if (J > 0)
            J = 1 / Math.sqrt(J), this.x = U * J, this.y = K * J;
          return this;
        }, normalizeRightHand: function() {
          var U = this.x;
          return this.x = this.y * -1, this.y = U, this;
        }, normalizeLeftHand: function() {
          var U = this.x;
          return this.x = this.y, this.y = U * -1, this;
        }, dot: function(U) {
          return this.x * U.x + this.y * U.y;
        }, cross: function(U) {
          return this.x * U.y - this.y * U.x;
        }, lerp: function(U, K) {
          if (K === undefined)
            K = 0;
          var J = this.x, Z = this.y;
          return this.x = J + K * (U.x - J), this.y = Z + K * (U.y - Z), this;
        }, transformMat3: function(U) {
          var K = this.x, J = this.y, Z = U.val;
          return this.x = Z[0] * K + Z[3] * J + Z[6], this.y = Z[1] * K + Z[4] * J + Z[7], this;
        }, transformMat4: function(U) {
          var K = this.x, J = this.y, Z = U.val;
          return this.x = Z[0] * K + Z[4] * J + Z[12], this.y = Z[1] * K + Z[5] * J + Z[13], this;
        }, reset: function() {
          return this.x = 0, this.y = 0, this;
        }, limit: function(U) {
          var K = this.length();
          if (K && K > U)
            this.scale(U / K);
          return this;
        }, reflect: function(U) {
          return U = U.clone().normalize(), this.subtract(U.scale(2 * this.dot(U)));
        }, mirror: function(U) {
          return this.reflect(U).negate();
        }, rotate: function(U) {
          var K = Math.cos(U), J = Math.sin(U);
          return this.set(K * this.x - J * this.y, J * this.x + K * this.y);
        }, project: function(U) {
          var K = this.dot(U) / U.dot(U);
          return this.copy(U).scale(K);
        } });
        z.ZERO = new z, z.RIGHT = new z(1, 0), z.LEFT = new z(-1, 0), z.UP = new z(0, -1), z.DOWN = new z(0, 1), z.ONE = new z(1, 1), M.exports = z;
      }, 25836: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U, K, J) {
          if (this.x = 0, this.y = 0, this.z = 0, typeof U === "object")
            this.x = U.x || 0, this.y = U.y || 0, this.z = U.z || 0;
          else
            this.x = U || 0, this.y = K || 0, this.z = J || 0;
        }, up: function() {
          return this.x = 0, this.y = 1, this.z = 0, this;
        }, min: function(z) {
          return this.x = Math.min(this.x, z.x), this.y = Math.min(this.y, z.y), this.z = Math.min(this.z, z.z), this;
        }, max: function(z) {
          return this.x = Math.max(this.x, z.x), this.y = Math.max(this.y, z.y), this.z = Math.max(this.z, z.z), this;
        }, clone: function() {
          return new L(this.x, this.y, this.z);
        }, addVectors: function(z, U) {
          return this.x = z.x + U.x, this.y = z.y + U.y, this.z = z.z + U.z, this;
        }, crossVectors: function(z, U) {
          var { x: K, y: J, z: Z } = z, D = U.x, Q = U.y, H = U.z;
          return this.x = J * H - Z * Q, this.y = Z * D - K * H, this.z = K * Q - J * D, this;
        }, equals: function(z) {
          return this.x === z.x && this.y === z.y && this.z === z.z;
        }, copy: function(z) {
          return this.x = z.x, this.y = z.y, this.z = z.z || 0, this;
        }, set: function(z, U, K) {
          if (typeof z === "object")
            this.x = z.x || 0, this.y = z.y || 0, this.z = z.z || 0;
          else
            this.x = z || 0, this.y = U || 0, this.z = K || 0;
          return this;
        }, setFromMatrixPosition: function(z) {
          return this.fromArray(z.val, 12);
        }, setFromMatrixColumn: function(z, U) {
          return this.fromArray(z.val, U * 4);
        }, fromArray: function(z, U) {
          if (U === undefined)
            U = 0;
          return this.x = z[U], this.y = z[U + 1], this.z = z[U + 2], this;
        }, add: function(z) {
          return this.x += z.x, this.y += z.y, this.z += z.z || 0, this;
        }, addScalar: function(z) {
          return this.x += z, this.y += z, this.z += z, this;
        }, addScale: function(z, U) {
          return this.x += z.x * U, this.y += z.y * U, this.z += z.z * U || 0, this;
        }, subtract: function(z) {
          return this.x -= z.x, this.y -= z.y, this.z -= z.z || 0, this;
        }, multiply: function(z) {
          return this.x *= z.x, this.y *= z.y, this.z *= z.z || 1, this;
        }, scale: function(z) {
          if (isFinite(z))
            this.x *= z, this.y *= z, this.z *= z;
          else
            this.x = 0, this.y = 0, this.z = 0;
          return this;
        }, divide: function(z) {
          return this.x /= z.x, this.y /= z.y, this.z /= z.z || 1, this;
        }, negate: function() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }, distance: function(z) {
          var U = z.x - this.x, K = z.y - this.y, J = z.z - this.z || 0;
          return Math.sqrt(U * U + K * K + J * J);
        }, distanceSq: function(z) {
          var U = z.x - this.x, K = z.y - this.y, J = z.z - this.z || 0;
          return U * U + K * K + J * J;
        }, length: function() {
          var z = this.x, U = this.y, K = this.z;
          return Math.sqrt(z * z + U * U + K * K);
        }, lengthSq: function() {
          var z = this.x, U = this.y, K = this.z;
          return z * z + U * U + K * K;
        }, normalize: function() {
          var z = this.x, U = this.y, K = this.z, J = z * z + U * U + K * K;
          if (J > 0)
            J = 1 / Math.sqrt(J), this.x = z * J, this.y = U * J, this.z = K * J;
          return this;
        }, dot: function(z) {
          return this.x * z.x + this.y * z.y + this.z * z.z;
        }, cross: function(z) {
          var U = this.x, K = this.y, J = this.z, Z = z.x, D = z.y, Q = z.z;
          return this.x = K * Q - J * D, this.y = J * Z - U * Q, this.z = U * D - K * Z, this;
        }, lerp: function(z, U) {
          if (U === undefined)
            U = 0;
          var K = this.x, J = this.y, Z = this.z;
          return this.x = K + U * (z.x - K), this.y = J + U * (z.y - J), this.z = Z + U * (z.z - Z), this;
        }, applyMatrix3: function(z) {
          var U = this.x, K = this.y, J = this.z, Z = z.val;
          return this.x = Z[0] * U + Z[3] * K + Z[6] * J, this.y = Z[1] * U + Z[4] * K + Z[7] * J, this.z = Z[2] * U + Z[5] * K + Z[8] * J, this;
        }, applyMatrix4: function(z) {
          var U = this.x, K = this.y, J = this.z, Z = z.val, D = 1 / (Z[3] * U + Z[7] * K + Z[11] * J + Z[15]);
          return this.x = (Z[0] * U + Z[4] * K + Z[8] * J + Z[12]) * D, this.y = (Z[1] * U + Z[5] * K + Z[9] * J + Z[13]) * D, this.z = (Z[2] * U + Z[6] * K + Z[10] * J + Z[14]) * D, this;
        }, transformMat3: function(z) {
          var U = this.x, K = this.y, J = this.z, Z = z.val;
          return this.x = U * Z[0] + K * Z[3] + J * Z[6], this.y = U * Z[1] + K * Z[4] + J * Z[7], this.z = U * Z[2] + K * Z[5] + J * Z[8], this;
        }, transformMat4: function(z) {
          var U = this.x, K = this.y, J = this.z, Z = z.val;
          return this.x = Z[0] * U + Z[4] * K + Z[8] * J + Z[12], this.y = Z[1] * U + Z[5] * K + Z[9] * J + Z[13], this.z = Z[2] * U + Z[6] * K + Z[10] * J + Z[14], this;
        }, transformCoordinates: function(z) {
          var U = this.x, K = this.y, J = this.z, Z = z.val, D = U * Z[0] + K * Z[4] + J * Z[8] + Z[12], Q = U * Z[1] + K * Z[5] + J * Z[9] + Z[13], H = U * Z[2] + K * Z[6] + J * Z[10] + Z[14], N = U * Z[3] + K * Z[7] + J * Z[11] + Z[15];
          return this.x = D / N, this.y = Q / N, this.z = H / N, this;
        }, transformQuat: function(z) {
          var U = this.x, K = this.y, J = this.z, Z = z.x, D = z.y, Q = z.z, H = z.w, N = H * U + D * J - Q * K, W = H * K + Q * U - Z * J, R = H * J + Z * K - D * U, Y = -Z * U - D * K - Q * J;
          return this.x = N * H + Y * -Z + W * -Q - R * -D, this.y = W * H + Y * -D + R * -Z - N * -Q, this.z = R * H + Y * -Q + N * -D - W * -Z, this;
        }, project: function(z) {
          var U = this.x, K = this.y, J = this.z, Z = z.val, D = Z[0], Q = Z[1], H = Z[2], N = Z[3], W = Z[4], R = Z[5], Y = Z[6], I = Z[7], P = Z[8], X = Z[9], G = Z[10], V = Z[11], A = Z[12], F = Z[13], j = Z[14], T = Z[15], C = 1 / (U * N + K * I + J * V + T);
          return this.x = (U * D + K * W + J * P + A) * C, this.y = (U * Q + K * R + J * X + F) * C, this.z = (U * H + K * Y + J * G + j) * C, this;
        }, projectViewMatrix: function(z, U) {
          return this.applyMatrix4(z).applyMatrix4(U);
        }, unprojectViewMatrix: function(z, U) {
          return this.applyMatrix4(z).applyMatrix4(U);
        }, unproject: function(z, U) {
          var { x: K, y: J, z: Z, w: D } = z, Q = this.x - K, H = D - this.y - 1 - J, N = this.z;
          return this.x = 2 * Q / Z - 1, this.y = 2 * H / D - 1, this.z = 2 * N - 1, this.project(U);
        }, reset: function() {
          return this.x = 0, this.y = 0, this.z = 0, this;
        } });
        L.ZERO = new L, L.RIGHT = new L(1, 0, 0), L.LEFT = new L(-1, 0, 0), L.UP = new L(0, -1, 0), L.DOWN = new L(0, 1, 0), L.FORWARD = new L(0, 0, 1), L.BACK = new L(0, 0, -1), L.ONE = new L(1, 1, 1), M.exports = L;
      }, 61369: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U, K, J, Z) {
          if (this.x = 0, this.y = 0, this.z = 0, this.w = 0, typeof U === "object")
            this.x = U.x || 0, this.y = U.y || 0, this.z = U.z || 0, this.w = U.w || 0;
          else
            this.x = U || 0, this.y = K || 0, this.z = J || 0, this.w = Z || 0;
        }, clone: function() {
          return new L(this.x, this.y, this.z, this.w);
        }, copy: function(z) {
          return this.x = z.x, this.y = z.y, this.z = z.z || 0, this.w = z.w || 0, this;
        }, equals: function(z) {
          return this.x === z.x && this.y === z.y && this.z === z.z && this.w === z.w;
        }, set: function(z, U, K, J) {
          if (typeof z === "object")
            this.x = z.x || 0, this.y = z.y || 0, this.z = z.z || 0, this.w = z.w || 0;
          else
            this.x = z || 0, this.y = U || 0, this.z = K || 0, this.w = J || 0;
          return this;
        }, add: function(z) {
          return this.x += z.x, this.y += z.y, this.z += z.z || 0, this.w += z.w || 0, this;
        }, subtract: function(z) {
          return this.x -= z.x, this.y -= z.y, this.z -= z.z || 0, this.w -= z.w || 0, this;
        }, scale: function(z) {
          return this.x *= z, this.y *= z, this.z *= z, this.w *= z, this;
        }, length: function() {
          var z = this.x, U = this.y, K = this.z, J = this.w;
          return Math.sqrt(z * z + U * U + K * K + J * J);
        }, lengthSq: function() {
          var z = this.x, U = this.y, K = this.z, J = this.w;
          return z * z + U * U + K * K + J * J;
        }, normalize: function() {
          var z = this.x, U = this.y, K = this.z, J = this.w, Z = z * z + U * U + K * K + J * J;
          if (Z > 0)
            Z = 1 / Math.sqrt(Z), this.x = z * Z, this.y = U * Z, this.z = K * Z, this.w = J * Z;
          return this;
        }, dot: function(z) {
          return this.x * z.x + this.y * z.y + this.z * z.z + this.w * z.w;
        }, lerp: function(z, U) {
          if (U === undefined)
            U = 0;
          var K = this.x, J = this.y, Z = this.z, D = this.w;
          return this.x = K + U * (z.x - K), this.y = J + U * (z.y - J), this.z = Z + U * (z.z - Z), this.w = D + U * (z.w - D), this;
        }, multiply: function(z) {
          return this.x *= z.x, this.y *= z.y, this.z *= z.z || 1, this.w *= z.w || 1, this;
        }, divide: function(z) {
          return this.x /= z.x, this.y /= z.y, this.z /= z.z || 1, this.w /= z.w || 1, this;
        }, distance: function(z) {
          var U = z.x - this.x, K = z.y - this.y, J = z.z - this.z || 0, Z = z.w - this.w || 0;
          return Math.sqrt(U * U + K * K + J * J + Z * Z);
        }, distanceSq: function(z) {
          var U = z.x - this.x, K = z.y - this.y, J = z.z - this.z || 0, Z = z.w - this.w || 0;
          return U * U + K * K + J * J + Z * Z;
        }, negate: function() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }, transformMat4: function(z) {
          var U = this.x, K = this.y, J = this.z, Z = this.w, D = z.val;
          return this.x = D[0] * U + D[4] * K + D[8] * J + D[12] * Z, this.y = D[1] * U + D[5] * K + D[9] * J + D[13] * Z, this.z = D[2] * U + D[6] * K + D[10] * J + D[14] * Z, this.w = D[3] * U + D[7] * K + D[11] * J + D[15] * Z, this;
        }, transformQuat: function(z) {
          var U = this.x, K = this.y, J = this.z, Z = z.x, D = z.y, Q = z.z, H = z.w, N = H * U + D * J - Q * K, W = H * K + Q * U - Z * J, R = H * J + Z * K - D * U, Y = -Z * U - D * K - Q * J;
          return this.x = N * H + Y * -Z + W * -Q - R * -D, this.y = W * H + Y * -D + R * -Z - N * -Q, this.z = R * H + Y * -Q + N * -D - W * -Z, this;
        }, reset: function() {
          return this.x = 0, this.y = 0, this.z = 0, this.w = 0, this;
        } });
        L.prototype.sub = L.prototype.subtract, L.prototype.mul = L.prototype.multiply, L.prototype.div = L.prototype.divide, L.prototype.dist = L.prototype.distance, L.prototype.distSq = L.prototype.distanceSq, L.prototype.len = L.prototype.length, L.prototype.lenSq = L.prototype.lengthSq, M.exports = L;
      }, 60417: (M) => {
        var B = function($, E, L) {
          return Math.abs($ - E) <= L;
        };
        M.exports = B;
      }, 15994: (M) => {
        var B = function($, E, L) {
          var z = L - E;
          return E + (($ - E) % z + z) % z;
        };
        M.exports = B;
      }, 31040: (M) => {
        var B = function($, E, L, z) {
          return Math.atan2(z - E, L - $);
        };
        M.exports = B;
      }, 55495: (M) => {
        var B = function($, E) {
          return Math.atan2(E.y - $.y, E.x - $.x);
        };
        M.exports = B;
      }, 128: (M) => {
        var B = function($, E) {
          return Math.atan2(E.x - $.x, E.y - $.y);
        };
        M.exports = B;
      }, 41273: (M) => {
        var B = function($, E, L, z) {
          return Math.atan2(L - $, z - E);
        };
        M.exports = B;
      }, 1432: (M, B, $) => {
        var E = $(36383), L = function(z) {
          if (z > Math.PI)
            z -= E.PI2;
          return Math.abs(((z + E.TAU) % E.PI2 - E.PI2) % E.PI2);
        };
        M.exports = L;
      }, 12407: (M) => {
        var B = function($) {
          if ($ = $ % (2 * Math.PI), $ >= 0)
            return $;
          else
            return $ + 2 * Math.PI;
        };
        M.exports = B;
      }, 53993: (M, B, $) => {
        var E = $(99472), L = function() {
          return E(-Math.PI, Math.PI);
        };
        M.exports = L;
      }, 86564: (M, B, $) => {
        var E = $(99472), L = function() {
          return E(-180, 180);
        };
        M.exports = L;
      }, 90154: (M, B, $) => {
        var E = $(12407), L = function(z) {
          return E(z + Math.PI);
        };
        M.exports = L;
      }, 48736: (M, B, $) => {
        var E = $(36383), L = function(z, U, K) {
          if (K === undefined)
            K = 0.05;
          if (z === U)
            return z;
          if (Math.abs(U - z) <= K || Math.abs(U - z) >= E.PI2 - K)
            z = U;
          else {
            if (Math.abs(U - z) > Math.PI)
              if (U < z)
                U += E.PI2;
              else
                U -= E.PI2;
            if (U > z)
              z += K;
            else if (U < z)
              z -= K;
          }
          return z;
        };
        M.exports = L;
      }, 61430: (M) => {
        var B = function($, E) {
          var L = E - $;
          if (L === 0)
            return 0;
          var z = Math.floor((L - -180) / 360);
          return L - z * 360;
        };
        M.exports = B;
      }, 86554: (M, B, $) => {
        var E = $(15994), L = function(z) {
          return E(z, -Math.PI, Math.PI);
        };
        M.exports = L;
      }, 30954: (M, B, $) => {
        var E = $(15994), L = function(z) {
          return E(z, -180, 180);
        };
        M.exports = L;
      }, 25588: (M, B, $) => {
        M.exports = { Between: $(31040), BetweenPoints: $(55495), BetweenPointsY: $(128), BetweenY: $(41273), CounterClockwise: $(1432), Normalize: $(12407), Random: $(53993), RandomDegrees: $(86564), Reverse: $(90154), RotateTo: $(48736), ShortestBetween: $(61430), Wrap: $(86554), WrapDegrees: $(30954) };
      }, 36383: (M) => {
        var B = { PI2: Math.PI * 2, TAU: Math.PI * 0.5, EPSILON: 0.000001, DEG_TO_RAD: Math.PI / 180, RAD_TO_DEG: 180 / Math.PI, RND: null, MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991 };
        M.exports = B;
      }, 20339: (M) => {
        var B = function($, E, L, z) {
          var U = $ - L, K = E - z;
          return Math.sqrt(U * U + K * K);
        };
        M.exports = B;
      }, 52816: (M) => {
        var B = function($, E) {
          var L = $.x - E.x, z = $.y - E.y;
          return Math.sqrt(L * L + z * z);
        };
        M.exports = B;
      }, 64559: (M) => {
        var B = function($, E) {
          var L = $.x - E.x, z = $.y - E.y;
          return L * L + z * z;
        };
        M.exports = B;
      }, 82340: (M) => {
        var B = function($, E, L, z) {
          return Math.max(Math.abs($ - L), Math.abs(E - z));
        };
        M.exports = B;
      }, 14390: (M) => {
        var B = function($, E, L, z, U) {
          if (U === undefined)
            U = 2;
          return Math.sqrt(Math.pow(L - $, U) + Math.pow(z - E, U));
        };
        M.exports = B;
      }, 2243: (M) => {
        var B = function($, E, L, z) {
          return Math.abs($ - L) + Math.abs(E - z);
        };
        M.exports = B;
      }, 89774: (M) => {
        var B = function($, E, L, z) {
          var U = $ - L, K = E - z;
          return U * U + K * K;
        };
        M.exports = B;
      }, 50994: (M, B, $) => {
        M.exports = { Between: $(20339), BetweenPoints: $(52816), BetweenPointsSquared: $(64559), Chebyshev: $(82340), Power: $(14390), Snake: $(2243), Squared: $(89774) };
      }, 62640: (M, B, $) => {
        var E = $(54178), L = $(41521), z = $(79980), U = $(85433), K = $(99140), J = $(48857), Z = $(81596), D = $(59133), Q = $(98516), H = $(35248), N = $(82500), W = $(49752);
        M.exports = { Power0: Z, Power1: D.Out, Power2: U.Out, Power3: Q.Out, Power4: H.Out, Linear: Z, Quad: D.Out, Cubic: U.Out, Quart: Q.Out, Quint: H.Out, Sine: N.Out, Expo: J.Out, Circ: z.Out, Elastic: K.Out, Back: E.Out, Bounce: L.Out, Stepped: W, "Quad.easeIn": D.In, "Cubic.easeIn": U.In, "Quart.easeIn": Q.In, "Quint.easeIn": H.In, "Sine.easeIn": N.In, "Expo.easeIn": J.In, "Circ.easeIn": z.In, "Elastic.easeIn": K.In, "Back.easeIn": E.In, "Bounce.easeIn": L.In, "Quad.easeOut": D.Out, "Cubic.easeOut": U.Out, "Quart.easeOut": Q.Out, "Quint.easeOut": H.Out, "Sine.easeOut": N.Out, "Expo.easeOut": J.Out, "Circ.easeOut": z.Out, "Elastic.easeOut": K.Out, "Back.easeOut": E.Out, "Bounce.easeOut": L.Out, "Quad.easeInOut": D.InOut, "Cubic.easeInOut": U.InOut, "Quart.easeInOut": Q.InOut, "Quint.easeInOut": H.InOut, "Sine.easeInOut": N.InOut, "Expo.easeInOut": J.InOut, "Circ.easeInOut": z.InOut, "Elastic.easeInOut": K.InOut, "Back.easeInOut": E.InOut, "Bounce.easeInOut": L.InOut };
      }, 1639: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = 1.70158;
          return $ * $ * ((E + 1) * $ - E);
        };
        M.exports = B;
      }, 50099: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = 1.70158;
          var L = E * 1.525;
          if (($ *= 2) < 1)
            return 0.5 * ($ * $ * ((L + 1) * $ - L));
          else
            return 0.5 * (($ -= 2) * $ * ((L + 1) * $ + L) + 2);
        };
        M.exports = B;
      }, 41286: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = 1.70158;
          return --$ * $ * ((E + 1) * $ + E) + 1;
        };
        M.exports = B;
      }, 54178: (M, B, $) => {
        M.exports = { In: $(1639), Out: $(41286), InOut: $(50099) };
      }, 59590: (M) => {
        var B = function($) {
          if ($ = 1 - $, $ < 0.36363636363636365)
            return 1 - 7.5625 * $ * $;
          else if ($ < 0.7272727272727273)
            return 1 - (7.5625 * ($ -= 0.5454545454545454) * $ + 0.75);
          else if ($ < 0.9090909090909091)
            return 1 - (7.5625 * ($ -= 0.8181818181818182) * $ + 0.9375);
          else
            return 1 - (7.5625 * ($ -= 0.9545454545454546) * $ + 0.984375);
        };
        M.exports = B;
      }, 41788: (M) => {
        var B = function($) {
          var E = false;
          if ($ < 0.5)
            $ = 1 - $ * 2, E = true;
          else
            $ = $ * 2 - 1;
          if ($ < 0.36363636363636365)
            $ = 7.5625 * $ * $;
          else if ($ < 0.7272727272727273)
            $ = 7.5625 * ($ -= 0.5454545454545454) * $ + 0.75;
          else if ($ < 0.9090909090909091)
            $ = 7.5625 * ($ -= 0.8181818181818182) * $ + 0.9375;
          else
            $ = 7.5625 * ($ -= 0.9545454545454546) * $ + 0.984375;
          if (E)
            return (1 - $) * 0.5;
          else
            return $ * 0.5 + 0.5;
        };
        M.exports = B;
      }, 69905: (M) => {
        var B = function($) {
          if ($ < 0.36363636363636365)
            return 7.5625 * $ * $;
          else if ($ < 0.7272727272727273)
            return 7.5625 * ($ -= 0.5454545454545454) * $ + 0.75;
          else if ($ < 0.9090909090909091)
            return 7.5625 * ($ -= 0.8181818181818182) * $ + 0.9375;
          else
            return 7.5625 * ($ -= 0.9545454545454546) * $ + 0.984375;
        };
        M.exports = B;
      }, 41521: (M, B, $) => {
        M.exports = { In: $(59590), Out: $(69905), InOut: $(41788) };
      }, 91861: (M) => {
        var B = function($) {
          return 1 - Math.sqrt(1 - $ * $);
        };
        M.exports = B;
      }, 4177: (M) => {
        var B = function($) {
          if (($ *= 2) < 1)
            return -0.5 * (Math.sqrt(1 - $ * $) - 1);
          else
            return 0.5 * (Math.sqrt(1 - ($ -= 2) * $) + 1);
        };
        M.exports = B;
      }, 57512: (M) => {
        var B = function($) {
          return Math.sqrt(1 - --$ * $);
        };
        M.exports = B;
      }, 79980: (M, B, $) => {
        M.exports = { In: $(91861), Out: $(57512), InOut: $(4177) };
      }, 51150: (M) => {
        var B = function($) {
          return $ * $ * $;
        };
        M.exports = B;
      }, 82820: (M) => {
        var B = function($) {
          if (($ *= 2) < 1)
            return 0.5 * $ * $ * $;
          else
            return 0.5 * (($ -= 2) * $ * $ + 2);
        };
        M.exports = B;
      }, 35033: (M) => {
        var B = function($) {
          return --$ * $ * $ + 1;
        };
        M.exports = B;
      }, 85433: (M, B, $) => {
        M.exports = { In: $(51150), Out: $(35033), InOut: $(82820) };
      }, 69965: (M) => {
        var B = function($, E, L) {
          if (E === undefined)
            E = 0.1;
          if (L === undefined)
            L = 0.1;
          if ($ === 0)
            return 0;
          else if ($ === 1)
            return 1;
          else {
            var z = L / 4;
            if (E < 1)
              E = 1;
            else
              z = L * Math.asin(1 / E) / (2 * Math.PI);
            return -(E * Math.pow(2, 10 * ($ -= 1)) * Math.sin(($ - z) * (2 * Math.PI) / L));
          }
        };
        M.exports = B;
      }, 50665: (M) => {
        var B = function($, E, L) {
          if (E === undefined)
            E = 0.1;
          if (L === undefined)
            L = 0.1;
          if ($ === 0)
            return 0;
          else if ($ === 1)
            return 1;
          else {
            var z = L / 4;
            if (E < 1)
              E = 1;
            else
              z = L * Math.asin(1 / E) / (2 * Math.PI);
            if (($ *= 2) < 1)
              return -0.5 * (E * Math.pow(2, 10 * ($ -= 1)) * Math.sin(($ - z) * (2 * Math.PI) / L));
            else
              return E * Math.pow(2, -10 * ($ -= 1)) * Math.sin(($ - z) * (2 * Math.PI) / L) * 0.5 + 1;
          }
        };
        M.exports = B;
      }, 7744: (M) => {
        var B = function($, E, L) {
          if (E === undefined)
            E = 0.1;
          if (L === undefined)
            L = 0.1;
          if ($ === 0)
            return 0;
          else if ($ === 1)
            return 1;
          else {
            var z = L / 4;
            if (E < 1)
              E = 1;
            else
              z = L * Math.asin(1 / E) / (2 * Math.PI);
            return E * Math.pow(2, -10 * $) * Math.sin(($ - z) * (2 * Math.PI) / L) + 1;
          }
        };
        M.exports = B;
      }, 99140: (M, B, $) => {
        M.exports = { In: $(69965), Out: $(7744), InOut: $(50665) };
      }, 24590: (M) => {
        var B = function($) {
          return Math.pow(2, 10 * ($ - 1)) - 0.001;
        };
        M.exports = B;
      }, 87844: (M) => {
        var B = function($) {
          if (($ *= 2) < 1)
            return 0.5 * Math.pow(2, 10 * ($ - 1));
          else
            return 0.5 * (2 - Math.pow(2, -10 * ($ - 1)));
        };
        M.exports = B;
      }, 89433: (M) => {
        var B = function($) {
          return 1 - Math.pow(2, -10 * $);
        };
        M.exports = B;
      }, 48857: (M, B, $) => {
        M.exports = { In: $(24590), Out: $(89433), InOut: $(87844) };
      }, 48820: (M, B, $) => {
        M.exports = { Back: $(54178), Bounce: $(41521), Circular: $(79980), Cubic: $(85433), Elastic: $(99140), Expo: $(48857), Linear: $(81596), Quadratic: $(59133), Quartic: $(98516), Quintic: $(35248), Sine: $(82500), Stepped: $(49752) };
      }, 7147: (M) => {
        var B = function($) {
          return $;
        };
        M.exports = B;
      }, 81596: (M, B, $) => {
        M.exports = $(7147);
      }, 34826: (M) => {
        var B = function($) {
          return $ * $;
        };
        M.exports = B;
      }, 20544: (M) => {
        var B = function($) {
          if (($ *= 2) < 1)
            return 0.5 * $ * $;
          else
            return -0.5 * (--$ * ($ - 2) - 1);
        };
        M.exports = B;
      }, 92029: (M) => {
        var B = function($) {
          return $ * (2 - $);
        };
        M.exports = B;
      }, 59133: (M, B, $) => {
        M.exports = { In: $(34826), Out: $(92029), InOut: $(20544) };
      }, 64413: (M) => {
        var B = function($) {
          return $ * $ * $ * $;
        };
        M.exports = B;
      }, 78137: (M) => {
        var B = function($) {
          if (($ *= 2) < 1)
            return 0.5 * $ * $ * $ * $;
          else
            return -0.5 * (($ -= 2) * $ * $ * $ - 2);
        };
        M.exports = B;
      }, 45840: (M) => {
        var B = function($) {
          return 1 - --$ * $ * $ * $;
        };
        M.exports = B;
      }, 98516: (M, B, $) => {
        M.exports = { In: $(64413), Out: $(45840), InOut: $(78137) };
      }, 87745: (M) => {
        var B = function($) {
          return $ * $ * $ * $ * $;
        };
        M.exports = B;
      }, 16509: (M) => {
        var B = function($) {
          if (($ *= 2) < 1)
            return 0.5 * $ * $ * $ * $ * $;
          else
            return 0.5 * (($ -= 2) * $ * $ * $ * $ + 2);
        };
        M.exports = B;
      }, 17868: (M) => {
        var B = function($) {
          return --$ * $ * $ * $ * $ + 1;
        };
        M.exports = B;
      }, 35248: (M, B, $) => {
        M.exports = { In: $(87745), Out: $(17868), InOut: $(16509) };
      }, 80461: (M) => {
        var B = function($) {
          if ($ === 0)
            return 0;
          else if ($ === 1)
            return 1;
          else
            return 1 - Math.cos($ * Math.PI / 2);
        };
        M.exports = B;
      }, 34025: (M) => {
        var B = function($) {
          if ($ === 0)
            return 0;
          else if ($ === 1)
            return 1;
          else
            return 0.5 * (1 - Math.cos(Math.PI * $));
        };
        M.exports = B;
      }, 52768: (M) => {
        var B = function($) {
          if ($ === 0)
            return 0;
          else if ($ === 1)
            return 1;
          else
            return Math.sin($ * Math.PI / 2);
        };
        M.exports = B;
      }, 82500: (M, B, $) => {
        M.exports = { In: $(80461), Out: $(52768), InOut: $(34025) };
      }, 72251: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = 1;
          if ($ <= 0)
            return 0;
          else if ($ >= 1)
            return 1;
          else
            return ((E * $ | 0) + 1) * (1 / E);
        };
        M.exports = B;
      }, 49752: (M, B, $) => {
        M.exports = $(72251);
      }, 75698: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = 0.0001;
          return Math.ceil($ - E);
        };
        M.exports = B;
      }, 43855: (M) => {
        var B = function($, E, L) {
          if (L === undefined)
            L = 0.0001;
          return Math.abs($ - E) < L;
        };
        M.exports = B;
      }, 25777: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = 0.0001;
          return Math.floor($ + E);
        };
        M.exports = B;
      }, 5470: (M) => {
        var B = function($, E, L) {
          if (L === undefined)
            L = 0.0001;
          return $ > E - L;
        };
        M.exports = B;
      }, 94977: (M) => {
        var B = function($, E, L) {
          if (L === undefined)
            L = 0.0001;
          return $ < E + L;
        };
        M.exports = B;
      }, 48379: (M, B, $) => {
        M.exports = { Ceil: $(75698), Equal: $(43855), Floor: $(25777), GreaterThan: $(5470), LessThan: $(94977) };
      }, 75508: (M, B, $) => {
        var E = $(36383), L = $(79291), z = { Angle: $(25588), Distance: $(50994), Easing: $(48820), Fuzzy: $(48379), Interpolation: $(38289), Pow2: $(49001), Snap: $(73697), RandomDataGenerator: $(28453), Average: $(53307), Bernstein: $(85710), Between: $(30976), CatmullRom: $(87842), CeilTo: $(26302), Clamp: $(45319), DegToRad: $(39506), Difference: $(61241), Euler: $(38857), Factorial: $(6411), FloatBetween: $(99472), FloorTo: $(77623), FromPercent: $(62945), GetSpeed: $(38265), IsEven: $(78702), IsEvenStrict: $(94883), Linear: $(28915), LinearXY: $(94908), MaxAdd: $(86883), Median: $(50040), MinSub: $(37204), Percent: $(65201), RadToDeg: $(43396), RandomXY: $(74362), RandomXYZ: $(60706), RandomXYZW: $(67421), Rotate: $(36305), RotateAround: $(11520), RotateAroundDistance: $(1163), RotateTo: $(70336), RoundAwayFromZero: $(2284), RoundTo: $(41013), SinCosTableGenerator: $(16922), SmootherStep: $(54261), SmoothStep: $(7602), ToXY: $(44408), TransformXY: $(85955), Within: $(60417), Wrap: $(15994), Vector2: $(26099), Vector3: $(25836), Vector4: $(61369), Matrix3: $(94434), Matrix4: $(37867), Quaternion: $(15746), RotateVec3: $(72678) };
        z = L(false, z, E), M.exports = z;
      }, 89318: (M, B, $) => {
        var E = $(85710), L = function(z, U) {
          var K = 0, J = z.length - 1;
          for (var Z = 0;Z <= J; Z++)
            K += Math.pow(1 - U, J - Z) * Math.pow(U, Z) * z[Z] * E(J, Z);
          return K;
        };
        M.exports = L;
      }, 77259: (M, B, $) => {
        var E = $(87842), L = function(z, U) {
          var K = z.length - 1, J = K * U, Z = Math.floor(J);
          if (z[0] === z[K]) {
            if (U < 0)
              Z = Math.floor(J = K * (1 + U));
            return E(J - Z, z[(Z - 1 + K) % K], z[Z], z[(Z + 1) % K], z[(Z + 2) % K]);
          } else {
            if (U < 0)
              return z[0] - (E(-J, z[0], z[0], z[1], z[1]) - z[0]);
            if (U > 1)
              return z[K] - (E(J - K, z[K], z[K], z[K - 1], z[K - 1]) - z[K]);
            return E(J - Z, z[Z ? Z - 1 : 0], z[Z], z[K < Z + 1 ? K : Z + 1], z[K < Z + 2 ? K : Z + 2]);
          }
        };
        M.exports = L;
      }, 36316: (M) => {
        function B(U, K) {
          var J = 1 - U;
          return J * J * J * K;
        }
        function $(U, K) {
          var J = 1 - U;
          return 3 * J * J * U * K;
        }
        function E(U, K) {
          return 3 * (1 - U) * U * U * K;
        }
        function L(U, K) {
          return U * U * U * K;
        }
        var z = function(U, K, J, Z, D) {
          return B(U, K) + $(U, J) + E(U, Z) + L(U, D);
        };
        M.exports = z;
      }, 28392: (M, B, $) => {
        var E = $(28915), L = function(z, U) {
          var K = z.length - 1, J = K * U, Z = Math.floor(J);
          if (U < 0)
            return E(z[0], z[1], J);
          else if (U > 1)
            return E(z[K], z[K - 1], K - J);
          else
            return E(z[Z], z[Z + 1 > K ? K : Z + 1], J - Z);
        };
        M.exports = L;
      }, 32112: (M) => {
        function B(z, U) {
          var K = 1 - z;
          return K * K * U;
        }
        function $(z, U) {
          return 2 * (1 - z) * z * U;
        }
        function E(z, U) {
          return z * z * U;
        }
        var L = function(z, U, K, J) {
          return B(z, U) + $(z, K) + E(z, J);
        };
        M.exports = L;
      }, 47235: (M, B, $) => {
        var E = $(7602), L = function(z, U, K) {
          return U + (K - U) * E(z, 0, 1);
        };
        M.exports = L;
      }, 50178: (M, B, $) => {
        var E = $(54261), L = function(z, U, K) {
          return U + (K - U) * E(z, 0, 1);
        };
        M.exports = L;
      }, 38289: (M, B, $) => {
        M.exports = { Bezier: $(89318), CatmullRom: $(77259), CubicBezier: $(36316), Linear: $(28392), QuadraticBezier: $(32112), SmoothStep: $(47235), SmootherStep: $(50178) };
      }, 98439: (M) => {
        var B = function($) {
          var E = Math.log($) / 0.6931471805599453;
          return 1 << Math.ceil(E);
        };
        M.exports = B;
      }, 50030: (M) => {
        var B = function($, E) {
          return $ > 0 && ($ & $ - 1) === 0 && E > 0 && (E & E - 1) === 0;
        };
        M.exports = B;
      }, 81230: (M) => {
        var B = function($) {
          return $ > 0 && ($ & $ - 1) === 0;
        };
        M.exports = B;
      }, 49001: (M, B, $) => {
        M.exports = { GetNext: $(98439), IsSize: $(50030), IsValue: $(81230) };
      }, 28453: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U) {
          if (U === undefined)
            U = [(Date.now() * Math.random()).toString()];
          if (this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.n = 0, this.signs = [-1, 1], U)
            this.init(U);
        }, rnd: function() {
          var z = 2091639 * this.s0 + this.c * 0.00000000023283064365386964;
          return this.c = z | 0, this.s0 = this.s1, this.s1 = this.s2, this.s2 = z - this.c, this.s2;
        }, hash: function(z) {
          var U, K = this.n;
          z = z.toString();
          for (var J = 0;J < z.length; J++)
            K += z.charCodeAt(J), U = 0.02519603282416938 * K, K = U >>> 0, U -= K, U *= K, K = U >>> 0, U -= K, K += U * 4294967296;
          return this.n = K, (K >>> 0) * 0.00000000023283064365386964;
        }, init: function(z) {
          if (typeof z === "string")
            this.state(z);
          else
            this.sow(z);
        }, sow: function(z) {
          if (this.n = 4022871197, this.s0 = this.hash(" "), this.s1 = this.hash(" "), this.s2 = this.hash(" "), this.c = 1, !z)
            return;
          for (var U = 0;U < z.length && z[U] != null; U++) {
            var K = z[U];
            this.s0 -= this.hash(K), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(K), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(K), this.s2 += ~~(this.s2 < 0);
          }
        }, integer: function() {
          return this.rnd() * 4294967296;
        }, frac: function() {
          return this.rnd() + (this.rnd() * 2097152 | 0) * 0.00000000000000011102230246251566;
        }, real: function() {
          return this.integer() + this.frac();
        }, integerInRange: function(z, U) {
          return Math.floor(this.realInRange(0, U - z + 1) + z);
        }, between: function(z, U) {
          return Math.floor(this.realInRange(0, U - z + 1) + z);
        }, realInRange: function(z, U) {
          return this.frac() * (U - z) + z;
        }, normal: function() {
          return 1 - 2 * this.frac();
        }, uuid: function() {
          var z = "", U = "";
          for (U = z = "";z++ < 36; U += ~z % 5 | z * 3 & 4 ? (z ^ 15 ? 8 ^ this.frac() * (z ^ 20 ? 16 : 4) : 4).toString(16) : "-")
            ;
          return U;
        }, pick: function(z) {
          return z[this.integerInRange(0, z.length - 1)];
        }, sign: function() {
          return this.pick(this.signs);
        }, weightedPick: function(z) {
          return z[~~(Math.pow(this.frac(), 2) * (z.length - 0.5) + 0.5)];
        }, timestamp: function(z, U) {
          return this.realInRange(z || 946684800000, U || 1577862000000);
        }, angle: function() {
          return this.integerInRange(-180, 180);
        }, rotation: function() {
          return this.realInRange(-3.1415926, 3.1415926);
        }, state: function(z) {
          if (typeof z === "string" && z.match(/^!rnd/))
            z = z.split(","), this.c = parseFloat(z[1]), this.s0 = parseFloat(z[2]), this.s1 = parseFloat(z[3]), this.s2 = parseFloat(z[4]);
          return ["!rnd", this.c, this.s0, this.s1, this.s2].join(",");
        }, shuffle: function(z) {
          var U = z.length - 1;
          for (var K = U;K > 0; K--) {
            var J = Math.floor(this.frac() * (K + 1)), Z = z[J];
            z[J] = z[K], z[K] = Z;
          }
          return z;
        } });
        M.exports = L;
      }, 63448: (M) => {
        var B = function($, E, L, z) {
          if (L === undefined)
            L = 0;
          if (E === 0)
            return $;
          return $ -= L, $ = E * Math.ceil($ / E), z ? (L + $) / E : L + $;
        };
        M.exports = B;
      }, 56583: (M) => {
        var B = function($, E, L, z) {
          if (L === undefined)
            L = 0;
          if (E === 0)
            return $;
          return $ -= L, $ = E * Math.floor($ / E), z ? (L + $) / E : L + $;
        };
        M.exports = B;
      }, 77720: (M) => {
        var B = function($, E, L, z) {
          if (L === undefined)
            L = 0;
          if (E === 0)
            return $;
          return $ -= L, $ = E * Math.round($ / E), z ? (L + $) / E : L + $;
        };
        M.exports = B;
      }, 73697: (M, B, $) => {
        M.exports = { Ceil: $(63448), Floor: $(56583), To: $(77720) };
      }, 85454: (M, B, $) => {
        $(63595);
        var E = $(8054), L = $(79291), z = { Actions: $(61061), Animations: $(60421), BlendModes: $(10312), Cache: $(83388), Cameras: $(26638), Core: $(42857), Class: $(83419), Create: $(15822), Curves: $(25410), Data: $(44965), Display: $(27460), DOM: $(84902), Events: $(93055), FX: $(66064), Game: $(50127), GameObjects: $(77856), Geom: $(55738), Input: $(14350), Loader: $(57777), Math: $(75508), Physics: $(44563), Plugins: $(18922), Renderer: $(36909), Scale: $(93364), ScaleModes: $(29795), Scene: $(97482), Scenes: $(62194), Structs: $(41392), Textures: $(27458), Tilemaps: $(62501), Time: $(90291), Tweens: $(43066), Utils: $(91799) };
        z.Sound = $(23717), z = L(false, z, E), M.exports = z, $.g.Phaser = z;
      }, 71289: (M, B, $) => {
        var E = $(83419), L = $(92209), z = $(88571), U = new E({ Extends: z, Mixins: [L.Acceleration, L.Angular, L.Bounce, L.Collision, L.Debug, L.Drag, L.Enable, L.Friction, L.Gravity, L.Immovable, L.Mass, L.Pushable, L.Size, L.Velocity], initialize: function K(J, Z, D, Q, H) {
          z.call(this, J, Z, D, Q, H), this.body = null;
        } });
        M.exports = U;
      }, 86689: (M, B, $) => {
        var E = $(83419), L = $(39506), z = $(20339), U = $(89774), K = $(66022), J = $(95540), Z = $(46975), D = $(72441), Q = $(47956), H = $(37277), N = $(44594), W = $(26099), R = $(82248), Y = new E({ initialize: function I(P) {
          this.scene = P, this.systems = P.sys, this.config = this.getConfig(), this.world, this.add, this._category = 1, P.sys.events.once(N.BOOT, this.boot, this), P.sys.events.on(N.START, this.start, this);
        }, boot: function() {
          this.world = new R(this.scene, this.config), this.add = new K(this.world), this.systems.events.once(N.DESTROY, this.destroy, this);
        }, start: function() {
          if (!this.world)
            this.world = new R(this.scene, this.config), this.add = new K(this.world);
          var I = this.systems.events;
          if (!J(this.config, "customUpdate", false))
            I.on(N.UPDATE, this.world.update, this.world);
          I.on(N.POST_UPDATE, this.world.postUpdate, this.world), I.once(N.SHUTDOWN, this.shutdown, this);
        }, enableUpdate: function() {
          this.systems.events.on(N.UPDATE, this.world.update, this.world);
        }, disableUpdate: function() {
          this.systems.events.off(N.UPDATE, this.world.update, this.world);
        }, getConfig: function() {
          var I = this.systems.game.config.physics, P = this.systems.settings.physics, X = Z(J(P, "arcade", {}), J(I, "arcade", {}));
          return X;
        }, nextCategory: function() {
          return this._category = this._category << 1, this._category;
        }, overlap: function(I, P, X, G, V) {
          if (X === undefined)
            X = null;
          if (G === undefined)
            G = null;
          if (V === undefined)
            V = X;
          return this.world.collideObjects(I, P, X, G, V, true);
        }, collide: function(I, P, X, G, V) {
          if (X === undefined)
            X = null;
          if (G === undefined)
            G = null;
          if (V === undefined)
            V = X;
          return this.world.collideObjects(I, P, X, G, V, false);
        }, collideTiles: function(I, P, X, G, V) {
          return this.world.collideTiles(I, P, X, G, V);
        }, overlapTiles: function(I, P, X, G, V) {
          return this.world.overlapTiles(I, P, X, G, V);
        }, pause: function() {
          return this.world.pause();
        }, resume: function() {
          return this.world.resume();
        }, accelerateTo: function(I, P, X, G, V, A) {
          if (G === undefined)
            G = 60;
          var F = Math.atan2(X - I.y, P - I.x);
          if (I.body.acceleration.setToPolar(F, G), V !== undefined && A !== undefined)
            I.body.maxVelocity.set(V, A);
          return F;
        }, accelerateToObject: function(I, P, X, G, V) {
          return this.accelerateTo(I, P.x, P.y, X, G, V);
        }, closest: function(I, P) {
          if (!P)
            P = this.world.bodies.entries;
          var X = Number.MAX_VALUE, G = null, V = I.x, A = I.y, F = P.length;
          for (var j = 0;j < F; j++) {
            var T = P[j], C = T.body || T;
            if (I === T || I === C || I === C.gameObject || I === C.center)
              continue;
            var v = U(V, A, C.center.x, C.center.y);
            if (v < X)
              G = T, X = v;
          }
          return G;
        }, furthest: function(I, P) {
          if (!P)
            P = this.world.bodies.entries;
          var X = -1, G = null, V = I.x, A = I.y, F = P.length;
          for (var j = 0;j < F; j++) {
            var T = P[j], C = T.body || T;
            if (I === T || I === C || I === C.gameObject || I === C.center)
              continue;
            var v = U(V, A, C.center.x, C.center.y);
            if (v > X)
              G = T, X = v;
          }
          return G;
        }, moveTo: function(I, P, X, G, V) {
          if (G === undefined)
            G = 60;
          if (V === undefined)
            V = 0;
          var A = Math.atan2(X - I.y, P - I.x);
          if (V > 0)
            G = z(I.x, I.y, P, X) / (V / 1000);
          return I.body.velocity.setToPolar(A, G), A;
        }, moveToObject: function(I, P, X, G) {
          return this.moveTo(I, P.x, P.y, X, G);
        }, velocityFromAngle: function(I, P, X) {
          if (P === undefined)
            P = 60;
          if (X === undefined)
            X = new W;
          return X.setToPolar(L(I), P);
        }, velocityFromRotation: function(I, P, X) {
          if (P === undefined)
            P = 60;
          if (X === undefined)
            X = new W;
          return X.setToPolar(I, P);
        }, overlapRect: function(I, P, X, G, V, A) {
          return Q(this.world, I, P, X, G, V, A);
        }, overlapCirc: function(I, P, X, G, V) {
          return D(this.world, I, P, X, G, V);
        }, shutdown: function() {
          if (!this.world)
            return;
          var I = this.systems.events;
          I.off(N.UPDATE, this.world.update, this.world), I.off(N.POST_UPDATE, this.world.postUpdate, this.world), I.off(N.SHUTDOWN, this.shutdown, this), this.add.destroy(), this.world.destroy(), this.add = null, this.world = null, this._category = 1;
        }, destroy: function() {
          this.shutdown(), this.scene.sys.events.off(N.START, this.start, this), this.scene = null, this.systems = null;
        } });
        H.register("ArcadePhysics", Y, "arcadePhysics"), M.exports = Y;
      }, 13759: (M, B, $) => {
        var E = $(83419), L = $(92209), z = $(68287), U = new E({ Extends: z, Mixins: [L.Acceleration, L.Angular, L.Bounce, L.Collision, L.Debug, L.Drag, L.Enable, L.Friction, L.Gravity, L.Immovable, L.Mass, L.Pushable, L.Size, L.Velocity], initialize: function K(J, Z, D, Q, H) {
          z.call(this, J, Z, D, Q, H), this.body = null;
        } });
        M.exports = U;
      }, 37742: (M, B, $) => {
        var E = $(83419), L = $(78389), z = $(37747), U = $(63012), K = $(43396), J = $(87841), Z = $(37303), D = $(95829), Q = $(26099), H = new E({ Mixins: [L], initialize: function N(W, R) {
          var Y = 64, I = 64, P = { x: 0, y: 0, angle: 0, rotation: 0, scaleX: 1, scaleY: 1, displayOriginX: 0, displayOriginY: 0 }, X = R !== undefined;
          if (X && R.displayWidth)
            Y = R.displayWidth, I = R.displayHeight;
          if (!X)
            R = P;
          if (this.world = W, this.gameObject = X ? R : undefined, this.isBody = true, this.transform = { x: R.x, y: R.y, rotation: R.angle, scaleX: R.scaleX, scaleY: R.scaleY, displayOriginX: R.displayOriginX, displayOriginY: R.displayOriginY }, this.debugShowBody = W.defaults.debugShowBody, this.debugShowVelocity = W.defaults.debugShowVelocity, this.debugBodyColor = W.defaults.bodyDebugColor, this.enable = true, this.isCircle = false, this.radius = 0, this.offset = new Q, this.position = new Q(R.x - R.scaleX * R.displayOriginX, R.y - R.scaleY * R.displayOriginY), this.prev = this.position.clone(), this.prevFrame = this.position.clone(), this.allowRotation = true, this.rotation = R.angle, this.preRotation = R.angle, this.width = Y, this.height = I, this.sourceWidth = Y, this.sourceHeight = I, R.frame)
            this.sourceWidth = R.frame.realWidth, this.sourceHeight = R.frame.realHeight;
          this.halfWidth = Math.abs(Y / 2), this.halfHeight = Math.abs(I / 2), this.center = new Q(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.velocity = new Q, this.newVelocity = new Q, this.deltaMax = new Q, this.acceleration = new Q, this.allowDrag = true, this.drag = new Q, this.allowGravity = true, this.gravity = new Q, this.bounce = new Q, this.worldBounce = null, this.customBoundsRectangle = W.bounds, this.onWorldBounds = false, this.onCollide = false, this.onOverlap = false, this.maxVelocity = new Q(1e4, 1e4), this.maxSpeed = -1, this.friction = new Q(1, 0), this.useDamping = false, this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1000, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = z.FACING_NONE, this.immovable = false, this.pushable = true, this.slideFactor = new Q(1, 1), this.moves = true, this.customSeparateX = false, this.customSeparateY = false, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = false, this.collideWorldBounds = false, this.checkCollision = D(false), this.touching = D(true), this.wasTouching = D(true), this.blocked = D(true), this.syncBounds = false, this.physicsType = z.DYNAMIC_BODY, this.collisionCategory = 1, this.collisionMask = 1, this._sx = R.scaleX, this._sy = R.scaleY, this._dx = 0, this._dy = 0, this._tx = 0, this._ty = 0, this._bounds = new J, this.directControl = false, this.autoFrame = this.position.clone();
        }, updateBounds: function() {
          var N = this.gameObject, W = this.transform;
          if (N.parentContainer) {
            var R = N.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2);
            W.x = R.tx, W.y = R.ty, W.rotation = K(R.rotation), W.scaleX = R.scaleX, W.scaleY = R.scaleY, W.displayOriginX = N.displayOriginX, W.displayOriginY = N.displayOriginY;
          } else
            W.x = N.x, W.y = N.y, W.rotation = N.angle, W.scaleX = N.scaleX, W.scaleY = N.scaleY, W.displayOriginX = N.displayOriginX, W.displayOriginY = N.displayOriginY;
          var Y = false;
          if (this.syncBounds) {
            var I = N.getBounds(this._bounds);
            this.width = I.width, this.height = I.height, Y = true;
          } else {
            var P = Math.abs(W.scaleX), X = Math.abs(W.scaleY);
            if (this._sx !== P || this._sy !== X)
              this.width = this.sourceWidth * P, this.height = this.sourceHeight * X, this._sx = P, this._sy = X, Y = true;
          }
          if (Y)
            this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter();
        }, updateCenter: function() {
          this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
        }, updateFromGameObject: function() {
          this.updateBounds();
          var N = this.transform;
          this.position.x = N.x + N.scaleX * (this.offset.x - N.displayOriginX), this.position.y = N.y + N.scaleY * (this.offset.y - N.displayOriginY), this.updateCenter();
        }, resetFlags: function(N) {
          if (N === undefined)
            N = false;
          var W = this.wasTouching, R = this.touching, Y = this.blocked;
          if (N)
            D(true, W);
          else
            W.none = R.none, W.up = R.up, W.down = R.down, W.left = R.left, W.right = R.right;
          D(true, R), D(true, Y), this.overlapR = 0, this.overlapX = 0, this.overlapY = 0, this.embedded = false;
        }, preUpdate: function(N, W) {
          if (N)
            this.resetFlags();
          if (this.gameObject)
            this.updateFromGameObject();
          if (this.rotation = this.transform.rotation, this.preRotation = this.rotation, this.moves) {
            var R = this.position;
            this.prev.x = R.x, this.prev.y = R.y, this.prevFrame.x = R.x, this.prevFrame.y = R.y;
          }
          if (N)
            this.update(W);
        }, update: function(N) {
          var W = this.prev, R = this.position, Y = this.velocity;
          if (W.set(R.x, R.y), !this.moves) {
            this._dx = R.x - W.x, this._dy = R.y - W.y;
            return;
          }
          if (this.directControl) {
            var I = this.autoFrame;
            Y.set((R.x - I.x) / N, (R.y - I.y) / N), this.world.updateMotion(this, N), this._dx = R.x - I.x, this._dy = R.y - I.y;
          } else
            this.world.updateMotion(this, N), this.newVelocity.set(Y.x * N, Y.y * N), R.add(this.newVelocity), this._dx = R.x - W.x, this._dy = R.y - W.y;
          var { x: P, y: X } = Y;
          if (this.updateCenter(), this.angle = Math.atan2(X, P), this.speed = Math.sqrt(P * P + X * X), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds) {
            var G = this.blocked;
            this.world.emit(U.WORLD_BOUNDS, this, G.up, G.down, G.left, G.right);
          }
        }, postUpdate: function() {
          var N = this.position, W = N.x - this.prevFrame.x, R = N.y - this.prevFrame.y, Y = this.gameObject;
          if (this.moves) {
            var I = this.deltaMax.x, P = this.deltaMax.y;
            if (I !== 0 && W !== 0) {
              if (W < 0 && W < -I)
                W = -I;
              else if (W > 0 && W > I)
                W = I;
            }
            if (P !== 0 && R !== 0) {
              if (R < 0 && R < -P)
                R = -P;
              else if (R > 0 && R > P)
                R = P;
            }
            if (Y)
              Y.x += W, Y.y += R;
          }
          if (W < 0)
            this.facing = z.FACING_LEFT;
          else if (W > 0)
            this.facing = z.FACING_RIGHT;
          if (R < 0)
            this.facing = z.FACING_UP;
          else if (R > 0)
            this.facing = z.FACING_DOWN;
          if (this.allowRotation && Y)
            Y.angle += this.deltaZ();
          this._tx = W, this._ty = R, this.autoFrame.set(N.x, N.y);
        }, setBoundsRectangle: function(N) {
          return this.customBoundsRectangle = !N ? this.world.bounds : N, this;
        }, checkWorldBounds: function() {
          var N = this.position, W = this.velocity, R = this.blocked, Y = this.customBoundsRectangle, I = this.world.checkCollision, P = this.worldBounce ? -this.worldBounce.x : -this.bounce.x, X = this.worldBounce ? -this.worldBounce.y : -this.bounce.y, G = false;
          if (N.x < Y.x && I.left)
            N.x = Y.x, W.x *= P, R.left = true, G = true;
          else if (this.right > Y.right && I.right)
            N.x = Y.right - this.width, W.x *= P, R.right = true, G = true;
          if (N.y < Y.y && I.up)
            N.y = Y.y, W.y *= X, R.up = true, G = true;
          else if (this.bottom > Y.bottom && I.down)
            N.y = Y.bottom - this.height, W.y *= X, R.down = true, G = true;
          if (G)
            this.blocked.none = false, this.updateCenter();
          return G;
        }, setOffset: function(N, W) {
          if (W === undefined)
            W = N;
          return this.offset.set(N, W), this;
        }, setGameObject: function(N, W) {
          if (W === undefined)
            W = true;
          if (this.world.remove(this), this.gameObject && this.gameObject.body)
            this.gameObject.body = null;
          if (this.gameObject = N, N.body)
            N.body = this;
          return this.setSize(), this.world.add(this), this.enable = W, this;
        }, setSize: function(N, W, R) {
          if (R === undefined)
            R = true;
          var Y = this.gameObject;
          if (Y) {
            if (!N && Y.frame)
              N = Y.frame.realWidth;
            if (!W && Y.frame)
              W = Y.frame.realHeight;
          }
          if (this.sourceWidth = N, this.sourceHeight = W, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter(), R && Y && Y.getCenter) {
            var I = (Y.width - N) / 2, P = (Y.height - W) / 2;
            this.offset.set(I, P);
          }
          return this.isCircle = false, this.radius = 0, this;
        }, setCircle: function(N, W, R) {
          if (W === undefined)
            W = this.offset.x;
          if (R === undefined)
            R = this.offset.y;
          if (N > 0)
            this.isCircle = true, this.radius = N, this.sourceWidth = N * 2, this.sourceHeight = N * 2, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(W, R), this.updateCenter();
          else
            this.isCircle = false;
          return this;
        }, reset: function(N, W) {
          this.stop();
          var R = this.gameObject;
          if (R)
            R.setPosition(N, W), this.rotation = R.angle, this.preRotation = R.angle;
          var Y = this.position;
          if (R && R.getTopLeft)
            R.getTopLeft(Y);
          else
            Y.set(N, W);
          if (this.prev.copy(Y), this.prevFrame.copy(Y), this.autoFrame.copy(Y), R)
            this.updateBounds();
          if (this.updateCenter(), this.collideWorldBounds)
            this.checkWorldBounds();
          this.resetFlags(true);
        }, stop: function() {
          return this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this;
        }, getBounds: function(N) {
          return N.x = this.x, N.y = this.y, N.right = this.right, N.bottom = this.bottom, N;
        }, hitTest: function(N, W) {
          if (!this.isCircle)
            return Z(this, N, W);
          if (this.radius > 0 && N >= this.left && N <= this.right && W >= this.top && W <= this.bottom) {
            var R = (this.center.x - N) * (this.center.x - N), Y = (this.center.y - W) * (this.center.y - W);
            return R + Y <= this.radius * this.radius;
          }
          return false;
        }, onFloor: function() {
          return this.blocked.down;
        }, onCeiling: function() {
          return this.blocked.up;
        }, onWall: function() {
          return this.blocked.left || this.blocked.right;
        }, deltaAbsX: function() {
          return this._dx > 0 ? this._dx : -this._dx;
        }, deltaAbsY: function() {
          return this._dy > 0 ? this._dy : -this._dy;
        }, deltaX: function() {
          return this._dx;
        }, deltaY: function() {
          return this._dy;
        }, deltaXFinal: function() {
          return this._tx;
        }, deltaYFinal: function() {
          return this._ty;
        }, deltaZ: function() {
          return this.rotation - this.preRotation;
        }, destroy: function() {
          if (this.enable = false, this.world)
            this.world.pendingDestroy.set(this);
        }, drawDebug: function(N) {
          var W = this.position, R = W.x + this.halfWidth, Y = W.y + this.halfHeight;
          if (this.debugShowBody)
            if (N.lineStyle(N.defaultStrokeWidth, this.debugBodyColor), this.isCircle)
              N.strokeCircle(R, Y, this.width / 2);
            else {
              if (this.checkCollision.up)
                N.lineBetween(W.x, W.y, W.x + this.width, W.y);
              if (this.checkCollision.right)
                N.lineBetween(W.x + this.width, W.y, W.x + this.width, W.y + this.height);
              if (this.checkCollision.down)
                N.lineBetween(W.x, W.y + this.height, W.x + this.width, W.y + this.height);
              if (this.checkCollision.left)
                N.lineBetween(W.x, W.y, W.x, W.y + this.height);
            }
          if (this.debugShowVelocity)
            N.lineStyle(N.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1), N.lineBetween(R, Y, R + this.velocity.x / 2, Y + this.velocity.y / 2);
        }, willDrawDebug: function() {
          return this.debugShowBody || this.debugShowVelocity;
        }, setDirectControl: function(N) {
          if (N === undefined)
            N = true;
          return this.directControl = N, this;
        }, setCollideWorldBounds: function(N, W, R, Y) {
          if (N === undefined)
            N = true;
          this.collideWorldBounds = N;
          var I = W !== undefined, P = R !== undefined;
          if (I || P) {
            if (!this.worldBounce)
              this.worldBounce = new Q;
            if (I)
              this.worldBounce.x = W;
            if (P)
              this.worldBounce.y = R;
          }
          if (Y !== undefined)
            this.onWorldBounds = Y;
          return this;
        }, setVelocity: function(N, W) {
          return this.velocity.set(N, W), N = this.velocity.x, W = this.velocity.y, this.speed = Math.sqrt(N * N + W * W), this;
        }, setVelocityX: function(N) {
          return this.setVelocity(N, this.velocity.y);
        }, setVelocityY: function(N) {
          return this.setVelocity(this.velocity.x, N);
        }, setMaxVelocity: function(N, W) {
          return this.maxVelocity.set(N, W), this;
        }, setMaxVelocityX: function(N) {
          return this.maxVelocity.x = N, this;
        }, setMaxVelocityY: function(N) {
          return this.maxVelocity.y = N, this;
        }, setMaxSpeed: function(N) {
          return this.maxSpeed = N, this;
        }, setSlideFactor: function(N, W) {
          return this.slideFactor.set(N, W), this;
        }, setBounce: function(N, W) {
          return this.bounce.set(N, W), this;
        }, setBounceX: function(N) {
          return this.bounce.x = N, this;
        }, setBounceY: function(N) {
          return this.bounce.y = N, this;
        }, setAcceleration: function(N, W) {
          return this.acceleration.set(N, W), this;
        }, setAccelerationX: function(N) {
          return this.acceleration.x = N, this;
        }, setAccelerationY: function(N) {
          return this.acceleration.y = N, this;
        }, setAllowDrag: function(N) {
          if (N === undefined)
            N = true;
          return this.allowDrag = N, this;
        }, setAllowGravity: function(N) {
          if (N === undefined)
            N = true;
          return this.allowGravity = N, this;
        }, setAllowRotation: function(N) {
          if (N === undefined)
            N = true;
          return this.allowRotation = N, this;
        }, setDrag: function(N, W) {
          return this.drag.set(N, W), this;
        }, setDamping: function(N) {
          return this.useDamping = N, this;
        }, setDragX: function(N) {
          return this.drag.x = N, this;
        }, setDragY: function(N) {
          return this.drag.y = N, this;
        }, setGravity: function(N, W) {
          return this.gravity.set(N, W), this;
        }, setGravityX: function(N) {
          return this.gravity.x = N, this;
        }, setGravityY: function(N) {
          return this.gravity.y = N, this;
        }, setFriction: function(N, W) {
          return this.friction.set(N, W), this;
        }, setFrictionX: function(N) {
          return this.friction.x = N, this;
        }, setFrictionY: function(N) {
          return this.friction.y = N, this;
        }, setAngularVelocity: function(N) {
          return this.angularVelocity = N, this;
        }, setAngularAcceleration: function(N) {
          return this.angularAcceleration = N, this;
        }, setAngularDrag: function(N) {
          return this.angularDrag = N, this;
        }, setMass: function(N) {
          return this.mass = N, this;
        }, setImmovable: function(N) {
          if (N === undefined)
            N = true;
          return this.immovable = N, this;
        }, setEnable: function(N) {
          if (N === undefined)
            N = true;
          return this.enable = N, this;
        }, processX: function(N, W, R, Y) {
          if (this.x += N, this.updateCenter(), W !== null)
            this.velocity.x = W * this.slideFactor.x;
          var I = this.blocked;
          if (R)
            I.left = true, I.none = false;
          if (Y)
            I.right = true, I.none = false;
        }, processY: function(N, W, R, Y) {
          if (this.y += N, this.updateCenter(), W !== null)
            this.velocity.y = W * this.slideFactor.y;
          var I = this.blocked;
          if (R)
            I.up = true, I.none = false;
          if (Y)
            I.down = true, I.none = false;
        }, x: { get: function() {
          return this.position.x;
        }, set: function(N) {
          this.position.x = N;
        } }, y: { get: function() {
          return this.position.y;
        }, set: function(N) {
          this.position.y = N;
        } }, left: { get: function() {
          return this.position.x;
        } }, right: { get: function() {
          return this.position.x + this.width;
        } }, top: { get: function() {
          return this.position.y;
        } }, bottom: { get: function() {
          return this.position.y + this.height;
        } } });
        M.exports = H;
      }, 79342: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U, K, J, Z, D, Q, H) {
          this.world = U, this.name = "", this.active = true, this.overlapOnly = K, this.object1 = J, this.object2 = Z, this.collideCallback = D, this.processCallback = Q, this.callbackContext = H;
        }, setName: function(z) {
          return this.name = z, this;
        }, update: function() {
          this.world.collideObjects(this.object1, this.object2, this.collideCallback, this.processCallback, this.callbackContext, this.overlapOnly);
        }, destroy: function() {
          this.world.removeCollider(this), this.active = false, this.world = null, this.object1 = null, this.object2 = null, this.collideCallback = null, this.processCallback = null, this.callbackContext = null;
        } });
        M.exports = L;
      }, 66022: (M, B, $) => {
        var E = $(71289), L = $(13759), z = $(37742), U = $(83419), K = $(37747), J = $(60758), Z = $(72624), D = $(71464), Q = new U({ initialize: function H(N) {
          this.world = N, this.scene = N.scene, this.sys = N.scene.sys;
        }, collider: function(H, N, W, R, Y) {
          return this.world.addCollider(H, N, W, R, Y);
        }, overlap: function(H, N, W, R, Y) {
          return this.world.addOverlap(H, N, W, R, Y);
        }, existing: function(H, N) {
          var W = N ? K.STATIC_BODY : K.DYNAMIC_BODY;
          return this.world.enableBody(H, W), H;
        }, staticImage: function(H, N, W, R) {
          var Y = new E(this.scene, H, N, W, R);
          return this.sys.displayList.add(Y), this.world.enableBody(Y, K.STATIC_BODY), Y;
        }, image: function(H, N, W, R) {
          var Y = new E(this.scene, H, N, W, R);
          return this.sys.displayList.add(Y), this.world.enableBody(Y, K.DYNAMIC_BODY), Y;
        }, staticSprite: function(H, N, W, R) {
          var Y = new L(this.scene, H, N, W, R);
          return this.sys.displayList.add(Y), this.sys.updateList.add(Y), this.world.enableBody(Y, K.STATIC_BODY), Y;
        }, sprite: function(H, N, W, R) {
          var Y = new L(this.scene, H, N, W, R);
          return this.sys.displayList.add(Y), this.sys.updateList.add(Y), this.world.enableBody(Y, K.DYNAMIC_BODY), Y;
        }, staticGroup: function(H, N) {
          return this.sys.updateList.add(new D(this.world, this.world.scene, H, N));
        }, group: function(H, N) {
          return this.sys.updateList.add(new J(this.world, this.world.scene, H, N));
        }, body: function(H, N, W, R) {
          var Y = new z(this.world);
          if (Y.position.set(H, N), W && R)
            Y.setSize(W, R);
          return this.world.add(Y, K.DYNAMIC_BODY), Y;
        }, staticBody: function(H, N, W, R) {
          var Y = new Z(this.world);
          if (Y.position.set(H, N), W && R)
            Y.setSize(W, R);
          return this.world.add(Y, K.STATIC_BODY), Y;
        }, destroy: function() {
          this.world = null, this.scene = null, this.sys = null;
        } });
        M.exports = Q;
      }, 79599: (M) => {
        var B = function($) {
          var E = 0;
          if (!Array.isArray($))
            E = $;
          else
            for (var L = 0;L < $.length; L++)
              E |= $[L];
          return E;
        };
        M.exports = B;
      }, 64897: (M, B, $) => {
        var E = $(37747), L = function(z, U, K, J) {
          var Z = 0, D = z.deltaAbsX() + U.deltaAbsX() + J;
          if (z._dx === 0 && U._dx === 0)
            z.embedded = true, U.embedded = true;
          else if (z._dx > U._dx)
            if (Z = z.right - U.x, Z > D && !K || z.checkCollision.right === false || U.checkCollision.left === false)
              Z = 0;
            else {
              if (z.touching.none = false, z.touching.right = true, U.touching.none = false, U.touching.left = true, U.physicsType === E.STATIC_BODY && !K)
                z.blocked.none = false, z.blocked.right = true;
              if (z.physicsType === E.STATIC_BODY && !K)
                U.blocked.none = false, U.blocked.left = true;
            }
          else if (z._dx < U._dx)
            if (Z = z.x - U.width - U.x, -Z > D && !K || z.checkCollision.left === false || U.checkCollision.right === false)
              Z = 0;
            else {
              if (z.touching.none = false, z.touching.left = true, U.touching.none = false, U.touching.right = true, U.physicsType === E.STATIC_BODY && !K)
                z.blocked.none = false, z.blocked.left = true;
              if (z.physicsType === E.STATIC_BODY && !K)
                U.blocked.none = false, U.blocked.right = true;
            }
          return z.overlapX = Z, U.overlapX = Z, Z;
        };
        M.exports = L;
      }, 45170: (M, B, $) => {
        var E = $(37747), L = function(z, U, K, J) {
          var Z = 0, D = z.deltaAbsY() + U.deltaAbsY() + J;
          if (z._dy === 0 && U._dy === 0)
            z.embedded = true, U.embedded = true;
          else if (z._dy > U._dy)
            if (Z = z.bottom - U.y, Z > D && !K || z.checkCollision.down === false || U.checkCollision.up === false)
              Z = 0;
            else {
              if (z.touching.none = false, z.touching.down = true, U.touching.none = false, U.touching.up = true, U.physicsType === E.STATIC_BODY && !K)
                z.blocked.none = false, z.blocked.down = true;
              if (z.physicsType === E.STATIC_BODY && !K)
                U.blocked.none = false, U.blocked.up = true;
            }
          else if (z._dy < U._dy)
            if (Z = z.y - U.bottom, -Z > D && !K || z.checkCollision.up === false || U.checkCollision.down === false)
              Z = 0;
            else {
              if (z.touching.none = false, z.touching.up = true, U.touching.none = false, U.touching.down = true, U.physicsType === E.STATIC_BODY && !K)
                z.blocked.none = false, z.blocked.up = true;
              if (z.physicsType === E.STATIC_BODY && !K)
                U.blocked.none = false, U.blocked.down = true;
            }
          return z.overlapY = Z, U.overlapY = Z, Z;
        };
        M.exports = L;
      }, 60758: (M, B, $) => {
        var E = $(13759), L = $(83419), z = $(78389), U = $(37747), K = $(95540), J = $(26479), Z = $(41212), D = new L({ Extends: J, Mixins: [z], initialize: function Q(H, N, W, R) {
          if (!W && !R)
            R = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler };
          else if (Z(W))
            R = W, W = null, R.internalCreateCallback = this.createCallbackHandler, R.internalRemoveCallback = this.removeCallbackHandler;
          else if (Array.isArray(W) && Z(W[0])) {
            var Y = this;
            W.forEach(function(I) {
              I.internalCreateCallback = Y.createCallbackHandler, I.internalRemoveCallback = Y.removeCallbackHandler, I.classType = K(I, "classType", E);
            }), R = null;
          } else
            R = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler };
          if (this.world = H, R)
            R.classType = K(R, "classType", E);
          this.physicsType = U.DYNAMIC_BODY, this.collisionCategory = 1, this.collisionMask = 1, this.defaults = { setCollideWorldBounds: K(R, "collideWorldBounds", false), setBoundsRectangle: K(R, "customBoundsRectangle", null), setAccelerationX: K(R, "accelerationX", 0), setAccelerationY: K(R, "accelerationY", 0), setAllowDrag: K(R, "allowDrag", true), setAllowGravity: K(R, "allowGravity", true), setAllowRotation: K(R, "allowRotation", true), setDamping: K(R, "useDamping", false), setBounceX: K(R, "bounceX", 0), setBounceY: K(R, "bounceY", 0), setDragX: K(R, "dragX", 0), setDragY: K(R, "dragY", 0), setEnable: K(R, "enable", true), setGravityX: K(R, "gravityX", 0), setGravityY: K(R, "gravityY", 0), setFrictionX: K(R, "frictionX", 0), setFrictionY: K(R, "frictionY", 0), setMaxSpeed: K(R, "maxSpeed", -1), setMaxVelocityX: K(R, "maxVelocityX", 1e4), setMaxVelocityY: K(R, "maxVelocityY", 1e4), setVelocityX: K(R, "velocityX", 0), setVelocityY: K(R, "velocityY", 0), setAngularVelocity: K(R, "angularVelocity", 0), setAngularAcceleration: K(R, "angularAcceleration", 0), setAngularDrag: K(R, "angularDrag", 0), setMass: K(R, "mass", 1), setImmovable: K(R, "immovable", false) }, J.call(this, N, W, R), this.type = "PhysicsGroup";
        }, createCallbackHandler: function(Q) {
          if (!Q.body)
            this.world.enableBody(Q, U.DYNAMIC_BODY);
          var H = Q.body;
          for (var N in this.defaults)
            H[N](this.defaults[N]);
        }, removeCallbackHandler: function(Q) {
          if (Q.body)
            this.world.disableBody(Q);
        }, setVelocity: function(Q, H, N) {
          if (N === undefined)
            N = 0;
          var W = this.getChildren();
          for (var R = 0;R < W.length; R++)
            W[R].body.velocity.set(Q + R * N, H + R * N);
          return this;
        }, setVelocityX: function(Q, H) {
          if (H === undefined)
            H = 0;
          var N = this.getChildren();
          for (var W = 0;W < N.length; W++)
            N[W].body.velocity.x = Q + W * H;
          return this;
        }, setVelocityY: function(Q, H) {
          if (H === undefined)
            H = 0;
          var N = this.getChildren();
          for (var W = 0;W < N.length; W++)
            N[W].body.velocity.y = Q + W * H;
          return this;
        } });
        M.exports = D;
      }, 3017: (M) => {
        var B, $, E, L, z, U, K, J, Z, D, Q, H, N, W, R, Y, I, P = function(j, T, C) {
          B = j, $ = T;
          var v = B.velocity.x, O = $.velocity.x;
          return E = B.pushable, Z = B._dx < 0, D = B._dx > 0, Q = B._dx === 0, R = Math.abs(B.right - $.x) <= Math.abs($.right - B.x), K = O - v * B.bounce.x, L = $.pushable, H = $._dx < 0, N = $._dx > 0, W = $._dx === 0, Y = !R, J = v - O * $.bounce.x, I = Math.abs(C), X();
        }, X = function() {
          if (D && R && $.blocked.right)
            return B.processX(-I, K, false, true), 1;
          if (Z && Y && $.blocked.left)
            return B.processX(I, K, true), 1;
          if (N && Y && B.blocked.right)
            return $.processX(-I, J, false, true), 2;
          if (H && R && B.blocked.left)
            return $.processX(I, J, true), 2;
          return 0;
        }, G = function() {
          var j = B.velocity.x, T = $.velocity.x, C = Math.sqrt(T * T * $.mass / B.mass) * (T > 0 ? 1 : -1), v = Math.sqrt(j * j * B.mass / $.mass) * (j > 0 ? 1 : -1), O = (C + v) * 0.5;
          if (C -= O, v -= O, z = O + C * B.bounce.x, U = O + v * $.bounce.x, Z && Y)
            return V(0);
          if (H && R)
            return V(1);
          if (D && R)
            return V(2);
          if (N && Y)
            return V(3);
          return false;
        }, V = function(j) {
          if (E && L)
            if (I *= 0.5, j === 0 || j === 3)
              B.processX(I, z), $.processX(-I, U);
            else
              B.processX(-I, z), $.processX(I, U);
          else if (E && !L)
            if (j === 0 || j === 3)
              B.processX(I, K, true);
            else
              B.processX(-I, K, false, true);
          else if (!E && L)
            if (j === 0 || j === 3)
              $.processX(-I, J, false, true);
            else
              $.processX(I, J, true);
          else {
            var T = I * 0.5;
            if (j === 0)
              if (W)
                B.processX(I, 0, true), $.processX(0, null, false, true);
              else if (N)
                B.processX(T, 0, true), $.processX(-T, 0, false, true);
              else
                B.processX(T, $.velocity.x, true), $.processX(-T, null, false, true);
            else if (j === 1)
              if (Q)
                B.processX(0, null, false, true), $.processX(I, 0, true);
              else if (D)
                B.processX(-T, 0, false, true), $.processX(T, 0, true);
              else
                B.processX(-T, null, false, true), $.processX(T, B.velocity.x, true);
            else if (j === 2)
              if (W)
                B.processX(-I, 0, false, true), $.processX(0, null, true);
              else if (H)
                B.processX(-T, 0, false, true), $.processX(T, 0, true);
              else
                B.processX(-T, $.velocity.x, false, true), $.processX(T, null, true);
            else if (j === 3)
              if (Q)
                B.processX(0, null, true), $.processX(-I, 0, false, true);
              else if (Z)
                B.processX(T, 0, true), $.processX(-T, 0, false, true);
              else
                B.processX(T, $.velocity.y, true), $.processX(-T, null, false, true);
          }
          return true;
        }, A = function(j) {
          if (j === 1)
            $.velocity.x = 0;
          else if (R)
            $.processX(I, J, true);
          else
            $.processX(-I, J, false, true);
          if (B.moves)
            $.y += (B.y - B.prev.y) * B.friction.y, $._dy = $.y - $.prev.y;
        }, F = function(j) {
          if (j === 2)
            B.velocity.x = 0;
          else if (Y)
            B.processX(I, K, true);
          else
            B.processX(-I, K, false, true);
          if ($.moves)
            B.y += ($.y - $.prev.y) * $.friction.y, B._dy = B.y - B.prev.y;
        };
        M.exports = { BlockCheck: X, Check: G, Set: P, Run: V, RunImmovableBody1: A, RunImmovableBody2: F };
      }, 47962: (M) => {
        var B, $, E, L, z, U, K, J, Z, D, Q, H, N, W, R, Y, I, P = function(j, T, C) {
          B = j, $ = T;
          var v = B.velocity.y, O = $.velocity.y;
          return E = B.pushable, Z = B._dy < 0, D = B._dy > 0, Q = B._dy === 0, R = Math.abs(B.bottom - $.y) <= Math.abs($.bottom - B.y), K = O - v * B.bounce.y, L = $.pushable, H = $._dy < 0, N = $._dy > 0, W = $._dy === 0, Y = !R, J = v - O * $.bounce.y, I = Math.abs(C), X();
        }, X = function() {
          if (D && R && $.blocked.down)
            return B.processY(-I, K, false, true), 1;
          if (Z && Y && $.blocked.up)
            return B.processY(I, K, true), 1;
          if (N && Y && B.blocked.down)
            return $.processY(-I, J, false, true), 2;
          if (H && R && B.blocked.up)
            return $.processY(I, J, true), 2;
          return 0;
        }, G = function() {
          var j = B.velocity.y, T = $.velocity.y, C = Math.sqrt(T * T * $.mass / B.mass) * (T > 0 ? 1 : -1), v = Math.sqrt(j * j * B.mass / $.mass) * (j > 0 ? 1 : -1), O = (C + v) * 0.5;
          if (C -= O, v -= O, z = O + C * B.bounce.y, U = O + v * $.bounce.y, Z && Y)
            return V(0);
          if (H && R)
            return V(1);
          if (D && R)
            return V(2);
          if (N && Y)
            return V(3);
          return false;
        }, V = function(j) {
          if (E && L)
            if (I *= 0.5, j === 0 || j === 3)
              B.processY(I, z), $.processY(-I, U);
            else
              B.processY(-I, z), $.processY(I, U);
          else if (E && !L)
            if (j === 0 || j === 3)
              B.processY(I, K, true);
            else
              B.processY(-I, K, false, true);
          else if (!E && L)
            if (j === 0 || j === 3)
              $.processY(-I, J, false, true);
            else
              $.processY(I, J, true);
          else {
            var T = I * 0.5;
            if (j === 0)
              if (W)
                B.processY(I, 0, true), $.processY(0, null, false, true);
              else if (N)
                B.processY(T, 0, true), $.processY(-T, 0, false, true);
              else
                B.processY(T, $.velocity.y, true), $.processY(-T, null, false, true);
            else if (j === 1)
              if (Q)
                B.processY(0, null, false, true), $.processY(I, 0, true);
              else if (D)
                B.processY(-T, 0, false, true), $.processY(T, 0, true);
              else
                B.processY(-T, null, false, true), $.processY(T, B.velocity.y, true);
            else if (j === 2)
              if (W)
                B.processY(-I, 0, false, true), $.processY(0, null, true);
              else if (H)
                B.processY(-T, 0, false, true), $.processY(T, 0, true);
              else
                B.processY(-T, $.velocity.y, false, true), $.processY(T, null, true);
            else if (j === 3)
              if (Q)
                B.processY(0, null, true), $.processY(-I, 0, false, true);
              else if (Z)
                B.processY(T, 0, true), $.processY(-T, 0, false, true);
              else
                B.processY(T, $.velocity.y, true), $.processY(-T, null, false, true);
          }
          return true;
        }, A = function(j) {
          if (j === 1)
            $.velocity.y = 0;
          else if (R)
            $.processY(I, J, true);
          else
            $.processY(-I, J, false, true);
          if (B.moves)
            $.x += (B.x - B.prev.x) * B.friction.x, $._dx = $.x - $.prev.x;
        }, F = function(j) {
          if (j === 2)
            B.velocity.y = 0;
          else if (Y)
            B.processY(I, K, true);
          else
            B.processY(-I, K, false, true);
          if ($.moves)
            B.x += ($.x - $.prev.x) * $.friction.x, B._dx = B.x - B.prev.x;
        };
        M.exports = { BlockCheck: X, Check: G, Set: P, Run: V, RunImmovableBody1: A, RunImmovableBody2: F };
      }, 14087: (M, B, $) => {
        var E = $(64897), L = $(3017), z = function(U, K, J, Z, D) {
          if (D === undefined)
            D = E(U, K, J, Z);
          var Q = U.immovable, H = K.immovable;
          if (J || D === 0 || Q && H || U.customSeparateX || K.customSeparateX)
            return D !== 0 || U.embedded && K.embedded;
          var N = L.Set(U, K, D);
          if (!Q && !H) {
            if (N > 0)
              return true;
            return L.Check();
          } else if (Q)
            L.RunImmovableBody1(N);
          else if (H)
            L.RunImmovableBody2(N);
          return true;
        };
        M.exports = z;
      }, 89936: (M, B, $) => {
        var E = $(45170), L = $(47962), z = function(U, K, J, Z, D) {
          if (D === undefined)
            D = E(U, K, J, Z);
          var Q = U.immovable, H = K.immovable;
          if (J || D === 0 || Q && H || U.customSeparateY || K.customSeparateY)
            return D !== 0 || U.embedded && K.embedded;
          var N = L.Set(U, K, D);
          if (!Q && !H) {
            if (N > 0)
              return true;
            return L.Check();
          } else if (Q)
            L.RunImmovableBody1(N);
          else if (H)
            L.RunImmovableBody2(N);
          return true;
        };
        M.exports = z;
      }, 95829: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = {};
          if (E.none = $, E.up = false, E.down = false, E.left = false, E.right = false, !$)
            E.up = true, E.down = true, E.left = true, E.right = true;
          return E;
        };
        M.exports = B;
      }, 72624: (M, B, $) => {
        var E = $(87902), L = $(83419), z = $(78389), U = $(37747), K = $(37303), J = $(95829), Z = $(26099), D = new L({ Mixins: [z], initialize: function Q(H, N) {
          var W = 64, R = 64, Y = { x: 0, y: 0, angle: 0, rotation: 0, scaleX: 1, scaleY: 1, displayOriginX: 0, displayOriginY: 0 }, I = N !== undefined;
          if (I && N.displayWidth)
            W = N.displayWidth, R = N.displayHeight;
          if (!I)
            N = Y;
          this.world = H, this.gameObject = I ? N : undefined, this.isBody = true, this.debugShowBody = H.defaults.debugShowStaticBody, this.debugBodyColor = H.defaults.staticBodyDebugColor, this.enable = true, this.isCircle = false, this.radius = 0, this.offset = new Z, this.position = new Z(N.x - W * N.originX, N.y - R * N.originY), this.width = W, this.height = R, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center = new Z(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.velocity = Z.ZERO, this.allowGravity = false, this.gravity = Z.ZERO, this.bounce = Z.ZERO, this.onWorldBounds = false, this.onCollide = false, this.onOverlap = false, this.mass = 1, this.immovable = true, this.pushable = false, this.customSeparateX = false, this.customSeparateY = false, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = false, this.collideWorldBounds = false, this.checkCollision = J(false), this.touching = J(true), this.wasTouching = J(true), this.blocked = J(true), this.physicsType = U.STATIC_BODY, this.collisionCategory = 1, this.collisionMask = 1, this._dx = 0, this._dy = 0;
        }, setGameObject: function(Q, H) {
          if (Q && Q !== this.gameObject)
            this.gameObject.body = null, Q.body = this, this.gameObject = Q;
          if (H)
            this.updateFromGameObject();
          return this;
        }, updateFromGameObject: function() {
          this.world.staticTree.remove(this);
          var Q = this.gameObject;
          return Q.getTopLeft(this.position), this.width = Q.displayWidth, this.height = Q.displayHeight, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.world.staticTree.insert(this), this;
        }, setOffset: function(Q, H) {
          if (H === undefined)
            H = Q;
          return this.world.staticTree.remove(this), this.position.x -= this.offset.x, this.position.y -= this.offset.y, this.offset.set(Q, H), this.position.x += this.offset.x, this.position.y += this.offset.y, this.updateCenter(), this.world.staticTree.insert(this), this;
        }, setSize: function(Q, H, N) {
          if (N === undefined)
            N = true;
          var W = this.gameObject;
          if (W && W.frame) {
            if (!Q)
              Q = W.frame.realWidth;
            if (!H)
              H = W.frame.realHeight;
          }
          if (this.world.staticTree.remove(this), this.width = Q, this.height = H, this.halfWidth = Math.floor(Q / 2), this.halfHeight = Math.floor(H / 2), N && W && W.getCenter) {
            var R = W.displayWidth / 2, Y = W.displayHeight / 2;
            this.position.x -= this.offset.x, this.position.y -= this.offset.y, this.offset.set(R - this.halfWidth, Y - this.halfHeight), this.position.x += this.offset.x, this.position.y += this.offset.y;
          }
          return this.updateCenter(), this.isCircle = false, this.radius = 0, this.world.staticTree.insert(this), this;
        }, setCircle: function(Q, H, N) {
          if (H === undefined)
            H = this.offset.x;
          if (N === undefined)
            N = this.offset.y;
          if (Q > 0)
            this.world.staticTree.remove(this), this.isCircle = true, this.radius = Q, this.width = Q * 2, this.height = Q * 2, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(H, N), this.updateCenter(), this.world.staticTree.insert(this);
          else
            this.isCircle = false;
          return this;
        }, updateCenter: function() {
          this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
        }, reset: function(Q, H) {
          var N = this.gameObject;
          if (Q === undefined)
            Q = N.x;
          if (H === undefined)
            H = N.y;
          this.world.staticTree.remove(this), N.setPosition(Q, H), N.getTopLeft(this.position), this.position.x += this.offset.x, this.position.y += this.offset.y, this.updateCenter(), this.world.staticTree.insert(this);
        }, stop: function() {
          return this;
        }, getBounds: function(Q) {
          return Q.x = this.x, Q.y = this.y, Q.right = this.right, Q.bottom = this.bottom, Q;
        }, hitTest: function(Q, H) {
          return this.isCircle ? E(this, Q, H) : K(this, Q, H);
        }, postUpdate: function() {
        }, deltaAbsX: function() {
          return 0;
        }, deltaAbsY: function() {
          return 0;
        }, deltaX: function() {
          return 0;
        }, deltaY: function() {
          return 0;
        }, deltaZ: function() {
          return 0;
        }, destroy: function() {
          this.enable = false, this.world.pendingDestroy.set(this);
        }, drawDebug: function(Q) {
          var H = this.position, N = H.x + this.halfWidth, W = H.y + this.halfHeight;
          if (this.debugShowBody)
            if (Q.lineStyle(Q.defaultStrokeWidth, this.debugBodyColor, 1), this.isCircle)
              Q.strokeCircle(N, W, this.width / 2);
            else
              Q.strokeRect(H.x, H.y, this.width, this.height);
        }, willDrawDebug: function() {
          return this.debugShowBody;
        }, setMass: function(Q) {
          if (Q <= 0)
            Q = 0.1;
          return this.mass = Q, this;
        }, x: { get: function() {
          return this.position.x;
        }, set: function(Q) {
          this.world.staticTree.remove(this), this.position.x = Q, this.world.staticTree.insert(this);
        } }, y: { get: function() {
          return this.position.y;
        }, set: function(Q) {
          this.world.staticTree.remove(this), this.position.y = Q, this.world.staticTree.insert(this);
        } }, left: { get: function() {
          return this.position.x;
        } }, right: { get: function() {
          return this.position.x + this.width;
        } }, top: { get: function() {
          return this.position.y;
        } }, bottom: { get: function() {
          return this.position.y + this.height;
        } } });
        M.exports = D;
      }, 71464: (M, B, $) => {
        var E = $(13759), L = $(83419), z = $(78389), U = $(37747), K = $(95540), J = $(26479), Z = $(41212), D = new L({ Extends: J, Mixins: [z], initialize: function Q(H, N, W, R) {
          if (!W && !R)
            R = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler, createMultipleCallback: this.createMultipleCallbackHandler, classType: E };
          else if (Z(W))
            R = W, W = null, R.internalCreateCallback = this.createCallbackHandler, R.internalRemoveCallback = this.removeCallbackHandler, R.createMultipleCallback = this.createMultipleCallbackHandler, R.classType = K(R, "classType", E);
          else if (Array.isArray(W) && Z(W[0]))
            R = W, W = null, R.forEach(function(Y) {
              Y.internalCreateCallback = this.createCallbackHandler, Y.internalRemoveCallback = this.removeCallbackHandler, Y.createMultipleCallback = this.createMultipleCallbackHandler, Y.classType = K(Y, "classType", E);
            });
          else
            R = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler };
          this.world = H, this.physicsType = U.STATIC_BODY, this.collisionCategory = 1, this.collisionMask = 1, J.call(this, N, W, R), this.type = "StaticPhysicsGroup";
        }, createCallbackHandler: function(Q) {
          if (!Q.body)
            this.world.enableBody(Q, U.STATIC_BODY);
        }, removeCallbackHandler: function(Q) {
          if (Q.body)
            this.world.disableBody(Q);
        }, createMultipleCallbackHandler: function() {
          this.refresh();
        }, refresh: function() {
          var Q = this.children.entries;
          for (var H = 0;H < Q.length; H++)
            Q[H].body.reset();
          return this;
        } });
        M.exports = D;
      }, 82248: (M, B, $) => {
        var E = $(55495), L = $(37742), z = $(45319), U = $(83419), K = $(79342), J = $(37747), Z = $(20339), D = $(52816), Q = $(50792), H = $(63012), N = $(43855), W = $(5470), R = $(94977), Y = $(64897), I = $(45170), P = $(96523), X = $(35154), G = $(36383), V = $(25774), A = $(96602), F = $(87841), j = $(59542), T = $(40012), C = $(14087), v = $(89936), O = $(35072), q = $(72624), w = $(2483), g = $(61340), b = $(26099), x = $(15994), k = new U({ Extends: Q, initialize: function S(f, h) {
          if (Q.call(this), this.scene = f, this.bodies = new O, this.staticBodies = new O, this.pendingDestroy = new O, this.colliders = new V, this.gravity = new b(X(h, "gravity.x", 0), X(h, "gravity.y", 0)), this.bounds = new F(X(h, "x", 0), X(h, "y", 0), X(h, "width", f.sys.scale.width), X(h, "height", f.sys.scale.height)), this.checkCollision = { up: X(h, "checkCollision.up", true), down: X(h, "checkCollision.down", true), left: X(h, "checkCollision.left", true), right: X(h, "checkCollision.right", true) }, this.fps = X(h, "fps", 60), this.fixedStep = X(h, "fixedStep", true), this._elapsed = 0, this._frameTime = 1 / this.fps, this._frameTimeMS = 1000 * this._frameTime, this.stepsLastFrame = 0, this.timeScale = X(h, "timeScale", 1), this.OVERLAP_BIAS = X(h, "overlapBias", 4), this.TILE_BIAS = X(h, "tileBias", 16), this.forceX = X(h, "forceX", false), this.isPaused = X(h, "isPaused", false), this._total = 0, this.drawDebug = X(h, "debug", false), this.debugGraphic, this.defaults = { debugShowBody: X(h, "debugShowBody", true), debugShowStaticBody: X(h, "debugShowStaticBody", true), debugShowVelocity: X(h, "debugShowVelocity", true), bodyDebugColor: X(h, "debugBodyColor", 16711935), staticBodyDebugColor: X(h, "debugStaticBodyColor", 255), velocityDebugColor: X(h, "debugVelocityColor", 65280) }, this.maxEntries = X(h, "maxEntries", 16), this.useTree = X(h, "useTree", true), this.tree = new j(this.maxEntries), this.staticTree = new j(this.maxEntries), this.treeMinMax = { minX: 0, minY: 0, maxX: 0, maxY: 0 }, this._tempMatrix = new g, this._tempMatrix2 = new g, this.tileFilterOptions = { isColliding: true, isNotEmpty: true, hasInterestingFace: true }, this.drawDebug)
            this.createDebugGraphic();
        }, enable: function(S, f) {
          if (f === undefined)
            f = J.DYNAMIC_BODY;
          if (!Array.isArray(S))
            S = [S];
          for (var h = 0;h < S.length; h++) {
            var m = S[h];
            if (m.isParent) {
              var y = m.getChildren();
              for (var d = 0;d < y.length; d++) {
                var p = y[d];
                if (p.isParent)
                  this.enable(p, f);
                else
                  this.enableBody(p, f);
              }
            } else
              this.enableBody(m, f);
          }
        }, enableBody: function(S, f) {
          if (f === undefined)
            f = J.DYNAMIC_BODY;
          if (S.hasTransformComponent) {
            if (!S.body) {
              if (f === J.DYNAMIC_BODY)
                S.body = new L(this, S);
              else if (f === J.STATIC_BODY)
                S.body = new q(this, S);
            }
            this.add(S.body);
          }
          return S;
        }, add: function(S) {
          if (S.physicsType === J.DYNAMIC_BODY)
            this.bodies.set(S);
          else if (S.physicsType === J.STATIC_BODY)
            this.staticBodies.set(S), this.staticTree.insert(S);
          return S.enable = true, S;
        }, disable: function(S) {
          if (!Array.isArray(S))
            S = [S];
          for (var f = 0;f < S.length; f++) {
            var h = S[f];
            if (h.isParent) {
              var m = h.getChildren();
              for (var y = 0;y < m.length; y++) {
                var d = m[y];
                if (d.isParent)
                  this.disable(d);
                else
                  this.disableBody(d.body);
              }
            } else
              this.disableBody(h.body);
          }
        }, disableBody: function(S) {
          this.remove(S), S.enable = false;
        }, remove: function(S) {
          if (S.physicsType === J.DYNAMIC_BODY)
            this.tree.remove(S), this.bodies.delete(S);
          else if (S.physicsType === J.STATIC_BODY)
            this.staticBodies.delete(S), this.staticTree.remove(S);
        }, createDebugGraphic: function() {
          var S = this.scene.sys.add.graphics({ x: 0, y: 0 });
          return S.setDepth(Number.MAX_VALUE), this.debugGraphic = S, this.drawDebug = true, S;
        }, setBounds: function(S, f, h, m, y, d, p, u) {
          if (this.bounds.setTo(S, f, h, m), y !== undefined)
            this.setBoundsCollision(y, d, p, u);
          return this;
        }, setBoundsCollision: function(S, f, h, m) {
          if (S === undefined)
            S = true;
          if (f === undefined)
            f = true;
          if (h === undefined)
            h = true;
          if (m === undefined)
            m = true;
          return this.checkCollision.left = S, this.checkCollision.right = f, this.checkCollision.up = h, this.checkCollision.down = m, this;
        }, pause: function() {
          return this.isPaused = true, this.emit(H.PAUSE), this;
        }, resume: function() {
          return this.isPaused = false, this.emit(H.RESUME), this;
        }, addCollider: function(S, f, h, m, y) {
          if (h === undefined)
            h = null;
          if (m === undefined)
            m = null;
          if (y === undefined)
            y = h;
          var d = new K(this, false, S, f, h, m, y);
          return this.colliders.add(d), d;
        }, addOverlap: function(S, f, h, m, y) {
          if (h === undefined)
            h = null;
          if (m === undefined)
            m = null;
          if (y === undefined)
            y = h;
          var d = new K(this, true, S, f, h, m, y);
          return this.colliders.add(d), d;
        }, removeCollider: function(S) {
          return this.colliders.remove(S), this;
        }, setFPS: function(S) {
          return this.fps = S, this._frameTime = 1 / this.fps, this._frameTimeMS = 1000 * this._frameTime, this;
        }, update: function(S, f) {
          if (this.isPaused || this.bodies.size === 0)
            return;
          var h, m = this._frameTime, y = this._frameTimeMS * this.timeScale;
          this._elapsed += f;
          var d, p = this.bodies.entries, u = this._elapsed >= y;
          if (!this.fixedStep)
            m = f * 0.001, u = true, this._elapsed = 0;
          for (h = 0;h < p.length; h++)
            if (d = p[h], d.enable)
              d.preUpdate(u, m);
          if (u) {
            if (this._elapsed -= y, this.stepsLastFrame = 1, this.useTree)
              this.tree.clear(), this.tree.load(p);
            var s = this.colliders.update();
            for (h = 0;h < s.length; h++) {
              var c = s[h];
              if (c.active)
                c.update();
            }
            this.emit(H.WORLD_STEP, m);
          }
          while (this._elapsed >= y)
            this._elapsed -= y, this.step(m);
        }, step: function(S) {
          var f, h, m = this.bodies.entries, y = m.length;
          for (f = 0;f < y; f++)
            if (h = m[f], h.enable)
              h.update(S);
          if (this.useTree)
            this.tree.clear(), this.tree.load(m);
          var d = this.colliders.update();
          for (f = 0;f < d.length; f++) {
            var p = d[f];
            if (p.active)
              p.update();
          }
          this.emit(H.WORLD_STEP, S), this.stepsLastFrame++;
        }, singleStep: function() {
          this.update(0, this._frameTimeMS), this.postUpdate();
        }, postUpdate: function() {
          var S, f, h = this.bodies.entries, m = h.length, y = this.bodies, d = this.staticBodies;
          if (this.stepsLastFrame) {
            this.stepsLastFrame = 0;
            for (S = 0;S < m; S++)
              if (f = h[S], f.enable)
                f.postUpdate();
          }
          if (this.drawDebug) {
            var p = this.debugGraphic;
            p.clear();
            for (S = 0;S < m; S++)
              if (f = h[S], f.willDrawDebug())
                f.drawDebug(p);
            h = d.entries, m = h.length;
            for (S = 0;S < m; S++)
              if (f = h[S], f.willDrawDebug())
                f.drawDebug(p);
          }
          var u = this.pendingDestroy;
          if (u.size > 0) {
            var s = this.tree, c = this.staticTree;
            h = u.entries, m = h.length;
            for (S = 0;S < m; S++) {
              if (f = h[S], f.physicsType === J.DYNAMIC_BODY)
                s.remove(f), y.delete(f);
              else if (f.physicsType === J.STATIC_BODY)
                c.remove(f), d.delete(f);
              f.world = undefined, f.gameObject = undefined;
            }
            u.clear();
          }
        }, updateMotion: function(S, f) {
          if (S.allowRotation)
            this.computeAngularVelocity(S, f);
          this.computeVelocity(S, f);
        }, computeAngularVelocity: function(S, f) {
          var { angularVelocity: h, angularAcceleration: m, angularDrag: y, maxAngular: d } = S;
          if (m)
            h += m * f;
          else if (S.allowDrag && y)
            if (y *= f, W(h - y, 0, 0.1))
              h -= y;
            else if (R(h + y, 0, 0.1))
              h += y;
            else
              h = 0;
          h = z(h, -d, d);
          var p = h - S.angularVelocity;
          S.angularVelocity += p, S.rotation += S.angularVelocity * f;
        }, computeVelocity: function(S, f) {
          var h = S.velocity.x, m = S.acceleration.x, y = S.drag.x, d = S.maxVelocity.x, p = S.velocity.y, u = S.acceleration.y, s = S.drag.y, c = S.maxVelocity.y, n = S.speed, _ = S.maxSpeed, l = S.allowDrag, i = S.useDamping;
          if (S.allowGravity)
            h += (this.gravity.x + S.gravity.x) * f, p += (this.gravity.y + S.gravity.y) * f;
          if (m)
            h += m * f;
          else if (l && y)
            if (i) {
              if (y = Math.pow(y, f), h *= y, n = Math.sqrt(h * h + p * p), N(n, 0, 0.001))
                h = 0;
            } else if (y *= f, W(h - y, 0, 0.01))
              h -= y;
            else if (R(h + y, 0, 0.01))
              h += y;
            else
              h = 0;
          if (u)
            p += u * f;
          else if (l && s)
            if (i) {
              if (s = Math.pow(s, f), p *= s, n = Math.sqrt(h * h + p * p), N(n, 0, 0.001))
                p = 0;
            } else if (s *= f, W(p - s, 0, 0.01))
              p -= s;
            else if (R(p + s, 0, 0.01))
              p += s;
            else
              p = 0;
          if (h = z(h, -d, d), p = z(p, -c, c), S.velocity.set(h, p), _ > -1 && S.velocity.length() > _)
            S.velocity.normalize().scale(_), n = _;
          S.speed = n;
        }, separate: function(S, f, h, m, y) {
          var d, p, u = false, s = true;
          if (!S.enable || !f.enable || S.checkCollision.none || f.checkCollision.none || !this.intersects(S, f))
            return u;
          if (h && h.call(m, S.gameObject, f.gameObject) === false)
            return u;
          if (S.isCircle || f.isCircle) {
            var c = this.separateCircle(S, f, y);
            if (c.result)
              u = true, s = false;
            else
              d = c.x, p = c.y, s = true;
          }
          if (s) {
            var n = false, _ = false, l = this.OVERLAP_BIAS;
            if (y)
              n = C(S, f, y, l, d), _ = v(S, f, y, l, p);
            else if (this.forceX || Math.abs(this.gravity.y + S.gravity.y) < Math.abs(this.gravity.x + S.gravity.x)) {
              if (n = C(S, f, y, l, d), this.intersects(S, f))
                _ = v(S, f, y, l, p);
            } else if (_ = v(S, f, y, l, p), this.intersects(S, f))
              n = C(S, f, y, l, d);
            u = n || _;
          }
          if (u) {
            if (y) {
              if (S.onOverlap || f.onOverlap)
                this.emit(H.OVERLAP, S.gameObject, f.gameObject, S, f);
            } else if (S.onCollide || f.onCollide)
              this.emit(H.COLLIDE, S.gameObject, f.gameObject, S, f);
          }
          return u;
        }, separateCircle: function(S, f, h) {
          Y(S, f, false, 0), I(S, f, false, 0);
          var m = S.isCircle, y = f.isCircle, d = S.center, p = f.center, u = S.immovable, s = f.immovable, c = S.velocity, n = f.velocity, _ = 0, l = true;
          if (m !== y) {
            l = false;
            var { x: i, y: t } = d, $0 = S.halfWidth, e = f.position.x, o = f.position.y, r = f.right, a = f.bottom;
            if (y)
              i = p.x, t = p.y, $0 = f.halfWidth, e = S.position.x, o = S.position.y, r = S.right, a = S.bottom;
            if (t < o) {
              if (i < e)
                _ = Z(i, t, e, o) - $0;
              else if (i > r)
                _ = Z(i, t, r, o) - $0;
            } else if (t > a) {
              if (i < e)
                _ = Z(i, t, e, a) - $0;
              else if (i > r)
                _ = Z(i, t, r, a) - $0;
            }
            _ *= -1;
          } else
            _ = S.halfWidth + f.halfWidth - D(d, p);
          S.overlapR = _, f.overlapR = _;
          var J0 = E(d, p), Q0 = (_ + G.EPSILON) * Math.cos(J0), D0 = (_ + G.EPSILON) * Math.sin(J0), z0 = { overlap: _, result: false, x: Q0, y: D0 };
          if (h && (!l || l && _ !== 0))
            return z0.result = true, z0;
          if (!l && _ === 0 || u && s || S.customSeparateX || f.customSeparateX)
            return z0.x = undefined, z0.y = undefined, z0;
          var K0 = !S.pushable && !f.pushable;
          if (l) {
            var Z0 = d.x - p.x, W0 = d.y - p.y, U0 = Math.sqrt(Math.pow(Z0, 2) + Math.pow(W0, 2)), N0 = (p.x - d.x) / U0 || 0, E0 = (p.y - d.y) / U0 || 0, L0 = 2 * (c.x * N0 + c.y * E0 - n.x * N0 - n.y * E0) / (S.mass + f.mass);
            if (u || s)
              L0 *= 2;
            if (!u)
              c.x = c.x - L0 / S.mass * N0, c.y = c.y - L0 / S.mass * E0, c.multiply(S.bounce);
            if (!s)
              n.x = n.x + L0 / f.mass * N0, n.y = n.y + L0 / f.mass * E0, n.multiply(f.bounce);
            if (!u && !s)
              Q0 *= 0.5, D0 *= 0.5;
            if (!u)
              S.x -= Q0, S.y -= D0, S.updateCenter();
            if (!s)
              f.x += Q0, f.y += D0, f.updateCenter();
            z0.result = true;
          } else {
            if (!u || S.pushable || K0)
              S.x -= Q0, S.y -= D0, S.updateCenter();
            else if (!s || f.pushable || K0)
              f.x += Q0, f.y += D0, f.updateCenter();
            z0.x = undefined, z0.y = undefined;
          }
          return z0;
        }, intersects: function(S, f) {
          if (S === f)
            return false;
          if (!S.isCircle && !f.isCircle)
            return !(S.right <= f.left || S.bottom <= f.top || S.left >= f.right || S.top >= f.bottom);
          else if (S.isCircle)
            if (f.isCircle)
              return D(S.center, f.center) <= S.halfWidth + f.halfWidth;
            else
              return this.circleBodyIntersects(S, f);
          else
            return this.circleBodyIntersects(f, S);
        }, circleBodyIntersects: function(S, f) {
          var h = z(S.center.x, f.left, f.right), m = z(S.center.y, f.top, f.bottom), y = (S.center.x - h) * (S.center.x - h), d = (S.center.y - m) * (S.center.y - m);
          return y + d <= S.halfWidth * S.halfWidth;
        }, overlap: function(S, f, h, m, y) {
          if (h === undefined)
            h = null;
          if (m === undefined)
            m = null;
          if (y === undefined)
            y = h;
          return this.collideObjects(S, f, h, m, y, true);
        }, collide: function(S, f, h, m, y) {
          if (h === undefined)
            h = null;
          if (m === undefined)
            m = null;
          if (y === undefined)
            y = h;
          return this.collideObjects(S, f, h, m, y, false);
        }, collideObjects: function(S, f, h, m, y, d) {
          var p, u;
          if (S.isParent && (S.physicsType === undefined || f === undefined || S === f))
            S = S.children.entries;
          if (f && f.isParent && f.physicsType === undefined)
            f = f.children.entries;
          var s = Array.isArray(S), c = Array.isArray(f);
          if (this._total = 0, !s && !c)
            this.collideHandler(S, f, h, m, y, d);
          else if (!s && c)
            for (p = 0;p < f.length; p++)
              this.collideHandler(S, f[p], h, m, y, d);
          else if (s && !c)
            if (!f)
              for (p = 0;p < S.length; p++) {
                var n = S[p];
                for (u = p + 1;u < S.length; u++) {
                  if (p === u)
                    continue;
                  this.collideHandler(n, S[u], h, m, y, d);
                }
              }
            else
              for (p = 0;p < S.length; p++)
                this.collideHandler(S[p], f, h, m, y, d);
          else
            for (p = 0;p < S.length; p++)
              for (u = 0;u < f.length; u++)
                this.collideHandler(S[p], f[u], h, m, y, d);
          return this._total > 0;
        }, collideHandler: function(S, f, h, m, y, d) {
          if (f === undefined && S.isParent)
            return this.collideGroupVsGroup(S, S, h, m, y, d);
          if (!S || !f)
            return false;
          if (S.body || S.isBody) {
            if (f.body || f.isBody)
              return this.collideSpriteVsSprite(S, f, h, m, y, d);
            else if (f.isParent)
              return this.collideSpriteVsGroup(S, f, h, m, y, d);
            else if (f.isTilemap)
              return this.collideSpriteVsTilemapLayer(S, f, h, m, y, d);
          } else if (S.isParent) {
            if (f.body || f.isBody)
              return this.collideSpriteVsGroup(f, S, h, m, y, d);
            else if (f.isParent)
              return this.collideGroupVsGroup(S, f, h, m, y, d);
            else if (f.isTilemap)
              return this.collideGroupVsTilemapLayer(S, f, h, m, y, d);
          } else if (S.isTilemap) {
            if (f.body || f.isBody)
              return this.collideSpriteVsTilemapLayer(f, S, h, m, y, d);
            else if (f.isParent)
              return this.collideGroupVsTilemapLayer(f, S, h, m, y, d);
          }
        }, canCollide: function(S, f) {
          return S && f && (S.collisionMask & f.collisionCategory) !== 0 && (f.collisionMask & S.collisionCategory) !== 0;
        }, collideSpriteVsSprite: function(S, f, h, m, y, d) {
          var p = S.isBody ? S : S.body, u = f.isBody ? f : f.body;
          if (!this.canCollide(p, u))
            return false;
          if (this.separate(p, u, m, y, d)) {
            if (h)
              h.call(y, S, f);
            this._total++;
          }
          return true;
        }, collideSpriteVsGroup: function(S, f, h, m, y, d) {
          var p = S.isBody ? S : S.body;
          if (f.length === 0 || !p || !p.enable || p.checkCollision.none || !this.canCollide(p, f))
            return;
          var u, s, c;
          if (this.useTree || f.physicsType === J.STATIC_BODY) {
            var n = this.treeMinMax;
            n.minX = p.left, n.minY = p.top, n.maxX = p.right, n.maxY = p.bottom;
            var _ = f.physicsType === J.DYNAMIC_BODY ? this.tree.search(n) : this.staticTree.search(n);
            s = _.length;
            for (u = 0;u < s; u++) {
              if (c = _[u], p === c || !c.enable || c.checkCollision.none || !f.contains(c.gameObject))
                continue;
              if (this.separate(p, c, m, y, d)) {
                if (h)
                  h.call(y, p.gameObject, c.gameObject);
                this._total++;
              }
            }
          } else {
            var l = f.getChildren(), i = f.children.entries.indexOf(S);
            s = l.length;
            for (u = 0;u < s; u++) {
              if (c = l[u].body, !c || u === i || !c.enable)
                continue;
              if (this.separate(p, c, m, y, d)) {
                if (h)
                  h.call(y, p.gameObject, c.gameObject);
                this._total++;
              }
            }
          }
        }, collideGroupVsTilemapLayer: function(S, f, h, m, y, d) {
          if (!this.canCollide(S, f))
            return false;
          var p = S.getChildren();
          if (p.length === 0)
            return false;
          var u = false;
          for (var s = 0;s < p.length; s++)
            if (p[s].body || p[s].isBody) {
              if (this.collideSpriteVsTilemapLayer(p[s], f, h, m, y, d))
                u = true;
            }
          return u;
        }, collideTiles: function(S, f, h, m, y) {
          if (f.length === 0 || S.body && !S.body.enable || S.isBody && !S.enable)
            return false;
          else
            return this.collideSpriteVsTilesHandler(S, f, h, m, y, false, false);
        }, overlapTiles: function(S, f, h, m, y) {
          if (f.length === 0 || S.body && !S.body.enable || S.isBody && !S.enable)
            return false;
          else
            return this.collideSpriteVsTilesHandler(S, f, h, m, y, true, false);
        }, collideSpriteVsTilemapLayer: function(S, f, h, m, y, d) {
          var p = S.isBody ? S : S.body;
          if (!p.enable || p.checkCollision.none || !this.canCollide(p, f))
            return false;
          var u = f.layer, s = p.x - u.tileWidth * f.scaleX, c = p.y - u.tileHeight * f.scaleY, n = p.width + u.tileWidth * f.scaleX, _ = p.height + u.tileHeight * f.scaleY, l = d ? null : this.tileFilterOptions, i = P(s, c, n, _, l, f.scene.cameras.main, f.layer);
          if (i.length === 0)
            return false;
          else
            return this.collideSpriteVsTilesHandler(S, i, h, m, y, d, true);
        }, collideSpriteVsTilesHandler: function(S, f, h, m, y, d, p) {
          var u = S.isBody ? S : S.body, s, c = { left: 0, right: 0, top: 0, bottom: 0 }, n, _ = false;
          for (var l = 0;l < f.length; l++) {
            s = f[l], n = s.tilemapLayer;
            var i = n.tileToWorldXY(s.x, s.y);
            if (c.left = i.x, c.top = i.y, c.right = c.left + s.width * n.scaleX, c.bottom = c.top + s.height * n.scaleY, w(c, u) && (!m || m.call(y, S, s)) && A(s, S) && (d || T(l, u, s, c, n, this.TILE_BIAS, p))) {
              if (this._total++, _ = true, h)
                h.call(y, S, s);
              if (d && u.onOverlap)
                this.emit(H.TILE_OVERLAP, S, s, u);
              else if (u.onCollide)
                this.emit(H.TILE_COLLIDE, S, s, u);
            }
          }
          return _;
        }, collideGroupVsGroup: function(S, f, h, m, y, d) {
          if (S.length === 0 || f.length === 0 || !this.canCollide(S, f))
            return;
          var p = S.getChildren();
          for (var u = 0;u < p.length; u++)
            this.collideSpriteVsGroup(p[u], f, h, m, y, d);
        }, wrap: function(S, f) {
          if (S.body)
            this.wrapObject(S, f);
          else if (S.getChildren)
            this.wrapArray(S.getChildren(), f);
          else if (Array.isArray(S))
            this.wrapArray(S, f);
          else
            this.wrapObject(S, f);
        }, wrapArray: function(S, f) {
          for (var h = 0;h < S.length; h++)
            this.wrapObject(S[h], f);
        }, wrapObject: function(S, f) {
          if (f === undefined)
            f = 0;
          S.x = x(S.x, this.bounds.left - f, this.bounds.right + f), S.y = x(S.y, this.bounds.top - f, this.bounds.bottom + f);
        }, shutdown: function() {
          this.tree.clear(), this.staticTree.clear(), this.bodies.clear(), this.staticBodies.clear(), this.colliders.destroy(), this.removeAllListeners();
        }, destroy: function() {
          if (this.shutdown(), this.scene = null, this.debugGraphic)
            this.debugGraphic.destroy(), this.debugGraphic = null;
        } });
        M.exports = k;
      }, 1093: (M) => {
        var B = { setAcceleration: function($, E) {
          return this.body.acceleration.set($, E), this;
        }, setAccelerationX: function($) {
          return this.body.acceleration.x = $, this;
        }, setAccelerationY: function($) {
          return this.body.acceleration.y = $, this;
        } };
        M.exports = B;
      }, 59023: (M) => {
        var B = { setAngularVelocity: function($) {
          return this.body.angularVelocity = $, this;
        }, setAngularAcceleration: function($) {
          return this.body.angularAcceleration = $, this;
        }, setAngularDrag: function($) {
          return this.body.angularDrag = $, this;
        } };
        M.exports = B;
      }, 62069: (M) => {
        var B = { setBounce: function($, E) {
          return this.body.bounce.set($, E), this;
        }, setBounceX: function($) {
          return this.body.bounce.x = $, this;
        }, setBounceY: function($) {
          return this.body.bounce.y = $, this;
        }, setCollideWorldBounds: function($, E, L, z) {
          return this.body.setCollideWorldBounds($, E, L, z), this;
        } };
        M.exports = B;
      }, 78389: (M, B, $) => {
        var E = $(79599), L = { setCollisionCategory: function(z) {
          var U = this.body ? this.body : this;
          return U.collisionCategory = z, this;
        }, willCollideWith: function(z) {
          var U = this.body ? this.body : this;
          return (U.collisionMask & z) !== 0;
        }, addCollidesWith: function(z) {
          var U = this.body ? this.body : this;
          return U.collisionMask = U.collisionMask | z, this;
        }, removeCollidesWith: function(z) {
          var U = this.body ? this.body : this;
          return U.collisionMask = U.collisionMask & ~z, this;
        }, setCollidesWith: function(z) {
          var U = this.body ? this.body : this;
          return U.collisionMask = E(z), this;
        }, resetCollisionCategory: function() {
          var z = this.body ? this.body : this;
          return z.collisionCategory = 1, z.collisionMask = 1, this;
        } };
        M.exports = L;
      }, 87118: (M) => {
        var B = { setDebug: function($, E, L) {
          return this.debugShowBody = $, this.debugShowVelocity = E, this.debugBodyColor = L, this;
        }, setDebugBodyColor: function($) {
          return this.body.debugBodyColor = $, this;
        }, debugShowBody: { get: function() {
          return this.body.debugShowBody;
        }, set: function($) {
          this.body.debugShowBody = $;
        } }, debugShowVelocity: { get: function() {
          return this.body.debugShowVelocity;
        }, set: function($) {
          this.body.debugShowVelocity = $;
        } }, debugBodyColor: { get: function() {
          return this.body.debugBodyColor;
        }, set: function($) {
          this.body.debugBodyColor = $;
        } } };
        M.exports = B;
      }, 52819: (M) => {
        var B = { setDrag: function($, E) {
          return this.body.drag.set($, E), this;
        }, setDragX: function($) {
          return this.body.drag.x = $, this;
        }, setDragY: function($) {
          return this.body.drag.y = $, this;
        }, setDamping: function($) {
          return this.body.useDamping = $, this;
        } };
        M.exports = B;
      }, 4074: (M) => {
        var B = { setDirectControl: function($) {
          return this.body.setDirectControl($), this;
        }, enableBody: function($, E, L, z, U) {
          if ($)
            this.body.reset(E, L);
          if (z)
            this.body.gameObject.active = true;
          if (U)
            this.body.gameObject.visible = true;
          return this.body.enable = true, this;
        }, disableBody: function($, E) {
          if ($ === undefined)
            $ = false;
          if (E === undefined)
            E = false;
          if (this.body.stop(), this.body.enable = false, $)
            this.body.gameObject.active = false;
          if (E)
            this.body.gameObject.visible = false;
          return this;
        }, refreshBody: function() {
          return this.body.updateFromGameObject(), this;
        } };
        M.exports = B;
      }, 40831: (M) => {
        var B = { setFriction: function($, E) {
          return this.body.friction.set($, E), this;
        }, setFrictionX: function($) {
          return this.body.friction.x = $, this;
        }, setFrictionY: function($) {
          return this.body.friction.y = $, this;
        } };
        M.exports = B;
      }, 26775: (M) => {
        var B = { setGravity: function($, E) {
          return this.body.gravity.set($, E), this;
        }, setGravityX: function($) {
          return this.body.gravity.x = $, this;
        }, setGravityY: function($) {
          return this.body.gravity.y = $, this;
        } };
        M.exports = B;
      }, 9437: (M) => {
        var B = { setImmovable: function($) {
          if ($ === undefined)
            $ = true;
          return this.body.immovable = $, this;
        } };
        M.exports = B;
      }, 30621: (M) => {
        var B = { setMass: function($) {
          return this.body.mass = $, this;
        } };
        M.exports = B;
      }, 72441: (M, B, $) => {
        var E = $(47956), L = $(96503), z = $(2044), U = $(81491), K = function(J, Z, D, Q, H, N) {
          var W = E(J, Z - Q, D - Q, 2 * Q, 2 * Q, H, N);
          if (W.length === 0)
            return W;
          var R = new L(Z, D, Q), Y = new L, I = [];
          for (var P = 0;P < W.length; P++) {
            var X = W[P];
            if (X.isCircle) {
              if (Y.setTo(X.center.x, X.center.y, X.halfWidth), z(R, Y))
                I.push(X);
            } else if (U(R, X))
              I.push(X);
          }
          return I;
        };
        M.exports = K;
      }, 47956: (M) => {
        var B = function($, E, L, z, U, K, J) {
          if (K === undefined)
            K = true;
          if (J === undefined)
            J = false;
          var Z = [], D = [], Q = $.treeMinMax;
          if (Q.minX = E, Q.minY = L, Q.maxX = E + z, Q.maxY = L + U, J)
            D = $.staticTree.search(Q);
          if (K && $.useTree)
            Z = $.tree.search(Q);
          else if (K) {
            var H = $.bodies, N = { position: { x: E, y: L }, left: E, top: L, right: E + z, bottom: L + U, isCircle: false }, W = $.intersects;
            H.iterate(function(R) {
              if (W(R, N))
                Z.push(R);
            });
          }
          return D.concat(Z);
        };
        M.exports = B;
      }, 62121: (M) => {
        var B = { setPushable: function($) {
          if ($ === undefined)
            $ = true;
          return this.body.pushable = $, this;
        } };
        M.exports = B;
      }, 29384: (M) => {
        var B = { setOffset: function($, E) {
          return this.body.setOffset($, E), this;
        }, setSize: function($, E, L) {
          return this.body.setSize($, E, L), this;
        }, setBodySize: function($, E, L) {
          return this.body.setSize($, E, L), this;
        }, setCircle: function($, E, L) {
          return this.body.setCircle($, E, L), this;
        } };
        M.exports = B;
      }, 15098: (M) => {
        var B = { setVelocity: function($, E) {
          return this.body.setVelocity($, E), this;
        }, setVelocityX: function($) {
          return this.body.setVelocityX($), this;
        }, setVelocityY: function($) {
          return this.body.setVelocityY($), this;
        }, setMaxVelocity: function($, E) {
          return this.body.maxVelocity.set($, E), this;
        } };
        M.exports = B;
      }, 92209: (M, B, $) => {
        M.exports = { Acceleration: $(1093), Angular: $(59023), Bounce: $(62069), Collision: $(78389), Debug: $(87118), Drag: $(52819), Enable: $(4074), Friction: $(40831), Gravity: $(26775), Immovable: $(9437), Mass: $(30621), OverlapCirc: $(72441), OverlapRect: $(47956), Pushable: $(62121), Size: $(29384), Velocity: $(15098) };
      }, 37747: (M) => {
        var B = { DYNAMIC_BODY: 0, STATIC_BODY: 1, GROUP: 2, TILEMAPLAYER: 3, FACING_NONE: 10, FACING_UP: 11, FACING_DOWN: 12, FACING_LEFT: 13, FACING_RIGHT: 14 };
        M.exports = B;
      }, 20009: (M) => {
        M.exports = "collide";
      }, 36768: (M) => {
        M.exports = "overlap";
      }, 60473: (M) => {
        M.exports = "pause";
      }, 89954: (M) => {
        M.exports = "resume";
      }, 61804: (M) => {
        M.exports = "tilecollide";
      }, 7161: (M) => {
        M.exports = "tileoverlap";
      }, 34689: (M) => {
        M.exports = "worldbounds";
      }, 16006: (M) => {
        M.exports = "worldstep";
      }, 63012: (M, B, $) => {
        M.exports = { COLLIDE: $(20009), OVERLAP: $(36768), PAUSE: $(60473), RESUME: $(89954), TILE_COLLIDE: $(61804), TILE_OVERLAP: $(7161), WORLD_BOUNDS: $(34689), WORLD_STEP: $(16006) };
      }, 27064: (M, B, $) => {
        var E = $(37747), L = $(79291), z = { ArcadePhysics: $(86689), Body: $(37742), Collider: $(79342), Components: $(92209), Events: $(63012), Factory: $(66022), GetCollidesWith: $(79599), GetOverlapX: $(64897), GetOverlapY: $(45170), SeparateX: $(14087), SeparateY: $(89936), Group: $(60758), Image: $(71289), Sprite: $(13759), StaticBody: $(72624), StaticGroup: $(71464), Tilemap: $(55173), World: $(82248) };
        z = L(false, z, E), M.exports = z;
      }, 96602: (M) => {
        var B = function($, E) {
          if ($.collisionCallback)
            return !$.collisionCallback.call($.collisionCallbackContext, E, $);
          else if ($.layer.callbacks[$.index])
            return !$.layer.callbacks[$.index].callback.call($.layer.callbacks[$.index].callbackContext, E, $);
          return true;
        };
        M.exports = B;
      }, 36294: (M) => {
        var B = function($, E) {
          if (E < 0)
            $.blocked.none = false, $.blocked.left = true;
          else if (E > 0)
            $.blocked.none = false, $.blocked.right = true;
          if ($.position.x -= E, $.updateCenter(), $.bounce.x === 0)
            $.velocity.x = 0;
          else
            $.velocity.x = -$.velocity.x * $.bounce.x;
        };
        M.exports = B;
      }, 67013: (M) => {
        var B = function($, E) {
          if (E < 0)
            $.blocked.none = false, $.blocked.up = true;
          else if (E > 0)
            $.blocked.none = false, $.blocked.down = true;
          if ($.position.y -= E, $.updateCenter(), $.bounce.y === 0)
            $.velocity.y = 0;
          else
            $.velocity.y = -$.velocity.y * $.bounce.y;
        };
        M.exports = B;
      }, 40012: (M, B, $) => {
        var E = $(21329), L = $(53442), z = $(2483), U = function(K, J, Z, D, Q, H, N) {
          var { left: W, top: R, right: Y, bottom: I } = D, P = Z.faceLeft || Z.faceRight, X = Z.faceTop || Z.faceBottom;
          if (!N)
            P = true, X = true;
          if (!P && !X)
            return false;
          var G = 0, V = 0, A = 0, F = 1;
          if (J.deltaAbsX() > J.deltaAbsY())
            A = -1;
          else if (J.deltaAbsX() < J.deltaAbsY())
            F = -1;
          if (J.deltaX() !== 0 && J.deltaY() !== 0 && P && X)
            A = Math.min(Math.abs(J.position.x - Y), Math.abs(J.right - W)), F = Math.min(Math.abs(J.position.y - I), Math.abs(J.bottom - R));
          if (A < F) {
            if (P) {
              if (G = E(J, Z, W, Y, H, N), G !== 0 && !z(D, J))
                return true;
            }
            if (X)
              V = L(J, Z, R, I, H, N);
          } else {
            if (X) {
              if (V = L(J, Z, R, I, H, N), V !== 0 && !z(D, J))
                return true;
            }
            if (P)
              G = E(J, Z, W, Y, H, N);
          }
          return G !== 0 || V !== 0;
        };
        M.exports = U;
      }, 21329: (M, B, $) => {
        var E = $(36294), L = function(z, U, K, J, Z, D) {
          var Q = 0, H = U.faceLeft, N = U.faceRight, W = U.collideLeft, R = U.collideRight;
          if (!D)
            H = true, N = true, W = true, R = true;
          if (z.deltaX() < 0 && R && z.checkCollision.left) {
            if (N && z.x < J) {
              if (Q = z.x - J, Q < -Z)
                Q = 0;
            }
          } else if (z.deltaX() > 0 && W && z.checkCollision.right) {
            if (H && z.right > K) {
              if (Q = z.right - K, Q > Z)
                Q = 0;
            }
          }
          if (Q !== 0)
            if (z.customSeparateX)
              z.overlapX = Q;
            else
              E(z, Q);
          return Q;
        };
        M.exports = L;
      }, 53442: (M, B, $) => {
        var E = $(67013), L = function(z, U, K, J, Z, D) {
          var Q = 0, H = U.faceTop, N = U.faceBottom, W = U.collideUp, R = U.collideDown;
          if (!D)
            H = true, N = true, W = true, R = true;
          if (z.deltaY() < 0 && R && z.checkCollision.up) {
            if (N && z.y < J) {
              if (Q = z.y - J, Q < -Z)
                Q = 0;
            }
          } else if (z.deltaY() > 0 && W && z.checkCollision.down) {
            if (H && z.bottom > K) {
              if (Q = z.bottom - K, Q > Z)
                Q = 0;
            }
          }
          if (Q !== 0)
            if (z.customSeparateY)
              z.overlapY = Q;
            else
              E(z, Q);
          return Q;
        };
        M.exports = L;
      }, 2483: (M) => {
        var B = function($, E) {
          return !(E.right <= $.left || E.bottom <= $.top || E.position.x >= $.right || E.position.y >= $.bottom);
        };
        M.exports = B;
      }, 55173: (M, B, $) => {
        var E = { ProcessTileCallbacks: $(96602), ProcessTileSeparationX: $(36294), ProcessTileSeparationY: $(67013), SeparateTile: $(40012), TileCheckX: $(21329), TileCheckY: $(53442), TileIntersectsBody: $(2483) };
        M.exports = E;
      }, 44563: (M, B, $) => {
        M.exports = { Arcade: $(27064), Matter: $(3875) };
      }, 68174: (M, B, $) => {
        var E = $(83419), L = $(26099), z = new E({ initialize: function U() {
          this.boundsCenter = new L, this.centerDiff = new L;
        }, parseBody: function(U) {
          if (U = U.hasOwnProperty("body") ? U.body : U, !U.hasOwnProperty("bounds") || !U.hasOwnProperty("centerOfMass"))
            return false;
          var K = this.boundsCenter, J = this.centerDiff, Z = U.bounds.max.x - U.bounds.min.x, D = U.bounds.max.y - U.bounds.min.y, Q = Z * U.centerOfMass.x, H = D * U.centerOfMass.y;
          return K.set(Z / 2, D / 2), J.set(Q - K.x, H - K.y), true;
        }, getTopLeft: function(U, K, J) {
          if (K === undefined)
            K = 0;
          if (J === undefined)
            J = 0;
          if (this.parseBody(U)) {
            var Z = this.boundsCenter, D = this.centerDiff;
            return new L(K + Z.x + D.x, J + Z.y + D.y);
          }
          return false;
        }, getTopCenter: function(U, K, J) {
          if (K === undefined)
            K = 0;
          if (J === undefined)
            J = 0;
          if (this.parseBody(U)) {
            var Z = this.boundsCenter, D = this.centerDiff;
            return new L(K + D.x, J + Z.y + D.y);
          }
          return false;
        }, getTopRight: function(U, K, J) {
          if (K === undefined)
            K = 0;
          if (J === undefined)
            J = 0;
          if (this.parseBody(U)) {
            var Z = this.boundsCenter, D = this.centerDiff;
            return new L(K - (Z.x - D.x), J + Z.y + D.y);
          }
          return false;
        }, getLeftCenter: function(U, K, J) {
          if (K === undefined)
            K = 0;
          if (J === undefined)
            J = 0;
          if (this.parseBody(U)) {
            var Z = this.boundsCenter, D = this.centerDiff;
            return new L(K + Z.x + D.x, J + D.y);
          }
          return false;
        }, getCenter: function(U, K, J) {
          if (K === undefined)
            K = 0;
          if (J === undefined)
            J = 0;
          if (this.parseBody(U)) {
            var Z = this.centerDiff;
            return new L(K + Z.x, J + Z.y);
          }
          return false;
        }, getRightCenter: function(U, K, J) {
          if (K === undefined)
            K = 0;
          if (J === undefined)
            J = 0;
          if (this.parseBody(U)) {
            var Z = this.boundsCenter, D = this.centerDiff;
            return new L(K - (Z.x - D.x), J + D.y);
          }
          return false;
        }, getBottomLeft: function(U, K, J) {
          if (K === undefined)
            K = 0;
          if (J === undefined)
            J = 0;
          if (this.parseBody(U)) {
            var Z = this.boundsCenter, D = this.centerDiff;
            return new L(K + Z.x + D.x, J - (Z.y - D.y));
          }
          return false;
        }, getBottomCenter: function(U, K, J) {
          if (K === undefined)
            K = 0;
          if (J === undefined)
            J = 0;
          if (this.parseBody(U)) {
            var Z = this.boundsCenter, D = this.centerDiff;
            return new L(K + D.x, J - (Z.y - D.y));
          }
          return false;
        }, getBottomRight: function(U, K, J) {
          if (K === undefined)
            K = 0;
          if (J === undefined)
            J = 0;
          if (this.parseBody(U)) {
            var Z = this.boundsCenter, D = this.centerDiff;
            return new L(K - (Z.x - D.x), J - (Z.y - D.y));
          }
          return false;
        } });
        M.exports = z;
      }, 19933: (M, B, $) => {
        var E = $(6790);
        E.Body = $(22562), E.Composite = $(69351), E.World = $(4372), E.Collision = $(52284), E.Detector = $(81388), E.Pairs = $(99561), E.Pair = $(4506), E.Query = $(73296), E.Resolver = $(66272), E.Constraint = $(48140), E.Common = $(53402), E.Engine = $(48413), E.Events = $(35810), E.Sleeping = $(53614), E.Plugin = $(73832), E.Bodies = $(66280), E.Composites = $(74116), E.Axes = $(66615), E.Bounds = $(15647), E.Svg = $(74058), E.Vector = $(31725), E.Vertices = $(41598), E.World.add = E.Composite.add, E.World.remove = E.Composite.remove, E.World.addComposite = E.Composite.addComposite, E.World.addBody = E.Composite.addBody, E.World.addConstraint = E.Composite.addConstraint, E.World.clear = E.Composite.clear, M.exports = E;
      }, 28137: (M, B, $) => {
        var E = $(66280), L = $(83419), z = $(74116), U = $(48140), K = $(74058), J = $(75803), Z = $(23181), D = $(34803), Q = $(73834), H = $(19496), N = $(85791), W = $(98713), R = $(41598), Y = new L({ initialize: function I(P) {
          this.world = P, this.scene = P.scene, this.sys = P.scene.sys;
        }, rectangle: function(I, P, X, G, V) {
          var A = E.rectangle(I, P, X, G, V);
          return this.world.add(A), A;
        }, trapezoid: function(I, P, X, G, V, A) {
          var F = E.trapezoid(I, P, X, G, V, A);
          return this.world.add(F), F;
        }, circle: function(I, P, X, G, V) {
          var A = E.circle(I, P, X, G, V);
          return this.world.add(A), A;
        }, polygon: function(I, P, X, G, V) {
          var A = E.polygon(I, P, X, G, V);
          return this.world.add(A), A;
        }, fromVertices: function(I, P, X, G, V, A, F) {
          if (typeof X === "string")
            X = R.fromPath(X);
          var j = E.fromVertices(I, P, X, G, V, A, F);
          return this.world.add(j), j;
        }, fromPhysicsEditor: function(I, P, X, G, V) {
          if (V === undefined)
            V = true;
          var A = H.parseBody(I, P, X, G);
          if (V && !this.world.has(A))
            this.world.add(A);
          return A;
        }, fromSVG: function(I, P, X, G, V, A) {
          if (G === undefined)
            G = 1;
          if (V === undefined)
            V = {};
          if (A === undefined)
            A = true;
          var F = X.getElementsByTagName("path"), j = [];
          for (var T = 0;T < F.length; T++) {
            var C = K.pathToVertices(F[T], 30);
            if (G !== 1)
              R.scale(C, G, G);
            j.push(C);
          }
          var v = E.fromVertices(I, P, j, V);
          if (A)
            this.world.add(v);
          return v;
        }, fromJSON: function(I, P, X, G, V) {
          if (G === undefined)
            G = {};
          if (V === undefined)
            V = true;
          var A = N.parseBody(I, P, X, G);
          if (A && V)
            this.world.add(A);
          return A;
        }, imageStack: function(I, P, X, G, V, A, F, j, T) {
          if (F === undefined)
            F = 0;
          if (j === undefined)
            j = 0;
          if (T === undefined)
            T = {};
          var C = this.world, v = this.sys.displayList;
          T.addToWorld = false;
          var O = z.stack(X, G, V, A, F, j, function(q, w) {
            var g = new Z(C, q, w, I, P, T);
            return v.add(g), g.body;
          });
          return C.add(O), O;
        }, stack: function(I, P, X, G, V, A, F) {
          var j = z.stack(I, P, X, G, V, A, F);
          return this.world.add(j), j;
        }, pyramid: function(I, P, X, G, V, A, F) {
          var j = z.pyramid(I, P, X, G, V, A, F);
          return this.world.add(j), j;
        }, chain: function(I, P, X, G, V, A) {
          return z.chain(I, P, X, G, V, A);
        }, mesh: function(I, P, X, G, V) {
          return z.mesh(I, P, X, G, V);
        }, newtonsCradle: function(I, P, X, G, V) {
          var A = z.newtonsCradle(I, P, X, G, V);
          return this.world.add(A), A;
        }, car: function(I, P, X, G, V) {
          var A = z.car(I, P, X, G, V);
          return this.world.add(A), A;
        }, softBody: function(I, P, X, G, V, A, F, j, T, C) {
          var v = z.softBody(I, P, X, G, V, A, F, j, T, C);
          return this.world.add(v), v;
        }, joint: function(I, P, X, G, V) {
          return this.constraint(I, P, X, G, V);
        }, spring: function(I, P, X, G, V) {
          return this.constraint(I, P, X, G, V);
        }, constraint: function(I, P, X, G, V) {
          if (G === undefined)
            G = 1;
          if (V === undefined)
            V = {};
          if (V.bodyA = I.type === "body" ? I : I.body, V.bodyB = P.type === "body" ? P : P.body, !isNaN(X))
            V.length = X;
          V.stiffness = G;
          var A = U.create(V);
          return this.world.add(A), A;
        }, worldConstraint: function(I, P, X, G) {
          if (X === undefined)
            X = 1;
          if (G === undefined)
            G = {};
          if (G.bodyB = I.type === "body" ? I : I.body, !isNaN(P))
            G.length = P;
          G.stiffness = X;
          var V = U.create(G);
          return this.world.add(V), V;
        }, mouseSpring: function(I) {
          return this.pointerConstraint(I);
        }, pointerConstraint: function(I) {
          if (I === undefined)
            I = {};
          if (!I.hasOwnProperty("render"))
            I.render = { visible: false };
          var P = new W(this.scene, this.world, I);
          return this.world.add(P.constraint), P;
        }, image: function(I, P, X, G, V) {
          var A = new Z(this.world, I, P, X, G, V);
          return this.sys.displayList.add(A), A;
        }, tileBody: function(I, P) {
          return new Q(this.world, I, P);
        }, sprite: function(I, P, X, G, V) {
          var A = new D(this.world, I, P, X, G, V);
          return this.sys.displayList.add(A), this.sys.updateList.add(A), A;
        }, gameObject: function(I, P, X) {
          return J(this.world, I, P, X);
        }, destroy: function() {
          this.world = null, this.scene = null, this.sys = null;
        } });
        M.exports = Y;
      }, 75803: (M, B, $) => {
        var E = $(31884), L = $(95540), z = $(26099);
        function U(J) {
          return !!J.get && typeof J.get === "function" || !!J.set && typeof J.set === "function";
        }
        var K = function(J, Z, D, Q) {
          if (D === undefined)
            D = {};
          if (Q === undefined)
            Q = true;
          var { x: H, y: N } = Z;
          Z.body = { temp: true, position: { x: H, y: N } };
          var W = [E.Bounce, E.Collision, E.Force, E.Friction, E.Gravity, E.Mass, E.Sensor, E.SetBody, E.Sleep, E.Static, E.Transform, E.Velocity];
          if (W.forEach(function(Y) {
            for (var I in Y)
              if (U(Y[I]))
                Object.defineProperty(Z, I, { get: Y[I].get, set: Y[I].set });
              else
                Object.defineProperty(Z, I, { value: Y[I] });
          }), Z.world = J, Z._tempVec2 = new z(H, N), D.hasOwnProperty("type") && D.type === "body")
            Z.setExistingBody(D, Q);
          else {
            var R = L(D, "shape", null);
            if (!R)
              R = "rectangle";
            D.addToWorld = Q, Z.setBody(R, D);
          }
          return Z;
        };
        M.exports = K;
      }, 23181: (M, B, $) => {
        var E = $(83419), L = $(31884), z = $(95643), U = $(95540), K = $(88571), J = $(72699), Z = $(26099), D = new E({ Extends: K, Mixins: [L.Bounce, L.Collision, L.Force, L.Friction, L.Gravity, L.Mass, L.Sensor, L.SetBody, L.Sleep, L.Static, L.Transform, L.Velocity, J], initialize: function Q(H, N, W, R, Y, I) {
          z.call(this, H.scene, "Image"), this._crop = this.resetCropObject(), this.setTexture(R, Y), this.setSizeToFrame(), this.setOrigin(), this.world = H, this._tempVec2 = new Z(N, W);
          var P = U(I, "shape", null);
          if (P)
            this.setBody(P, I);
          else
            this.setRectangle(this.width, this.height, I);
          this.setPosition(N, W), this.initPipeline(), this.initPostPipeline(true);
        } });
        M.exports = D;
      }, 42045: (M, B, $) => {
        var E = $(60461), L = $(66615), z = $(66280), U = $(22562), K = $(68174), J = $(15647), Z = $(83419), D = $(52284), Q = $(53402), H = $(69351), N = $(74116), W = $(48140), R = $(81388), Y = $(20339), I = $(28137), P = $(95540), X = $(35154), G = $(18210), V = $(40178), A = $(6790), F = $(74507), j = $(46975), T = $(4506), C = $(99561), v = $(73832), O = $(37277), q = $(73296), w = $(66272), g = $(44594), b = $(74058), x = $(31725), k = $(41598), S = $(68243);
        Q.setDecomp($(55973));
        var f = new Z({ initialize: function h(m) {
          if (this.scene = m, this.systems = m.sys, this.config = this.getConfig(), this.world, this.add, this.bodyBounds, this.body = U, this.composite = H, this.collision = D, this.detector = R, this.pair = T, this.pairs = C, this.query = q, this.resolver = w, this.constraint = W, this.bodies = z, this.composites = N, this.axes = L, this.bounds = J, this.svg = b, this.vector = x, this.vertices = k, this.verts = k, this._tempVec2 = x.create(), X(this.config, "plugins.collisionevents", true))
            this.enableCollisionEventsPlugin();
          if (X(this.config, "plugins.attractors", false))
            this.enableAttractorPlugin();
          if (X(this.config, "plugins.wrap", false))
            this.enableWrapPlugin();
          w._restingThresh = X(this.config, "restingThresh", 4), w._restingThreshTangent = X(this.config, "restingThreshTangent", 6), w._positionDampen = X(this.config, "positionDampen", 0.9), w._positionWarming = X(this.config, "positionWarming", 0.8), w._frictionNormalMultiplier = X(this.config, "frictionNormalMultiplier", 5), m.sys.events.once(g.BOOT, this.boot, this), m.sys.events.on(g.START, this.start, this);
        }, boot: function() {
          this.world = new S(this.scene, this.config), this.add = new I(this.world), this.bodyBounds = new K, this.systems.events.once(g.DESTROY, this.destroy, this);
        }, start: function() {
          if (!this.world)
            this.world = new S(this.scene, this.config), this.add = new I(this.world);
          var h = this.systems.events;
          h.on(g.UPDATE, this.world.update, this.world), h.on(g.POST_UPDATE, this.world.postUpdate, this.world), h.once(g.SHUTDOWN, this.shutdown, this);
        }, getConfig: function() {
          var h = this.systems.game.config.physics, m = this.systems.settings.physics, y = j(P(m, "matter", {}), P(h, "matter", {}));
          return y;
        }, enableAttractorPlugin: function() {
          return v.register(G), v.use(A, G), this;
        }, enableWrapPlugin: function() {
          return v.register(F), v.use(A, F), this;
        }, enableCollisionEventsPlugin: function() {
          return v.register(V), v.use(A, V), this;
        }, pause: function() {
          return this.world.pause();
        }, resume: function() {
          return this.world.resume();
        }, set60Hz: function() {
          return this.world.getDelta = this.world.update60Hz, this.world.autoUpdate = true, this;
        }, set30Hz: function() {
          return this.world.getDelta = this.world.update30Hz, this.world.autoUpdate = true, this;
        }, step: function(h, m) {
          this.world.step(h, m);
        }, containsPoint: function(h, m, y) {
          h = this.getMatterBodies(h);
          var d = x.create(m, y), p = q.point(h, d);
          return p.length > 0 ? true : false;
        }, intersectPoint: function(h, m, y) {
          y = this.getMatterBodies(y);
          var d = x.create(h, m), p = [], u = q.point(y, d);
          return u.forEach(function(s) {
            if (p.indexOf(s) === -1)
              p.push(s);
          }), p;
        }, intersectRect: function(h, m, y, d, p, u) {
          if (p === undefined)
            p = false;
          u = this.getMatterBodies(u);
          var s = { min: { x: h, y: m }, max: { x: h + y, y: m + d } }, c = [], n = q.region(u, s, p);
          return n.forEach(function(_) {
            if (c.indexOf(_) === -1)
              c.push(_);
          }), c;
        }, intersectRay: function(h, m, y, d, p, u) {
          if (p === undefined)
            p = 1;
          u = this.getMatterBodies(u);
          var s = [], c = q.ray(u, x.create(h, m), x.create(y, d), p);
          for (var n = 0;n < c.length; n++)
            s.push(c[n].body);
          return s;
        }, intersectBody: function(h, m) {
          m = this.getMatterBodies(m);
          var y = [], d = q.collides(h, m);
          for (var p = 0;p < d.length; p++) {
            var u = d[p];
            if (u.bodyA === h)
              y.push(u.bodyB);
            else
              y.push(u.bodyA);
          }
          return y;
        }, overlap: function(h, m, y, d, p) {
          if (y === undefined)
            y = null;
          if (d === undefined)
            d = null;
          if (p === undefined)
            p = y;
          if (!Array.isArray(h))
            h = [h];
          h = this.getMatterBodies(h), m = this.getMatterBodies(m);
          var u = false;
          for (var s = 0;s < h.length; s++) {
            var c = h[s], n = q.collides(c, m);
            for (var _ = 0;_ < n.length; _++) {
              var l = n[_], i = l.bodyA.id === c.id ? l.bodyB : l.bodyA;
              if (!d || d.call(p, c, i, l)) {
                if (u = true, y)
                  y.call(p, c, i, l);
                else if (!d)
                  return true;
              }
            }
          }
          return u;
        }, setCollisionCategory: function(h, m) {
          return h = this.getMatterBodies(h), h.forEach(function(y) {
            y.collisionFilter.category = m;
          }), this;
        }, setCollisionGroup: function(h, m) {
          return h = this.getMatterBodies(h), h.forEach(function(y) {
            y.collisionFilter.group = m;
          }), this;
        }, setCollidesWith: function(h, m) {
          h = this.getMatterBodies(h);
          var y = 0;
          if (!Array.isArray(m))
            y = m;
          else
            for (var d = 0;d < m.length; d++)
              y |= m[d];
          return h.forEach(function(p) {
            p.collisionFilter.mask = y;
          }), this;
        }, getMatterBodies: function(h) {
          if (!h)
            return this.world.getAllBodies();
          if (!Array.isArray(h))
            h = [h];
          var m = [];
          for (var y = 0;y < h.length; y++) {
            var d = h[y].hasOwnProperty("body") ? h[y].body : h[y];
            m.push(d);
          }
          return m;
        }, setVelocity: function(h, m, y) {
          h = this.getMatterBodies(h);
          var d = this._tempVec2;
          return d.x = m, d.y = y, h.forEach(function(p) {
            U.setVelocity(p, d);
          }), this;
        }, setVelocityX: function(h, m) {
          h = this.getMatterBodies(h);
          var y = this._tempVec2;
          return y.x = m, h.forEach(function(d) {
            y.y = d.velocity.y, U.setVelocity(d, y);
          }), this;
        }, setVelocityY: function(h, m) {
          h = this.getMatterBodies(h);
          var y = this._tempVec2;
          return y.y = m, h.forEach(function(d) {
            y.x = d.velocity.x, U.setVelocity(d, y);
          }), this;
        }, setAngularVelocity: function(h, m) {
          return h = this.getMatterBodies(h), h.forEach(function(y) {
            U.setAngularVelocity(y, m);
          }), this;
        }, applyForce: function(h, m) {
          h = this.getMatterBodies(h);
          var y = this._tempVec2;
          return h.forEach(function(d) {
            y.x = d.position.x, y.y = d.position.y, U.applyForce(d, y, m);
          }), this;
        }, applyForceFromPosition: function(h, m, y, d) {
          h = this.getMatterBodies(h);
          var p = this._tempVec2;
          return h.forEach(function(u) {
            if (d === undefined)
              d = u.angle;
            p.x = y * Math.cos(d), p.y = y * Math.sin(d), U.applyForce(u, m, p);
          }), this;
        }, applyForceFromAngle: function(h, m, y) {
          h = this.getMatterBodies(h);
          var d = this._tempVec2;
          return h.forEach(function(p) {
            if (y === undefined)
              y = p.angle;
            d.x = m * Math.cos(y), d.y = m * Math.sin(y), U.applyForce(p, { x: p.position.x, y: p.position.y }, d);
          }), this;
        }, getConstraintLength: function(h) {
          var m = h.pointA.x, y = h.pointA.y, d = h.pointB.x, p = h.pointB.y;
          if (h.bodyA)
            m += h.bodyA.position.x, y += h.bodyA.position.y;
          if (h.bodyB)
            d += h.bodyB.position.x, p += h.bodyB.position.y;
          return Y(m, y, d, p);
        }, alignBody: function(h, m, y, d) {
          h = h.hasOwnProperty("body") ? h.body : h;
          var p;
          switch (d) {
            case E.TOP_LEFT:
            case E.LEFT_TOP:
              p = this.bodyBounds.getTopLeft(h, m, y);
              break;
            case E.TOP_CENTER:
              p = this.bodyBounds.getTopCenter(h, m, y);
              break;
            case E.TOP_RIGHT:
            case E.RIGHT_TOP:
              p = this.bodyBounds.getTopRight(h, m, y);
              break;
            case E.LEFT_CENTER:
              p = this.bodyBounds.getLeftCenter(h, m, y);
              break;
            case E.CENTER:
              p = this.bodyBounds.getCenter(h, m, y);
              break;
            case E.RIGHT_CENTER:
              p = this.bodyBounds.getRightCenter(h, m, y);
              break;
            case E.LEFT_BOTTOM:
            case E.BOTTOM_LEFT:
              p = this.bodyBounds.getBottomLeft(h, m, y);
              break;
            case E.BOTTOM_CENTER:
              p = this.bodyBounds.getBottomCenter(h, m, y);
              break;
            case E.BOTTOM_RIGHT:
            case E.RIGHT_BOTTOM:
              p = this.bodyBounds.getBottomRight(h, m, y);
              break;
          }
          if (p)
            U.setPosition(h, p);
          return this;
        }, shutdown: function() {
          var h = this.systems.events;
          if (this.world)
            h.off(g.UPDATE, this.world.update, this.world), h.off(g.POST_UPDATE, this.world.postUpdate, this.world);
          if (h.off(g.SHUTDOWN, this.shutdown, this), this.add)
            this.add.destroy();
          if (this.world)
            this.world.destroy();
          this.add = null, this.world = null;
        }, destroy: function() {
          this.shutdown(), this.scene.sys.events.off(g.START, this.start, this), this.scene = null, this.systems = null;
        } });
        O.register("MatterPhysics", f, "matterPhysics"), M.exports = f;
      }, 34803: (M, B, $) => {
        var E = $(9674), L = $(83419), z = $(31884), U = $(95643), K = $(95540), J = $(72699), Z = $(68287), D = $(26099), Q = new L({ Extends: Z, Mixins: [z.Bounce, z.Collision, z.Force, z.Friction, z.Gravity, z.Mass, z.Sensor, z.SetBody, z.Sleep, z.Static, z.Transform, z.Velocity, J], initialize: function H(N, W, R, Y, I, P) {
          U.call(this, N.scene, "Sprite"), this._crop = this.resetCropObject(), this.anims = new E(this), this.setTexture(Y, I), this.setSizeToFrame(), this.setOrigin(), this.world = N, this._tempVec2 = new D(W, R);
          var X = K(P, "shape", null);
          if (X)
            this.setBody(X, P);
          else
            this.setRectangle(this.width, this.height, P);
          this.setPosition(W, R), this.initPipeline(), this.initPostPipeline(true);
        } });
        M.exports = Q;
      }, 73834: (M, B, $) => {
        var E = $(66280), L = $(22562), z = $(83419), U = $(31884), K = $(62644), J = $(50792), Z = $(95540), D = $(97022), Q = $(41598), H = new z({ Extends: J, Mixins: [U.Bounce, U.Collision, U.Friction, U.Gravity, U.Mass, U.Sensor, U.Sleep, U.Static], initialize: function N(W, R, Y) {
          if (J.call(this), this.tile = R, this.world = W, R.physics.matterBody)
            R.physics.matterBody.destroy();
          R.physics.matterBody = this;
          var I = Z(Y, "body", null), P = Z(Y, "addToWorld", true);
          if (!I) {
            var X = R.getCollisionGroup(), G = Z(X, "objects", []);
            if (G.length > 0)
              this.setFromTileCollision(Y);
            else
              this.setFromTileRectangle(Y);
          } else
            this.setBody(I, P);
          if (R.flipX || R.flipY) {
            var V = { x: R.getCenterX(), y: R.getCenterY() }, A = R.flipX ? -1 : 1, F = R.flipY ? -1 : 1;
            L.scale(I, A, F, V);
          }
        }, setFromTileRectangle: function(N) {
          if (N === undefined)
            N = {};
          if (!D(N, "isStatic"))
            N.isStatic = true;
          if (!D(N, "addToWorld"))
            N.addToWorld = true;
          var W = this.tile.getBounds(), R = W.x + W.width / 2, Y = W.y + W.height / 2, I = E.rectangle(R, Y, W.width, W.height, N);
          return this.setBody(I, N.addToWorld), this;
        }, setFromTileCollision: function(N) {
          if (N === undefined)
            N = {};
          if (!D(N, "isStatic"))
            N.isStatic = true;
          if (!D(N, "addToWorld"))
            N.addToWorld = true;
          var W = this.tile.tilemapLayer.scaleX, R = this.tile.tilemapLayer.scaleY, Y = this.tile.getLeft(), I = this.tile.getTop(), P = this.tile.getCollisionGroup(), X = Z(P, "objects", []), G = [];
          for (var V = 0;V < X.length; V++) {
            var A = X[V], F = Y + A.x * W, j = I + A.y * R, T = A.width * W, C = A.height * R, v = null;
            if (A.rectangle)
              v = E.rectangle(F + T / 2, j + C / 2, T, C, N);
            else if (A.ellipse)
              v = E.circle(F + T / 2, j + C / 2, T / 2, N);
            else if (A.polygon || A.polyline) {
              var O = A.polygon ? A.polygon : A.polyline, q = O.map(function(x) {
                return { x: x.x * W, y: x.y * R };
              }), w = Q.create(q), g = Q.centre(w);
              F += g.x, j += g.y, v = E.fromVertices(F, j, w, N);
            }
            if (v)
              G.push(v);
          }
          if (G.length === 1)
            this.setBody(G[0], N.addToWorld);
          else if (G.length > 1) {
            var b = K(N);
            b.parts = G, this.setBody(L.create(b), b.addToWorld);
          }
          return this;
        }, setBody: function(N, W) {
          if (W === undefined)
            W = true;
          if (this.body)
            this.removeBody();
          if (this.body = N, this.body.gameObject = this, W)
            this.world.add(this.body);
          return this;
        }, removeBody: function() {
          if (this.body)
            this.world.remove(this.body), this.body.gameObject = undefined, this.body = undefined;
          return this;
        }, destroy: function() {
          this.removeBody(), this.tile.physics.matterBody = undefined, this.removeAllListeners();
        } });
        M.exports = H;
      }, 19496: (M, B, $) => {
        var E = $(66280), L = $(22562), z = $(53402), U = $(95540), K = $(41598), J = { parseBody: function(Z, D, Q, H) {
          if (H === undefined)
            H = {};
          var N = U(Q, "fixtures", []), W = [];
          for (var R = 0;R < N.length; R++) {
            var Y = this.parseFixture(N[R]);
            for (var I = 0;I < Y.length; I++)
              W.push(Y[I]);
          }
          var P = z.clone(Q, true);
          z.extend(P, H, true), delete P.fixtures, delete P.type;
          var X = L.create(P);
          return L.setParts(X, W), L.setPosition(X, { x: Z, y: D }), X;
        }, parseFixture: function(Z) {
          var D = z.extend({}, false, Z);
          delete D.circle, delete D.vertices;
          var Q;
          if (Z.circle) {
            var H = U(Z.circle, "x"), N = U(Z.circle, "y"), W = U(Z.circle, "radius");
            Q = [E.circle(H, N, W, D)];
          } else if (Z.vertices)
            Q = this.parseVertices(Z.vertices, D);
          return Q;
        }, parseVertices: function(Z, D) {
          if (D === undefined)
            D = {};
          var Q = [];
          for (var H = 0;H < Z.length; H++)
            K.clockwiseSort(Z[H]), Q.push(L.create(z.extend({ position: K.centre(Z[H]), vertices: Z[H] }, D)));
          return E.flagCoincidentParts(Q);
        } };
        M.exports = J;
      }, 85791: (M, B, $) => {
        var E = $(66280), L = $(22562), z = { parseBody: function(U, K, J, Z) {
          if (Z === undefined)
            Z = {};
          var D, Q = J.vertices;
          if (Q.length === 1)
            Z.vertices = Q[0], D = L.create(Z), E.flagCoincidentParts(D.parts);
          else {
            var H = [];
            for (var N = 0;N < Q.length; N++) {
              var W = L.create({ vertices: Q[N] });
              H.push(W);
            }
            E.flagCoincidentParts(H), Z.parts = H, D = L.create(Z);
          }
          return D.label = J.label, L.setPosition(D, { x: U, y: K }), D;
        } };
        M.exports = z;
      }, 98713: (M, B, $) => {
        var E = $(15647), L = $(83419), z = $(69351), U = $(48140), K = $(81388), J = $(1121), Z = $(8214), D = $(46975), Q = $(53614), H = $(26099), N = $(41598), W = new L({ initialize: function R(Y, I, P) {
          if (P === undefined)
            P = {};
          var X = { label: "Pointer Constraint", pointA: { x: 0, y: 0 }, pointB: { x: 0, y: 0 }, length: 0.01, stiffness: 0.1, angularStiffness: 1, collisionFilter: { category: 1, mask: 4294967295, group: 0 } };
          this.scene = Y, this.world = I, this.camera = null, this.pointer = null, this.active = true, this.position = new H, this.body = null, this.part = null, this.constraint = U.create(D(P, X)), this.world.on(J.BEFORE_UPDATE, this.update, this), Y.sys.input.on(Z.POINTER_DOWN, this.onDown, this), Y.sys.input.on(Z.POINTER_UP, this.onUp, this);
        }, onDown: function(R) {
          if (!this.pointer)
            this.pointer = R, this.camera = R.camera;
        }, onUp: function(R) {
          if (R === this.pointer)
            this.pointer = null;
        }, getBody: function(R) {
          var Y = this.position, I = this.constraint;
          this.camera.getWorldPoint(R.x, R.y, Y);
          var P = z.allBodies(this.world.localWorld);
          for (var X = 0;X < P.length; X++) {
            var G = P[X];
            if (!G.ignorePointer && E.contains(G.bounds, Y) && K.canCollide(G.collisionFilter, I.collisionFilter)) {
              if (this.hitTestBody(G, Y))
                return this.world.emit(J.DRAG_START, G, this.part, this), true;
            }
          }
          return false;
        }, hitTestBody: function(R, Y) {
          var I = this.constraint, P = R.parts.length, X = P > 1 ? 1 : 0;
          for (var G = X;G < P; G++) {
            var V = R.parts[G];
            if (N.contains(V.vertices, Y))
              return I.pointA = Y, I.pointB = { x: Y.x - R.position.x, y: Y.y - R.position.y }, I.bodyB = R, I.angleB = R.angle, Q.set(R, false), this.part = V, this.body = R, true;
          }
          return false;
        }, update: function() {
          var R = this.pointer, Y = this.body;
          if (!this.active || !R) {
            if (Y)
              this.stopDrag();
            return;
          }
          if (!R.isDown && Y) {
            this.stopDrag();
            return;
          } else if (R.isDown) {
            if (!this.camera || !Y && !this.getBody(R))
              return;
            Y = this.body;
            var I = this.position, P = this.constraint;
            this.camera.getWorldPoint(R.x, R.y, I), P.pointA.x = I.x, P.pointA.y = I.y, Q.set(Y, false), this.world.emit(J.DRAG, Y, this);
          }
        }, stopDrag: function() {
          var R = this.body, Y = this.constraint;
          if (Y.bodyB = null, Y.pointB = null, this.pointer = null, this.body = null, this.part = null, R)
            this.world.emit(J.DRAG_END, R, this);
        }, destroy: function() {
          this.world.removeConstraint(this.constraint), this.pointer = null, this.constraint = null, this.body = null, this.part = null, this.world.off(J.BEFORE_UPDATE, this.update), this.scene.sys.input.off(Z.POINTER_DOWN, this.onDown, this), this.scene.sys.input.off(Z.POINTER_UP, this.onUp, this);
        } });
        M.exports = W;
      }, 68243: (M, B, $) => {
        var E = $(66280), L = $(22562), z = $(83419), U = $(53402), K = $(69351), J = $(48413), Z = $(50792), D = $(1121), Q = $(95540), H = $(35154), N = $(22562), W = $(35810), R = $(73834), Y = $(4372), I = $(31725), P = new z({ Extends: Z, initialize: function X(G, V) {
          Z.call(this), this.scene = G, this.engine = J.create(V), this.localWorld = this.engine.world;
          var A = H(V, "gravity", null);
          if (A)
            this.setGravity(A.x, A.y, A.scale);
          else if (A === false)
            this.setGravity(0, 0, 0);
          this.walls = { left: null, right: null, top: null, bottom: null }, this.enabled = H(V, "enabled", true), this.getDelta = H(V, "getDelta", this.update60Hz);
          var F = Q(V, "runner", {}), j = Q(F, "fps", false), T = Q(F, "fps", 60), C = Q(F, "delta", 1000 / T), v = Q(F, "deltaMin", 1000 / T), O = Q(F, "deltaMax", 1000 / (T * 0.5));
          if (!j)
            T = 1000 / C;
          this.runner = { fps: T, deltaSampleSize: Q(F, "deltaSampleSize", 60), counterTimestamp: 0, frameCounter: 0, deltaHistory: [], timePrev: null, timeScalePrev: 1, frameRequestId: null, isFixed: Q(F, "isFixed", false), delta: C, deltaMin: v, deltaMax: O }, this.autoUpdate = H(V, "autoUpdate", true);
          var q = H(V, "debug", false);
          if (this.drawDebug = typeof q === "object" ? true : q, this.debugGraphic, this.debugConfig = { showAxes: Q(q, "showAxes", false), showAngleIndicator: Q(q, "showAngleIndicator", false), angleColor: Q(q, "angleColor", 15208787), showBroadphase: Q(q, "showBroadphase", false), broadphaseColor: Q(q, "broadphaseColor", 16757760), showBounds: Q(q, "showBounds", false), boundsColor: Q(q, "boundsColor", 16777215), showVelocity: Q(q, "showVelocity", false), velocityColor: Q(q, "velocityColor", 44783), showCollisions: Q(q, "showCollisions", false), collisionColor: Q(q, "collisionColor", 16094476), showSeparations: Q(q, "showSeparations", false), separationColor: Q(q, "separationColor", 16753920), showBody: Q(q, "showBody", true), showStaticBody: Q(q, "showStaticBody", true), showInternalEdges: Q(q, "showInternalEdges", false), renderFill: Q(q, "renderFill", false), renderLine: Q(q, "renderLine", true), fillColor: Q(q, "fillColor", 1075465), fillOpacity: Q(q, "fillOpacity", 1), lineColor: Q(q, "lineColor", 2678297), lineOpacity: Q(q, "lineOpacity", 1), lineThickness: Q(q, "lineThickness", 1), staticFillColor: Q(q, "staticFillColor", 857979), staticLineColor: Q(q, "staticLineColor", 1255396), showSleeping: Q(q, "showSleeping", false), staticBodySleepOpacity: Q(q, "staticBodySleepOpacity", 0.7), sleepFillColor: Q(q, "sleepFillColor", 4605510), sleepLineColor: Q(q, "sleepLineColor", 10066585), showSensors: Q(q, "showSensors", true), sensorFillColor: Q(q, "sensorFillColor", 857979), sensorLineColor: Q(q, "sensorLineColor", 1255396), showPositions: Q(q, "showPositions", true), positionSize: Q(q, "positionSize", 4), positionColor: Q(q, "positionColor", 14697178), showJoint: Q(q, "showJoint", true), jointColor: Q(q, "jointColor", 14737474), jointLineOpacity: Q(q, "jointLineOpacity", 1), jointLineThickness: Q(q, "jointLineThickness", 2), pinSize: Q(q, "pinSize", 4), pinColor: Q(q, "pinColor", 4382944), springColor: Q(q, "springColor", 14697184), anchorColor: Q(q, "anchorColor", 15724527), anchorSize: Q(q, "anchorSize", 4), showConvexHulls: Q(q, "showConvexHulls", false), hullColor: Q(q, "hullColor", 14091216) }, this.drawDebug)
            this.createDebugGraphic();
          if (this.setEventsProxy(), Q(V, "setBounds", false)) {
            var w = V.setBounds;
            if (typeof w === "boolean")
              this.setBounds();
            else {
              var g = Q(w, "x", 0), b = Q(w, "y", 0), x = Q(w, "width", G.sys.scale.width), k = Q(w, "height", G.sys.scale.height), S = Q(w, "thickness", 64), f = Q(w, "left", true), h = Q(w, "right", true), m = Q(w, "top", true), y = Q(w, "bottom", true);
              this.setBounds(g, b, x, k, S, f, h, m, y);
            }
          }
        }, setCompositeRenderStyle: function(X) {
          var { bodies: G, constraints: V, composites: A } = X, F, j, T;
          for (F = 0;F < G.length; F++)
            j = G[F], T = j.render, this.setBodyRenderStyle(j, T.lineColor, T.lineOpacity, T.lineThickness, T.fillColor, T.fillOpacity);
          for (F = 0;F < V.length; F++)
            j = V[F], T = j.render, this.setConstraintRenderStyle(j, T.lineColor, T.lineOpacity, T.lineThickness, T.pinSize, T.anchorColor, T.anchorSize);
          for (F = 0;F < A.length; F++)
            j = A[F], this.setCompositeRenderStyle(j);
          return this;
        }, setBodyRenderStyle: function(X, G, V, A, F, j) {
          var T = X.render, C = this.debugConfig;
          if (!T)
            return this;
          if (G === undefined || G === null)
            G = X.isStatic ? C.staticLineColor : C.lineColor;
          if (V === undefined || V === null)
            V = C.lineOpacity;
          if (A === undefined || A === null)
            A = C.lineThickness;
          if (F === undefined || F === null)
            F = X.isStatic ? C.staticFillColor : C.fillColor;
          if (j === undefined || j === null)
            j = C.fillOpacity;
          if (G !== false)
            T.lineColor = G;
          if (V !== false)
            T.lineOpacity = V;
          if (A !== false)
            T.lineThickness = A;
          if (F !== false)
            T.fillColor = F;
          if (j !== false)
            T.fillOpacity = j;
          return this;
        }, setConstraintRenderStyle: function(X, G, V, A, F, j, T) {
          var C = X.render, v = this.debugConfig;
          if (!C)
            return this;
          if (G === undefined || G === null) {
            var O = C.type;
            if (O === "line")
              G = v.jointColor;
            else if (O === "pin")
              G = v.pinColor;
            else if (O === "spring")
              G = v.springColor;
          }
          if (V === undefined || V === null)
            V = v.jointLineOpacity;
          if (A === undefined || A === null)
            A = v.jointLineThickness;
          if (F === undefined || F === null)
            F = v.pinSize;
          if (j === undefined || j === null)
            j = v.anchorColor;
          if (T === undefined || T === null)
            T = v.anchorSize;
          if (G !== false)
            C.lineColor = G;
          if (V !== false)
            C.lineOpacity = V;
          if (A !== false)
            C.lineThickness = A;
          if (F !== false)
            C.pinSize = F;
          if (j !== false)
            C.anchorColor = j;
          if (T !== false)
            C.anchorSize = T;
          return this;
        }, setEventsProxy: function() {
          var X = this, G = this.engine, V = this.localWorld;
          if (this.drawDebug)
            W.on(V, "compositeModified", function(A) {
              X.setCompositeRenderStyle(A);
            }), W.on(V, "beforeAdd", function(A) {
              var F = [].concat(A.object);
              for (var j = 0;j < F.length; j++) {
                var T = F[j], C = T.render;
                if (T.type === "body")
                  X.setBodyRenderStyle(T, C.lineColor, C.lineOpacity, C.lineThickness, C.fillColor, C.fillOpacity);
                else if (T.type === "composite")
                  X.setCompositeRenderStyle(T);
                else if (T.type === "constraint")
                  X.setConstraintRenderStyle(T, C.lineColor, C.lineOpacity, C.lineThickness, C.pinSize, C.anchorColor, C.anchorSize);
              }
            });
          W.on(V, "beforeAdd", function(A) {
            X.emit(D.BEFORE_ADD, A);
          }), W.on(V, "afterAdd", function(A) {
            X.emit(D.AFTER_ADD, A);
          }), W.on(V, "beforeRemove", function(A) {
            X.emit(D.BEFORE_REMOVE, A);
          }), W.on(V, "afterRemove", function(A) {
            X.emit(D.AFTER_REMOVE, A);
          }), W.on(G, "beforeUpdate", function(A) {
            X.emit(D.BEFORE_UPDATE, A);
          }), W.on(G, "afterUpdate", function(A) {
            X.emit(D.AFTER_UPDATE, A);
          }), W.on(G, "collisionStart", function(A) {
            var F = A.pairs, j, T;
            if (F.length > 0)
              j = F[0].bodyA, T = F[0].bodyB;
            X.emit(D.COLLISION_START, A, j, T);
          }), W.on(G, "collisionActive", function(A) {
            var F = A.pairs, j, T;
            if (F.length > 0)
              j = F[0].bodyA, T = F[0].bodyB;
            X.emit(D.COLLISION_ACTIVE, A, j, T);
          }), W.on(G, "collisionEnd", function(A) {
            var F = A.pairs, j, T;
            if (F.length > 0)
              j = F[0].bodyA, T = F[0].bodyB;
            X.emit(D.COLLISION_END, A, j, T);
          });
        }, setBounds: function(X, G, V, A, F, j, T, C, v) {
          if (X === undefined)
            X = 0;
          if (G === undefined)
            G = 0;
          if (V === undefined)
            V = this.scene.sys.scale.width;
          if (A === undefined)
            A = this.scene.sys.scale.height;
          if (F === undefined)
            F = 64;
          if (j === undefined)
            j = true;
          if (T === undefined)
            T = true;
          if (C === undefined)
            C = true;
          if (v === undefined)
            v = true;
          return this.updateWall(j, "left", X - F, G - F, F, A + F * 2), this.updateWall(T, "right", X + V, G - F, F, A + F * 2), this.updateWall(C, "top", X, G - F, V, F), this.updateWall(v, "bottom", X, G + A, V, F), this;
        }, updateWall: function(X, G, V, A, F, j) {
          var T = this.walls[G];
          if (X) {
            if (T)
              Y.remove(this.localWorld, T);
            V += F / 2, A += j / 2, this.walls[G] = this.create(V, A, F, j, { isStatic: true, friction: 0, frictionStatic: 0 });
          } else {
            if (T)
              Y.remove(this.localWorld, T);
            this.walls[G] = null;
          }
        }, createDebugGraphic: function() {
          var X = this.scene.sys.add.graphics({ x: 0, y: 0 });
          return X.setDepth(Number.MAX_VALUE), this.debugGraphic = X, this.drawDebug = true, X;
        }, disableGravity: function() {
          return this.localWorld.gravity.x = 0, this.localWorld.gravity.y = 0, this.localWorld.gravity.scale = 0, this;
        }, setGravity: function(X, G, V) {
          if (X === undefined)
            X = 0;
          if (G === undefined)
            G = 1;
          if (V === undefined)
            V = 0.001;
          return this.localWorld.gravity.x = X, this.localWorld.gravity.y = G, this.localWorld.gravity.scale = V, this;
        }, create: function(X, G, V, A, F) {
          var j = E.rectangle(X, G, V, A, F);
          return Y.add(this.localWorld, j), j;
        }, add: function(X) {
          return Y.add(this.localWorld, X), this;
        }, remove: function(X, G) {
          if (!Array.isArray(X))
            X = [X];
          for (var V = 0;V < X.length; V++) {
            var A = X[V], F = A.body ? A.body : A;
            K.remove(this.localWorld, F, G);
          }
          return this;
        }, removeConstraint: function(X, G) {
          return K.remove(this.localWorld, X, G), this;
        }, convertTilemapLayer: function(X, G) {
          var V = X.layer, A = X.getTilesWithin(0, 0, V.width, V.height, { isColliding: true });
          return this.convertTiles(A, G), this;
        }, convertTiles: function(X, G) {
          if (X.length === 0)
            return this;
          for (var V = 0;V < X.length; V++)
            new R(this, X[V], G);
          return this;
        }, nextGroup: function(X) {
          return N.nextGroup(X);
        }, nextCategory: function() {
          return N.nextCategory();
        }, pause: function() {
          return this.enabled = false, this.emit(D.PAUSE), this;
        }, resume: function() {
          return this.enabled = true, this.emit(D.RESUME), this;
        }, update: function(X, G) {
          if (!this.enabled || !this.autoUpdate)
            return;
          var V = this.engine, A = this.runner, F = V.timing;
          if (A.isFixed)
            G = this.getDelta(X, G);
          else
            G = X - A.timePrev || A.delta, A.timePrev = X, A.deltaHistory.push(G), A.deltaHistory = A.deltaHistory.slice(-A.deltaSampleSize), G = Math.min.apply(null, A.deltaHistory), G = G < A.deltaMin ? A.deltaMin : G, G = G > A.deltaMax ? A.deltaMax : G, A.delta = G;
          if (A.timeScalePrev = F.timeScale, A.frameCounter += 1, X - A.counterTimestamp >= 1000)
            A.fps = A.frameCounter * ((X - A.counterTimestamp) / 1000), A.counterTimestamp = X, A.frameCounter = 0;
          J.update(V, G);
        }, step: function(X) {
          J.update(this.engine, X);
        }, update60Hz: function() {
          return 16.666666666666668;
        }, update30Hz: function() {
          return 33.333333333333336;
        }, has: function(X) {
          var G = X.hasOwnProperty("body") ? X.body : X;
          return K.get(this.localWorld, G.id, G.type) !== null;
        }, getAllBodies: function() {
          return K.allBodies(this.localWorld);
        }, getAllConstraints: function() {
          return K.allConstraints(this.localWorld);
        }, getAllComposites: function() {
          return K.allComposites(this.localWorld);
        }, postUpdate: function() {
          if (!this.drawDebug)
            return;
          var X = this.debugConfig, G = this.engine, V = this.debugGraphic, A = K.allBodies(this.localWorld);
          if (this.debugGraphic.clear(), X.showBroadphase && G.broadphase.controller)
            this.renderGrid(G.broadphase, V, X.broadphaseColor, 0.5);
          if (X.showBounds)
            this.renderBodyBounds(A, V, X.boundsColor, 0.5);
          if (X.showBody || X.showStaticBody)
            this.renderBodies(A);
          if (X.showJoint)
            this.renderJoints();
          if (X.showAxes || X.showAngleIndicator)
            this.renderBodyAxes(A, V, X.showAxes, X.angleColor, 0.5);
          if (X.showVelocity)
            this.renderBodyVelocity(A, V, X.velocityColor, 1, 2);
          if (X.showSeparations)
            this.renderSeparations(G.pairs.list, V, X.separationColor);
          if (X.showCollisions)
            this.renderCollisions(G.pairs.list, V, X.collisionColor);
        }, renderGrid: function(X, G, V, A) {
          G.lineStyle(1, V, A);
          var F = U.keys(X.buckets);
          for (var j = 0;j < F.length; j++) {
            var T = F[j];
            if (X.buckets[T].length < 2)
              continue;
            var C = T.split(/C|R/);
            G.strokeRect(parseInt(C[1], 10) * X.bucketWidth, parseInt(C[2], 10) * X.bucketHeight, X.bucketWidth, X.bucketHeight);
          }
          return this;
        }, renderSeparations: function(X, G, V) {
          G.lineStyle(1, V, 1);
          for (var A = 0;A < X.length; A++) {
            var F = X[A];
            if (!F.isActive)
              continue;
            var j = F.collision, T = j.bodyA, C = j.bodyB, v = T.position, O = C.position, q = j.penetration, w = !T.isStatic && !C.isStatic ? 4 : 1;
            if (C.isStatic)
              w = 0;
            if (G.lineBetween(O.x, O.y, O.x - q.x * w, O.y - q.y * w), w = !T.isStatic && !C.isStatic ? 4 : 1, T.isStatic)
              w = 0;
            G.lineBetween(v.x, v.y, v.x - q.x * w, v.y - q.y * w);
          }
          return this;
        }, renderCollisions: function(X, G, V) {
          G.lineStyle(1, V, 0.5), G.fillStyle(V, 1);
          var A, F;
          for (A = 0;A < X.length; A++) {
            if (F = X[A], !F.isActive)
              continue;
            for (var j = 0;j < F.activeContacts.length; j++) {
              var T = F.activeContacts[j], C = T.vertex;
              G.fillRect(C.x - 2, C.y - 2, 5, 5);
            }
          }
          for (A = 0;A < X.length; A++) {
            if (F = X[A], !F.isActive)
              continue;
            var { collision: v, activeContacts: O } = F;
            if (O.length > 0) {
              var q = O[0].vertex.x, w = O[0].vertex.y;
              if (O.length === 2)
                q = (O[0].vertex.x + O[1].vertex.x) / 2, w = (O[0].vertex.y + O[1].vertex.y) / 2;
              if (v.bodyB === v.supports[0].body || v.bodyA.isStatic)
                G.lineBetween(q - v.normal.x * 8, w - v.normal.y * 8, q, w);
              else
                G.lineBetween(q + v.normal.x * 8, w + v.normal.y * 8, q, w);
            }
          }
          return this;
        }, renderBodyBounds: function(X, G, V, A) {
          G.lineStyle(1, V, A);
          for (var F = 0;F < X.length; F++) {
            var j = X[F];
            if (!j.render.visible)
              continue;
            var T = j.bounds;
            if (T)
              G.strokeRect(T.min.x, T.min.y, T.max.x - T.min.x, T.max.y - T.min.y);
            else {
              var C = j.parts;
              for (var v = C.length > 1 ? 1 : 0;v < C.length; v++) {
                var O = C[v];
                G.strokeRect(O.bounds.min.x, O.bounds.min.y, O.bounds.max.x - O.bounds.min.x, O.bounds.max.y - O.bounds.min.y);
              }
            }
          }
          return this;
        }, renderBodyAxes: function(X, G, V, A, F) {
          G.lineStyle(1, A, F);
          for (var j = 0;j < X.length; j++) {
            var T = X[j], C = T.parts;
            if (!T.render.visible)
              continue;
            var v, O, q;
            if (V)
              for (O = C.length > 1 ? 1 : 0;O < C.length; O++) {
                v = C[O];
                for (q = 0;q < v.axes.length; q++) {
                  var w = v.axes[q];
                  G.lineBetween(v.position.x, v.position.y, v.position.x + w.x * 20, v.position.y + w.y * 20);
                }
              }
            else
              for (O = C.length > 1 ? 1 : 0;O < C.length; O++) {
                v = C[O];
                for (q = 0;q < v.axes.length; q++)
                  G.lineBetween(v.position.x, v.position.y, (v.vertices[0].x + v.vertices[v.vertices.length - 1].x) / 2, (v.vertices[0].y + v.vertices[v.vertices.length - 1].y) / 2);
              }
          }
          return this;
        }, renderBodyVelocity: function(X, G, V, A, F) {
          G.lineStyle(F, V, A);
          for (var j = 0;j < X.length; j++) {
            var T = X[j];
            if (!T.render.visible)
              continue;
            G.lineBetween(T.position.x, T.position.y, T.position.x + (T.position.x - T.positionPrev.x) * 2, T.position.y + (T.position.y - T.positionPrev.y) * 2);
          }
          return this;
        }, renderBodies: function(X) {
          var G = this.debugGraphic, V = this.debugConfig, A = V.showBody, F = V.showStaticBody, j = V.showSleeping, T = V.showInternalEdges, C = V.showConvexHulls, v = V.renderFill, O = V.renderLine, q = V.staticBodySleepOpacity, w = V.sleepFillColor, g = V.sleepLineColor, b = V.hullColor;
          for (var x = 0;x < X.length; x++) {
            var k = X[x];
            if (!k.render.visible)
              continue;
            if (!F && k.isStatic || !A && !k.isStatic)
              continue;
            var S = k.render.lineColor, f = k.render.lineOpacity, h = k.render.lineThickness, m = k.render.fillColor, y = k.render.fillOpacity;
            if (j && k.isSleeping)
              if (k.isStatic)
                f *= q, y *= q;
              else
                S = g, m = w;
            if (!v)
              m = null;
            if (!O)
              S = null;
            this.renderBody(k, G, T, S, f, h, m, y);
            var d = k.parts.length;
            if (C && d > 1)
              this.renderConvexHull(k, G, b, h);
          }
        }, renderBody: function(X, G, V, A, F, j, T, C) {
          if (A === undefined)
            A = null;
          if (F === undefined)
            F = null;
          if (j === undefined)
            j = 1;
          if (T === undefined)
            T = null;
          if (C === undefined)
            C = null;
          var v = this.debugConfig, O = v.sensorFillColor, q = v.sensorLineColor, w = X.parts, g = w.length;
          for (var b = g > 1 ? 1 : 0;b < g; b++) {
            var x = w[b], k = x.render, S = k.opacity;
            if (!k.visible || S === 0 || x.isSensor && !v.showSensors)
              continue;
            var f = x.circleRadius;
            if (G.beginPath(), x.isSensor) {
              if (T !== null)
                G.fillStyle(O, C * S);
              if (A !== null)
                G.lineStyle(j, q, F * S);
            } else {
              if (T !== null)
                G.fillStyle(T, C * S);
              if (A !== null)
                G.lineStyle(j, A, F * S);
            }
            if (f)
              G.arc(x.position.x, x.position.y, f, 0, 2 * Math.PI);
            else {
              var h = x.vertices, m = h.length;
              G.moveTo(h[0].x, h[0].y);
              for (var y = 1;y < m; y++) {
                var d = h[y];
                if (!h[y - 1].isInternal || V)
                  G.lineTo(d.x, d.y);
                else
                  G.moveTo(d.x, d.y);
                if (y < m && d.isInternal && !V) {
                  var p = (y + 1) % m;
                  G.moveTo(h[p].x, h[p].y);
                }
              }
              G.closePath();
            }
            if (T !== null)
              G.fillPath();
            if (A !== null)
              G.strokePath();
          }
          if (v.showPositions && !X.isStatic) {
            var u = X.position.x, s = X.position.y, c = Math.ceil(v.positionSize / 2);
            G.fillStyle(v.positionColor, 1), G.fillRect(u - c, s - c, v.positionSize, v.positionSize);
          }
          return this;
        }, renderConvexHull: function(X, G, V, A) {
          if (A === undefined)
            A = 1;
          var F = X.parts, j = F.length;
          if (j > 1) {
            var T = X.vertices;
            G.lineStyle(A, V), G.beginPath(), G.moveTo(T[0].x, T[0].y);
            for (var C = 1;C < T.length; C++)
              G.lineTo(T[C].x, T[C].y);
            G.lineTo(T[0].x, T[0].y), G.strokePath();
          }
          return this;
        }, renderJoints: function() {
          var X = this.debugGraphic, G = K.allConstraints(this.localWorld);
          for (var V = 0;V < G.length; V++) {
            var A = G[V].render, F = A.lineColor, j = A.lineOpacity, T = A.lineThickness, C = A.pinSize, v = A.anchorColor, O = A.anchorSize;
            this.renderConstraint(G[V], X, F, j, T, C, v, O);
          }
        }, renderConstraint: function(X, G, V, A, F, j, T, C) {
          var v = X.render;
          if (!v.visible || !X.pointA || !X.pointB)
            return this;
          G.lineStyle(F, V, A);
          var { bodyA: O, bodyB: q } = X, w, g;
          if (O)
            w = I.add(O.position, X.pointA);
          else
            w = X.pointA;
          if (v.type === "pin")
            G.strokeCircle(w.x, w.y, j);
          else {
            if (q)
              g = I.add(q.position, X.pointB);
            else
              g = X.pointB;
            if (G.beginPath(), G.moveTo(w.x, w.y), v.type === "spring") {
              var b = I.sub(g, w), x = I.perp(I.normalise(b)), k = Math.ceil(U.clamp(X.length / 5, 12, 20)), S;
              for (var f = 1;f < k; f += 1)
                S = f % 2 === 0 ? 1 : -1, G.lineTo(w.x + b.x * (f / k) + x.x * S * 4, w.y + b.y * (f / k) + x.y * S * 4);
            }
            G.lineTo(g.x, g.y);
          }
          if (G.strokePath(), v.anchors && C > 0)
            G.fillStyle(T), G.fillCircle(w.x, w.y, C), G.fillCircle(g.x, g.y, C);
          return this;
        }, resetCollisionIDs: function() {
          return L._nextCollidingGroupId = 1, L._nextNonCollidingGroupId = -1, L._nextCategory = 1, this;
        }, shutdown: function() {
          if (W.off(this.engine), this.removeAllListeners(), Y.clear(this.localWorld, false), J.clear(this.engine), this.drawDebug)
            this.debugGraphic.destroy();
        }, destroy: function() {
          this.shutdown();
        } });
        M.exports = P;
      }, 70410: (M) => {
        var B = { setBounce: function($) {
          return this.body.restitution = $, this;
        } };
        M.exports = B;
      }, 66968: (M) => {
        var B = { setCollisionCategory: function($) {
          return this.body.collisionFilter.category = $, this;
        }, setCollisionGroup: function($) {
          return this.body.collisionFilter.group = $, this;
        }, setCollidesWith: function($) {
          var E = 0;
          if (!Array.isArray($))
            E = $;
          else
            for (var L = 0;L < $.length; L++)
              E |= $[L];
          return this.body.collisionFilter.mask = E, this;
        }, setOnCollide: function($) {
          return this.body.onCollideCallback = $, this;
        }, setOnCollideEnd: function($) {
          return this.body.onCollideEndCallback = $, this;
        }, setOnCollideActive: function($) {
          return this.body.onCollideActiveCallback = $, this;
        }, setOnCollideWith: function($, E) {
          if (!Array.isArray($))
            $ = [$];
          for (var L = 0;L < $.length; L++) {
            var z = $[L].hasOwnProperty("body") ? $[L].body : $[L];
            this.body.setOnCollideWith(z, E);
          }
          return this;
        } };
        M.exports = B;
      }, 51607: (M, B, $) => {
        var E = $(22562), L = { applyForce: function(z) {
          return this._tempVec2.set(this.body.position.x, this.body.position.y), E.applyForce(this.body, this._tempVec2, z), this;
        }, applyForceFrom: function(z, U) {
          return E.applyForce(this.body, z, U), this;
        }, thrust: function(z) {
          var U = this.body.angle;
          return this._tempVec2.set(z * Math.cos(U), z * Math.sin(U)), E.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this;
        }, thrustLeft: function(z) {
          var U = this.body.angle - Math.PI / 2;
          return this._tempVec2.set(z * Math.cos(U), z * Math.sin(U)), E.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this;
        }, thrustRight: function(z) {
          var U = this.body.angle + Math.PI / 2;
          return this._tempVec2.set(z * Math.cos(U), z * Math.sin(U)), E.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this;
        }, thrustBack: function(z) {
          var U = this.body.angle - Math.PI;
          return this._tempVec2.set(z * Math.cos(U), z * Math.sin(U)), E.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this;
        } };
        M.exports = L;
      }, 5436: (M) => {
        var B = { setFriction: function($, E, L) {
          if (this.body.friction = $, E !== undefined)
            this.body.frictionAir = E;
          if (L !== undefined)
            this.body.frictionStatic = L;
          return this;
        }, setFrictionAir: function($) {
          return this.body.frictionAir = $, this;
        }, setFrictionStatic: function($) {
          return this.body.frictionStatic = $, this;
        } };
        M.exports = B;
      }, 39858: (M) => {
        var B = { setIgnoreGravity: function($) {
          return this.body.ignoreGravity = $, this;
        } };
        M.exports = B;
      }, 37302: (M, B, $) => {
        var E = $(22562), L = $(26099), z = { setMass: function(U) {
          return E.setMass(this.body, U), this;
        }, setDensity: function(U) {
          return E.setDensity(this.body, U), this;
        }, centerOfMass: { get: function() {
          return new L(this.body.centerOfMass.x, this.body.centerOfMass.y);
        } } };
        M.exports = z;
      }, 39132: (M) => {
        var B = { setSensor: function($) {
          return this.body.isSensor = $, this;
        }, isSensor: function() {
          return this.body.isSensor;
        } };
        M.exports = B;
      }, 57772: (M, B, $) => {
        var E = $(66280), L = $(22562), z = $(43855), U = $(95540), K = $(19496), J = $(85791), Z = $(41598), D = { setRectangle: function(Q, H, N) {
          return this.setBody({ type: "rectangle", width: Q, height: H }, N);
        }, setCircle: function(Q, H) {
          return this.setBody({ type: "circle", radius: Q }, H);
        }, setPolygon: function(Q, H, N) {
          return this.setBody({ type: "polygon", sides: H, radius: Q }, N);
        }, setTrapezoid: function(Q, H, N, W) {
          return this.setBody({ type: "trapezoid", width: Q, height: H, slope: N }, W);
        }, setExistingBody: function(Q, H) {
          if (H === undefined)
            H = true;
          if (this.body)
            this.world.remove(this.body, true);
          this.body = Q;
          for (var N = 0;N < Q.parts.length; N++)
            Q.parts[N].gameObject = this;
          var W = this;
          if (Q.destroy = function V() {
            W.world.remove(W.body, true), W.body.gameObject = null;
          }, H) {
            if (this.world.has(Q))
              this.world.remove(Q, true);
            this.world.add(Q);
          }
          if (this._originComponent) {
            var R = Q.render.sprite.xOffset, Y = Q.render.sprite.yOffset, I = Q.centerOfMass.x, P = Q.centerOfMass.y;
            if (z(I, 0.5) && z(P, 0.5))
              this.setOrigin(R + 0.5, Y + 0.5);
            else {
              var X = Q.centerOffset.x, G = Q.centerOffset.y;
              this.setOrigin(R + X / this.displayWidth, Y + G / this.displayHeight);
            }
          }
          return this;
        }, setBody: function(Q, H) {
          if (!Q)
            return this;
          var N;
          if (typeof Q === "string")
            Q = { type: Q };
          var W = U(Q, "type", "rectangle"), R = U(Q, "x", this._tempVec2.x), Y = U(Q, "y", this._tempVec2.y), I = U(Q, "width", this.width), P = U(Q, "height", this.height);
          switch (W) {
            case "rectangle":
              N = E.rectangle(R, Y, I, P, H);
              break;
            case "circle":
              var X = U(Q, "radius", Math.max(I, P) / 2), G = U(Q, "maxSides", 25);
              N = E.circle(R, Y, X, H, G);
              break;
            case "trapezoid":
              var V = U(Q, "slope", 0.5);
              N = E.trapezoid(R, Y, I, P, V, H);
              break;
            case "polygon":
              var A = U(Q, "sides", 5), F = U(Q, "radius", Math.max(I, P) / 2);
              N = E.polygon(R, Y, A, F, H);
              break;
            case "fromVertices":
            case "fromVerts":
              var j = U(Q, "verts", null);
              if (j) {
                if (typeof j === "string")
                  j = Z.fromPath(j);
                if (this.body && !this.body.hasOwnProperty("temp"))
                  L.setVertices(this.body, j), N = this.body;
                else {
                  var T = U(Q, "flagInternal", false), C = U(Q, "removeCollinear", 0.01), v = U(Q, "minimumArea", 10);
                  N = E.fromVertices(R, Y, j, H, T, C, v);
                }
              }
              break;
            case "fromPhysicsEditor":
              N = K.parseBody(R, Y, Q, H);
              break;
            case "fromPhysicsTracer":
              N = J.parseBody(R, Y, Q, H);
              break;
          }
          if (N)
            this.setExistingBody(N, Q.addToWorld);
          return this;
        } };
        M.exports = D;
      }, 38083: (M, B, $) => {
        var E = $(1121), L = $(53614), z = $(35810), U = { setToSleep: function() {
          return L.set(this.body, true), this;
        }, setAwake: function() {
          return L.set(this.body, false), this;
        }, setSleepThreshold: function(K) {
          if (K === undefined)
            K = 60;
          return this.body.sleepThreshold = K, this;
        }, setSleepEvents: function(K, J) {
          return this.setSleepStartEvent(K), this.setSleepEndEvent(J), this;
        }, setSleepStartEvent: function(K) {
          if (K) {
            var J = this.world;
            z.on(this.body, "sleepStart", function(Z) {
              J.emit(E.SLEEP_START, Z, this);
            });
          } else
            z.off(this.body, "sleepStart");
          return this;
        }, setSleepEndEvent: function(K) {
          if (K) {
            var J = this.world;
            z.on(this.body, "sleepEnd", function(Z) {
              J.emit(E.SLEEP_END, Z, this);
            });
          } else
            z.off(this.body, "sleepEnd");
          return this;
        } };
        M.exports = U;
      }, 90556: (M, B, $) => {
        var E = $(22562), L = { setStatic: function(z) {
          return E.setStatic(this.body, z), this;
        }, isStatic: function() {
          return this.body.isStatic;
        } };
        M.exports = L;
      }, 85436: (M, B, $) => {
        var E = $(22562), L = $(36383), z = $(86554), U = $(30954), K = 4, J = { x: { get: function() {
          return this.body.position.x;
        }, set: function(Z) {
          this._tempVec2.set(Z, this.y), E.setPosition(this.body, this._tempVec2);
        } }, y: { get: function() {
          return this.body.position.y;
        }, set: function(Z) {
          this._tempVec2.set(this.x, Z), E.setPosition(this.body, this._tempVec2);
        } }, scaleX: { get: function() {
          return this._scaleX;
        }, set: function(Z) {
          var D = 1 / this._scaleX, Q = 1 / this._scaleY;
          if (this._scaleX = Z, this._scaleX === 0)
            this.renderFlags &= ~K;
          else
            this.renderFlags |= K;
          E.scale(this.body, D, Q), E.scale(this.body, Z, this._scaleY);
        } }, scaleY: { get: function() {
          return this._scaleY;
        }, set: function(Z) {
          var D = 1 / this._scaleX, Q = 1 / this._scaleY;
          if (this._scaleY = Z, this._scaleY === 0)
            this.renderFlags &= ~K;
          else
            this.renderFlags |= K;
          E.scale(this.body, D, Q), E.scale(this.body, this._scaleX, Z);
        } }, angle: { get: function() {
          return U(this.body.angle * L.RAD_TO_DEG);
        }, set: function(Z) {
          this.rotation = U(Z) * L.DEG_TO_RAD;
        } }, rotation: { get: function() {
          return this.body.angle;
        }, set: function(Z) {
          this._rotation = z(Z), E.setAngle(this.body, this._rotation);
        } }, setPosition: function(Z, D) {
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = Z;
          return this._tempVec2.set(Z, D), E.setPosition(this.body, this._tempVec2), this;
        }, setRotation: function(Z) {
          if (Z === undefined)
            Z = 0;
          return this._rotation = z(Z), E.setAngle(this.body, Z), this;
        }, setFixedRotation: function() {
          return E.setInertia(this.body, Infinity), this;
        }, setAngle: function(Z) {
          if (Z === undefined)
            Z = 0;
          return this.angle = Z, E.setAngle(this.body, this.rotation), this;
        }, setScale: function(Z, D, Q) {
          if (Z === undefined)
            Z = 1;
          if (D === undefined)
            D = Z;
          var H = 1 / this._scaleX, N = 1 / this._scaleY;
          return this._scaleX = Z, this._scaleY = D, E.scale(this.body, H, N, Q), E.scale(this.body, Z, D, Q), this;
        } };
        M.exports = J;
      }, 42081: (M, B, $) => {
        var E = $(22562), L = { setVelocityX: function(z) {
          return this._tempVec2.set(z, this.body.velocity.y), E.setVelocity(this.body, this._tempVec2), this;
        }, setVelocityY: function(z) {
          return this._tempVec2.set(this.body.velocity.x, z), E.setVelocity(this.body, this._tempVec2), this;
        }, setVelocity: function(z, U) {
          return this._tempVec2.set(z, U), E.setVelocity(this.body, this._tempVec2), this;
        }, getVelocity: function() {
          return E.getVelocity(this.body);
        }, setAngularVelocity: function(z) {
          return E.setAngularVelocity(this.body, z), this;
        }, getAngularVelocity: function() {
          return E.getAngularVelocity(this.body);
        }, setAngularSpeed: function(z) {
          return E.setAngularSpeed(this.body, z), this;
        }, getAngularSpeed: function() {
          return E.getAngularSpeed(this.body);
        } };
        M.exports = L;
      }, 31884: (M, B, $) => {
        M.exports = { Bounce: $(70410), Collision: $(66968), Force: $(51607), Friction: $(5436), Gravity: $(39858), Mass: $(37302), Sensor: $(39132), SetBody: $(57772), Sleep: $(38083), Static: $(90556), Transform: $(85436), Velocity: $(42081) };
      }, 85608: (M) => {
        M.exports = "afteradd";
      }, 1213: (M) => {
        M.exports = "afterremove";
      }, 25968: (M) => {
        M.exports = "afterupdate";
      }, 67205: (M) => {
        M.exports = "beforeadd";
      }, 39438: (M) => {
        M.exports = "beforeremove";
      }, 44823: (M) => {
        M.exports = "beforeupdate";
      }, 92593: (M) => {
        M.exports = "collisionactive";
      }, 60128: (M) => {
        M.exports = "collisionend";
      }, 76861: (M) => {
        M.exports = "collisionstart";
      }, 92362: (M) => {
        M.exports = "dragend";
      }, 76408: (M) => {
        M.exports = "drag";
      }, 93971: (M) => {
        M.exports = "dragstart";
      }, 5656: (M) => {
        M.exports = "pause";
      }, 47861: (M) => {
        M.exports = "resume";
      }, 79099: (M) => {
        M.exports = "sleepend";
      }, 35906: (M) => {
        M.exports = "sleepstart";
      }, 1121: (M, B, $) => {
        M.exports = { AFTER_ADD: $(85608), AFTER_REMOVE: $(1213), AFTER_UPDATE: $(25968), BEFORE_ADD: $(67205), BEFORE_REMOVE: $(39438), BEFORE_UPDATE: $(44823), COLLISION_ACTIVE: $(92593), COLLISION_END: $(60128), COLLISION_START: $(76861), DRAG_END: $(92362), DRAG: $(76408), DRAG_START: $(93971), PAUSE: $(5656), RESUME: $(47861), SLEEP_END: $(79099), SLEEP_START: $(35906) };
      }, 3875: (M, B, $) => {
        M.exports = { BodyBounds: $(68174), Components: $(31884), Events: $(1121), Factory: $(28137), MatterGameObject: $(75803), Image: $(23181), Matter: $(19933), MatterPhysics: $(42045), PolyDecomp: $(55973), Sprite: $(34803), TileBody: $(73834), PhysicsEditorParser: $(19496), PhysicsJSONParser: $(85791), PointerConstraint: $(98713), World: $(68243) };
      }, 22562: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(41598), z = $(31725), U = $(53614), K = $(53402), J = $(15647), Z = $(66615);
        (function() {
          E._timeCorrection = true, E._inertiaScale = 4, E._nextCollidingGroupId = 1, E._nextNonCollidingGroupId = -1, E._nextCategory = 1, E._baseDelta = 16.666666666666668, E.create = function(Q) {
            var H = { id: K.nextId(), type: "body", label: "Body", parts: [], plugin: {}, angle: 0, vertices: null, position: { x: 0, y: 0 }, force: { x: 0, y: 0 }, torque: 0, positionImpulse: { x: 0, y: 0 }, constraintImpulse: { x: 0, y: 0, angle: 0 }, totalContacts: 0, speed: 0, angularSpeed: 0, velocity: { x: 0, y: 0 }, angularVelocity: 0, isSensor: false, isStatic: false, isSleeping: false, motion: 0, sleepThreshold: 60, density: 0.001, restitution: 0, friction: 0.1, frictionStatic: 0.5, frictionAir: 0.01, collisionFilter: { category: 1, mask: 4294967295, group: 0 }, slop: 0.05, timeScale: 1, events: null, bounds: null, chamfer: null, circleRadius: 0, positionPrev: null, anglePrev: 0, parent: null, axes: null, area: 0, mass: 0, inverseMass: 0, inertia: 0, deltaTime: 16.666666666666668, inverseInertia: 0, _original: null, render: { visible: true, opacity: 1, sprite: { xOffset: 0, yOffset: 0 }, fillColor: null, fillOpacity: null, lineColor: null, lineOpacity: null, lineThickness: null }, gameObject: null, scale: { x: 1, y: 1 }, centerOfMass: { x: 0, y: 0 }, centerOffset: { x: 0, y: 0 }, gravityScale: { x: 1, y: 1 }, ignoreGravity: false, ignorePointer: false, onCollideCallback: null, onCollideEndCallback: null, onCollideActiveCallback: null, onCollideWith: {} };
            if (!Q.hasOwnProperty("position") && Q.hasOwnProperty("vertices"))
              Q.position = L.centre(Q.vertices);
            else if (!Q.hasOwnProperty("vertices"))
              H.vertices = L.fromPath("L 0 0 L 40 0 L 40 40 L 0 40");
            var N = K.extend(H, Q);
            return D(N, Q), N.setOnCollideWith = function(W, R) {
              if (R)
                this.onCollideWith[W.id] = R;
              else
                delete this.onCollideWith[W.id];
              return this;
            }, N;
          }, E.nextGroup = function(Q) {
            if (Q)
              return E._nextNonCollidingGroupId--;
            return E._nextCollidingGroupId++;
          }, E.nextCategory = function() {
            return E._nextCategory = E._nextCategory << 1, E._nextCategory;
          };
          var D = function(Q, H) {
            if (H = H || {}, E.set(Q, { bounds: Q.bounds || J.create(Q.vertices), positionPrev: Q.positionPrev || z.clone(Q.position), anglePrev: Q.anglePrev || Q.angle, vertices: Q.vertices, parts: Q.parts || [Q], isStatic: Q.isStatic, isSleeping: Q.isSleeping, parent: Q.parent || Q }), L.rotate(Q.vertices, Q.angle, Q.position), Z.rotate(Q.axes, Q.angle), J.update(Q.bounds, Q.vertices, Q.velocity), E.set(Q, { axes: H.axes || Q.axes, area: H.area || Q.area, mass: H.mass || Q.mass, inertia: H.inertia || Q.inertia }), Q.parts.length === 1) {
              var { bounds: N, centerOfMass: W, centerOffset: R } = Q, Y = N.max.x - N.min.x, I = N.max.y - N.min.y;
              W.x = -(N.min.x - Q.position.x) / Y, W.y = -(N.min.y - Q.position.y) / I, R.x = Y * W.x, R.y = I * W.y;
            }
          };
          E.set = function(Q, H, N) {
            var W;
            if (typeof H === "string")
              W = H, H = {}, H[W] = N;
            for (W in H) {
              if (!Object.prototype.hasOwnProperty.call(H, W))
                continue;
              switch (N = H[W], W) {
                case "isStatic":
                  E.setStatic(Q, N);
                  break;
                case "isSleeping":
                  U.set(Q, N);
                  break;
                case "mass":
                  E.setMass(Q, N);
                  break;
                case "density":
                  E.setDensity(Q, N);
                  break;
                case "inertia":
                  E.setInertia(Q, N);
                  break;
                case "vertices":
                  E.setVertices(Q, N);
                  break;
                case "position":
                  E.setPosition(Q, N);
                  break;
                case "angle":
                  E.setAngle(Q, N);
                  break;
                case "velocity":
                  E.setVelocity(Q, N);
                  break;
                case "angularVelocity":
                  E.setAngularVelocity(Q, N);
                  break;
                case "speed":
                  E.setSpeed(Q, N);
                  break;
                case "angularSpeed":
                  E.setAngularSpeed(Q, N);
                  break;
                case "parts":
                  E.setParts(Q, N);
                  break;
                case "centre":
                  E.setCentre(Q, N);
                  break;
                default:
                  Q[W] = N;
              }
            }
          }, E.setStatic = function(Q, H) {
            for (var N = 0;N < Q.parts.length; N++) {
              var W = Q.parts[N];
              if (H) {
                if (!W.isStatic)
                  W._original = { restitution: W.restitution, friction: W.friction, mass: W.mass, inertia: W.inertia, density: W.density, inverseMass: W.inverseMass, inverseInertia: W.inverseInertia };
                W.restitution = 0, W.friction = 1, W.mass = W.inertia = W.density = Infinity, W.inverseMass = W.inverseInertia = 0, W.positionPrev.x = W.position.x, W.positionPrev.y = W.position.y, W.anglePrev = W.angle, W.angularVelocity = 0, W.speed = 0, W.angularSpeed = 0, W.motion = 0;
              } else if (W._original)
                W.restitution = W._original.restitution, W.friction = W._original.friction, W.mass = W._original.mass, W.inertia = W._original.inertia, W.density = W._original.density, W.inverseMass = W._original.inverseMass, W.inverseInertia = W._original.inverseInertia, W._original = null;
              W.isStatic = H;
            }
          }, E.setMass = function(Q, H) {
            var N = Q.inertia / (Q.mass / 6);
            Q.inertia = N * (H / 6), Q.inverseInertia = 1 / Q.inertia, Q.mass = H, Q.inverseMass = 1 / Q.mass, Q.density = Q.mass / Q.area;
          }, E.setDensity = function(Q, H) {
            E.setMass(Q, H * Q.area), Q.density = H;
          }, E.setInertia = function(Q, H) {
            Q.inertia = H, Q.inverseInertia = 1 / Q.inertia;
          }, E.setVertices = function(Q, H) {
            if (H[0].body === Q)
              Q.vertices = H;
            else
              Q.vertices = L.create(H, Q);
            Q.axes = Z.fromVertices(Q.vertices), Q.area = L.area(Q.vertices), E.setMass(Q, Q.density * Q.area);
            var N = L.centre(Q.vertices);
            L.translate(Q.vertices, N, -1), E.setInertia(Q, E._inertiaScale * L.inertia(Q.vertices, Q.mass)), L.translate(Q.vertices, Q.position), J.update(Q.bounds, Q.vertices, Q.velocity);
          }, E.setParts = function(Q, H, N) {
            var W;
            H = H.slice(0), Q.parts.length = 0, Q.parts.push(Q), Q.parent = Q;
            for (W = 0;W < H.length; W++) {
              var R = H[W];
              if (R !== Q)
                R.parent = Q, Q.parts.push(R);
            }
            if (Q.parts.length === 1)
              return;
            if (N = typeof N !== "undefined" ? N : true, N) {
              var Y = [];
              for (W = 0;W < H.length; W++)
                Y = Y.concat(H[W].vertices);
              L.clockwiseSort(Y);
              var I = L.hull(Y), P = L.centre(I);
              E.setVertices(Q, I), L.translate(Q.vertices, P);
            }
            var X = E._totalProperties(Q), G = X.centre.x, V = X.centre.y, A = Q.bounds, F = Q.centerOfMass, j = Q.centerOffset;
            J.update(A, Q.vertices, Q.velocity), F.x = -(A.min.x - G) / (A.max.x - A.min.x), F.y = -(A.min.y - V) / (A.max.y - A.min.y), j.x = G, j.y = V, Q.area = X.area, Q.parent = Q, Q.position.x = G, Q.position.y = V, Q.positionPrev.x = G, Q.positionPrev.y = V, E.setMass(Q, X.mass), E.setInertia(Q, X.inertia), E.setPosition(Q, X.centre);
          }, E.setCentre = function(Q, H, N) {
            if (!N)
              Q.positionPrev.x = H.x - (Q.position.x - Q.positionPrev.x), Q.positionPrev.y = H.y - (Q.position.y - Q.positionPrev.y), Q.position.x = H.x, Q.position.y = H.y;
            else
              Q.positionPrev.x += H.x, Q.positionPrev.y += H.y, Q.position.x += H.x, Q.position.y += H.y;
          }, E.setPosition = function(Q, H, N) {
            var W = z.sub(H, Q.position);
            if (N)
              Q.positionPrev.x = Q.position.x, Q.positionPrev.y = Q.position.y, Q.velocity.x = W.x, Q.velocity.y = W.y, Q.speed = z.magnitude(W);
            else
              Q.positionPrev.x += W.x, Q.positionPrev.y += W.y;
            for (var R = 0;R < Q.parts.length; R++) {
              var Y = Q.parts[R];
              Y.position.x += W.x, Y.position.y += W.y, L.translate(Y.vertices, W), J.update(Y.bounds, Y.vertices, Q.velocity);
            }
          }, E.setAngle = function(Q, H, N) {
            var W = H - Q.angle;
            if (N)
              Q.anglePrev = Q.angle, Q.angularVelocity = W, Q.angularSpeed = Math.abs(W);
            else
              Q.anglePrev += W;
            for (var R = 0;R < Q.parts.length; R++) {
              var Y = Q.parts[R];
              if (Y.angle += W, L.rotate(Y.vertices, W, Q.position), Z.rotate(Y.axes, W), J.update(Y.bounds, Y.vertices, Q.velocity), R > 0)
                z.rotateAbout(Y.position, W, Q.position, Y.position);
            }
          }, E.setVelocity = function(Q, H) {
            var N = Q.deltaTime / E._baseDelta;
            Q.positionPrev.x = Q.position.x - H.x * N, Q.positionPrev.y = Q.position.y - H.y * N, Q.velocity.x = (Q.position.x - Q.positionPrev.x) / N, Q.velocity.y = (Q.position.y - Q.positionPrev.y) / N, Q.speed = z.magnitude(Q.velocity);
          }, E.getVelocity = function(Q) {
            var H = E._baseDelta / Q.deltaTime;
            return { x: (Q.position.x - Q.positionPrev.x) * H, y: (Q.position.y - Q.positionPrev.y) * H };
          }, E.getSpeed = function(Q) {
            return z.magnitude(E.getVelocity(Q));
          }, E.setSpeed = function(Q, H) {
            E.setVelocity(Q, z.mult(z.normalise(E.getVelocity(Q)), H));
          }, E.setAngularVelocity = function(Q, H) {
            var N = Q.deltaTime / E._baseDelta;
            Q.anglePrev = Q.angle - H * N, Q.angularVelocity = (Q.angle - Q.anglePrev) / N, Q.angularSpeed = Math.abs(Q.angularVelocity);
          }, E.getAngularVelocity = function(Q) {
            return (Q.angle - Q.anglePrev) * E._baseDelta / Q.deltaTime;
          }, E.getAngularSpeed = function(Q) {
            return Math.abs(E.getAngularVelocity(Q));
          }, E.setAngularSpeed = function(Q, H) {
            E.setAngularVelocity(Q, K.sign(E.getAngularVelocity(Q)) * H);
          }, E.translate = function(Q, H, N) {
            E.setPosition(Q, z.add(Q.position, H), N);
          }, E.rotate = function(Q, H, N, W) {
            if (!N)
              E.setAngle(Q, Q.angle + H, W);
            else {
              var R = Math.cos(H), Y = Math.sin(H), I = Q.position.x - N.x, P = Q.position.y - N.y;
              E.setPosition(Q, { x: N.x + (I * R - P * Y), y: N.y + (I * Y + P * R) }, W), E.setAngle(Q, Q.angle + H, W);
            }
          }, E.scale = function(Q, H, N, W) {
            var R = 0, Y = 0;
            W = W || Q.position;
            var I = Q.inertia === Infinity ? true : false;
            for (var P = 0;P < Q.parts.length; P++) {
              var X = Q.parts[P];
              if (X.scale.x = H, X.scale.y = N, L.scale(X.vertices, H, N, W), X.axes = Z.fromVertices(X.vertices), X.area = L.area(X.vertices), E.setMass(X, Q.density * X.area), L.translate(X.vertices, { x: -X.position.x, y: -X.position.y }), E.setInertia(X, E._inertiaScale * L.inertia(X.vertices, X.mass)), L.translate(X.vertices, { x: X.position.x, y: X.position.y }), P > 0)
                R += X.area, Y += X.inertia;
              X.position.x = W.x + (X.position.x - W.x) * H, X.position.y = W.y + (X.position.y - W.y) * N, J.update(X.bounds, X.vertices, Q.velocity);
            }
            if (Q.parts.length > 1) {
              if (Q.area = R, !Q.isStatic)
                E.setMass(Q, Q.density * R), E.setInertia(Q, Y);
            }
            if (Q.circleRadius)
              if (H === N)
                Q.circleRadius *= H;
              else
                Q.circleRadius = null;
            if (I)
              E.setInertia(Q, Infinity);
          }, E.update = function(Q, H) {
            H = (typeof H !== "undefined" ? H : 16.666666666666668) * Q.timeScale;
            var N = H * H, W = E._timeCorrection ? H / (Q.deltaTime || H) : 1, R = 1 - Q.frictionAir * (H / K._baseDelta), Y = (Q.position.x - Q.positionPrev.x) * W, I = (Q.position.y - Q.positionPrev.y) * W;
            Q.velocity.x = Y * R + Q.force.x / Q.mass * N, Q.velocity.y = I * R + Q.force.y / Q.mass * N, Q.positionPrev.x = Q.position.x, Q.positionPrev.y = Q.position.y, Q.position.x += Q.velocity.x, Q.position.y += Q.velocity.y, Q.deltaTime = H, Q.angularVelocity = (Q.angle - Q.anglePrev) * R * W + Q.torque / Q.inertia * N, Q.anglePrev = Q.angle, Q.angle += Q.angularVelocity, Q.speed = z.magnitude(Q.velocity), Q.angularSpeed = Math.abs(Q.angularVelocity);
            for (var P = 0;P < Q.parts.length; P++) {
              var X = Q.parts[P];
              if (L.translate(X.vertices, Q.velocity), P > 0)
                X.position.x += Q.velocity.x, X.position.y += Q.velocity.y;
              if (Q.angularVelocity !== 0) {
                if (L.rotate(X.vertices, Q.angularVelocity, Q.position), Z.rotate(X.axes, Q.angularVelocity), P > 0)
                  z.rotateAbout(X.position, Q.angularVelocity, Q.position, X.position);
              }
              J.update(X.bounds, X.vertices, Q.velocity);
            }
          }, E.updateVelocities = function(Q) {
            var H = E._baseDelta / Q.deltaTime, N = Q.velocity;
            N.x = (Q.position.x - Q.positionPrev.x) * H, N.y = (Q.position.y - Q.positionPrev.y) * H, Q.speed = Math.sqrt(N.x * N.x + N.y * N.y), Q.angularVelocity = (Q.angle - Q.anglePrev) * H, Q.angularSpeed = Math.abs(Q.angularVelocity);
          }, E.applyForce = function(Q, H, N) {
            var W = { x: H.x - Q.position.x, y: H.y - Q.position.y };
            Q.force.x += N.x, Q.force.y += N.y, Q.torque += W.x * N.y - W.y * N.x;
          }, E._totalProperties = function(Q) {
            var H = { mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 } };
            for (var N = Q.parts.length === 1 ? 0 : 1;N < Q.parts.length; N++) {
              var W = Q.parts[N], R = W.mass !== Infinity ? W.mass : 1;
              H.mass += R, H.area += W.area, H.inertia += W.inertia, H.centre = z.add(H.centre, z.mult(W.position, R));
            }
            return H.centre = z.div(H.centre, H.mass), H;
          };
        })();
      }, 69351: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(35810), z = $(53402), U = $(15647), K = $(22562);
        (function() {
          E.create = function(J) {
            return z.extend({ id: z.nextId(), type: "composite", parent: null, isModified: false, bodies: [], constraints: [], composites: [], label: "Composite", plugin: {}, cache: { allBodies: null, allConstraints: null, allComposites: null } }, J);
          }, E.setModified = function(J, Z, D, Q) {
            if (L.trigger(J, "compositeModified", J), J.isModified = Z, Z && J.cache)
              J.cache.allBodies = null, J.cache.allConstraints = null, J.cache.allComposites = null;
            if (D && J.parent)
              E.setModified(J.parent, Z, D, Q);
            if (Q)
              for (var H = 0;H < J.composites.length; H++) {
                var N = J.composites[H];
                E.setModified(N, Z, D, Q);
              }
          }, E.add = function(J, Z) {
            var D = [].concat(Z);
            L.trigger(J, "beforeAdd", { object: Z });
            for (var Q = 0;Q < D.length; Q++) {
              var H = D[Q];
              switch (H.type) {
                case "body":
                  if (H.parent !== H) {
                    z.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
                    break;
                  }
                  E.addBody(J, H);
                  break;
                case "constraint":
                  E.addConstraint(J, H);
                  break;
                case "composite":
                  E.addComposite(J, H);
                  break;
                case "mouseConstraint":
                  E.addConstraint(J, H.constraint);
                  break;
              }
            }
            return L.trigger(J, "afterAdd", { object: Z }), J;
          }, E.remove = function(J, Z, D) {
            var Q = [].concat(Z);
            L.trigger(J, "beforeRemove", { object: Z });
            for (var H = 0;H < Q.length; H++) {
              var N = Q[H];
              switch (N.type) {
                case "body":
                  E.removeBody(J, N, D);
                  break;
                case "constraint":
                  E.removeConstraint(J, N, D);
                  break;
                case "composite":
                  E.removeComposite(J, N, D);
                  break;
                case "mouseConstraint":
                  E.removeConstraint(J, N.constraint);
                  break;
              }
            }
            return L.trigger(J, "afterRemove", { object: Z }), J;
          }, E.addComposite = function(J, Z) {
            return J.composites.push(Z), Z.parent = J, E.setModified(J, true, true, false), J;
          }, E.removeComposite = function(J, Z, D) {
            var Q = z.indexOf(J.composites, Z);
            if (Q !== -1)
              E.removeCompositeAt(J, Q);
            if (D)
              for (var H = 0;H < J.composites.length; H++)
                E.removeComposite(J.composites[H], Z, true);
            return J;
          }, E.removeCompositeAt = function(J, Z) {
            return J.composites.splice(Z, 1), E.setModified(J, true, true, false), J;
          }, E.addBody = function(J, Z) {
            return J.bodies.push(Z), E.setModified(J, true, true, false), J;
          }, E.removeBody = function(J, Z, D) {
            var Q = z.indexOf(J.bodies, Z);
            if (Q !== -1)
              E.removeBodyAt(J, Q);
            if (D)
              for (var H = 0;H < J.composites.length; H++)
                E.removeBody(J.composites[H], Z, true);
            return J;
          }, E.removeBodyAt = function(J, Z) {
            return J.bodies.splice(Z, 1), E.setModified(J, true, true, false), J;
          }, E.addConstraint = function(J, Z) {
            return J.constraints.push(Z), E.setModified(J, true, true, false), J;
          }, E.removeConstraint = function(J, Z, D) {
            var Q = z.indexOf(J.constraints, Z);
            if (Q !== -1)
              E.removeConstraintAt(J, Q);
            if (D)
              for (var H = 0;H < J.composites.length; H++)
                E.removeConstraint(J.composites[H], Z, true);
            return J;
          }, E.removeConstraintAt = function(J, Z) {
            return J.constraints.splice(Z, 1), E.setModified(J, true, true, false), J;
          }, E.clear = function(J, Z, D) {
            if (D)
              for (var Q = 0;Q < J.composites.length; Q++)
                E.clear(J.composites[Q], Z, true);
            if (Z)
              J.bodies = J.bodies.filter(function(H) {
                return H.isStatic;
              });
            else
              J.bodies.length = 0;
            return J.constraints.length = 0, J.composites.length = 0, E.setModified(J, true, true, false), J;
          }, E.allBodies = function(J) {
            if (J.cache && J.cache.allBodies)
              return J.cache.allBodies;
            var Z = [].concat(J.bodies);
            for (var D = 0;D < J.composites.length; D++)
              Z = Z.concat(E.allBodies(J.composites[D]));
            if (J.cache)
              J.cache.allBodies = Z;
            return Z;
          }, E.allConstraints = function(J) {
            if (J.cache && J.cache.allConstraints)
              return J.cache.allConstraints;
            var Z = [].concat(J.constraints);
            for (var D = 0;D < J.composites.length; D++)
              Z = Z.concat(E.allConstraints(J.composites[D]));
            if (J.cache)
              J.cache.allConstraints = Z;
            return Z;
          }, E.allComposites = function(J) {
            if (J.cache && J.cache.allComposites)
              return J.cache.allComposites;
            var Z = [].concat(J.composites);
            for (var D = 0;D < J.composites.length; D++)
              Z = Z.concat(E.allComposites(J.composites[D]));
            if (J.cache)
              J.cache.allComposites = Z;
            return Z;
          }, E.get = function(J, Z, D) {
            var Q, H;
            switch (D) {
              case "body":
                Q = E.allBodies(J);
                break;
              case "constraint":
                Q = E.allConstraints(J);
                break;
              case "composite":
                Q = E.allComposites(J).concat(J);
                break;
            }
            if (!Q)
              return null;
            return H = Q.filter(function(N) {
              return N.id.toString() === Z.toString();
            }), H.length === 0 ? null : H[0];
          }, E.move = function(J, Z, D) {
            return E.remove(J, Z), E.add(D, Z), J;
          }, E.rebase = function(J) {
            var Z = E.allBodies(J).concat(E.allConstraints(J)).concat(E.allComposites(J));
            for (var D = 0;D < Z.length; D++)
              Z[D].id = z.nextId();
            return J;
          }, E.translate = function(J, Z, D) {
            var Q = D ? E.allBodies(J) : J.bodies;
            for (var H = 0;H < Q.length; H++)
              K.translate(Q[H], Z);
            return J;
          }, E.rotate = function(J, Z, D, Q) {
            var H = Math.cos(Z), N = Math.sin(Z), W = Q ? E.allBodies(J) : J.bodies;
            for (var R = 0;R < W.length; R++) {
              var Y = W[R], I = Y.position.x - D.x, P = Y.position.y - D.y;
              K.setPosition(Y, { x: D.x + (I * H - P * N), y: D.y + (I * N + P * H) }), K.rotate(Y, Z);
            }
            return J;
          }, E.scale = function(J, Z, D, Q, H) {
            var N = H ? E.allBodies(J) : J.bodies;
            for (var W = 0;W < N.length; W++) {
              var R = N[W], Y = R.position.x - Q.x, I = R.position.y - Q.y;
              K.setPosition(R, { x: Q.x + Y * Z, y: Q.y + I * D }), K.scale(R, Z, D);
            }
            return J;
          }, E.bounds = function(J) {
            var Z = E.allBodies(J), D = [];
            for (var Q = 0;Q < Z.length; Q += 1) {
              var H = Z[Q];
              D.push(H.bounds.min, H.bounds.max);
            }
            return U.create(D);
          };
        })();
      }, 4372: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(69351);
        (function() {
          E.create = L.create, E.add = L.add, E.remove = L.remove, E.clear = L.clear, E.addComposite = L.addComposite, E.addBody = L.addBody, E.addConstraint = L.addConstraint;
        })();
      }, 52284: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(41598), z = $(4506);
        (function() {
          var U = [], K = { overlap: 0, axis: null }, J = { overlap: 0, axis: null };
          E.create = function(Z, D) {
            return { pair: null, collided: false, bodyA: Z, bodyB: D, parentA: Z.parent, parentB: D.parent, depth: 0, normal: { x: 0, y: 0 }, tangent: { x: 0, y: 0 }, penetration: { x: 0, y: 0 }, supports: [] };
          }, E.collides = function(Z, D, Q) {
            if (E._overlapAxes(K, Z.vertices, D.vertices, Z.axes), K.overlap <= 0)
              return null;
            if (E._overlapAxes(J, D.vertices, Z.vertices, D.axes), J.overlap <= 0)
              return null;
            var H = Q && Q.table[z.id(Z, D)], N;
            if (!H)
              N = E.create(Z, D), N.collided = true, N.bodyA = Z.id < D.id ? Z : D, N.bodyB = Z.id < D.id ? D : Z, N.parentA = N.bodyA.parent, N.parentB = N.bodyB.parent;
            else
              N = H.collision;
            Z = N.bodyA, D = N.bodyB;
            var W;
            if (K.overlap < J.overlap)
              W = K;
            else
              W = J;
            var { normal: R, supports: Y } = N, I = W.axis, P = I.x, X = I.y;
            if (P * (D.position.x - Z.position.x) + X * (D.position.y - Z.position.y) < 0)
              R.x = P, R.y = X;
            else
              R.x = -P, R.y = -X;
            N.tangent.x = -R.y, N.tangent.y = R.x, N.depth = W.overlap, N.penetration.x = R.x * N.depth, N.penetration.y = R.y * N.depth;
            var G = E._findSupports(Z, D, R, 1), V = 0;
            if (L.contains(Z.vertices, G[0]))
              Y[V++] = G[0];
            if (L.contains(Z.vertices, G[1]))
              Y[V++] = G[1];
            if (V < 2) {
              var A = E._findSupports(D, Z, R, -1);
              if (L.contains(D.vertices, A[0]))
                Y[V++] = A[0];
              if (V < 2 && L.contains(D.vertices, A[1]))
                Y[V++] = A[1];
            }
            if (V === 0)
              Y[V++] = G[0];
            return Y.length = V, N;
          }, E._overlapAxes = function(Z, D, Q, H) {
            var N = D.length, W = Q.length, R = D[0].x, Y = D[0].y, I = Q[0].x, P = Q[0].y, X = H.length, G = Number.MAX_VALUE, V = 0, A, F, j, T, C, v;
            for (C = 0;C < X; C++) {
              var O = H[C], q = O.x, w = O.y, g = R * q + Y * w, b = I * q + P * w, x = g, k = b;
              for (v = 1;v < N; v += 1)
                if (T = D[v].x * q + D[v].y * w, T > x)
                  x = T;
                else if (T < g)
                  g = T;
              for (v = 1;v < W; v += 1)
                if (T = Q[v].x * q + Q[v].y * w, T > k)
                  k = T;
                else if (T < b)
                  b = T;
              if (F = x - b, j = k - g, A = F < j ? F : j, A < G) {
                if (G = A, V = C, A <= 0)
                  break;
              }
            }
            Z.axis = H[V], Z.overlap = G;
          }, E._projectToAxis = function(Z, D, Q) {
            var H = D[0].x * Q.x + D[0].y * Q.y, N = H;
            for (var W = 1;W < D.length; W += 1) {
              var R = D[W].x * Q.x + D[W].y * Q.y;
              if (R > N)
                N = R;
              else if (R < H)
                H = R;
            }
            Z.min = H, Z.max = N;
          }, E._findSupports = function(Z, D, Q, H) {
            var N = D.vertices, W = N.length, R = Z.position.x, Y = Z.position.y, I = Q.x * H, P = Q.y * H, X = Number.MAX_VALUE, G, V, A, F, j;
            for (j = 0;j < W; j += 1)
              if (V = N[j], F = I * (R - V.x) + P * (Y - V.y), F < X)
                X = F, G = V;
            if (A = N[(W + G.index - 1) % W], X = I * (R - A.x) + P * (Y - A.y), V = N[(G.index + 1) % W], I * (R - V.x) + P * (Y - V.y) < X)
              return U[0] = G, U[1] = V, U;
            return U[0] = G, U[1] = A, U;
          };
        })();
      }, 43424: (M) => {
        var B = {};
        M.exports = B, function() {
          B.create = function($) {
            return { vertex: $, normalImpulse: 0, tangentImpulse: 0 };
          };
        }();
      }, 81388: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(53402), z = $(52284);
        (function() {
          E.create = function(U) {
            var K = { bodies: [], pairs: null };
            return L.extend(K, U);
          }, E.setBodies = function(U, K) {
            U.bodies = K.slice(0);
          }, E.clear = function(U) {
            U.bodies = [];
          }, E.collisions = function(U) {
            var K = [], J = U.pairs, Z = U.bodies, D = Z.length, Q = E.canCollide, H = z.collides, N, W;
            Z.sort(E._compareBoundsX);
            for (N = 0;N < D; N++) {
              var R = Z[N], Y = R.bounds, I = R.bounds.max.x, P = R.bounds.max.y, X = R.bounds.min.y, G = R.isStatic || R.isSleeping, V = R.parts.length, A = V === 1;
              for (W = N + 1;W < D; W++) {
                var F = Z[W], j = F.bounds;
                if (j.min.x > I)
                  break;
                if (P < j.min.y || X > j.max.y)
                  continue;
                if (G && (F.isStatic || F.isSleeping))
                  continue;
                if (!Q(R.collisionFilter, F.collisionFilter))
                  continue;
                var T = F.parts.length;
                if (A && T === 1) {
                  var C = H(R, F, J);
                  if (C)
                    K.push(C);
                } else {
                  var v = V > 1 ? 1 : 0, O = T > 1 ? 1 : 0;
                  for (var q = v;q < V; q++) {
                    var w = R.parts[q], Y = w.bounds;
                    for (var g = O;g < T; g++) {
                      var b = F.parts[g], j = b.bounds;
                      if (Y.min.x > j.max.x || Y.max.x < j.min.x || Y.max.y < j.min.y || Y.min.y > j.max.y)
                        continue;
                      var C = H(w, b, J);
                      if (C)
                        K.push(C);
                    }
                  }
                }
              }
            }
            return K;
          }, E.canCollide = function(U, K) {
            if (U.group === K.group && U.group !== 0)
              return U.group > 0;
            return (U.mask & K.category) !== 0 && (K.mask & U.category) !== 0;
          }, E._compareBoundsX = function(U, K) {
            return U.bounds.min.x - K.bounds.min.x;
          };
        })();
      }, 4506: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(43424);
        (function() {
          E.create = function(z, U) {
            var { bodyA: K, bodyB: J } = z, Z = { id: E.id(K, J), bodyA: K, bodyB: J, collision: z, contacts: [], activeContacts: [], separation: 0, isActive: true, confirmedActive: true, isSensor: K.isSensor || J.isSensor, timeCreated: U, timeUpdated: U, inverseMass: 0, friction: 0, frictionStatic: 0, restitution: 0, slop: 0 };
            return E.update(Z, z, U), Z;
          }, E.update = function(z, U, K) {
            var J = z.contacts, Z = U.supports, D = z.activeContacts, Q = U.parentA, H = U.parentB, N = Q.vertices.length;
            z.isActive = true, z.timeUpdated = K, z.collision = U, z.separation = U.depth, z.inverseMass = Q.inverseMass + H.inverseMass, z.friction = Q.friction < H.friction ? Q.friction : H.friction, z.frictionStatic = Q.frictionStatic > H.frictionStatic ? Q.frictionStatic : H.frictionStatic, z.restitution = Q.restitution > H.restitution ? Q.restitution : H.restitution, z.slop = Q.slop > H.slop ? Q.slop : H.slop, U.pair = z, D.length = 0;
            for (var W = 0;W < Z.length; W++) {
              var R = Z[W], Y = R.body === Q ? R.index : N + R.index, I = J[Y];
              if (I)
                D.push(I);
              else
                D.push(J[Y] = L.create(R));
            }
          }, E.setActive = function(z, U, K) {
            if (U)
              z.isActive = true, z.timeUpdated = K;
            else
              z.isActive = false, z.activeContacts.length = 0;
          }, E.id = function(z, U) {
            if (z.id < U.id)
              return "A" + z.id + "B" + U.id;
            else
              return "A" + U.id + "B" + z.id;
          };
        })();
      }, 99561: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(4506), z = $(53402);
        (function() {
          E.create = function(U) {
            return z.extend({ table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [] }, U);
          }, E.update = function(U, K, J) {
            var Z = U.list, D = Z.length, Q = U.table, H = K.length, N = U.collisionStart, W = U.collisionEnd, R = U.collisionActive, Y, I, P, X;
            N.length = 0, W.length = 0, R.length = 0;
            for (X = 0;X < D; X++)
              Z[X].confirmedActive = false;
            for (X = 0;X < H; X++)
              if (Y = K[X], P = Y.pair, P) {
                if (P.isActive)
                  R.push(P);
                else
                  N.push(P);
                L.update(P, Y, J), P.confirmedActive = true;
              } else
                P = L.create(Y, J), Q[P.id] = P, N.push(P), Z.push(P);
            var G = [];
            D = Z.length;
            for (X = 0;X < D; X++)
              if (P = Z[X], !P.confirmedActive) {
                if (L.setActive(P, false, J), W.push(P), !P.collision.bodyA.isSleeping && !P.collision.bodyB.isSleeping)
                  G.push(X);
              }
            for (X = 0;X < G.length; X++)
              I = G[X] - X, P = Z[I], Z.splice(I, 1), delete Q[P.id];
          }, E.clear = function(U) {
            return U.table = {}, U.list.length = 0, U.collisionStart.length = 0, U.collisionActive.length = 0, U.collisionEnd.length = 0, U;
          };
        })();
      }, 73296: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(31725), z = $(52284), U = $(15647), K = $(66280), J = $(41598);
        (function() {
          E.collides = function(Z, D) {
            var Q = [], H = D.length, N = Z.bounds, W = z.collides, R = U.overlaps;
            for (var Y = 0;Y < H; Y++) {
              var I = D[Y], P = I.parts.length, X = P === 1 ? 0 : 1;
              if (Z === I)
                continue;
              if (R(I.bounds, N))
                for (var G = X;G < P; G++) {
                  var V = I.parts[G];
                  if (R(V.bounds, N)) {
                    var A = W(V, Z);
                    if (A) {
                      Q.push(A);
                      break;
                    }
                  }
                }
            }
            return Q;
          }, E.ray = function(Z, D, Q, H) {
            H = H || 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001;
            var N = L.angle(D, Q), W = L.magnitude(L.sub(D, Q)), R = (Q.x + D.x) * 0.5, Y = (Q.y + D.y) * 0.5, I = K.rectangle(R, Y, W, H, { angle: N }), P = E.collides(I, Z);
            for (var X = 0;X < P.length; X += 1) {
              var G = P[X];
              G.body = G.bodyB = G.bodyA;
            }
            return P;
          }, E.region = function(Z, D, Q) {
            var H = [];
            for (var N = 0;N < Z.length; N++) {
              var W = Z[N], R = U.overlaps(W.bounds, D);
              if (R && !Q || !R && Q)
                H.push(W);
            }
            return H;
          }, E.point = function(Z, D) {
            var Q = [];
            for (var H = 0;H < Z.length; H++) {
              var N = Z[H];
              if (U.contains(N.bounds, D))
                for (var W = N.parts.length === 1 ? 0 : 1;W < N.parts.length; W++) {
                  var R = N.parts[W];
                  if (U.contains(R.bounds, D) && J.contains(R.vertices, D)) {
                    Q.push(N);
                    break;
                  }
                }
            }
            return Q;
          };
        })();
      }, 66272: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(41598), z = $(53402), U = $(15647);
        (function() {
          E._restingThresh = 2, E._restingThreshTangent = Math.sqrt(6), E._positionDampen = 0.9, E._positionWarming = 0.8, E._frictionNormalMultiplier = 5, E._frictionMaxStatic = Number.MAX_VALUE, E.preSolvePosition = function(K) {
            var J, Z, D, Q = K.length;
            for (J = 0;J < Q; J++) {
              if (Z = K[J], !Z.isActive)
                continue;
              D = Z.activeContacts.length, Z.collision.parentA.totalContacts += D, Z.collision.parentB.totalContacts += D;
            }
          }, E.solvePosition = function(K, J, Z) {
            var D, Q, H, N, W, R, Y, I, P = E._positionDampen * (Z || 1), X = z.clamp(J / z._baseDelta, 0, 1), G = K.length;
            for (D = 0;D < G; D++) {
              if (Q = K[D], !Q.isActive || Q.isSensor)
                continue;
              H = Q.collision, N = H.parentA, W = H.parentB, R = H.normal, Q.separation = R.x * (W.positionImpulse.x + H.penetration.x - N.positionImpulse.x) + R.y * (W.positionImpulse.y + H.penetration.y - N.positionImpulse.y);
            }
            for (D = 0;D < G; D++) {
              if (Q = K[D], !Q.isActive || Q.isSensor)
                continue;
              if (H = Q.collision, N = H.parentA, W = H.parentB, R = H.normal, I = Q.separation - Q.slop * X, N.isStatic || W.isStatic)
                I *= 2;
              if (!(N.isStatic || N.isSleeping))
                Y = P / N.totalContacts, N.positionImpulse.x += R.x * I * Y, N.positionImpulse.y += R.y * I * Y;
              if (!(W.isStatic || W.isSleeping))
                Y = P / W.totalContacts, W.positionImpulse.x -= R.x * I * Y, W.positionImpulse.y -= R.y * I * Y;
            }
          }, E.postSolvePosition = function(K) {
            var J = E._positionWarming, Z = K.length, D = L.translate, Q = U.update;
            for (var H = 0;H < Z; H++) {
              var N = K[H], W = N.positionImpulse, R = W.x, Y = W.y, I = N.velocity;
              if (N.totalContacts = 0, R !== 0 || Y !== 0) {
                for (var P = 0;P < N.parts.length; P++) {
                  var X = N.parts[P];
                  D(X.vertices, W), Q(X.bounds, X.vertices, I), X.position.x += R, X.position.y += Y;
                }
                if (N.positionPrev.x += R, N.positionPrev.y += Y, R * I.x + Y * I.y < 0)
                  W.x = 0, W.y = 0;
                else
                  W.x *= J, W.y *= J;
              }
            }
          }, E.preSolveVelocity = function(K) {
            var J = K.length, Z, D;
            for (Z = 0;Z < J; Z++) {
              var Q = K[Z];
              if (!Q.isActive || Q.isSensor)
                continue;
              var H = Q.activeContacts, N = H.length, W = Q.collision, R = W.parentA, Y = W.parentB, I = W.normal, P = W.tangent;
              for (D = 0;D < N; D++) {
                var X = H[D], G = X.vertex, V = X.normalImpulse, A = X.tangentImpulse;
                if (V !== 0 || A !== 0) {
                  var F = I.x * V + P.x * A, j = I.y * V + P.y * A;
                  if (!(R.isStatic || R.isSleeping))
                    R.positionPrev.x += F * R.inverseMass, R.positionPrev.y += j * R.inverseMass, R.anglePrev += R.inverseInertia * ((G.x - R.position.x) * j - (G.y - R.position.y) * F);
                  if (!(Y.isStatic || Y.isSleeping))
                    Y.positionPrev.x -= F * Y.inverseMass, Y.positionPrev.y -= j * Y.inverseMass, Y.anglePrev -= Y.inverseInertia * ((G.x - Y.position.x) * j - (G.y - Y.position.y) * F);
                }
              }
            }
          }, E.solveVelocity = function(K, J) {
            var Z = J / z._baseDelta, D = Z * Z, Q = D * Z, H = -E._restingThresh * Z, N = E._restingThreshTangent, W = E._frictionNormalMultiplier * Z, R = E._frictionMaxStatic, Y = K.length, I, P, X, G;
            for (X = 0;X < Y; X++) {
              var V = K[X];
              if (!V.isActive || V.isSensor)
                continue;
              var A = V.collision, F = A.parentA, j = A.parentB, T = F.velocity, C = j.velocity, v = A.normal.x, O = A.normal.y, q = A.tangent.x, w = A.tangent.y, g = V.activeContacts, b = g.length, x = 1 / b, k = F.inverseMass + j.inverseMass, S = V.friction * V.frictionStatic * W;
              T.x = F.position.x - F.positionPrev.x, T.y = F.position.y - F.positionPrev.y, C.x = j.position.x - j.positionPrev.x, C.y = j.position.y - j.positionPrev.y, F.angularVelocity = F.angle - F.anglePrev, j.angularVelocity = j.angle - j.anglePrev;
              for (G = 0;G < b; G++) {
                var f = g[G], h = f.vertex, m = h.x - F.position.x, y = h.y - F.position.y, d = h.x - j.position.x, p = h.y - j.position.y, u = T.x - y * F.angularVelocity, s = T.y + m * F.angularVelocity, c = C.x - p * j.angularVelocity, n = C.y + d * j.angularVelocity, _ = u - c, l = s - n, i = v * _ + O * l, t = q * _ + w * l, $0 = V.separation + i, e = Math.min($0, 1);
                e = $0 < 0 ? 0 : e;
                var o = e * S;
                if (t < -o || t > o) {
                  if (P = t > 0 ? t : -t, I = V.friction * (t > 0 ? 1 : -1) * Q, I < -P)
                    I = -P;
                  else if (I > P)
                    I = P;
                } else
                  I = t, P = R;
                var r = m * O - y * v, a = d * O - p * v, J0 = x / (k + F.inverseInertia * r * r + j.inverseInertia * a * a), Q0 = (1 + V.restitution) * i * J0;
                if (I *= J0, i < H)
                  f.normalImpulse = 0;
                else {
                  var D0 = f.normalImpulse;
                  if (f.normalImpulse += Q0, f.normalImpulse > 0)
                    f.normalImpulse = 0;
                  Q0 = f.normalImpulse - D0;
                }
                if (t < -N || t > N)
                  f.tangentImpulse = 0;
                else {
                  var z0 = f.tangentImpulse;
                  if (f.tangentImpulse += I, f.tangentImpulse < -P)
                    f.tangentImpulse = -P;
                  if (f.tangentImpulse > P)
                    f.tangentImpulse = P;
                  I = f.tangentImpulse - z0;
                }
                var K0 = v * Q0 + q * I, Z0 = O * Q0 + w * I;
                if (!(F.isStatic || F.isSleeping))
                  F.positionPrev.x += K0 * F.inverseMass, F.positionPrev.y += Z0 * F.inverseMass, F.anglePrev += (m * Z0 - y * K0) * F.inverseInertia;
                if (!(j.isStatic || j.isSleeping))
                  j.positionPrev.x -= K0 * j.inverseMass, j.positionPrev.y -= Z0 * j.inverseMass, j.anglePrev -= (d * Z0 - p * K0) * j.inverseInertia;
              }
            }
          };
        })();
      }, 48140: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(41598), z = $(31725), U = $(53614), K = $(15647), J = $(66615), Z = $(53402);
        (function() {
          E._warming = 0.4, E._torqueDampen = 1, E._minLength = 0.000001, E.create = function(D) {
            var Q = D;
            if (Q.bodyA && !Q.pointA)
              Q.pointA = { x: 0, y: 0 };
            if (Q.bodyB && !Q.pointB)
              Q.pointB = { x: 0, y: 0 };
            var H = Q.bodyA ? z.add(Q.bodyA.position, Q.pointA) : Q.pointA, N = Q.bodyB ? z.add(Q.bodyB.position, Q.pointB) : Q.pointB, W = z.magnitude(z.sub(H, N));
            Q.length = typeof Q.length !== "undefined" ? Q.length : W, Q.id = Q.id || Z.nextId(), Q.label = Q.label || "Constraint", Q.type = "constraint", Q.stiffness = Q.stiffness || (Q.length > 0 ? 1 : 0.7), Q.damping = Q.damping || 0, Q.angularStiffness = Q.angularStiffness || 0, Q.angleA = Q.bodyA ? Q.bodyA.angle : Q.angleA, Q.angleB = Q.bodyB ? Q.bodyB.angle : Q.angleB, Q.plugin = {};
            var R = { visible: true, type: "line", anchors: true, lineColor: null, lineOpacity: null, lineThickness: null, pinSize: null, anchorColor: null, anchorSize: null };
            if (Q.length === 0 && Q.stiffness > 0.1)
              R.type = "pin", R.anchors = false;
            else if (Q.stiffness < 0.9)
              R.type = "spring";
            return Q.render = Z.extend(R, Q.render), Q;
          }, E.preSolveAll = function(D) {
            for (var Q = 0;Q < D.length; Q += 1) {
              var H = D[Q], N = H.constraintImpulse;
              if (H.isStatic || N.x === 0 && N.y === 0 && N.angle === 0)
                continue;
              H.position.x += N.x, H.position.y += N.y, H.angle += N.angle;
            }
          }, E.solveAll = function(D, Q) {
            var H = Z.clamp(Q / Z._baseDelta, 0, 1);
            for (var N = 0;N < D.length; N += 1) {
              var W = D[N], R = !W.bodyA || W.bodyA && W.bodyA.isStatic, Y = !W.bodyB || W.bodyB && W.bodyB.isStatic;
              if (R || Y)
                E.solve(D[N], H);
            }
            for (N = 0;N < D.length; N += 1)
              if (W = D[N], R = !W.bodyA || W.bodyA && W.bodyA.isStatic, Y = !W.bodyB || W.bodyB && W.bodyB.isStatic, !R && !Y)
                E.solve(D[N], H);
          }, E.solve = function(D, Q) {
            var { bodyA: H, bodyB: N, pointA: W, pointB: R } = D;
            if (!H && !N)
              return;
            if (H && !H.isStatic)
              z.rotate(W, H.angle - D.angleA, W), D.angleA = H.angle;
            if (N && !N.isStatic)
              z.rotate(R, N.angle - D.angleB, R), D.angleB = N.angle;
            var Y = W, I = R;
            if (H)
              Y = z.add(H.position, W);
            if (N)
              I = z.add(N.position, R);
            if (!Y || !I)
              return;
            var P = z.sub(Y, I), X = z.magnitude(P);
            if (X < E._minLength)
              X = E._minLength;
            var G = (X - D.length) / X, V = D.stiffness >= 1 || D.length === 0, A = V ? D.stiffness * Q : D.stiffness * Q * Q, F = D.damping * Q, j = z.mult(P, G * A), T = (H ? H.inverseMass : 0) + (N ? N.inverseMass : 0), C = (H ? H.inverseInertia : 0) + (N ? N.inverseInertia : 0), v = T + C, O, q, w, g, b;
            if (F > 0) {
              var x = z.create();
              w = z.div(P, X), b = z.sub(N && z.sub(N.position, N.positionPrev) || x, H && z.sub(H.position, H.positionPrev) || x), g = z.dot(w, b);
            }
            if (H && !H.isStatic) {
              if (q = H.inverseMass / T, H.constraintImpulse.x -= j.x * q, H.constraintImpulse.y -= j.y * q, H.position.x -= j.x * q, H.position.y -= j.y * q, F > 0)
                H.positionPrev.x -= F * w.x * g * q, H.positionPrev.y -= F * w.y * g * q;
              O = z.cross(W, j) / v * E._torqueDampen * H.inverseInertia * (1 - D.angularStiffness), H.constraintImpulse.angle -= O, H.angle -= O;
            }
            if (N && !N.isStatic) {
              if (q = N.inverseMass / T, N.constraintImpulse.x += j.x * q, N.constraintImpulse.y += j.y * q, N.position.x += j.x * q, N.position.y += j.y * q, F > 0)
                N.positionPrev.x += F * w.x * g * q, N.positionPrev.y += F * w.y * g * q;
              O = z.cross(R, j) / v * E._torqueDampen * N.inverseInertia * (1 - D.angularStiffness), N.constraintImpulse.angle += O, N.angle += O;
            }
          }, E.postSolveAll = function(D) {
            for (var Q = 0;Q < D.length; Q++) {
              var H = D[Q], N = H.constraintImpulse;
              if (H.isStatic || N.x === 0 && N.y === 0 && N.angle === 0)
                continue;
              U.set(H, false);
              for (var W = 0;W < H.parts.length; W++) {
                var R = H.parts[W];
                if (L.translate(R.vertices, N), W > 0)
                  R.position.x += N.x, R.position.y += N.y;
                if (N.angle !== 0) {
                  if (L.rotate(R.vertices, N.angle, H.position), J.rotate(R.axes, N.angle), W > 0)
                    z.rotateAbout(R.position, N.angle, H.position, R.position);
                }
                K.update(R.bounds, R.vertices, H.velocity);
              }
              N.angle *= E._warming, N.x *= E._warming, N.y *= E._warming;
            }
          }, E.pointAWorld = function(D) {
            return { x: (D.bodyA ? D.bodyA.position.x : 0) + (D.pointA ? D.pointA.x : 0), y: (D.bodyA ? D.bodyA.position.y : 0) + (D.pointA ? D.pointA.y : 0) };
          }, E.pointBWorld = function(D) {
            return { x: (D.bodyB ? D.bodyB.position.x : 0) + (D.pointB ? D.pointB.x : 0), y: (D.bodyB ? D.bodyB.position.y : 0) + (D.pointB ? D.pointB.y : 0) };
          }, E.currentLength = function(D) {
            var Q = (D.bodyA ? D.bodyA.position.x : 0) + (D.pointA ? D.pointA.x : 0), H = (D.bodyA ? D.bodyA.position.y : 0) + (D.pointA ? D.pointA.y : 0), N = (D.bodyB ? D.bodyB.position.x : 0) + (D.pointB ? D.pointB.x : 0), W = (D.bodyB ? D.bodyB.position.y : 0) + (D.pointB ? D.pointB.y : 0), R = Q - N, Y = H - W;
            return Math.sqrt(R * R + Y * Y);
          };
        })();
      }, 53402: (M, B, $) => {
        var E = {};
        M.exports = E, function() {
          E._baseDelta = 16.666666666666668, E._nextId = 0, E._seed = 0, E._nowStartTime = +new Date, E._warnedOnce = {}, E._decomp = null, E.extend = function(z, U) {
            var K, J, Z;
            if (typeof U === "boolean")
              K = 2, Z = U;
            else
              K = 1, Z = true;
            for (var D = K;D < arguments.length; D++) {
              var Q = arguments[D];
              if (Q)
                for (var H in Q)
                  if (Z && Q[H] && Q[H].constructor === Object)
                    if (!z[H] || z[H].constructor === Object)
                      z[H] = z[H] || {}, E.extend(z[H], Z, Q[H]);
                    else
                      z[H] = Q[H];
                  else
                    z[H] = Q[H];
            }
            return z;
          }, E.clone = function(z, U) {
            return E.extend({}, U, z);
          }, E.keys = function(z) {
            if (Object.keys)
              return Object.keys(z);
            var U = [];
            for (var K in z)
              U.push(K);
            return U;
          }, E.values = function(z) {
            var U = [];
            if (Object.keys) {
              var K = Object.keys(z);
              for (var J = 0;J < K.length; J++)
                U.push(z[K[J]]);
              return U;
            }
            for (var Z in z)
              U.push(z[Z]);
            return U;
          }, E.get = function(z, U, K, J) {
            U = U.split(".").slice(K, J);
            for (var Z = 0;Z < U.length; Z += 1)
              z = z[U[Z]];
            return z;
          }, E.set = function(z, U, K, J, Z) {
            var D = U.split(".").slice(J, Z);
            return E.get(z, U, 0, -1)[D[D.length - 1]] = K, K;
          }, E.shuffle = function(z) {
            for (var U = z.length - 1;U > 0; U--) {
              var K = Math.floor(E.random() * (U + 1)), J = z[U];
              z[U] = z[K], z[K] = J;
            }
            return z;
          }, E.choose = function(z) {
            return z[Math.floor(E.random() * z.length)];
          }, E.isElement = function(z) {
            if (typeof HTMLElement !== "undefined")
              return z instanceof HTMLElement;
            return !!(z && z.nodeType && z.nodeName);
          }, E.isArray = function(z) {
            return Object.prototype.toString.call(z) === "[object Array]";
          }, E.isFunction = function(z) {
            return typeof z === "function";
          }, E.isPlainObject = function(z) {
            return typeof z === "object" && z.constructor === Object;
          }, E.isString = function(z) {
            return toString.call(z) === "[object String]";
          }, E.clamp = function(z, U, K) {
            if (z < U)
              return U;
            if (z > K)
              return K;
            return z;
          }, E.sign = function(z) {
            return z < 0 ? -1 : 1;
          }, E.now = function() {
            if (typeof window !== "undefined" && window.performance) {
              if (window.performance.now)
                return window.performance.now();
              else if (window.performance.webkitNow)
                return window.performance.webkitNow();
            }
            if (Date.now)
              return Date.now();
            return new Date - E._nowStartTime;
          }, E.random = function(z, U) {
            return z = typeof z !== "undefined" ? z : 0, U = typeof U !== "undefined" ? U : 1, z + L() * (U - z);
          };
          var L = function() {
            return E._seed = (E._seed * 9301 + 49297) % 233280, E._seed / 233280;
          };
          E.colorToNumber = function(z) {
            if (z = z.replace("#", ""), z.length == 3)
              z = z.charAt(0) + z.charAt(0) + z.charAt(1) + z.charAt(1) + z.charAt(2) + z.charAt(2);
            return parseInt(z, 16);
          }, E.logLevel = 1, E.log = function() {
            if (console && E.logLevel > 0 && E.logLevel <= 3)
              console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
          }, E.info = function() {
            if (console && E.logLevel > 0 && E.logLevel <= 2)
              console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
          }, E.warn = function() {
            if (console && E.logLevel > 0 && E.logLevel <= 3)
              console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
          }, E.warnOnce = function() {
            var z = Array.prototype.slice.call(arguments).join(" ");
            if (!E._warnedOnce[z])
              E.warn(z), E._warnedOnce[z] = true;
          }, E.deprecated = function(z, U, K) {
            z[U] = E.chain(function() {
              E.warnOnce("\uD83D\uDD05 deprecated \uD83D\uDD05", K);
            }, z[U]);
          }, E.nextId = function() {
            return E._nextId++;
          }, E.indexOf = function(z, U) {
            if (z.indexOf)
              return z.indexOf(U);
            for (var K = 0;K < z.length; K++)
              if (z[K] === U)
                return K;
            return -1;
          }, E.map = function(z, U) {
            if (z.map)
              return z.map(U);
            var K = [];
            for (var J = 0;J < z.length; J += 1)
              K.push(U(z[J]));
            return K;
          }, E.topologicalSort = function(z) {
            var U = [], K = [], J = [];
            for (var Z in z)
              if (!K[Z] && !J[Z])
                E._topologicalSort(Z, K, J, z, U);
            return U;
          }, E._topologicalSort = function(z, U, K, J, Z) {
            var D = J[z] || [];
            K[z] = true;
            for (var Q = 0;Q < D.length; Q += 1) {
              var H = D[Q];
              if (K[H])
                continue;
              if (!U[H])
                E._topologicalSort(H, U, K, J, Z);
            }
            K[z] = false, U[z] = true, Z.push(z);
          }, E.chain = function() {
            var z = [];
            for (var U = 0;U < arguments.length; U += 1) {
              var K = arguments[U];
              if (K._chained)
                z.push.apply(z, K._chained);
              else
                z.push(K);
            }
            var J = function() {
              var Z, D = new Array(arguments.length);
              for (var Q = 0, H = arguments.length;Q < H; Q++)
                D[Q] = arguments[Q];
              for (Q = 0;Q < z.length; Q += 1) {
                var N = z[Q].apply(Z, D);
                if (typeof N !== "undefined")
                  Z = N;
              }
              return Z;
            };
            return J._chained = z, J;
          }, E.chainPathBefore = function(z, U, K) {
            return E.set(z, U, E.chain(K, E.get(z, U)));
          }, E.chainPathAfter = function(z, U, K) {
            return E.set(z, U, E.chain(E.get(z, U), K));
          }, E.setDecomp = function(z) {
            E._decomp = z;
          }, E.getDecomp = function() {
            var z = E._decomp;
            try {
              if (!z && typeof window !== "undefined")
                z = window.decomp;
              if (!z && typeof $.g !== "undefined")
                z = $.g.decomp;
            } catch (U) {
              z = null;
            }
            return z;
          };
        }();
      }, 48413: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(53614), z = $(66272), U = $(81388), K = $(99561), J = $(35810), Z = $(69351), D = $(48140), Q = $(53402), H = $(22562);
        (function() {
          E.create = function(N) {
            N = N || {};
            var W = { positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: false, events: [], plugin: {}, gravity: { x: 0, y: 1, scale: 0.001 }, timing: { timestamp: 0, timeScale: 1, lastDelta: 0, lastElapsed: 0 } }, R = Q.extend(W, N);
            return R.world = N.world || Z.create({ label: "World" }), R.pairs = N.pairs || K.create(), R.detector = N.detector || U.create(), R.grid = { buckets: [] }, R.world.gravity = R.gravity, R.broadphase = R.grid, R.metrics = {}, R;
          }, E.update = function(N, W) {
            var R = Q.now(), Y = N.world, I = N.detector, P = N.pairs, X = N.timing, G = X.timestamp, V;
            W = typeof W !== "undefined" ? W : Q._baseDelta, W *= X.timeScale, X.timestamp += W, X.lastDelta = W;
            var A = { timestamp: X.timestamp, delta: W };
            J.trigger(N, "beforeUpdate", A);
            var F = Z.allBodies(Y), j = Z.allConstraints(Y);
            if (Y.isModified)
              U.setBodies(I, F), Z.setModified(Y, false, false, true);
            if (N.enableSleeping)
              L.update(F, W);
            if (E._bodiesApplyGravity(F, N.gravity), W > 0)
              E._bodiesUpdate(F, W);
            J.trigger(N, "beforeSolve", A), D.preSolveAll(F);
            for (V = 0;V < N.constraintIterations; V++)
              D.solveAll(j, W);
            D.postSolveAll(F), I.pairs = N.pairs;
            var T = U.collisions(I);
            if (K.update(P, T, G), N.enableSleeping)
              L.afterCollisions(P.list);
            if (P.collisionStart.length > 0)
              J.trigger(N, "collisionStart", { pairs: P.collisionStart, timestamp: X.timestamp, delta: W });
            var C = Q.clamp(20 / N.positionIterations, 0, 1);
            z.preSolvePosition(P.list);
            for (V = 0;V < N.positionIterations; V++)
              z.solvePosition(P.list, W, C);
            z.postSolvePosition(F), D.preSolveAll(F);
            for (V = 0;V < N.constraintIterations; V++)
              D.solveAll(j, W);
            D.postSolveAll(F), z.preSolveVelocity(P.list);
            for (V = 0;V < N.velocityIterations; V++)
              z.solveVelocity(P.list, W);
            if (E._bodiesUpdateVelocities(F), P.collisionActive.length > 0)
              J.trigger(N, "collisionActive", { pairs: P.collisionActive, timestamp: X.timestamp, delta: W });
            if (P.collisionEnd.length > 0)
              J.trigger(N, "collisionEnd", { pairs: P.collisionEnd, timestamp: X.timestamp, delta: W });
            return E._bodiesClearForces(F), J.trigger(N, "afterUpdate", A), N.timing.lastElapsed = Q.now() - R, N;
          }, E.merge = function(N, W) {
            if (Q.extend(N, W), W.world) {
              N.world = W.world, E.clear(N);
              var R = Z.allBodies(N.world);
              for (var Y = 0;Y < R.length; Y++) {
                var I = R[Y];
                L.set(I, false), I.id = Q.nextId();
              }
            }
          }, E.clear = function(N) {
            K.clear(N.pairs), U.clear(N.detector);
          }, E._bodiesClearForces = function(N) {
            var W = N.length;
            for (var R = 0;R < W; R++) {
              var Y = N[R];
              Y.force.x = 0, Y.force.y = 0, Y.torque = 0;
            }
          }, E._bodiesApplyGravity = function(N, W) {
            var R = typeof W.scale !== "undefined" ? W.scale : 0.001, Y = N.length;
            if (W.x === 0 && W.y === 0 || R === 0)
              return;
            for (var I = 0;I < Y; I++) {
              var P = N[I];
              if (P.ignoreGravity || P.isStatic || P.isSleeping)
                continue;
              P.force.y += P.mass * W.y * R, P.force.x += P.mass * W.x * R;
            }
          }, E._bodiesUpdate = function(N, W) {
            var R = N.length;
            for (var Y = 0;Y < R; Y++) {
              var I = N[Y];
              if (I.isStatic || I.isSleeping)
                continue;
              H.update(I, W);
            }
          }, E._bodiesUpdateVelocities = function(N) {
            var W = N.length;
            for (var R = 0;R < W; R++)
              H.updateVelocities(N[R]);
          };
        })();
      }, 35810: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(53402);
        (function() {
          E.on = function(z, U, K) {
            var J = U.split(" "), Z;
            for (var D = 0;D < J.length; D++)
              Z = J[D], z.events = z.events || {}, z.events[Z] = z.events[Z] || [], z.events[Z].push(K);
            return K;
          }, E.off = function(z, U, K) {
            if (!U) {
              z.events = {};
              return;
            }
            if (typeof U === "function")
              K = U, U = L.keys(z.events).join(" ");
            var J = U.split(" ");
            for (var Z = 0;Z < J.length; Z++) {
              var D = z.events[J[Z]], Q = [];
              if (K && D) {
                for (var H = 0;H < D.length; H++)
                  if (D[H] !== K)
                    Q.push(D[H]);
              }
              z.events[J[Z]] = Q;
            }
          }, E.trigger = function(z, U, K) {
            var J, Z, D, Q, H = z.events;
            if (H && L.keys(H).length > 0) {
              if (!K)
                K = {};
              J = U.split(" ");
              for (var N = 0;N < J.length; N++)
                if (Z = J[N], D = H[Z], D) {
                  Q = L.clone(K, false), Q.name = Z, Q.source = z;
                  for (var W = 0;W < D.length; W++)
                    D[W].apply(z, [Q]);
                }
            }
          };
        })();
      }, 6790: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(73832), z = $(53402);
        (function() {
          E.name = "matter-js", E.version = "0.19.0", E.uses = [], E.used = [], E.use = function() {
            L.use(E, Array.prototype.slice.call(arguments));
          }, E.before = function(U, K) {
            return U = U.replace(/^Matter./, ""), z.chainPathBefore(E, U, K);
          }, E.after = function(U, K) {
            return U = U.replace(/^Matter./, ""), z.chainPathAfter(E, U, K);
          };
        })();
      }, 73832: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(53402);
        (function() {
          E._registry = {}, E.register = function(z) {
            if (!E.isPlugin(z))
              L.warn("Plugin.register:", E.toString(z), "does not implement all required fields.");
            if (z.name in E._registry) {
              var U = E._registry[z.name], K = E.versionParse(z.version).number, J = E.versionParse(U.version).number;
              if (K > J)
                L.warn("Plugin.register:", E.toString(U), "was upgraded to", E.toString(z)), E._registry[z.name] = z;
              else if (K < J)
                L.warn("Plugin.register:", E.toString(U), "can not be downgraded to", E.toString(z));
              else if (z !== U)
                L.warn("Plugin.register:", E.toString(z), "is already registered to different plugin object");
            } else
              E._registry[z.name] = z;
            return z;
          }, E.resolve = function(z) {
            return E._registry[E.dependencyParse(z).name];
          }, E.toString = function(z) {
            return typeof z === "string" ? z : (z.name || "anonymous") + "@" + (z.version || z.range || "0.0.0");
          }, E.isPlugin = function(z) {
            return z && z.name && z.version && z.install;
          }, E.isUsed = function(z, U) {
            return z.used.indexOf(U) > -1;
          }, E.isFor = function(z, U) {
            var K = z.for && E.dependencyParse(z.for);
            return !z.for || U.name === K.name && E.versionSatisfies(U.version, K.range);
          }, E.use = function(z, U) {
            if (z.uses = (z.uses || []).concat(U || []), z.uses.length === 0) {
              L.warn("Plugin.use:", E.toString(z), "does not specify any dependencies to install.");
              return;
            }
            var K = E.dependencies(z), J = L.topologicalSort(K), Z = [];
            for (var D = 0;D < J.length; D += 1) {
              if (J[D] === z.name)
                continue;
              var Q = E.resolve(J[D]);
              if (!Q) {
                Z.push("\u274C " + J[D]);
                continue;
              }
              if (E.isUsed(z, Q.name))
                continue;
              if (!E.isFor(Q, z))
                L.warn("Plugin.use:", E.toString(Q), "is for", Q.for, "but installed on", E.toString(z) + "."), Q._warned = true;
              if (Q.install)
                Q.install(z);
              else
                L.warn("Plugin.use:", E.toString(Q), "does not specify an install function."), Q._warned = true;
              if (Q._warned)
                Z.push("\uD83D\uDD36 " + E.toString(Q)), delete Q._warned;
              else
                Z.push("\u2705 " + E.toString(Q));
              z.used.push(Q.name);
            }
            if (Z.length > 0 && !Q.silent)
              L.info(Z.join("  "));
          }, E.dependencies = function(z, U) {
            var K = E.dependencyParse(z), J = K.name;
            if (U = U || {}, J in U)
              return;
            z = E.resolve(z) || z, U[J] = L.map(z.uses || [], function(D) {
              if (E.isPlugin(D))
                E.register(D);
              var Q = E.dependencyParse(D), H = E.resolve(D);
              if (H && !E.versionSatisfies(H.version, Q.range))
                L.warn("Plugin.dependencies:", E.toString(H), "does not satisfy", E.toString(Q), "used by", E.toString(K) + "."), H._warned = true, z._warned = true;
              else if (!H)
                L.warn("Plugin.dependencies:", E.toString(D), "used by", E.toString(K), "could not be resolved."), z._warned = true;
              return Q.name;
            });
            for (var Z = 0;Z < U[J].length; Z += 1)
              E.dependencies(U[J][Z], U);
            return U;
          }, E.dependencyParse = function(z) {
            if (L.isString(z)) {
              var U = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/;
              if (!U.test(z))
                L.warn("Plugin.dependencyParse:", z, "is not a valid dependency string.");
              return { name: z.split("@")[0], range: z.split("@")[1] || "*" };
            }
            return { name: z.name, range: z.range || z.version };
          }, E.versionParse = function(z) {
            var U = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/;
            if (!U.test(z))
              L.warn("Plugin.versionParse:", z, "is not a valid version or range.");
            var K = U.exec(z), J = Number(K[4]), Z = Number(K[5]), D = Number(K[6]);
            return { isRange: Boolean(K[1] || K[2]), version: K[3], range: z, operator: K[1] || K[2] || "", major: J, minor: Z, patch: D, parts: [J, Z, D], prerelease: K[7], number: J * 1e8 + Z * 1e4 + D };
          }, E.versionSatisfies = function(z, U) {
            U = U || "*";
            var K = E.versionParse(U), J = E.versionParse(z);
            if (K.isRange) {
              if (K.operator === "*" || z === "*")
                return true;
              if (K.operator === ">")
                return J.number > K.number;
              if (K.operator === ">=")
                return J.number >= K.number;
              if (K.operator === "~")
                return J.major === K.major && J.minor === K.minor && J.patch >= K.patch;
              if (K.operator === "^") {
                if (K.major > 0)
                  return J.major === K.major && J.number >= K.number;
                if (K.minor > 0)
                  return J.minor === K.minor && J.patch >= K.patch;
                return J.patch === K.patch;
              }
            }
            return z === U || z === "*";
          };
        })();
      }, 53614: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(22562), z = $(35810), U = $(53402);
        (function() {
          E._motionWakeThreshold = 0.18, E._motionSleepThreshold = 0.08, E._minBias = 0.9, E.update = function(K, J) {
            var Z = J / U._baseDelta, D = E._motionSleepThreshold;
            for (var Q = 0;Q < K.length; Q++) {
              var H = K[Q], N = L.getSpeed(H), W = L.getAngularSpeed(H), R = N * N + W * W;
              if (H.force.x !== 0 || H.force.y !== 0) {
                E.set(H, false);
                continue;
              }
              var Y = Math.min(H.motion, R), I = Math.max(H.motion, R);
              if (H.motion = E._minBias * Y + (1 - E._minBias) * I, H.sleepThreshold > 0 && H.motion < D) {
                if (H.sleepCounter += 1, H.sleepCounter >= H.sleepThreshold / Z)
                  E.set(H, true);
              } else if (H.sleepCounter > 0)
                H.sleepCounter -= 1;
            }
          }, E.afterCollisions = function(K) {
            var J = E._motionSleepThreshold;
            for (var Z = 0;Z < K.length; Z++) {
              var D = K[Z];
              if (!D.isActive)
                continue;
              var Q = D.collision, H = Q.bodyA.parent, N = Q.bodyB.parent;
              if (H.isSleeping && N.isSleeping || H.isStatic || N.isStatic)
                continue;
              if (H.isSleeping || N.isSleeping) {
                var W = H.isSleeping && !H.isStatic ? H : N, R = W === H ? N : H;
                if (!W.isStatic && R.motion > J)
                  E.set(W, false);
              }
            }
          }, E.set = function(K, J) {
            var Z = K.isSleeping;
            if (J) {
              if (K.isSleeping = true, K.sleepCounter = K.sleepThreshold, K.positionImpulse.x = 0, K.positionImpulse.y = 0, K.positionPrev.x = K.position.x, K.positionPrev.y = K.position.y, K.anglePrev = K.angle, K.speed = 0, K.angularSpeed = 0, K.motion = 0, !Z)
                z.trigger(K, "sleepStart");
            } else if (K.isSleeping = false, K.sleepCounter = 0, Z)
              z.trigger(K, "sleepEnd");
          };
        })();
      }, 66280: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(41598), z = $(53402), U = $(22562), K = $(15647), J = $(31725);
        (function() {
          E.rectangle = function(Z, D, Q, H, N) {
            N = N || {};
            var W = { label: "Rectangle Body", position: { x: Z, y: D }, vertices: L.fromPath("L 0 0 L " + Q + " 0 L " + Q + " " + H + " L 0 " + H) };
            if (N.chamfer) {
              var R = N.chamfer;
              W.vertices = L.chamfer(W.vertices, R.radius, R.quality, R.qualityMin, R.qualityMax), delete N.chamfer;
            }
            return U.create(z.extend({}, W, N));
          }, E.trapezoid = function(Z, D, Q, H, N, W) {
            W = W || {}, N *= 0.5;
            var R = (1 - N * 2) * Q, Y = Q * N, I = Y + R, P = I + Y, X;
            if (N < 0.5)
              X = "L 0 0 L " + Y + " " + -H + " L " + I + " " + -H + " L " + P + " 0";
            else
              X = "L 0 0 L " + I + " " + -H + " L " + P + " 0";
            var G = { label: "Trapezoid Body", position: { x: Z, y: D }, vertices: L.fromPath(X) };
            if (W.chamfer) {
              var V = W.chamfer;
              G.vertices = L.chamfer(G.vertices, V.radius, V.quality, V.qualityMin, V.qualityMax), delete W.chamfer;
            }
            return U.create(z.extend({}, G, W));
          }, E.circle = function(Z, D, Q, H, N) {
            H = H || {};
            var W = { label: "Circle Body", circleRadius: Q };
            N = N || 25;
            var R = Math.ceil(Math.max(10, Math.min(N, Q)));
            if (R % 2 === 1)
              R += 1;
            return E.polygon(Z, D, R, Q, z.extend({}, W, H));
          }, E.polygon = function(Z, D, Q, H, N) {
            if (N = N || {}, Q < 3)
              return E.circle(Z, D, H, N);
            var W = 2 * Math.PI / Q, R = "", Y = W * 0.5;
            for (var I = 0;I < Q; I += 1) {
              var P = Y + I * W, X = Math.cos(P) * H, G = Math.sin(P) * H;
              R += "L " + X.toFixed(3) + " " + G.toFixed(3) + " ";
            }
            var V = { label: "Polygon Body", position: { x: Z, y: D }, vertices: L.fromPath(R) };
            if (N.chamfer) {
              var A = N.chamfer;
              V.vertices = L.chamfer(V.vertices, A.radius, A.quality, A.qualityMin, A.qualityMax), delete N.chamfer;
            }
            return U.create(z.extend({}, V, N));
          }, E.fromVertices = function(Z, D, Q, H, N, W, R, Y) {
            var I = z.getDecomp(), P, X, G, V, A, F, j, T, C, v, O;
            if (P = Boolean(I && I.quickDecomp), H = H || {}, G = [], N = typeof N !== "undefined" ? N : false, W = typeof W !== "undefined" ? W : 0.01, R = typeof R !== "undefined" ? R : 10, Y = typeof Y !== "undefined" ? Y : 0.01, !z.isArray(Q[0]))
              Q = [Q];
            for (v = 0;v < Q.length; v += 1) {
              if (F = Q[v], V = L.isConvex(F), A = !V, A && !P)
                z.warnOnce("Bodies.fromVertices: Install the \'poly-decomp\' library and use Common.setDecomp or provide \'decomp\' as a global to decompose concave vertices.");
              if (V || !P) {
                if (V)
                  F = L.clockwiseSort(F);
                else
                  F = L.hull(F);
                G.push({ position: { x: Z, y: D }, vertices: F });
              } else {
                var q = F.map(function(d) {
                  return [d.x, d.y];
                });
                if (I.makeCCW(q), W !== false)
                  I.removeCollinearPoints(q, W);
                if (Y !== false && I.removeDuplicatePoints)
                  I.removeDuplicatePoints(q, Y);
                var w = I.quickDecomp(q);
                for (j = 0;j < w.length; j++) {
                  var g = w[j], b = g.map(function(d) {
                    return { x: d[0], y: d[1] };
                  });
                  if (R > 0 && L.area(b) < R)
                    continue;
                  G.push({ position: L.centre(b), vertices: b });
                }
              }
            }
            for (j = 0;j < G.length; j++)
              G[j] = U.create(z.extend(G[j], H));
            if (N) {
              var x = 5;
              for (j = 0;j < G.length; j++) {
                var k = G[j];
                for (T = j + 1;T < G.length; T++) {
                  var S = G[T];
                  if (K.overlaps(k.bounds, S.bounds)) {
                    var f = k.vertices, h = S.vertices;
                    for (C = 0;C < k.vertices.length; C++)
                      for (O = 0;O < S.vertices.length; O++) {
                        var m = J.magnitudeSquared(J.sub(f[(C + 1) % f.length], h[O])), y = J.magnitudeSquared(J.sub(f[C], h[(O + 1) % h.length]));
                        if (m < x && y < x)
                          f[C].isInternal = true, h[O].isInternal = true;
                      }
                  }
                }
              }
            }
            if (G.length > 1)
              return X = U.create(z.extend({ parts: G.slice(0) }, H)), U.setPosition(X, { x: Z, y: D }), X;
            else
              return G[0];
          }, E.flagCoincidentParts = function(Z, D) {
            if (D === undefined)
              D = 5;
            for (var Q = 0;Q < Z.length; Q++) {
              var H = Z[Q];
              for (var N = Q + 1;N < Z.length; N++) {
                var W = Z[N];
                if (K.overlaps(H.bounds, W.bounds)) {
                  var R = H.vertices, Y = W.vertices;
                  for (var I = 0;I < H.vertices.length; I++)
                    for (var P = 0;P < W.vertices.length; P++) {
                      var X = J.magnitudeSquared(J.sub(R[(I + 1) % R.length], Y[P])), G = J.magnitudeSquared(J.sub(R[I], Y[(P + 1) % Y.length]));
                      if (X < D && G < D)
                        R[I].isInternal = true, Y[P].isInternal = true;
                    }
                }
              }
            }
            return Z;
          };
        })();
      }, 74116: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(69351), z = $(48140), U = $(53402), K = $(22562), J = $(66280);
        (function() {
          E.stack = function(Z, D, Q, H, N, W, R) {
            var Y = L.create({ label: "Stack" }), I = Z, P = D, X, G = 0;
            for (var V = 0;V < H; V++) {
              var A = 0;
              for (var F = 0;F < Q; F++) {
                var j = R(I, P, F, V, X, G);
                if (j) {
                  var T = j.bounds.max.y - j.bounds.min.y, C = j.bounds.max.x - j.bounds.min.x;
                  if (T > A)
                    A = T;
                  K.translate(j, { x: C * 0.5, y: T * 0.5 }), I = j.bounds.max.x + N, L.addBody(Y, j), X = j, G += 1;
                } else
                  I += N;
              }
              P += A + W, I = Z;
            }
            return Y;
          }, E.chain = function(Z, D, Q, H, N, W) {
            var R = Z.bodies;
            for (var Y = 1;Y < R.length; Y++) {
              var I = R[Y - 1], P = R[Y], X = I.bounds.max.y - I.bounds.min.y, G = I.bounds.max.x - I.bounds.min.x, V = P.bounds.max.y - P.bounds.min.y, A = P.bounds.max.x - P.bounds.min.x, F = { bodyA: I, pointA: { x: G * D, y: X * Q }, bodyB: P, pointB: { x: A * H, y: V * N } }, j = U.extend(F, W);
              L.addConstraint(Z, z.create(j));
            }
            return Z.label += " Chain", Z;
          }, E.mesh = function(Z, D, Q, H, N) {
            var W = Z.bodies, R, Y, I, P, X;
            for (R = 0;R < Q; R++) {
              for (Y = 1;Y < D; Y++)
                I = W[Y - 1 + R * D], P = W[Y + R * D], L.addConstraint(Z, z.create(U.extend({ bodyA: I, bodyB: P }, N)));
              if (R > 0)
                for (Y = 0;Y < D; Y++) {
                  if (I = W[Y + (R - 1) * D], P = W[Y + R * D], L.addConstraint(Z, z.create(U.extend({ bodyA: I, bodyB: P }, N))), H && Y > 0)
                    X = W[Y - 1 + (R - 1) * D], L.addConstraint(Z, z.create(U.extend({ bodyA: X, bodyB: P }, N)));
                  if (H && Y < D - 1)
                    X = W[Y + 1 + (R - 1) * D], L.addConstraint(Z, z.create(U.extend({ bodyA: X, bodyB: P }, N)));
                }
            }
            return Z.label += " Mesh", Z;
          }, E.pyramid = function(Z, D, Q, H, N, W, R) {
            return E.stack(Z, D, Q, H, N, W, function(Y, I, P, X, G, V) {
              var A = Math.min(H, Math.ceil(Q / 2)), F = G ? G.bounds.max.x - G.bounds.min.x : 0;
              if (X > A)
                return;
              X = A - X;
              var j = X, T = Q - 1 - X;
              if (P < j || P > T)
                return;
              if (V === 1)
                K.translate(G, { x: (P + (Q % 2 === 1 ? 1 : -1)) * F, y: 0 });
              var C = G ? P * F : 0;
              return R(Z + C + P * N, I, P, X, G, V);
            });
          }, E.newtonsCradle = function(Z, D, Q, H, N) {
            var W = L.create({ label: "Newtons Cradle" });
            for (var R = 0;R < Q; R++) {
              var Y = 1.9, I = J.circle(Z + R * (H * Y), D + N, H, { inertia: Infinity, restitution: 1, friction: 0, frictionAir: 0.0001, slop: 1 }), P = z.create({ pointA: { x: Z + R * (H * Y), y: D }, bodyB: I });
              L.addBody(W, I), L.addConstraint(W, P);
            }
            return W;
          }, E.car = function(Z, D, Q, H, N) {
            var W = K.nextGroup(true), R = 20, Y = -Q * 0.5 + R, I = Q * 0.5 - R, P = 0, X = L.create({ label: "Car" }), G = J.rectangle(Z, D, Q, H, { collisionFilter: { group: W }, chamfer: { radius: H * 0.5 }, density: 0.0002 }), V = J.circle(Z + Y, D + P, N, { collisionFilter: { group: W }, friction: 0.8 }), A = J.circle(Z + I, D + P, N, { collisionFilter: { group: W }, friction: 0.8 }), F = z.create({ bodyB: G, pointB: { x: Y, y: P }, bodyA: V, stiffness: 1, length: 0 }), j = z.create({ bodyB: G, pointB: { x: I, y: P }, bodyA: A, stiffness: 1, length: 0 });
            return L.addBody(X, G), L.addBody(X, V), L.addBody(X, A), L.addConstraint(X, F), L.addConstraint(X, j), X;
          }, E.softBody = function(Z, D, Q, H, N, W, R, Y, I, P) {
            I = U.extend({ inertia: Infinity }, I), P = U.extend({ stiffness: 0.2, render: { type: "line", anchors: false } }, P);
            var X = E.stack(Z, D, Q, H, N, W, function(G, V) {
              return J.circle(G, V, Y, I);
            });
            return E.mesh(X, Q, H, R, P), X.label = "Soft Body", X;
          };
        })();
      }, 66615: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(31725), z = $(53402);
        (function() {
          E.fromVertices = function(U) {
            var K = {};
            for (var J = 0;J < U.length; J++) {
              var Z = (J + 1) % U.length, D = L.normalise({ x: U[Z].y - U[J].y, y: U[J].x - U[Z].x }), Q = D.y === 0 ? Infinity : D.x / D.y;
              Q = Q.toFixed(3).toString(), K[Q] = D;
            }
            return z.values(K);
          }, E.rotate = function(U, K) {
            if (K === 0)
              return;
            var J = Math.cos(K), Z = Math.sin(K);
            for (var D = 0;D < U.length; D++) {
              var Q = U[D], H;
              H = Q.x * J - Q.y * Z, Q.y = Q.x * Z + Q.y * J, Q.x = H;
            }
          };
        })();
      }, 15647: (M) => {
        var B = {};
        M.exports = B, function() {
          B.create = function($) {
            var E = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } };
            if ($)
              B.update(E, $);
            return E;
          }, B.update = function($, E, L) {
            $.min.x = Infinity, $.max.x = (-Infinity), $.min.y = Infinity, $.max.y = (-Infinity);
            for (var z = 0;z < E.length; z++) {
              var U = E[z];
              if (U.x > $.max.x)
                $.max.x = U.x;
              if (U.x < $.min.x)
                $.min.x = U.x;
              if (U.y > $.max.y)
                $.max.y = U.y;
              if (U.y < $.min.y)
                $.min.y = U.y;
            }
            if (L) {
              if (L.x > 0)
                $.max.x += L.x;
              else
                $.min.x += L.x;
              if (L.y > 0)
                $.max.y += L.y;
              else
                $.min.y += L.y;
            }
          }, B.contains = function($, E) {
            return E.x >= $.min.x && E.x <= $.max.x && E.y >= $.min.y && E.y <= $.max.y;
          }, B.overlaps = function($, E) {
            return $.min.x <= E.max.x && $.max.x >= E.min.x && $.max.y >= E.min.y && $.min.y <= E.max.y;
          }, B.translate = function($, E) {
            $.min.x += E.x, $.max.x += E.x, $.min.y += E.y, $.max.y += E.y;
          }, B.shift = function($, E) {
            var L = $.max.x - $.min.x, z = $.max.y - $.min.y;
            $.min.x = E.x, $.max.x = E.x + L, $.min.y = E.y, $.max.y = E.y + z;
          };
        }();
      }, 74058: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(15647), z = $(53402);
        (function() {
          E.pathToVertices = function(U, K) {
            if (typeof window !== "undefined" && !("SVGPathSeg" in window))
              z.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
            var J, Z, D, Q, H, N, W, R, Y, I, P = [], X, G, V = 0, A = 0, F = 0;
            K = K || 15;
            var j = function(C, v, O) {
              var q = O % 2 === 1 && O > 1;
              if (!Y || C != Y.x || v != Y.y) {
                if (Y && q)
                  X = Y.x, G = Y.y;
                else
                  X = 0, G = 0;
                var w = { x: X + C, y: G + v };
                if (q || !Y)
                  Y = w;
                P.push(w), A = X + C, F = G + v;
              }
            }, T = function(C) {
              var v = C.pathSegTypeAsLetter.toUpperCase();
              if (v === "Z")
                return;
              switch (v) {
                case "M":
                case "L":
                case "T":
                case "C":
                case "S":
                case "Q":
                  A = C.x, F = C.y;
                  break;
                case "H":
                  A = C.x;
                  break;
                case "V":
                  F = C.y;
                  break;
              }
              j(A, F, C.pathSegType);
            };
            E._svgPathToAbsolute(U), D = U.getTotalLength(), N = [];
            for (J = 0;J < U.pathSegList.numberOfItems; J += 1)
              N.push(U.pathSegList.getItem(J));
            W = N.concat();
            while (V < D) {
              if (I = U.getPathSegAtLength(V), H = N[I], H != R) {
                while (W.length && W[0] != H)
                  T(W.shift());
                R = H;
              }
              switch (H.pathSegTypeAsLetter.toUpperCase()) {
                case "C":
                case "T":
                case "S":
                case "Q":
                case "A":
                  Q = U.getPointAtLength(V), j(Q.x, Q.y, 0);
                  break;
              }
              V += K;
            }
            for (J = 0, Z = W.length;J < Z; ++J)
              T(W[J]);
            return P;
          }, E._svgPathToAbsolute = function(U) {
            var K, J, Z, D, Q, H, N = U.pathSegList, W = 0, R = 0, Y = N.numberOfItems;
            for (var I = 0;I < Y; ++I) {
              var P = N.getItem(I), X = P.pathSegTypeAsLetter;
              if (/[MLHVCSQTA]/.test(X)) {
                if ("x" in P)
                  W = P.x;
                if ("y" in P)
                  R = P.y;
              } else {
                if ("x1" in P)
                  Z = W + P.x1;
                if ("x2" in P)
                  Q = W + P.x2;
                if ("y1" in P)
                  D = R + P.y1;
                if ("y2" in P)
                  H = R + P.y2;
                if ("x" in P)
                  W += P.x;
                if ("y" in P)
                  R += P.y;
                switch (X) {
                  case "m":
                    N.replaceItem(U.createSVGPathSegMovetoAbs(W, R), I);
                    break;
                  case "l":
                    N.replaceItem(U.createSVGPathSegLinetoAbs(W, R), I);
                    break;
                  case "h":
                    N.replaceItem(U.createSVGPathSegLinetoHorizontalAbs(W), I);
                    break;
                  case "v":
                    N.replaceItem(U.createSVGPathSegLinetoVerticalAbs(R), I);
                    break;
                  case "c":
                    N.replaceItem(U.createSVGPathSegCurvetoCubicAbs(W, R, Z, D, Q, H), I);
                    break;
                  case "s":
                    N.replaceItem(U.createSVGPathSegCurvetoCubicSmoothAbs(W, R, Q, H), I);
                    break;
                  case "q":
                    N.replaceItem(U.createSVGPathSegCurvetoQuadraticAbs(W, R, Z, D), I);
                    break;
                  case "t":
                    N.replaceItem(U.createSVGPathSegCurvetoQuadraticSmoothAbs(W, R), I);
                    break;
                  case "a":
                    N.replaceItem(U.createSVGPathSegArcAbs(W, R, P.r1, P.r2, P.angle, P.largeArcFlag, P.sweepFlag), I);
                    break;
                  case "z":
                  case "Z":
                    W = K, R = J;
                    break;
                }
              }
              if (X == "M" || X == "m")
                K = W, J = R;
            }
          };
        })();
      }, 31725: (M) => {
        var B = {};
        M.exports = B, function() {
          B.create = function($, E) {
            return { x: $ || 0, y: E || 0 };
          }, B.clone = function($) {
            return { x: $.x, y: $.y };
          }, B.magnitude = function($) {
            return Math.sqrt($.x * $.x + $.y * $.y);
          }, B.magnitudeSquared = function($) {
            return $.x * $.x + $.y * $.y;
          }, B.rotate = function($, E, L) {
            var z = Math.cos(E), U = Math.sin(E);
            if (!L)
              L = {};
            var K = $.x * z - $.y * U;
            return L.y = $.x * U + $.y * z, L.x = K, L;
          }, B.rotateAbout = function($, E, L, z) {
            var U = Math.cos(E), K = Math.sin(E);
            if (!z)
              z = {};
            var J = L.x + (($.x - L.x) * U - ($.y - L.y) * K);
            return z.y = L.y + (($.x - L.x) * K + ($.y - L.y) * U), z.x = J, z;
          }, B.normalise = function($) {
            var E = B.magnitude($);
            if (E === 0)
              return { x: 0, y: 0 };
            return { x: $.x / E, y: $.y / E };
          }, B.dot = function($, E) {
            return $.x * E.x + $.y * E.y;
          }, B.cross = function($, E) {
            return $.x * E.y - $.y * E.x;
          }, B.cross3 = function($, E, L) {
            return (E.x - $.x) * (L.y - $.y) - (E.y - $.y) * (L.x - $.x);
          }, B.add = function($, E, L) {
            if (!L)
              L = {};
            return L.x = $.x + E.x, L.y = $.y + E.y, L;
          }, B.sub = function($, E, L) {
            if (!L)
              L = {};
            return L.x = $.x - E.x, L.y = $.y - E.y, L;
          }, B.mult = function($, E) {
            return { x: $.x * E, y: $.y * E };
          }, B.div = function($, E) {
            return { x: $.x / E, y: $.y / E };
          }, B.perp = function($, E) {
            return E = E === true ? -1 : 1, { x: E * -$.y, y: E * $.x };
          }, B.neg = function($) {
            return { x: -$.x, y: -$.y };
          }, B.angle = function($, E) {
            return Math.atan2(E.y - $.y, E.x - $.x);
          }, B._temp = [B.create(), B.create(), B.create(), B.create(), B.create(), B.create()];
        }();
      }, 41598: (M, B, $) => {
        var E = {};
        M.exports = E;
        var L = $(31725), z = $(53402);
        (function() {
          E.create = function(U, K) {
            var J = [];
            for (var Z = 0;Z < U.length; Z++) {
              var D = U[Z], Q = { x: D.x, y: D.y, index: Z, body: K, isInternal: false };
              J.push(Q);
            }
            return J;
          }, E.fromPath = function(U, K) {
            var J = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig, Z = [];
            return U.replace(J, function(D, Q, H) {
              Z.push({ x: parseFloat(Q), y: parseFloat(H) });
            }), E.create(Z, K);
          }, E.centre = function(U) {
            var K = E.area(U, true), J = { x: 0, y: 0 }, Z, D, Q;
            for (var H = 0;H < U.length; H++)
              Q = (H + 1) % U.length, Z = L.cross(U[H], U[Q]), D = L.mult(L.add(U[H], U[Q]), Z), J = L.add(J, D);
            return L.div(J, 6 * K);
          }, E.mean = function(U) {
            var K = { x: 0, y: 0 };
            for (var J = 0;J < U.length; J++)
              K.x += U[J].x, K.y += U[J].y;
            return L.div(K, U.length);
          }, E.area = function(U, K) {
            var J = 0, Z = U.length - 1;
            for (var D = 0;D < U.length; D++)
              J += (U[Z].x - U[D].x) * (U[Z].y + U[D].y), Z = D;
            if (K)
              return J / 2;
            return Math.abs(J) / 2;
          }, E.inertia = function(U, K) {
            var J = 0, Z = 0, D = U, Q, H;
            for (var N = 0;N < D.length; N++)
              H = (N + 1) % D.length, Q = Math.abs(L.cross(D[H], D[N])), J += Q * (L.dot(D[H], D[H]) + L.dot(D[H], D[N]) + L.dot(D[N], D[N])), Z += Q;
            return K / 6 * (J / Z);
          }, E.translate = function(U, K, J) {
            J = typeof J !== "undefined" ? J : 1;
            var Z = U.length, D = K.x * J, Q = K.y * J, H;
            for (H = 0;H < Z; H++)
              U[H].x += D, U[H].y += Q;
            return U;
          }, E.rotate = function(U, K, J) {
            if (K === 0)
              return;
            var Z = Math.cos(K), D = Math.sin(K), Q = J.x, H = J.y, N = U.length, W, R, Y, I;
            for (I = 0;I < N; I++)
              W = U[I], R = W.x - Q, Y = W.y - H, W.x = Q + (R * Z - Y * D), W.y = H + (R * D + Y * Z);
            return U;
          }, E.contains = function(U, K) {
            var { x: J, y: Z } = K, D = U.length, Q = U[D - 1], H;
            for (var N = 0;N < D; N++) {
              if (H = U[N], (J - Q.x) * (H.y - Q.y) + (Z - Q.y) * (Q.x - H.x) > 0)
                return false;
              Q = H;
            }
            return true;
          }, E.scale = function(U, K, J, Z) {
            if (K === 1 && J === 1)
              return U;
            Z = Z || E.centre(U);
            var D, Q;
            for (var H = 0;H < U.length; H++)
              D = U[H], Q = L.sub(D, Z), U[H].x = Z.x + Q.x * K, U[H].y = Z.y + Q.y * J;
            return U;
          }, E.chamfer = function(U, K, J, Z, D) {
            if (typeof K === "number")
              K = [K];
            else
              K = K || [8];
            J = typeof J !== "undefined" ? J : -1, Z = Z || 2, D = D || 14;
            var Q = [];
            for (var H = 0;H < U.length; H++) {
              var N = U[H - 1 >= 0 ? H - 1 : U.length - 1], W = U[H], R = U[(H + 1) % U.length], Y = K[H < K.length ? H : K.length - 1];
              if (Y === 0) {
                Q.push(W);
                continue;
              }
              var I = L.normalise({ x: W.y - N.y, y: N.x - W.x }), P = L.normalise({ x: R.y - W.y, y: W.x - R.x }), X = Math.sqrt(2 * Math.pow(Y, 2)), G = L.mult(z.clone(I), Y), V = L.normalise(L.mult(L.add(I, P), 0.5)), A = L.sub(W, L.mult(V, X)), F = J;
              if (J === -1)
                F = Math.pow(Y, 0.32) * 1.75;
              if (F = z.clamp(F, Z, D), F % 2 === 1)
                F += 1;
              var j = Math.acos(L.dot(I, P)), T = j / F;
              for (var C = 0;C < F; C++)
                Q.push(L.add(L.rotate(G, T * C), A));
            }
            return Q;
          }, E.clockwiseSort = function(U) {
            var K = E.mean(U);
            return U.sort(function(J, Z) {
              return L.angle(K, J) - L.angle(K, Z);
            }), U;
          }, E.isConvex = function(U) {
            var K = 0, J = U.length, Z, D, Q, H;
            if (J < 3)
              return null;
            for (Z = 0;Z < J; Z++) {
              if (D = (Z + 1) % J, Q = (Z + 2) % J, H = (U[D].x - U[Z].x) * (U[Q].y - U[D].y), H -= (U[D].y - U[Z].y) * (U[Q].x - U[D].x), H < 0)
                K |= 1;
              else if (H > 0)
                K |= 2;
              if (K === 3)
                return false;
            }
            if (K !== 0)
              return true;
            else
              return null;
          }, E.hull = function(U) {
            var K = [], J = [], Z, D;
            U = U.slice(0), U.sort(function(Q, H) {
              var N = Q.x - H.x;
              return N !== 0 ? N : Q.y - H.y;
            });
            for (D = 0;D < U.length; D += 1) {
              Z = U[D];
              while (J.length >= 2 && L.cross3(J[J.length - 2], J[J.length - 1], Z) <= 0)
                J.pop();
              J.push(Z);
            }
            for (D = U.length - 1;D >= 0; D -= 1) {
              Z = U[D];
              while (K.length >= 2 && L.cross3(K[K.length - 2], K[K.length - 1], Z) <= 0)
                K.pop();
              K.push(Z);
            }
            return K.pop(), J.pop(), K.concat(J);
          };
        })();
      }, 18210: (M, B, $) => {
        var E = $(19933), L = { name: "matter-attractors", version: "0.1.7", for: "matter-js@^0.19.0", silent: true, install: function(z) {
          z.after("Body.create", function() {
            L.Body.init(this);
          }), z.before("Engine.update", function(U) {
            L.Engine.update(U);
          });
        }, Body: { init: function(z) {
          z.plugin.attractors = z.plugin.attractors || [];
        } }, Engine: { update: function(z) {
          var U = E.Composite.allBodies(z.world);
          for (var K = 0;K < U.length; K++) {
            var J = U[K], Z = J.plugin.attractors;
            if (Z && Z.length > 0)
              for (var D = 0;D < U.length; D++) {
                var Q = U[D];
                if (K !== D)
                  for (var H = 0;H < Z.length; H++) {
                    var N = Z[H], W = N;
                    if (E.Common.isFunction(N))
                      W = N(J, Q);
                    if (W)
                      E.Body.applyForce(Q, Q.position, W);
                  }
              }
          }
        } }, Attractors: { gravityConstant: 0.001, gravity: function(z, U) {
          var K = E.Vector.sub(U.position, z.position), J = E.Vector.magnitudeSquared(K) || 0.0001, Z = E.Vector.normalise(K), D = -L.Attractors.gravityConstant * (z.mass * U.mass / J), Q = E.Vector.mult(Z, D);
          E.Body.applyForce(z, z.position, E.Vector.neg(Q)), E.Body.applyForce(U, U.position, Q);
        } } };
        M.exports = L;
      }, 40178: (M) => {
        var B = { name: "matter-collision-events", version: "0.1.6", for: "matter-js@^0.19.0", silent: true, install: function($) {
          $.after("Engine.create", function() {
            $.Events.on(this, "collisionStart", function(E) {
              E.pairs.map(function(L) {
                var { bodyA: z, bodyB: U } = L;
                if (z.gameObject)
                  z.gameObject.emit("collide", z, U, L);
                if (U.gameObject)
                  U.gameObject.emit("collide", U, z, L);
                if ($.Events.trigger(z, "onCollide", { pair: L }), $.Events.trigger(U, "onCollide", { pair: L }), z.onCollideCallback)
                  z.onCollideCallback(L);
                if (U.onCollideCallback)
                  U.onCollideCallback(L);
                if (z.onCollideWith[U.id])
                  z.onCollideWith[U.id](U, L);
                if (U.onCollideWith[z.id])
                  U.onCollideWith[z.id](z, L);
              });
            }), $.Events.on(this, "collisionActive", function(E) {
              E.pairs.map(function(L) {
                var { bodyA: z, bodyB: U } = L;
                if (z.gameObject)
                  z.gameObject.emit("collideActive", z, U, L);
                if (U.gameObject)
                  U.gameObject.emit("collideActive", U, z, L);
                if ($.Events.trigger(z, "onCollideActive", { pair: L }), $.Events.trigger(U, "onCollideActive", { pair: L }), z.onCollideActiveCallback)
                  z.onCollideActiveCallback(L);
                if (U.onCollideActiveCallback)
                  U.onCollideActiveCallback(L);
              });
            }), $.Events.on(this, "collisionEnd", function(E) {
              E.pairs.map(function(L) {
                var { bodyA: z, bodyB: U } = L;
                if (z.gameObject)
                  z.gameObject.emit("collideEnd", z, U, L);
                if (U.gameObject)
                  U.gameObject.emit("collideEnd", U, z, L);
                if ($.Events.trigger(z, "onCollideEnd", { pair: L }), $.Events.trigger(U, "onCollideEnd", { pair: L }), z.onCollideEndCallback)
                  z.onCollideEndCallback(L);
                if (U.onCollideEndCallback)
                  U.onCollideEndCallback(L);
              });
            });
          });
        } };
        M.exports = B;
      }, 74507: (M, B, $) => {
        var E = $(19933), L = { name: "matter-wrap", version: "0.1.4", for: "matter-js@^0.19.0", silent: true, install: function(z) {
          z.after("Engine.update", function() {
            L.Engine.update(this);
          });
        }, Engine: { update: function(z) {
          var U = z.world, K = E.Composite.allBodies(U), J = E.Composite.allComposites(U);
          for (var Z = 0;Z < K.length; Z += 1) {
            var D = K[Z];
            if (D.plugin.wrap)
              L.Body.wrap(D, D.plugin.wrap);
          }
          for (Z = 0;Z < J.length; Z += 1) {
            var Q = J[Z];
            if (Q.plugin.wrap)
              L.Composite.wrap(Q, Q.plugin.wrap);
          }
        } }, Bounds: { wrap: function(z, U) {
          var K = null, J = null;
          if (typeof U.min.x !== "undefined" && typeof U.max.x !== "undefined") {
            if (z.min.x > U.max.x)
              K = U.min.x - z.max.x;
            else if (z.max.x < U.min.x)
              K = U.max.x - z.min.x;
          }
          if (typeof U.min.y !== "undefined" && typeof U.max.y !== "undefined") {
            if (z.min.y > U.max.y)
              J = U.min.y - z.max.y;
            else if (z.max.y < U.min.y)
              J = U.max.y - z.min.y;
          }
          if (K !== null || J !== null)
            return { x: K || 0, y: J || 0 };
        } }, Body: { wrap: function(z, U) {
          var K = L.Bounds.wrap(z.bounds, U);
          if (K)
            E.Body.translate(z, K);
          return K;
        } }, Composite: { bounds: function(z) {
          var U = E.Composite.allBodies(z), K = [];
          for (var J = 0;J < U.length; J += 1) {
            var Z = U[J];
            K.push(Z.bounds.min, Z.bounds.max);
          }
          return E.Bounds.create(K);
        }, wrap: function(z, U) {
          var K = L.Bounds.wrap(L.Composite.bounds(z), U);
          if (K)
            E.Composite.translate(z, K);
          return K;
        } } };
        M.exports = L;
      }, 55973: (M) => {
        M.exports = { decomp: j, quickDecomp: O, isSimple: C, removeCollinearPoints: q, removeDuplicatePoints: w, makeCCW: R };
        function B(x, k, S) {
          S = S || 0;
          var f = [0, 0], h, m, y, d, p, u, s;
          if (h = x[1][1] - x[0][1], m = x[0][0] - x[1][0], y = h * x[0][0] + m * x[0][1], d = k[1][1] - k[0][1], p = k[0][0] - k[1][0], u = d * k[0][0] + p * k[0][1], s = h * p - d * m, !g(s, 0, S))
            f[0] = (p * y - m * u) / s, f[1] = (h * u - d * y) / s;
          return f;
        }
        function $(x, k, S, f) {
          var h = k[0] - x[0], m = k[1] - x[1], y = f[0] - S[0], d = f[1] - S[1];
          if (y * m - d * h === 0)
            return false;
          var p = (h * (S[1] - x[1]) + m * (x[0] - S[0])) / (y * m - d * h), u = (y * (x[1] - S[1]) + d * (S[0] - x[0])) / (d * h - y * m);
          return p >= 0 && p <= 1 && u >= 0 && u <= 1;
        }
        function E(x, k, S) {
          return (k[0] - x[0]) * (S[1] - x[1]) - (S[0] - x[0]) * (k[1] - x[1]);
        }
        function L(x, k, S) {
          return E(x, k, S) > 0;
        }
        function z(x, k, S) {
          return E(x, k, S) >= 0;
        }
        function U(x, k, S) {
          return E(x, k, S) < 0;
        }
        function K(x, k, S) {
          return E(x, k, S) <= 0;
        }
        var J = [], Z = [];
        function D(x, k, S, f) {
          if (!f)
            return E(x, k, S) === 0;
          else {
            var h = J, m = Z;
            h[0] = k[0] - x[0], h[1] = k[1] - x[1], m[0] = S[0] - k[0], m[1] = S[1] - k[1];
            var y = h[0] * m[0] + h[1] * m[1], d = Math.sqrt(h[0] * h[0] + h[1] * h[1]), p = Math.sqrt(m[0] * m[0] + m[1] * m[1]), u = Math.acos(y / (d * p));
            return u < f;
          }
        }
        function Q(x, k) {
          var S = k[0] - x[0], f = k[1] - x[1];
          return S * S + f * f;
        }
        function H(x, k) {
          var S = x.length;
          return x[k < 0 ? k % S + S : k % S];
        }
        function N(x) {
          x.length = 0;
        }
        function W(x, k, S, f) {
          for (var h = S;h < f; h++)
            x.push(k[h]);
        }
        function R(x) {
          var k = 0, S = x;
          for (var f = 1;f < x.length; ++f)
            if (S[f][1] < S[k][1] || S[f][1] === S[k][1] && S[f][0] > S[k][0])
              k = f;
          if (!L(H(x, k - 1), H(x, k), H(x, k + 1)))
            return Y(x), true;
          else
            return false;
        }
        function Y(x) {
          var k = [], S = x.length;
          for (var f = 0;f !== S; f++)
            k.push(x.pop());
          for (var f = 0;f !== S; f++)
            x[f] = k[f];
        }
        function I(x, k) {
          return U(H(x, k - 1), H(x, k), H(x, k + 1));
        }
        var P = [], X = [];
        function G(x, k, S) {
          var f, h, m = P, y = X;
          if (z(H(x, k + 1), H(x, k), H(x, S)) && K(H(x, k - 1), H(x, k), H(x, S)))
            return false;
          h = Q(H(x, k), H(x, S));
          for (var d = 0;d !== x.length; ++d) {
            if ((d + 1) % x.length === k || d === k)
              continue;
            if (z(H(x, k), H(x, S), H(x, d + 1)) && K(H(x, k), H(x, S), H(x, d))) {
              if (m[0] = H(x, k), m[1] = H(x, S), y[0] = H(x, d), y[1] = H(x, d + 1), f = B(m, y), Q(H(x, k), f) < h)
                return false;
            }
          }
          return true;
        }
        function V(x, k, S) {
          for (var f = 0;f !== x.length; ++f) {
            if (f === k || f === S || (f + 1) % x.length === k || (f + 1) % x.length === S)
              continue;
            if ($(H(x, k), H(x, S), H(x, f), H(x, f + 1)))
              return false;
          }
          return true;
        }
        function A(x, k, S, f) {
          var h = f || [];
          if (N(h), k < S)
            for (var m = k;m <= S; m++)
              h.push(x[m]);
          else {
            for (var m = 0;m <= S; m++)
              h.push(x[m]);
            for (var m = k;m < x.length; m++)
              h.push(x[m]);
          }
          return h;
        }
        function F(x) {
          var k = [], S = [], f = [], h = [], m = Number.MAX_VALUE;
          for (var y = 0;y < x.length; ++y)
            if (I(x, y)) {
              for (var d = 0;d < x.length; ++d)
                if (G(x, y, d)) {
                  S = F(A(x, y, d, h)), f = F(A(x, d, y, h));
                  for (var p = 0;p < f.length; p++)
                    S.push(f[p]);
                  if (S.length < m)
                    k = S, m = S.length, k.push([H(x, y), H(x, d)]);
                }
            }
          return k;
        }
        function j(x) {
          var k = F(x);
          if (k.length > 0)
            return T(x, k);
          else
            return [x];
        }
        function T(x, k) {
          if (k.length === 0)
            return [x];
          if (k instanceof Array && k.length && k[0] instanceof Array && k[0].length === 2 && k[0][0] instanceof Array) {
            var S = [x];
            for (var f = 0;f < k.length; f++) {
              var h = k[f];
              for (var m = 0;m < S.length; m++) {
                var y = S[m], d = T(y, h);
                if (d) {
                  S.splice(m, 1), S.push(d[0], d[1]);
                  break;
                }
              }
            }
            return S;
          } else {
            var h = k, f = x.indexOf(h[0]), m = x.indexOf(h[1]);
            if (f !== -1 && m !== -1)
              return [A(x, f, m), A(x, m, f)];
            else
              return false;
          }
        }
        function C(x) {
          var k = x, S;
          for (S = 0;S < k.length - 1; S++)
            for (var f = 0;f < S - 1; f++)
              if ($(k[S], k[S + 1], k[f], k[f + 1]))
                return false;
          for (S = 1;S < k.length - 2; S++)
            if ($(k[0], k[k.length - 1], k[S], k[S + 1]))
              return false;
          return true;
        }
        function v(x, k, S, f, h) {
          h = h || 0;
          var m = k[1] - x[1], y = x[0] - k[0], d = m * x[0] + y * x[1], p = f[1] - S[1], u = S[0] - f[0], s = p * S[0] + u * S[1], c = m * u - p * y;
          if (!g(c, 0, h))
            return [(u * d - y * s) / c, (m * s - p * d) / c];
          else
            return [0, 0];
        }
        function O(x, k, S, f, h, m, y) {
          m = m || 100, y = y || 0, h = h || 25, k = typeof k !== "undefined" ? k : [], S = S || [], f = f || [];
          var d = [0, 0], p = [0, 0], u = [0, 0], s = 0, c = 0, n = 0, _ = 0, l = 0, i = 0, t = 0, $0 = [], e = [], o = x, r = x;
          if (r.length < 3)
            return k;
          if (y++, y > m)
            return console.warn("quickDecomp: max level (" + m + ") reached."), k;
          for (var a = 0;a < x.length; ++a)
            if (I(o, a)) {
              S.push(o[a]), s = c = Number.MAX_VALUE;
              for (var J0 = 0;J0 < x.length; ++J0) {
                if (L(H(o, a - 1), H(o, a), H(o, J0)) && K(H(o, a - 1), H(o, a), H(o, J0 - 1))) {
                  if (u = v(H(o, a - 1), H(o, a), H(o, J0), H(o, J0 - 1)), U(H(o, a + 1), H(o, a), u)) {
                    if (n = Q(o[a], u), n < c)
                      c = n, p = u, i = J0;
                  }
                }
                if (L(H(o, a + 1), H(o, a), H(o, J0 + 1)) && K(H(o, a + 1), H(o, a), H(o, J0))) {
                  if (u = v(H(o, a + 1), H(o, a), H(o, J0), H(o, J0 + 1)), L(H(o, a - 1), H(o, a), u)) {
                    if (n = Q(o[a], u), n < s)
                      s = n, d = u, l = J0;
                  }
                }
              }
              if (i === (l + 1) % x.length)
                if (u[0] = (p[0] + d[0]) / 2, u[1] = (p[1] + d[1]) / 2, f.push(u), a < l) {
                  if (W($0, o, a, l + 1), $0.push(u), e.push(u), i !== 0)
                    W(e, o, i, o.length);
                  W(e, o, 0, a + 1);
                } else {
                  if (a !== 0)
                    W($0, o, a, o.length);
                  W($0, o, 0, l + 1), $0.push(u), e.push(u), W(e, o, i, a + 1);
                }
              else {
                if (i > l)
                  l += x.length;
                if (_ = Number.MAX_VALUE, l < i)
                  return k;
                for (var J0 = i;J0 <= l; ++J0)
                  if (z(H(o, a - 1), H(o, a), H(o, J0)) && K(H(o, a + 1), H(o, a), H(o, J0))) {
                    if (n = Q(H(o, a), H(o, J0)), n < _ && V(o, a, J0))
                      _ = n, t = J0 % x.length;
                  }
                if (a < t) {
                  if (W($0, o, a, t + 1), t !== 0)
                    W(e, o, t, r.length);
                  W(e, o, 0, a + 1);
                } else {
                  if (a !== 0)
                    W($0, o, a, r.length);
                  W($0, o, 0, t + 1), W(e, o, t, a + 1);
                }
              }
              if ($0.length < e.length)
                O($0, k, S, f, h, m, y), O(e, k, S, f, h, m, y);
              else
                O(e, k, S, f, h, m, y), O($0, k, S, f, h, m, y);
              return k;
            }
          return k.push(x), k;
        }
        function q(x, k) {
          var S = 0;
          for (var f = x.length - 1;x.length > 3 && f >= 0; --f)
            if (D(H(x, f - 1), H(x, f), H(x, f + 1), k))
              x.splice(f % x.length, 1), S++;
          return S;
        }
        function w(x, k) {
          for (var S = x.length - 1;S >= 1; --S) {
            var f = x[S];
            for (var h = S - 1;h >= 0; --h)
              if (b(f, x[h], k)) {
                x.splice(S, 1);
                continue;
              }
          }
        }
        function g(x, k, S) {
          return S = S || 0, Math.abs(x - k) <= S;
        }
        function b(x, k, S) {
          return g(x[0], k[0], S) && g(x[1], k[1], S);
        }
      }, 52018: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U) {
          this.pluginManager = U, this.game = U.game;
        }, init: function() {
        }, start: function() {
        }, stop: function() {
        }, destroy: function() {
          this.pluginManager = null, this.game = null, this.scene = null, this.systems = null;
        } });
        M.exports = L;
      }, 42363: (M) => {
        var B = { Global: ["game", "anims", "cache", "plugins", "registry", "scale", "sound", "textures", "renderer"], CoreScene: ["EventEmitter", "CameraManager", "GameObjectCreator", "GameObjectFactory", "ScenePlugin", "DisplayList", "UpdateList"], DefaultScene: ["Clock", "DataManagerPlugin", "InputPlugin", "Loader", "TweenManager", "LightsPlugin"] };
        M.exports = B;
      }, 37277: (M) => {
        var B = {}, $ = {}, E = {};
        E.register = function(L, z, U, K) {
          if (K === undefined)
            K = false;
          B[L] = { plugin: z, mapping: U, custom: K };
        }, E.registerCustom = function(L, z, U, K) {
          $[L] = { plugin: z, mapping: U, data: K };
        }, E.hasCore = function(L) {
          return B.hasOwnProperty(L);
        }, E.hasCustom = function(L) {
          return $.hasOwnProperty(L);
        }, E.getCore = function(L) {
          return B[L];
        }, E.getCustom = function(L) {
          return $[L];
        }, E.getCustomClass = function(L) {
          return $.hasOwnProperty(L) ? $[L].plugin : null;
        }, E.remove = function(L) {
          if (B.hasOwnProperty(L))
            delete B[L];
        }, E.removeCustom = function(L) {
          if ($.hasOwnProperty(L))
            delete $[L];
        }, E.destroyCorePlugins = function() {
          for (var L in B)
            if (B.hasOwnProperty(L))
              delete B[L];
        }, E.destroyCustomPlugins = function() {
          for (var L in $)
            if ($.hasOwnProperty(L))
              delete $[L];
        }, M.exports = E;
      }, 77332: (M, B, $) => {
        var E = $(83419), L = $(8443), z = $(50792), U = $(74099), K = $(44603), J = $(39429), Z = $(95540), D = $(37277), Q = $(72905), H = new E({ Extends: z, initialize: function N(W) {
          if (z.call(this), this.game = W, this.plugins = [], this.scenePlugins = [], this._pendingGlobal = [], this._pendingScene = [], W.isBooted)
            this.boot();
          else
            W.events.once(L.BOOT, this.boot, this);
        }, boot: function() {
          var N, W, R, Y, I, P, X, G = this.game.config, V = G.installGlobalPlugins;
          V = V.concat(this._pendingGlobal);
          for (N = 0;N < V.length; N++)
            if (W = V[N], R = Z(W, "key", null), Y = Z(W, "plugin", null), I = Z(W, "start", false), P = Z(W, "mapping", null), X = Z(W, "data", null), R)
              if (Y)
                this.install(R, Y, I, P, X);
              else
                console.warn("Missing `plugin` for key: " + R);
          V = G.installScenePlugins, V = V.concat(this._pendingScene);
          for (N = 0;N < V.length; N++)
            if (W = V[N], R = Z(W, "key", null), Y = Z(W, "plugin", null), P = Z(W, "mapping", null), R)
              if (Y)
                this.installScenePlugin(R, Y, P);
              else
                console.warn("Missing `plugin` for key: " + R);
          this._pendingGlobal = [], this._pendingScene = [], this.game.events.once(L.DESTROY, this.destroy, this);
        }, addToScene: function(N, W, R) {
          var Y, I, P, X = this.game, G = N.scene, V = N.settings.map, A = N.settings.isBooted;
          for (Y = 0;Y < W.length; Y++)
            if (I = W[Y], X[I]) {
              if (N[I] = X[I], V.hasOwnProperty(I))
                G[V[I]] = N[I];
            } else if (I === "game" && V.hasOwnProperty(I))
              G[V[I]] = X;
          for (var F = 0;F < R.length; F++) {
            P = R[F];
            for (Y = 0;Y < P.length; Y++) {
              if (I = P[Y], !D.hasCore(I))
                continue;
              var j = D.getCore(I), T = j.mapping, C = new j.plugin(G, this, T);
              if (N[T] = C, j.custom)
                G[T] = C;
              else if (V.hasOwnProperty(T))
                G[V[T]] = C;
              if (A)
                C.boot();
            }
          }
          P = this.plugins;
          for (Y = 0;Y < P.length; Y++) {
            var v = P[Y];
            if (v.mapping)
              G[v.mapping] = v.plugin;
          }
        }, getDefaultScenePlugins: function() {
          var N = this.game.config.defaultPlugins;
          return N = N.concat(this.scenePlugins), N;
        }, installScenePlugin: function(N, W, R, Y, I) {
          if (I === undefined)
            I = false;
          if (typeof W !== "function") {
            console.warn("Invalid Scene Plugin: " + N);
            return;
          }
          if (!D.hasCore(N))
            D.register(N, W, R, true);
          if (this.scenePlugins.indexOf(N) === -1)
            this.scenePlugins.push(N);
          else if (!I && D.hasCore(N)) {
            console.warn("Scene Plugin key in use: " + N);
            return;
          }
          if (Y) {
            var P = new W(Y, this, N);
            if (Y.sys[N] = P, R && R !== "")
              Y[R] = P;
            P.boot();
          }
        }, install: function(N, W, R, Y, I) {
          if (R === undefined)
            R = false;
          if (Y === undefined)
            Y = null;
          if (I === undefined)
            I = null;
          if (typeof W !== "function")
            return console.warn("Invalid Plugin: " + N), null;
          if (D.hasCustom(N))
            return console.warn("Plugin key in use: " + N), null;
          if (Y !== null)
            R = true;
          if (!this.game.isBooted)
            this._pendingGlobal.push({ key: N, plugin: W, start: R, mapping: Y, data: I });
          else if (D.registerCustom(N, W, Y, I), R)
            return this.start(N);
          return null;
        }, getIndex: function(N) {
          var W = this.plugins;
          for (var R = 0;R < W.length; R++) {
            var Y = W[R];
            if (Y.key === N)
              return R;
          }
          return -1;
        }, getEntry: function(N) {
          var W = this.getIndex(N);
          if (W !== -1)
            return this.plugins[W];
        }, isActive: function(N) {
          var W = this.getEntry(N);
          return W && W.active;
        }, start: function(N, W) {
          if (W === undefined)
            W = N;
          var R = this.getEntry(W);
          if (R && !R.active)
            R.active = true, R.plugin.start();
          else if (!R)
            R = this.createEntry(N, W);
          return R ? R.plugin : null;
        }, createEntry: function(N, W) {
          var R = D.getCustom(N);
          if (R) {
            var Y = new R.plugin(this);
            R = { key: W, plugin: Y, active: true, mapping: R.mapping, data: R.data }, this.plugins.push(R), Y.init(R.data), Y.start();
          }
          return R;
        }, stop: function(N) {
          var W = this.getEntry(N);
          if (W && W.active)
            W.active = false, W.plugin.stop();
          return this;
        }, get: function(N, W) {
          if (W === undefined)
            W = true;
          var R = this.getEntry(N);
          if (R)
            return R.plugin;
          else {
            var Y = this.getClass(N);
            if (Y && W)
              return R = this.createEntry(N, N), R ? R.plugin : null;
            else if (Y)
              return Y;
          }
          return null;
        }, getClass: function(N) {
          return D.getCustomClass(N);
        }, removeGlobalPlugin: function(N) {
          var W = this.getEntry(N);
          if (W)
            Q(this.plugins, W);
          D.removeCustom(N);
        }, removeScenePlugin: function(N) {
          Q(this.scenePlugins, N), D.remove(N);
        }, registerGameObject: function(N, W, R) {
          if (W)
            J.register(N, W);
          if (R)
            K.register(N, R);
          return this;
        }, removeGameObject: function(N, W, R) {
          if (W === undefined)
            W = true;
          if (R === undefined)
            R = true;
          if (W)
            J.remove(N);
          if (R)
            K.remove(N);
          return this;
        }, registerFileType: function(N, W, R) {
          if (U.register(N, W), R && R.sys.load)
            R.sys.load[N] = W;
        }, destroy: function() {
          for (var N = 0;N < this.plugins.length; N++)
            this.plugins[N].plugin.destroy();
          if (D.destroyCustomPlugins(), this.game.noReturn)
            D.destroyCorePlugins();
          this.game = null, this.plugins = [], this.scenePlugins = [];
        } });
        M.exports = H;
      }, 45145: (M, B, $) => {
        var E = $(52018), L = $(83419), z = $(44594), U = new L({ Extends: E, initialize: function K(J, Z, D) {
          E.call(this, Z), this.scene = J, this.systems = J.sys, this.pluginKey = D, J.sys.events.once(z.BOOT, this.boot, this);
        }, boot: function() {
        }, destroy: function() {
          this.pluginManager = null, this.game = null, this.scene = null, this.systems = null;
        } });
        M.exports = U;
      }, 18922: (M, B, $) => {
        M.exports = { BasePlugin: $(52018), DefaultPlugins: $(42363), PluginCache: $(37277), PluginManager: $(77332), ScenePlugin: $(45145) };
      }, 63595: () => {
        if (HTMLVideoElement && !("requestVideoFrameCallback" in HTMLVideoElement.prototype) && "getVideoPlaybackQuality" in HTMLVideoElement.prototype)
          HTMLVideoElement.prototype._rvfcpolyfillmap = {}, HTMLVideoElement.prototype.requestVideoFrameCallback = function(M) {
            const B = performance.now(), $ = this.getVideoPlaybackQuality(), E = this.mozPresentedFrames || this.mozPaintedFrames || $.totalVideoFrames - $.droppedVideoFrames, L = (z, U) => {
              const K = this.getVideoPlaybackQuality(), J = this.mozPresentedFrames || this.mozPaintedFrames || K.totalVideoFrames - K.droppedVideoFrames;
              if (J > E) {
                const Z = this.mozFrameDelay || K.totalFrameDelay - $.totalFrameDelay || 0, D = U - z;
                M(U, { presentationTime: U + Z * 1000, expectedDisplayTime: U + D, width: this.videoWidth, height: this.videoHeight, mediaTime: Math.max(0, this.currentTime || 0) + D / 1000, presentedFrames: J, processingDuration: Z }), delete this._rvfcpolyfillmap[B];
              } else
                this._rvfcpolyfillmap[B] = requestAnimationFrame((Z) => L(U, Z));
            };
            return this._rvfcpolyfillmap[B] = requestAnimationFrame((z) => L(B, z)), B;
          }, HTMLVideoElement.prototype.cancelVideoFrameCallback = function(M) {
            cancelAnimationFrame(this._rvfcpolyfillmap[M]), delete this._rvfcpolyfillmap[M];
          };
      }, 10312: (M) => {
        M.exports = { SKIP_CHECK: -1, NORMAL: 0, ADD: 1, MULTIPLY: 2, SCREEN: 3, OVERLAY: 4, DARKEN: 5, LIGHTEN: 6, COLOR_DODGE: 7, COLOR_BURN: 8, HARD_LIGHT: 9, SOFT_LIGHT: 10, DIFFERENCE: 11, EXCLUSION: 12, HUE: 13, SATURATION: 14, COLOR: 15, LUMINOSITY: 16, ERASE: 17, SOURCE_IN: 18, SOURCE_OUT: 19, SOURCE_ATOP: 20, DESTINATION_OVER: 21, DESTINATION_IN: 22, DESTINATION_OUT: 23, DESTINATION_ATOP: 24, LIGHTER: 25, COPY: 26, XOR: 27 };
      }, 29795: (M) => {
        var B = { DEFAULT: 0, LINEAR: 0, NEAREST: 1 };
        M.exports = B;
      }, 68627: (M, B, $) => {
        var E = $(19715), L = $(32880), z = $(83419), U = $(8054), K = $(50792), J = $(92503), Z = $(56373), D = $(97480), Q = $(69442), H = $(61340), N = new z({ Extends: K, initialize: function W(R) {
          K.call(this);
          var Y = R.config;
          this.config = { clearBeforeRender: Y.clearBeforeRender, backgroundColor: Y.backgroundColor, antialias: Y.antialias, roundPixels: Y.roundPixels }, this.game = R, this.type = U.CANVAS, this.drawCount = 0, this.width = 0, this.height = 0, this.gameCanvas = R.canvas;
          var I = { alpha: R.config.transparent, desynchronized: R.config.desynchronized, willReadFrequently: false };
          this.gameContext = Y.context ? Y.context : this.gameCanvas.getContext("2d", I), this.currentContext = this.gameContext, this.antialias = R.config.antialias, this.blendModes = Z(), this.snapshotState = { x: 0, y: 0, width: 1, height: 1, getPixel: false, callback: null, type: "image/png", encoder: 0.92 }, this._tempMatrix1 = new H, this._tempMatrix2 = new H, this._tempMatrix3 = new H, this.isBooted = false, this.init();
        }, init: function() {
          this.game.textures.once(Q.READY, this.boot, this);
        }, boot: function() {
          var W = this.game, R = W.scale.baseSize;
          this.width = R.width, this.height = R.height, this.isBooted = true, W.scale.on(D.RESIZE, this.onResize, this), this.resize(R.width, R.height);
        }, onResize: function(W, R) {
          if (R.width !== this.width || R.height !== this.height)
            this.resize(R.width, R.height);
        }, resize: function(W, R) {
          this.width = W, this.height = R, this.emit(J.RESIZE, W, R);
        }, resetTransform: function() {
          this.currentContext.setTransform(1, 0, 0, 1, 0, 0);
        }, setBlendMode: function(W) {
          return this.currentContext.globalCompositeOperation = W, this;
        }, setContext: function(W) {
          return this.currentContext = W ? W : this.gameContext, this;
        }, setAlpha: function(W) {
          return this.currentContext.globalAlpha = W, this;
        }, preRender: function() {
          var W = this.gameContext, R = this.config, Y = this.width, I = this.height;
          if (W.globalAlpha = 1, W.globalCompositeOperation = "source-over", W.setTransform(1, 0, 0, 1, 0, 0), R.clearBeforeRender) {
            if (W.clearRect(0, 0, Y, I), !R.transparent)
              W.fillStyle = R.backgroundColor.rgba, W.fillRect(0, 0, Y, I);
          }
          W.save(), this.drawCount = 0, this.emit(J.PRE_RENDER);
        }, render: function(W, R, Y) {
          var I = R.length;
          this.emit(J.RENDER, W, Y);
          var { x: P, y: X, width: G, height: V } = Y, A = Y.renderToTexture ? Y.context : W.sys.context;
          if (A.save(), this.game.scene.customViewports)
            A.beginPath(), A.rect(P, X, G, V), A.clip();
          Y.emit(E.PRE_RENDER, Y), this.currentContext = A;
          var F = Y.mask;
          if (F)
            F.preRenderCanvas(this, null, Y._maskCamera);
          if (!Y.transparent)
            A.fillStyle = Y.backgroundColor.rgba, A.fillRect(P, X, G, V);
          if (A.globalAlpha = Y.alpha, A.globalCompositeOperation = "source-over", this.drawCount += I, Y.renderToTexture)
            Y.emit(E.PRE_RENDER, Y);
          Y.matrix.copyToContext(A);
          for (var j = 0;j < I; j++) {
            var T = R[j];
            if (T.mask)
              T.mask.preRenderCanvas(this, T, Y);
            if (T.renderCanvas(this, T, Y), T.mask)
              T.mask.postRenderCanvas(this, T, Y);
          }
          if (A.setTransform(1, 0, 0, 1, 0, 0), A.globalCompositeOperation = "source-over", A.globalAlpha = 1, Y.flashEffect.postRenderCanvas(A), Y.fadeEffect.postRenderCanvas(A), Y.dirty = false, F)
            F.postRenderCanvas(this);
          if (A.restore(), Y.renderToTexture) {
            if (Y.emit(E.POST_RENDER, Y), Y.renderToGame)
              W.sys.context.drawImage(Y.canvas, P, X);
          }
          Y.emit(E.POST_RENDER, Y);
        }, postRender: function() {
          var W = this.gameContext;
          W.restore(), this.emit(J.POST_RENDER);
          var R = this.snapshotState;
          if (R.callback)
            L(this.gameCanvas, R), R.callback = null;
        }, snapshotCanvas: function(W, R, Y, I, P, X, G, V, A) {
          if (Y === undefined)
            Y = false;
          this.snapshotArea(I, P, X, G, R, V, A);
          var F = this.snapshotState;
          return F.getPixel = Y, L(W, F), F.callback = null, this;
        }, snapshot: function(W, R, Y) {
          return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, W, R, Y);
        }, snapshotArea: function(W, R, Y, I, P, X, G) {
          var V = this.snapshotState;
          return V.callback = P, V.type = X, V.encoder = G, V.getPixel = false, V.x = W, V.y = R, V.width = Math.min(Y, this.gameCanvas.width), V.height = Math.min(I, this.gameCanvas.height), this;
        }, snapshotPixel: function(W, R, Y) {
          return this.snapshotArea(W, R, 1, 1, Y), this.snapshotState.getPixel = true, this;
        }, batchSprite: function(W, R, Y, I) {
          var P = Y.alpha * W.alpha;
          if (P === 0)
            return;
          var X = this.currentContext, G = this._tempMatrix1, V = this._tempMatrix2, A = R.canvasData, F = A.x, j = A.y, T = R.cutWidth, C = R.cutHeight, v = R.customPivot, O = R.source.resolution, q = W.displayOriginX, w = W.displayOriginY, g = -q + R.x, b = -w + R.y;
          if (W.isCropped) {
            var x = W._crop;
            if (x.flipX !== W.flipX || x.flipY !== W.flipY)
              R.updateCropUVs(x, W.flipX, W.flipY);
            if (T = x.cw, C = x.ch, F = x.cx, j = x.cy, g = -q + x.x, b = -w + x.y, W.flipX) {
              if (g >= 0)
                g = -(g + T);
              else if (g < 0)
                g = Math.abs(g) - T;
            }
            if (W.flipY) {
              if (b >= 0)
                b = -(b + C);
              else if (b < 0)
                b = Math.abs(b) - C;
            }
          }
          var k = 1, S = 1;
          if (W.flipX) {
            if (!v)
              g += -R.realWidth + q * 2;
            k = -1;
          }
          if (W.flipY) {
            if (!v)
              b += -R.realHeight + w * 2;
            S = -1;
          }
          var { x: f, y: h } = W;
          if (V.applyITRS(f, h, W.rotation, W.scaleX * k, W.scaleY * S), G.copyFrom(Y.matrix), I)
            G.multiplyWithOffset(I, -Y.scrollX * W.scrollFactorX, -Y.scrollY * W.scrollFactorY), V.e = f, V.f = h;
          else
            V.e -= Y.scrollX * W.scrollFactorX, V.f -= Y.scrollY * W.scrollFactorY;
          if (G.multiply(V), Y.roundPixels)
            G.e = Math.round(G.e), G.f = Math.round(G.f);
          if (X.save(), G.setToContext(X), X.globalCompositeOperation = this.blendModes[W.blendMode], X.globalAlpha = P, X.imageSmoothingEnabled = !R.source.scaleMode, W.mask)
            W.mask.preRenderCanvas(this, W, Y);
          if (T > 0 && C > 0)
            if (Y.roundPixels)
              X.drawImage(R.source.image, F, j, T, C, Math.round(g), Math.round(b), Math.round(T / O), Math.round(C / O));
            else
              X.drawImage(R.source.image, F, j, T, C, g, b, T / O, C / O);
          if (W.mask)
            W.mask.postRenderCanvas(this, W, Y);
          X.restore();
        }, destroy: function() {
          this.removeAllListeners(), this.game = null, this.gameCanvas = null, this.gameContext = null;
        } });
        M.exports = N;
      }, 55830: (M, B, $) => {
        M.exports = { CanvasRenderer: $(68627), GetBlendModes: $(56373), SetTransform: $(20926) };
      }, 56373: (M, B, $) => {
        var E = $(10312), L = $(89289), z = function() {
          var U = [], K = L.supportNewBlendModes, J = "source-over";
          return U[E.NORMAL] = J, U[E.ADD] = "lighter", U[E.MULTIPLY] = K ? "multiply" : J, U[E.SCREEN] = K ? "screen" : J, U[E.OVERLAY] = K ? "overlay" : J, U[E.DARKEN] = K ? "darken" : J, U[E.LIGHTEN] = K ? "lighten" : J, U[E.COLOR_DODGE] = K ? "color-dodge" : J, U[E.COLOR_BURN] = K ? "color-burn" : J, U[E.HARD_LIGHT] = K ? "hard-light" : J, U[E.SOFT_LIGHT] = K ? "soft-light" : J, U[E.DIFFERENCE] = K ? "difference" : J, U[E.EXCLUSION] = K ? "exclusion" : J, U[E.HUE] = K ? "hue" : J, U[E.SATURATION] = K ? "saturation" : J, U[E.COLOR] = K ? "color" : J, U[E.LUMINOSITY] = K ? "luminosity" : J, U[E.ERASE] = "destination-out", U[E.SOURCE_IN] = "source-in", U[E.SOURCE_OUT] = "source-out", U[E.SOURCE_ATOP] = "source-atop", U[E.DESTINATION_OVER] = "destination-over", U[E.DESTINATION_IN] = "destination-in", U[E.DESTINATION_OUT] = "destination-out", U[E.DESTINATION_ATOP] = "destination-atop", U[E.LIGHTER] = "lighter", U[E.COPY] = "copy", U[E.XOR] = "xor", U;
        };
        M.exports = z;
      }, 20926: (M, B, $) => {
        var E = $(91296), L = function(z, U, K, J, Z) {
          var D = J.alpha * K.alpha;
          if (D <= 0)
            return false;
          var Q = E(K, J, Z).calc;
          return U.globalCompositeOperation = z.blendModes[K.blendMode], U.globalAlpha = D, U.save(), Q.setToContext(U), U.imageSmoothingEnabled = K.frame ? !K.frame.source.scaleMode : z.antialias, true;
        };
        M.exports = L;
      }, 63899: (M) => {
        M.exports = "losewebgl";
      }, 6119: (M) => {
        M.exports = "postrender";
      }, 48070: (M) => {
        M.exports = "prerender";
      }, 15640: (M) => {
        M.exports = "render";
      }, 8912: (M) => {
        M.exports = "resize";
      }, 87124: (M) => {
        M.exports = "restorewebgl";
      }, 92503: (M, B, $) => {
        M.exports = { LOSE_WEBGL: $(63899), POST_RENDER: $(6119), PRE_RENDER: $(48070), RENDER: $(15640), RESIZE: $(8912), RESTORE_WEBGL: $(87124) };
      }, 36909: (M, B, $) => {
        M.exports = { Events: $(92503), Snapshot: $(89966) }, M.exports.Canvas = $(55830), M.exports.WebGL = $(4159);
      }, 32880: (M, B, $) => {
        var E = $(27919), L = $(40987), z = $(95540), U = function(K, J) {
          var Z = z(J, "callback"), D = z(J, "type", "image/png"), Q = z(J, "encoder", 0.92), H = Math.abs(Math.round(z(J, "x", 0))), N = Math.abs(Math.round(z(J, "y", 0))), W = Math.floor(z(J, "width", K.width)), R = Math.floor(z(J, "height", K.height)), Y = z(J, "getPixel", false);
          if (Y) {
            var I = K.getContext("2d", { willReadFrequently: false }), P = I.getImageData(H, N, 1, 1), X = P.data;
            Z.call(null, new L(X[0], X[1], X[2], X[3]));
          } else if (H !== 0 || N !== 0 || W !== K.width || R !== K.height) {
            var G = E.createWebGL(this, W, R), V = G.getContext("2d", { willReadFrequently: true });
            if (W > 0 && R > 0)
              V.drawImage(K, H, N, W, R, 0, 0, W, R);
            var A = new Image;
            A.onerror = function() {
              Z.call(null), E.remove(G);
            }, A.onload = function() {
              Z.call(null, A), E.remove(G);
            }, A.src = G.toDataURL(D, Q);
          } else {
            var F = new Image;
            F.onerror = function() {
              Z.call(null);
            }, F.onload = function() {
              Z.call(null, F);
            }, F.src = K.toDataURL(D, Q);
          }
        };
        M.exports = U;
      }, 88815: (M, B, $) => {
        var E = $(27919), L = $(40987), z = $(95540), U = function(K, J) {
          var Z = K, D = z(J, "callback"), Q = z(J, "type", "image/png"), H = z(J, "encoder", 0.92), N = Math.abs(Math.round(z(J, "x", 0))), W = Math.abs(Math.round(z(J, "y", 0))), R = z(J, "getPixel", false), Y = z(J, "isFramebuffer", false), I = Y ? z(J, "bufferWidth", 1) : Z.drawingBufferWidth, P = Y ? z(J, "bufferHeight", 1) : Z.drawingBufferHeight;
          if (R) {
            var X = new Uint8Array(4), G = Y ? W : P - W;
            Z.readPixels(N, G, 1, 1, Z.RGBA, Z.UNSIGNED_BYTE, X), D.call(null, new L(X[0], X[1], X[2], X[3]));
          } else {
            var V = Math.floor(z(J, "width", I)), A = Math.floor(z(J, "height", P)), F = V * A * 4, j = new Uint8Array(F);
            Z.readPixels(N, P - W - A, V, A, Z.RGBA, Z.UNSIGNED_BYTE, j);
            var T = E.createWebGL(this, V, A), C = T.getContext("2d", { willReadFrequently: true }), v = C.getImageData(0, 0, V, A), O = v.data;
            for (var q = 0;q < A; q++)
              for (var w = 0;w < V; w++) {
                var g = ((A - q - 1) * V + w) * 4, b = Y ? F - (q * V + (V - w)) * 4 : (q * V + w) * 4;
                O[b + 0] = j[g + 0], O[b + 1] = j[g + 1], O[b + 2] = j[g + 2], O[b + 3] = j[g + 3];
              }
            C.putImageData(v, 0, 0);
            var x = new Image;
            x.onerror = function() {
              D.call(null), E.remove(T);
            }, x.onload = function() {
              D.call(null, x), E.remove(T);
            }, x.src = T.toDataURL(Q, H);
          }
        };
        M.exports = U;
      }, 89966: (M, B, $) => {
        M.exports = { Canvas: $(32880), WebGL: $(88815) };
      }, 7530: (M, B, $) => {
        var E = $(83419), L = $(36060), z = $(90330), U = $(82264), K = $(95540), J = $(32302), Z = $(63448), D = $(31302), Q = $(58918), H = $(14811), N = $(92651), W = $(96569), R = $(56527), Y = $(57516), I = $(43439), P = $(81041), X = $(12385), G = $(7589), V = $(95428), A = $(72905), F = new E({ initialize: function j(T) {
          this.game = T.game, this.renderer = T, this.classes = new z([[L.UTILITY_PIPELINE, G], [L.MULTI_PIPELINE, Y], [L.BITMAPMASK_PIPELINE, D], [L.SINGLE_PIPELINE, X], [L.ROPE_PIPELINE, P], [L.LIGHT_PIPELINE, W], [L.POINTLIGHT_PIPELINE, I], [L.MOBILE_PIPELINE, R]]), this.postPipelineClasses = new z, this.pipelines = new z, this.postPipelineInstances = [], this.default = null, this.current = null, this.previous = null, this.MULTI_PIPELINE = null, this.BITMAPMASK_PIPELINE = null, this.UTILITY_PIPELINE = null, this.MOBILE_PIPELINE = null, this.FX_PIPELINE = null, this.fullFrame1, this.fullFrame2, this.halfFrame1, this.halfFrame2, this.renderTargets = [], this.maxDimension = 0, this.frameInc = 32, this.targetIndex = 0;
        }, boot: function(j, T, C) {
          var v = this.renderer, O = this.renderTargets;
          this.frameInc = Math.floor(K(j, "frameInc", 32));
          var { width: q, height: w } = v, g = this.game.config.disablePreFX, b = this.game.config.disablePostFX;
          if (!b)
            this.postPipelineClasses.setAll([[String(H.BARREL), Q.Barrel], [String(H.BLOOM), Q.Bloom], [String(H.BLUR), Q.Blur], [String(H.BOKEH), Q.Bokeh], [String(H.CIRCLE), Q.Circle], [String(H.COLOR_MATRIX), Q.ColorMatrix], [String(H.DISPLACEMENT), Q.Displacement], [String(H.GLOW), Q.Glow], [String(H.GRADIENT), Q.Gradient], [String(H.PIXELATE), Q.Pixelate], [String(H.SHADOW), Q.Shadow], [String(H.SHINE), Q.Shine], [String(H.VIGNETTE), Q.Vignette], [String(H.WIPE), Q.Wipe]]);
          if (!g) {
            this.classes.set(L.FX_PIPELINE, N);
            var x = Math.min(q, w), k = Math.ceil(x / this.frameInc);
            for (var S = 1;S < k; S++) {
              var f = S * this.frameInc;
              O.push(new J(v, f, f)), O.push(new J(v, f, f)), O.push(new J(v, f, f)), this.maxDimension = f;
            }
            O.push(new J(v, q, w, 1, 0, true, true)), O.push(new J(v, q, w, 1, 0, true, true)), O.push(new J(v, q, w, 1, 0, true, true));
          }
          var h, m, y = this, d = this.game;
          if (this.classes.each(function(u, s) {
            if (h = y.add(u, new s({ game: d })), u === L.UTILITY_PIPELINE)
              y.UTILITY_PIPELINE = h, y.fullFrame1 = h.fullFrame1, y.fullFrame2 = h.fullFrame2, y.halfFrame1 = h.halfFrame1, y.halfFrame2 = h.halfFrame2;
          }), this.MULTI_PIPELINE = this.get(L.MULTI_PIPELINE), this.BITMAPMASK_PIPELINE = this.get(L.BITMAPMASK_PIPELINE), this.MOBILE_PIPELINE = this.get(L.MOBILE_PIPELINE), !g)
            this.FX_PIPELINE = this.get(L.FX_PIPELINE);
          if (j)
            for (m in j) {
              var p = j[m];
              if (h = new p(d), h.name = m, h.isPostFX)
                this.postPipelineClasses.set(m, p);
              else if (!this.has(m))
                this.classes.set(m, p), this.add(m, h);
            }
          if (this.default = this.get(T), C && !U.os.desktop)
            this.default = this.MOBILE_PIPELINE;
        }, setDefaultPipeline: function(j) {
          var T = this.get(j);
          if (T)
            this.default = T;
          return T;
        }, add: function(j, T) {
          if (T.isPostFX) {
            console.warn(j + " is a Post Pipeline. Use `addPostPipeline` instead");
            return;
          }
          var C = this.pipelines, v = this.renderer;
          if (!C.has(j))
            T.name = j, T.manager = this, C.set(j, T);
          else
            console.warn("Pipeline exists: " + j);
          if (!T.hasBooted)
            T.boot();
          if (v.width !== 0 && v.height !== 0 && !T.isPreFX)
            T.resize(v.width, v.height);
          return T;
        }, addPostPipeline: function(j, T) {
          if (!this.postPipelineClasses.has(j))
            this.postPipelineClasses.set(j, T);
        }, flush: function() {
          if (this.current)
            this.current.flush();
        }, has: function(j) {
          var T = this.pipelines;
          if (typeof j === "string")
            return T.has(j);
          else if (T.contains(j))
            return true;
          return false;
        }, get: function(j) {
          var T = this.pipelines;
          if (typeof j === "string")
            return T.get(j);
          else if (T.contains(j))
            return j;
        }, getPostPipeline: function(j, T, C) {
          var v = this.postPipelineClasses, O, q = "", w = typeof j;
          if (w === "string" || w === "number")
            O = v.get(j), q = j;
          else if (w === "function") {
            if (v.contains(j))
              O = j;
            q = j.name;
          } else if (w === "object")
            O = v.get(j.name), q = j.name;
          if (O) {
            var g = new O(this.game, C);
            if (g.name = q, T)
              g.gameObject = T;
            return this.postPipelineInstances.push(g), g;
          }
        }, removePostPipeline: function(j) {
          A(this.postPipelineInstances, j);
        }, remove: function(j, T, C) {
          if (T === undefined)
            T = true;
          if (C === undefined)
            C = true;
          if (this.pipelines.delete(j), T)
            this.classes.delete(j);
          if (C)
            this.postPipelineClasses.delete(j);
        }, set: function(j, T, C) {
          if (j.isPostFX)
            return;
          if (!this.isCurrent(j, C)) {
            if (this.flush(), this.current)
              this.current.unbind();
            this.current = j, j.bind(C);
          }
          return j.updateProjectionMatrix(), j.onBind(T), j;
        }, preBatch: function(j) {
          if (j.hasPostPipeline) {
            this.flush();
            var T = j.postPipelines;
            for (var C = T.length - 1;C >= 0; C--) {
              var v = T[C];
              if (v.active)
                v.preBatch(j);
            }
          }
        }, postBatch: function(j) {
          if (j.hasPostPipeline) {
            this.flush();
            var T = j.postPipelines;
            for (var C = 0;C < T.length; C++) {
              var v = T[C];
              if (v.active)
                v.postBatch(j);
            }
          }
        }, preBatchCamera: function(j) {
          if (j.hasPostPipeline) {
            this.flush();
            var T = j.postPipelines;
            for (var C = T.length - 1;C >= 0; C--) {
              var v = T[C];
              if (v.active)
                v.preBatch(j);
            }
          }
        }, postBatchCamera: function(j) {
          if (j.hasPostPipeline) {
            this.flush();
            var T = j.postPipelines;
            for (var C = 0;C < T.length; C++) {
              var v = T[C];
              if (v.active)
                v.postBatch(j);
            }
          }
        }, isCurrent: function(j, T) {
          var C = this.renderer, v = this.current;
          if (v && !T)
            T = v.currentShader;
          return !(v !== j || T.program !== C.currentProgram);
        }, copyFrame: function(j, T, C, v, O) {
          return this.setUtility(this.UTILITY_PIPELINE.copyShader).copyFrame(j, T, C, v, O), this;
        }, copyToGame: function(j) {
          return this.setUtility(this.UTILITY_PIPELINE.copyShader).copyToGame(j), this;
        }, drawFrame: function(j, T, C, v) {
          return this.setUtility(this.UTILITY_PIPELINE.colorMatrixShader).drawFrame(j, T, C, v), this;
        }, blendFrames: function(j, T, C, v, O) {
          return this.setUtility(this.UTILITY_PIPELINE.linearShader).blendFrames(j, T, C, v, O), this;
        }, blendFramesAdditive: function(j, T, C, v, O) {
          return this.setUtility(this.UTILITY_PIPELINE.addShader).blendFramesAdditive(j, T, C, v, O), this;
        }, clearFrame: function(j, T) {
          return this.UTILITY_PIPELINE.clearFrame(j, T), this;
        }, blitFrame: function(j, T, C, v, O, q) {
          return this.setUtility(this.UTILITY_PIPELINE.copyShader).blitFrame(j, T, C, v, O, q), this;
        }, copyFrameRect: function(j, T, C, v, O, q, w, g) {
          return this.UTILITY_PIPELINE.copyFrameRect(j, T, C, v, O, q, w, g), this;
        }, forceZero: function() {
          return this.current && this.current.forceZero;
        }, setMulti: function() {
          return this.set(this.MULTI_PIPELINE);
        }, setUtility: function(j) {
          return this.UTILITY_PIPELINE.bind(j);
        }, setFX: function() {
          return this.set(this.FX_PIPELINE);
        }, restoreContext: function() {
          this.rebind(), this.pipelines.each(function(j, T) {
            T.restoreContext();
          }), V(this.postPipelineInstances, function(j) {
            j.restoreContext();
          });
        }, rebind: function(j) {
          if (j === undefined && this.previous)
            j = this.previous;
          var T = this.renderer, C = T.gl;
          if (C.disable(C.DEPTH_TEST), C.disable(C.CULL_FACE), T.hasActiveStencilMask())
            C.clear(C.DEPTH_BUFFER_BIT);
          else
            C.disable(C.STENCIL_TEST), C.clear(C.DEPTH_BUFFER_BIT | C.STENCIL_BUFFER_BIT);
          C.viewport(0, 0, T.width, T.height), T.currentProgram = null, T.setBlendMode(0, true);
          var v = T.vaoExtension;
          if (v)
            v.bindVertexArrayOES(null);
          var O = this.pipelines.entries;
          for (var q in O)
            O[q].glReset = true;
          if (j)
            this.current = j, j.rebind();
        }, clear: function() {
          var j = this.renderer;
          if (this.flush(), this.current)
            this.current.unbind(), this.previous = this.current, this.current = null;
          else
            this.previous = null;
          j.currentProgram = null, j.setBlendMode(0, true);
          var T = j.vaoExtension;
          if (T)
            T.bindVertexArrayOES(null);
        }, getRenderTarget: function(j) {
          var T = this.renderTargets, C = 3;
          if (j > this.maxDimension)
            return this.targetIndex = T.length - C, T[this.targetIndex];
          else {
            var v = (Z(j, this.frameInc, 0, true) - 1) * C;
            return this.targetIndex = v, T[v];
          }
        }, getSwapRenderTarget: function() {
          return this.renderTargets[this.targetIndex + 1];
        }, getAltSwapRenderTarget: function() {
          return this.renderTargets[this.targetIndex + 2];
        }, destroy: function() {
          this.flush(), this.classes.clear(), this.postPipelineClasses.clear(), this.pipelines.clear(), this.renderer = null, this.game = null, this.classes = null, this.postPipelineClasses = null, this.pipelines = null, this.default = null, this.current = null, this.previous = null;
        } });
        M.exports = F;
      }, 32302: (M, B, $) => {
        var E = $(83419), L = $(92503), z = new E({ initialize: function U(K, J, Z, D, Q, H, N, W, R) {
          if (D === undefined)
            D = 1;
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = true;
          if (N === undefined)
            N = false;
          if (W === undefined)
            W = true;
          if (R === undefined)
            R = true;
          if (this.renderer = K, this.framebuffer = null, this.texture = null, this.width = 0, this.height = 0, this.scale = D, this.minFilter = Q, this.autoClear = H, this.autoResize = true, this.hasDepthBuffer = W, this.forceClamp = R, this.resize(J, Z), N)
            this.setAutoResize(true);
          else
            this.autoResize = false;
        }, setAutoResize: function(U) {
          if (U && !this.autoResize)
            this.renderer.on(L.RESIZE, this.resize, this), this.autoResize = true;
          else if (!U && this.autoResize)
            this.renderer.off(L.RESIZE, this.resize, this), this.autoResize = false;
          return this;
        }, resize: function(U, K) {
          if (U = Math.round(U * this.scale), K = Math.round(K * this.scale), U <= 0)
            U = 1;
          if (K <= 0)
            K = 1;
          if (this.autoResize && (U !== this.width || K !== this.height)) {
            var J = this.renderer;
            J.deleteFramebuffer(this.framebuffer), J.deleteTexture(this.texture), this.texture = J.createTextureFromSource(null, U, K, this.minFilter, this.forceClamp), this.framebuffer = J.createFramebuffer(U, K, this.texture, this.hasDepthBuffer), this.width = U, this.height = K;
          }
          return this;
        }, willResize: function(U, K) {
          if (U = Math.round(U * this.scale), K = Math.round(K * this.scale), U <= 0)
            U = 1;
          if (K <= 0)
            K = 1;
          return U !== this.width || K !== this.height;
        }, bind: function(U, K, J) {
          if (U === undefined)
            U = false;
          var Z = this.renderer;
          if (U)
            Z.flush();
          if (K && J)
            this.resize(K, J);
          if (Z.pushFramebuffer(this.framebuffer, false, false), U)
            this.adjustViewport();
          if (this.autoClear) {
            var D = this.renderer.gl;
            D.clearColor(0, 0, 0, 0), D.clear(D.COLOR_BUFFER_BIT);
          }
          Z.clearStencilMask();
        }, adjustViewport: function() {
          var U = this.renderer.gl;
          U.viewport(0, 0, this.width, this.height), U.disable(U.SCISSOR_TEST);
        }, clear: function() {
          var U = this.renderer, K = U.gl;
          U.pushFramebuffer(this.framebuffer), K.disable(K.SCISSOR_TEST), K.clearColor(0, 0, 0, 0), K.clear(K.COLOR_BUFFER_BIT), U.popFramebuffer(), U.resetScissor();
        }, unbind: function(U) {
          if (U === undefined)
            U = false;
          var K = this.renderer;
          if (U)
            K.flush();
          return K.popFramebuffer();
        }, destroy: function() {
          var U = this.renderer;
          U.off(L.RESIZE, this.resize, this), U.deleteFramebuffer(this.framebuffer), U.deleteTexture(this.texture), this.renderer = null, this.framebuffer = null, this.texture = null;
        } });
        M.exports = z;
      }, 70554: (M) => {
        M.exports = { getTintFromFloats: function(B, $, E, L) {
          var z = (B * 255 | 0) & 255, U = ($ * 255 | 0) & 255, K = (E * 255 | 0) & 255, J = (L * 255 | 0) & 255;
          return (J << 24 | z << 16 | U << 8 | K) >>> 0;
        }, getTintAppendFloatAlpha: function(B, $) {
          var E = ($ * 255 | 0) & 255;
          return (E << 24 | B) >>> 0;
        }, getTintAppendFloatAlphaAndSwap: function(B, $) {
          var E = (B >> 16 | 0) & 255, L = (B >> 8 | 0) & 255, z = (B | 0) & 255, U = ($ * 255 | 0) & 255;
          return (U << 24 | z << 16 | L << 8 | E) >>> 0;
        }, getFloatsFromUintRGB: function(B) {
          var $ = (B >> 16 | 0) & 255, E = (B >> 8 | 0) & 255, L = (B | 0) & 255;
          return [$ / 255, E / 255, L / 255];
        }, checkShaderMax: function(B, $) {
          var E = Math.min(16, B.getParameter(B.MAX_TEXTURE_IMAGE_UNITS));
          if (!$ || $ === -1)
            return E;
          else
            return Math.min(E, $);
        }, parseFragmentShaderMaxTextures: function(B, $) {
          if (!B)
            return "";
          var E = "";
          for (var L = 0;L < $; L++) {
            if (L > 0)
              E += "\n\telse ";
            if (L < $ - 1)
              E += "if (outTexId < " + L + ".5)";
            E += "\n\t{", E += "\n\t\ttexture = texture2D(uMainSampler[" + L + "], outTexCoord);", E += "\n\t}";
          }
          return B = B.replace(/%count%/gi, $.toString()), B.replace(/%forloop%/gi, E);
        }, setGlowQuality: function(B, $, E, L) {
          if (E === undefined)
            E = $.config.glowFXQuality;
          if (L === undefined)
            L = $.config.glowFXDistance;
          return B = B.replace(/__SIZE__/gi, (1 / E / L).toFixed(7)), B = B.replace(/__DIST__/gi, L.toFixed(0) + ".0"), B;
        } };
      }, 29100: (M, B, $) => {
        var E = $(83419), L = $(62644), z = $(50792), U = $(77085), K = $(95540), J = $(37867), Z = $(92503), D = $(32302), Q = $(70554), H = $(38683), N = new E({ Extends: z, initialize: function W(R) {
          z.call(this);
          var Y = R.game, I = Y.renderer, P = I.gl;
          this.name = K(R, "name", "WebGLPipeline"), this.game = Y, this.renderer = I, this.manager, this.gl = P, this.view = Y.canvas, this.width = 0, this.height = 0, this.vertexCount = 0, this.vertexCapacity = 0, this.vertexData, this.vertexBuffer, this.activeBuffer, this.topology = K(R, "topology", P.TRIANGLES), this.bytes, this.vertexViewF32, this.vertexViewU32, this.active = true, this.forceZero = K(R, "forceZero", false), this.hasBooted = false, this.isPostFX = false, this.isPreFX = false, this.renderTargets = [], this.currentRenderTarget, this.shaders = [], this.currentShader, this.projectionMatrix, this.projectionWidth = 0, this.projectionHeight = 0, this.config = R, this.glReset = false, this.batch = [], this.currentBatch = null, this.currentTexture = null, this.currentUnit = 0, this.activeTextures = [], this.resizeUniform = K(R, "resizeUniform", "");
        }, boot: function() {
          var W, R = this.gl, Y = this.config, I = this.renderer;
          if (!this.isPostFX)
            this.projectionMatrix = new J().identity();
          var P = this.renderTargets, X = K(Y, "renderTarget", false);
          if (typeof X === "boolean" && X)
            X = 1;
          var { width: G, height: V } = I;
          if (typeof X === "number")
            for (W = 0;W < X; W++)
              P.push(new D(I, G, V, 1, 0, true));
          else if (Array.isArray(X))
            for (W = 0;W < X.length; W++) {
              var A = K(X[W], "scale", 1), F = K(X[W], "minFilter", 0), j = K(X[W], "autoClear", 1), T = K(X[W], "autoResize", false), C = K(X[W], "width", null), v = K(X[W], "height", C);
              if (C)
                P.push(new D(I, C, v, 1, F, j, T));
              else
                P.push(new D(I, G, V, A, F, j, T));
            }
          if (P.length)
            this.currentRenderTarget = P[0];
          this.setShadersFromConfig(Y);
          var O = this.shaders, q = 0;
          for (W = 0;W < O.length; W++)
            if (O[W].vertexSize > q)
              q = O[W].vertexSize;
          var w = K(Y, "batchSize", I.config.batchSize);
          this.vertexCapacity = w * 6;
          var g = new ArrayBuffer(this.vertexCapacity * q);
          this.vertexData = g, this.bytes = new Uint8Array(g), this.vertexViewF32 = new Float32Array(g), this.vertexViewU32 = new Uint32Array(g);
          var b = K(Y, "vertices", null);
          if (b)
            this.vertexViewF32.set(b), this.vertexBuffer = I.createVertexBuffer(g, R.STATIC_DRAW);
          else
            this.vertexBuffer = I.createVertexBuffer(g.byteLength, R.DYNAMIC_DRAW);
          this.setVertexBuffer();
          for (W = O.length - 1;W >= 0; W--)
            O[W].rebind();
          this.hasBooted = true, I.on(Z.RESIZE, this.resize, this), I.on(Z.PRE_RENDER, this.onPreRender, this), I.on(Z.RENDER, this.onRender, this), I.on(Z.POST_RENDER, this.onPostRender, this), this.emit(U.BOOT, this), this.onBoot();
        }, onBoot: function() {
        }, onResize: function() {
        }, setShader: function(W, R, Y) {
          var I = this.renderer;
          if (W !== this.currentShader || I.currentProgram !== this.currentShader.program) {
            this.flush();
            var P = this.setVertexBuffer(Y);
            if (P && !R)
              R = true;
            W.bind(R, false), this.currentShader = W;
          }
          return this;
        }, getShaderByName: function(W) {
          var R = this.shaders;
          for (var Y = 0;Y < R.length; Y++)
            if (R[Y].name === W)
              return R[Y];
        }, setShadersFromConfig: function(W) {
          var R, Y = this.shaders, I = this.renderer;
          for (R = 0;R < Y.length; R++)
            Y[R].destroy();
          var P = "vertShader", X = "fragShader", G = "attributes", V = K(W, P, null), A = Q.parseFragmentShaderMaxTextures(K(W, X, null), I.maxTextures), F = K(W, G, null), j = K(W, "shaders", []), T = j.length;
          if (T === 0) {
            if (V && A)
              this.shaders = [new H(this, "default", V, A, L(F))];
          } else {
            var C = [];
            for (R = 0;R < T; R++) {
              var v = j[R], O, q, w, g;
              if (typeof v === "string")
                O = "default", q = V, w = Q.parseFragmentShaderMaxTextures(v, I.maxTextures), g = F;
              else
                O = K(v, "name", "default"), q = K(v, P, V), w = Q.parseFragmentShaderMaxTextures(K(v, X, A), I.maxTextures), g = K(v, G, F);
              if (O === "default") {
                var b = w.split("\n"), x = b[0].trim();
                if (x.indexOf("#define SHADER_NAME") > -1)
                  O = x.substring(20);
              }
              if (q && w)
                C.push(new H(this, O, q, w, L(g)));
            }
            this.shaders = C;
          }
          if (this.shaders.length === 0)
            console.warn("Pipeline: " + this.name + " - Invalid shader config");
          else
            this.currentShader = this.shaders[0];
          return this;
        }, createBatch: function(W) {
          return this.currentBatch = { start: this.vertexCount, count: 0, texture: [W], unit: 0, maxUnit: 0 }, this.currentUnit = 0, this.currentTexture = W, this.batch.push(this.currentBatch), 0;
        }, addTextureToBatch: function(W) {
          var R = this.currentBatch;
          if (R)
            R.texture.push(W), R.unit++, R.maxUnit++;
        }, pushBatch: function(W) {
          if (!this.currentBatch || this.forceZero && W !== this.currentTexture)
            return this.createBatch(W);
          if (W === this.currentTexture)
            return this.currentUnit;
          else {
            var R = this.currentBatch, Y = R.texture.indexOf(W);
            if (Y === -1)
              if (R.texture.length === this.renderer.maxTextures)
                return this.createBatch(W);
              else
                return R.unit++, R.maxUnit++, R.texture.push(W), this.currentUnit = R.unit, this.currentTexture = W, R.unit;
            else
              return this.currentUnit = Y, this.currentTexture = W, Y;
          }
        }, setGameObject: function(W, R) {
          if (R === undefined)
            R = W.frame;
          return this.pushBatch(R.source.glTexture);
        }, shouldFlush: function(W) {
          if (W === undefined)
            W = 0;
          return this.vertexCount + W > this.vertexCapacity;
        }, vertexAvailable: function() {
          return this.vertexCapacity - this.vertexCount;
        }, resize: function(W, R) {
          if (W !== this.width || R !== this.height)
            this.flush();
          this.width = W, this.height = R;
          var Y = this.renderTargets;
          for (var I = 0;I < Y.length; I++)
            Y[I].resize(W, R);
          if (this.setProjectionMatrix(W, R), this.resizeUniform)
            this.set2f(this.resizeUniform, W, R);
          return this.emit(U.RESIZE, W, R, this), this.onResize(W, R), this;
        }, setProjectionMatrix: function(W, R) {
          var Y = this.projectionMatrix;
          if (!Y)
            return this;
          this.projectionWidth = W, this.projectionHeight = R, Y.ortho(0, W, R, 0, -1000, 1000);
          var I = this.shaders, P = "uProjectionMatrix";
          for (var X = 0;X < I.length; X++) {
            var G = I[X];
            if (G.hasUniform(P))
              G.resetUniform(P), G.setMatrix4fv(P, false, Y.val, G);
          }
          return this;
        }, flipProjectionMatrix: function(W) {
          if (W === undefined)
            W = true;
          var R = this.projectionMatrix;
          if (!R)
            return this;
          var Y = this.projectionWidth, I = this.projectionHeight;
          if (W)
            R.ortho(0, Y, 0, I, -1000, 1000);
          else
            R.ortho(0, Y, I, 0, -1000, 1000);
          this.setMatrix4fv("uProjectionMatrix", false, R.val);
        }, updateProjectionMatrix: function() {
          if (this.projectionMatrix) {
            var W = this.renderer.projectionWidth, R = this.renderer.projectionHeight;
            if (this.projectionWidth !== W || this.projectionHeight !== R)
              this.setProjectionMatrix(W, R);
          }
        }, bind: function(W) {
          if (W === undefined)
            W = this.currentShader;
          if (this.glReset)
            return this.rebind(W);
          var R = false, Y = this.gl;
          if (Y.getParameter(Y.ARRAY_BUFFER_BINDING) !== this.vertexBuffer)
            Y.bindBuffer(Y.ARRAY_BUFFER, this.vertexBuffer.webGLBuffer), this.activeBuffer = this.vertexBuffer, R = true;
          return W.bind(R), this.currentShader = W, this.activeTextures.length = 0, this.emit(U.BIND, this, W), this.onActive(W), this;
        }, rebind: function(W) {
          this.activeBuffer = null, this.setVertexBuffer();
          var R = this.shaders;
          for (var Y = R.length - 1;Y >= 0; Y--) {
            var I = R[Y].rebind();
            if (!W || I === W)
              this.currentShader = I;
          }
          return this.activeTextures.length = 0, this.emit(U.REBIND, this.currentShader), this.onActive(this.currentShader), this.onRebind(), this.glReset = false, this;
        }, restoreContext: function() {
          var W = this.shaders, R = !!this.vertexBuffer;
          if (this.activeBuffer = null, this.activeTextures.length = 0, this.batch.length = 0, this.currentBatch = null, this.currentTexture = null, this.currentUnit = 0, R)
            this.setVertexBuffer();
          for (var Y = 0;Y < W.length; Y++) {
            var I = W[Y];
            if (I.syncUniforms(), R)
              I.rebind();
          }
        }, setVertexBuffer: function(W) {
          if (W === undefined)
            W = this.vertexBuffer;
          if (W !== this.activeBuffer) {
            var R = this.gl;
            return this.gl.bindBuffer(R.ARRAY_BUFFER, W.webGLBuffer), this.activeBuffer = W, true;
          }
          return false;
        }, preBatch: function(W) {
          if (this.currentRenderTarget)
            this.currentRenderTarget.bind();
          return this.onPreBatch(W), this;
        }, postBatch: function(W) {
          return this.onDraw(this.currentRenderTarget), this.onPostBatch(W), this;
        }, onDraw: function() {
        }, unbind: function() {
          if (this.currentRenderTarget)
            this.currentRenderTarget.unbind();
        }, flush: function(W) {
          if (W === undefined)
            W = false;
          if (this.vertexCount > 0) {
            this.emit(U.BEFORE_FLUSH, this, W), this.onBeforeFlush(W);
            var R = this.gl, Y = this.vertexCount, I = this.currentShader.vertexSize, P = this.topology;
            if (this.active) {
              if (this.setVertexBuffer(), Y === this.vertexCapacity)
                R.bufferData(R.ARRAY_BUFFER, this.vertexData, R.DYNAMIC_DRAW);
              else
                R.bufferSubData(R.ARRAY_BUFFER, 0, this.bytes.subarray(0, Y * I));
              var X, G, V, A = this.batch, F = this.activeTextures;
              if (this.forceZero) {
                if (!F[0])
                  R.activeTexture(R.TEXTURE0);
                for (X = 0;X < A.length; X++) {
                  if (G = A[X], V = G.texture[0], F[0] !== V)
                    R.bindTexture(R.TEXTURE_2D, V.webGLTexture), F[0] = V;
                  R.drawArrays(P, G.start, G.count);
                }
              } else
                for (X = 0;X < A.length; X++) {
                  G = A[X];
                  for (var j = 0;j <= G.maxUnit; j++)
                    if (V = G.texture[j], F[j] !== V)
                      R.activeTexture(R.TEXTURE0 + j), R.bindTexture(R.TEXTURE_2D, V.webGLTexture), F[j] = V;
                  R.drawArrays(P, G.start, G.count);
                }
            }
            this.vertexCount = 0, this.batch.length = 0, this.currentBatch = null, this.currentTexture = null, this.currentUnit = 0, this.emit(U.AFTER_FLUSH, this, W), this.onAfterFlush(W);
          }
          return this;
        }, onActive: function() {
        }, onBind: function() {
        }, onRebind: function() {
        }, onBatch: function() {
        }, onPreBatch: function() {
        }, onPostBatch: function() {
        }, onPreRender: function() {
        }, onRender: function() {
        }, onPostRender: function() {
        }, onBeforeFlush: function() {
        }, onAfterFlush: function() {
        }, batchVert: function(W, R, Y, I, P, X, G) {
          var V = this.vertexViewF32, A = this.vertexViewU32, F = this.vertexCount * this.currentShader.vertexComponentCount - 1;
          V[++F] = W, V[++F] = R, V[++F] = Y, V[++F] = I, V[++F] = P, V[++F] = X, A[++F] = G, this.vertexCount++, this.currentBatch.count = this.vertexCount - this.currentBatch.start;
        }, batchQuad: function(W, R, Y, I, P, X, G, V, A, F, j, T, C, v, O, q, w, g, b, x) {
          if (x === undefined)
            x = this.currentUnit;
          var k = false;
          if (this.shouldFlush(6))
            this.flush(), k = true;
          if (!this.currentBatch)
            x = this.setTexture2D(b);
          var S = this.vertexViewF32, f = this.vertexViewU32, h = this.vertexCount * this.currentShader.vertexComponentCount - 1;
          return S[++h] = R, S[++h] = Y, S[++h] = F, S[++h] = j, S[++h] = x, S[++h] = g, f[++h] = v, S[++h] = I, S[++h] = P, S[++h] = F, S[++h] = C, S[++h] = x, S[++h] = g, f[++h] = q, S[++h] = X, S[++h] = G, S[++h] = T, S[++h] = C, S[++h] = x, S[++h] = g, f[++h] = w, S[++h] = R, S[++h] = Y, S[++h] = F, S[++h] = j, S[++h] = x, S[++h] = g, f[++h] = v, S[++h] = X, S[++h] = G, S[++h] = T, S[++h] = C, S[++h] = x, S[++h] = g, f[++h] = w, S[++h] = V, S[++h] = A, S[++h] = T, S[++h] = j, S[++h] = x, S[++h] = g, f[++h] = O, this.vertexCount += 6, this.currentBatch.count = this.vertexCount - this.currentBatch.start, this.onBatch(W), k;
        }, batchTri: function(W, R, Y, I, P, X, G, V, A, F, j, T, C, v, O, q, w) {
          if (w === undefined)
            w = this.currentUnit;
          var g = false;
          if (this.shouldFlush(3))
            this.flush(), g = true;
          if (!this.currentBatch)
            w = this.setTexture2D(q);
          var b = this.vertexViewF32, x = this.vertexViewU32, k = this.vertexCount * this.currentShader.vertexComponentCount - 1;
          return b[++k] = R, b[++k] = Y, b[++k] = V, b[++k] = A, b[++k] = w, b[++k] = O, x[++k] = T, b[++k] = I, b[++k] = P, b[++k] = V, b[++k] = j, b[++k] = w, b[++k] = O, x[++k] = C, b[++k] = X, b[++k] = G, b[++k] = F, b[++k] = j, b[++k] = w, b[++k] = O, x[++k] = v, this.vertexCount += 3, this.currentBatch.count = this.vertexCount - this.currentBatch.start, this.onBatch(W), g;
        }, drawFillRect: function(W, R, Y, I, P, X, G, V) {
          if (G === undefined)
            G = this.renderer.whiteTexture;
          if (V === undefined)
            V = true;
          W = Math.floor(W), R = Math.floor(R);
          var A = Math.floor(W + Y), F = Math.floor(R + I), j = this.setTexture2D(G), T = Q.getTintAppendFloatAlphaAndSwap(P, X), C = 0, v = 0, O = 1, q = 1;
          if (V)
            v = 1, q = 0;
          this.batchQuad(null, W, R, W, F, A, F, A, R, C, v, O, q, T, T, T, T, 0, G, j);
        }, setTexture2D: function(W) {
          if (W === undefined)
            W = this.renderer.whiteTexture;
          return this.pushBatch(W);
        }, bindTexture: function(W, R) {
          if (R === undefined)
            R = 0;
          var Y = this.gl;
          return Y.activeTexture(Y.TEXTURE0 + R), Y.bindTexture(Y.TEXTURE_2D, W.webGLTexture), this;
        }, bindRenderTarget: function(W, R) {
          return this.bindTexture(W.texture, R);
        }, setTime: function(W, R) {
          return this.set1f(W, this.game.loop.getDuration(), R), this;
        }, setBoolean: function(W, R, Y) {
          if (Y === undefined)
            Y = this.currentShader;
          return Y.setBoolean(W, R), this;
        }, set1f: function(W, R, Y) {
          if (Y === undefined)
            Y = this.currentShader;
          return Y.set1f(W, R), this;
        }, set2f: function(W, R, Y, I) {
          if (I === undefined)
            I = this.currentShader;
          return I.set2f(W, R, Y), this;
        }, set3f: function(W, R, Y, I, P) {
          if (P === undefined)
            P = this.currentShader;
          return P.set3f(W, R, Y, I), this;
        }, set4f: function(W, R, Y, I, P, X) {
          if (X === undefined)
            X = this.currentShader;
          return X.set4f(W, R, Y, I, P), this;
        }, set1fv: function(W, R, Y) {
          if (Y === undefined)
            Y = this.currentShader;
          return Y.set1fv(W, R), this;
        }, set2fv: function(W, R, Y) {
          if (Y === undefined)
            Y = this.currentShader;
          return Y.set2fv(W, R), this;
        }, set3fv: function(W, R, Y) {
          if (Y === undefined)
            Y = this.currentShader;
          return Y.set3fv(W, R), this;
        }, set4fv: function(W, R, Y) {
          if (Y === undefined)
            Y = this.currentShader;
          return Y.set4fv(W, R), this;
        }, set1iv: function(W, R, Y) {
          if (Y === undefined)
            Y = this.currentShader;
          return Y.set1iv(W, R), this;
        }, set2iv: function(W, R, Y) {
          if (Y === undefined)
            Y = this.currentShader;
          return Y.set2iv(W, R), this;
        }, set3iv: function(W, R, Y) {
          if (Y === undefined)
            Y = this.currentShader;
          return Y.set3iv(W, R), this;
        }, set4iv: function(W, R, Y) {
          if (Y === undefined)
            Y = this.currentShader;
          return Y.set4iv(W, R), this;
        }, set1i: function(W, R, Y) {
          if (Y === undefined)
            Y = this.currentShader;
          return Y.set1i(W, R), this;
        }, set2i: function(W, R, Y, I) {
          if (I === undefined)
            I = this.currentShader;
          return I.set2i(W, R, Y), this;
        }, set3i: function(W, R, Y, I, P) {
          if (P === undefined)
            P = this.currentShader;
          return P.set3i(W, R, Y, I), this;
        }, set4i: function(W, R, Y, I, P, X) {
          if (X === undefined)
            X = this.currentShader;
          return X.set4i(W, R, Y, I, P), this;
        }, setMatrix2fv: function(W, R, Y, I) {
          if (I === undefined)
            I = this.currentShader;
          return I.setMatrix2fv(W, R, Y), this;
        }, setMatrix3fv: function(W, R, Y, I) {
          if (I === undefined)
            I = this.currentShader;
          return I.setMatrix3fv(W, R, Y), this;
        }, setMatrix4fv: function(W, R, Y, I) {
          if (I === undefined)
            I = this.currentShader;
          return I.setMatrix4fv(W, R, Y), this;
        }, destroy: function() {
          this.emit(U.DESTROY, this);
          var W, R = this.shaders;
          for (W = 0;W < R.length; W++)
            R[W].destroy();
          var Y = this.renderTargets;
          for (W = 0;W < Y.length; W++)
            Y[W].destroy();
          var I = this.renderer;
          return I.deleteBuffer(this.vertexBuffer), I.off(Z.RESIZE, this.resize, this), I.off(Z.PRE_RENDER, this.onPreRender, this), I.off(Z.RENDER, this.onRender, this), I.off(Z.POST_RENDER, this.onPostRender, this), this.removeAllListeners(), this.game = null, this.renderer = null, this.manager = null, this.gl = null, this.view = null, this.shaders = null, this.renderTargets = null, this.bytes = null, this.vertexViewF32 = null, this.vertexViewU32 = null, this.vertexData = null, this.vertexBuffer = null, this.currentShader = null, this.currentRenderTarget = null, this.activeTextures = null, this;
        } });
        M.exports = N;
      }, 74797: (M, B, $) => {
        var E = $(95428), L = $(72905), z = $(19715), U = $(83419), K = $(8054), J = $(50792), Z = $(92503), D = $(50030), Q = $(37867), H = $(29747), N = $(7530), W = $(32302), R = $(97480), Y = $(69442), I = $(70554), P = $(88815), X = $(26128), G = $(1482), V = $(82751), A = $(84387), F = $(93567), j = $(57183), T = false;
        if (false)
          var C;
        var v = new U({ Extends: J, initialize: function O(q) {
          J.call(this);
          var w = q.config, g = { alpha: w.transparent, desynchronized: w.desynchronized, depth: true, antialias: w.antialiasGL, premultipliedAlpha: w.premultipliedAlpha, stencil: true, failIfMajorPerformanceCaveat: w.failIfMajorPerformanceCaveat, powerPreference: w.powerPreference, preserveDrawingBuffer: w.preserveDrawingBuffer, willReadFrequently: false };
          this.config = { clearBeforeRender: w.clearBeforeRender, antialias: w.antialias, backgroundColor: w.backgroundColor, contextCreation: g, roundPixels: w.roundPixels, maxTextures: w.maxTextures, maxTextureSize: w.maxTextureSize, batchSize: w.batchSize, maxLights: w.maxLights, mipmapFilter: w.mipmapFilter }, this.game = q, this.type = K.WEBGL, this.pipelines = null, this.width = 0, this.height = 0, this.canvas = q.canvas, this.blendModes = [], this.contextLost = false, this.snapshotState = { x: 0, y: 0, width: 1, height: 1, getPixel: false, callback: null, type: "image/png", encoder: 0.92, isFramebuffer: false, bufferWidth: 0, bufferHeight: 0 }, this.maxTextures = 0, this.textureIndexes, this.glBufferWrappers = [], this.glProgramWrappers = [], this.glTextureWrappers = [], this.glFramebufferWrappers = [], this.glAttribLocationWrappers = [], this.glUniformLocationWrappers = [], this.currentFramebuffer = null, this.fboStack = [], this.currentProgram = null, this.currentBlendMode = Infinity, this.currentScissorEnabled = false, this.currentScissor = null, this.scissorStack = [], this.contextLostHandler = H, this.contextRestoredHandler = H, this.gl = null, this.supportedExtensions = null, this.instancedArraysExtension = null, this.vaoExtension = null, this.extensions = {}, this.glFormats, this.compression, this.drawingBufferHeight = 0, this.blankTexture = null, this.normalTexture = null, this.whiteTexture = null, this.maskCount = 0, this.maskStack = [], this.currentMask = { mask: null, camera: null }, this.currentCameraMask = { mask: null, camera: null }, this.glFuncMap = null, this.currentType = "", this.newType = false, this.nextTypeMatch = false, this.finalType = false, this.mipmapFilter = null, this.defaultScissor = [0, 0, 0, 0], this.isBooted = false, this.renderTarget = null, this.projectionMatrix, this.projectionWidth = 0, this.projectionHeight = 0, this.maskSource = null, this.maskTarget = null, this.spector = null, this._debugCapture = false, this.init(this.config);
        }, init: function(O) {
          var q, w = this.game, g = this.canvas, b = O.backgroundColor;
          if (T)
            this.spector = new C.Spector, this.spector.onCapture.add(this.onCapture.bind(this));
          if (w.config.context)
            q = w.config.context;
          else
            q = g.getContext("webgl", O.contextCreation) || g.getContext("experimental-webgl", O.contextCreation);
          if (!q || q.isContextLost())
            throw this.contextLost = true, new Error("WebGL unsupported");
          this.gl = q;
          var x = this, k = function() {
            var h = q.getSupportedExtensions();
            x.supportedExtensions = h;
            var m = "ANGLE_instanced_arrays";
            x.instancedArraysExtension = h.indexOf(m) > -1 ? q.getExtension(m) : null;
            var y = "OES_vertex_array_object";
            x.vaoExtension = h.indexOf(y) > -1 ? q.getExtension(y) : null;
          };
          k(), this.contextLostHandler = function(h) {
            if (x.contextLost = true, console)
              console.warn("WebGL Context lost. Renderer disabled");
            x.emit(Z.LOSE_WEBGL, x), h.preventDefault();
          }, g.addEventListener("webglcontextlost", this.contextLostHandler, false), this.contextRestoredHandler = function(h) {
            if (q.isContextLost()) {
              if (console)
                console.log("WebGL Context restored, but context is still lost");
              return;
            }
            x.currentProgram = null, x.currentFramebuffer = null, x.setBlendMode(K.BlendModes.NORMAL), q.disable(q.BLEND), q.disable(q.DEPTH_TEST), q.enable(q.CULL_FACE), x.compression = x.getCompressedTextures();
            var m = function(y) {
              y.createResource();
            };
            if (E(x.glTextureWrappers, m), E(x.glBufferWrappers, m), E(x.glFramebufferWrappers, m), E(x.glProgramWrappers, m), E(x.glAttribLocationWrappers, m), E(x.glUniformLocationWrappers, m), x.createTemporaryTextures(), x.pipelines.restoreContext(), x.resize(x.game.scale.baseSize.width, x.game.scale.baseSize.height), k(), x.contextLost = false, console)
              console.warn("WebGL Context restored. Renderer running again.");
            x.emit(Z.RESTORE_WEBGL, x), h.preventDefault();
          }, g.addEventListener("webglcontextrestored", this.contextRestoredHandler, false), w.context = q;
          for (var S = 0;S <= 27; S++)
            this.blendModes.push({ func: [q.ONE, q.ONE_MINUS_SRC_ALPHA], equation: q.FUNC_ADD });
          if (this.blendModes[1].func = [q.ONE, q.DST_ALPHA], this.blendModes[2].func = [q.DST_COLOR, q.ONE_MINUS_SRC_ALPHA], this.blendModes[3].func = [q.ONE, q.ONE_MINUS_SRC_COLOR], this.blendModes[17] = { func: [q.ZERO, q.ONE_MINUS_SRC_ALPHA], equation: q.FUNC_REVERSE_SUBTRACT }, this.glFormats = [q.BYTE, q.SHORT, q.UNSIGNED_BYTE, q.UNSIGNED_SHORT, q.FLOAT], this.glFuncMap = { mat2: { func: q.uniformMatrix2fv, length: 1, matrix: true }, mat3: { func: q.uniformMatrix3fv, length: 1, matrix: true }, mat4: { func: q.uniformMatrix4fv, length: 1, matrix: true }, "1f": { func: q.uniform1f, length: 1 }, "1fv": { func: q.uniform1fv, length: 1 }, "1i": { func: q.uniform1i, length: 1 }, "1iv": { func: q.uniform1iv, length: 1 }, "2f": { func: q.uniform2f, length: 2 }, "2fv": { func: q.uniform2fv, length: 1 }, "2i": { func: q.uniform2i, length: 2 }, "2iv": { func: q.uniform2iv, length: 1 }, "3f": { func: q.uniform3f, length: 3 }, "3fv": { func: q.uniform3fv, length: 1 }, "3i": { func: q.uniform3i, length: 3 }, "3iv": { func: q.uniform3iv, length: 1 }, "4f": { func: q.uniform4f, length: 4 }, "4fv": { func: q.uniform4fv, length: 1 }, "4i": { func: q.uniform4i, length: 4 }, "4iv": { func: q.uniform4iv, length: 1 } }, !O.maxTextures || O.maxTextures === -1)
            O.maxTextures = q.getParameter(q.MAX_TEXTURE_IMAGE_UNITS);
          if (!O.maxTextureSize)
            O.maxTextureSize = q.getParameter(q.MAX_TEXTURE_SIZE);
          this.compression = this.getCompressedTextures(), q.disable(q.DEPTH_TEST), q.disable(q.CULL_FACE), q.enable(q.BLEND), q.clearColor(b.redGL, b.greenGL, b.blueGL, b.alphaGL);
          var f = ["NEAREST", "LINEAR", "NEAREST_MIPMAP_NEAREST", "LINEAR_MIPMAP_NEAREST", "NEAREST_MIPMAP_LINEAR", "LINEAR_MIPMAP_LINEAR"];
          if (f.indexOf(O.mipmapFilter) !== -1)
            this.mipmapFilter = q[O.mipmapFilter];
          return this.maxTextures = I.checkShaderMax(q, O.maxTextures), this.textureIndexes = [], this.createTemporaryTextures(), this.pipelines = new N(this), this.setBlendMode(K.BlendModes.NORMAL), this.projectionMatrix = new Q().identity(), w.textures.once(Y.READY, this.boot, this), this;
        }, boot: function() {
          var O = this.game, q = this.pipelines, w = O.scale.baseSize, g = w.width, b = w.height;
          this.width = g, this.height = b, this.isBooted = true, this.renderTarget = new W(this, g, b, 1, 0, true, true), this.maskTarget = new W(this, g, b, 1, 0, true, true), this.maskSource = new W(this, g, b, 1, 0, true, true);
          var x = O.config;
          q.boot(x.pipeline, x.defaultPipeline, x.autoMobilePipeline), this.blankTexture = O.textures.getFrame("__DEFAULT").glTexture, this.normalTexture = O.textures.getFrame("__NORMAL").glTexture, this.whiteTexture = O.textures.getFrame("__WHITE").glTexture;
          var k = this.gl;
          k.bindFramebuffer(k.FRAMEBUFFER, null), k.enable(k.SCISSOR_TEST), O.scale.on(R.RESIZE, this.onResize, this), this.resize(g, b);
        }, createTemporaryTextures: function() {
          var O = this.gl;
          for (var q = 0;q < this.maxTextures; q++) {
            var w = O.createTexture();
            O.activeTexture(O.TEXTURE0 + q), O.bindTexture(O.TEXTURE_2D, w), O.texImage2D(O.TEXTURE_2D, 0, O.RGBA, 1, 1, 0, O.RGBA, O.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255])), this.textureIndexes.push(q);
          }
        }, captureFrame: function(O, q) {
          if (O === undefined)
            O = false;
          if (q === undefined)
            q = false;
          if (T && this.spector && !this._debugCapture)
            this.spector.captureCanvas(this.canvas, 0, O, q), this._debugCapture = true;
        }, captureNextFrame: function() {
          if (T && this.spector && !this._debugCapture)
            this._debugCapture = true, this.spector.captureNextFrame(this.canvas);
        }, getFps: function() {
          if (T && this.spector)
            return this.spector.getFps();
        }, log: function() {
          if (T && this.spector) {
            var O = Array.prototype.slice.call(arguments).join(" ");
            return this.spector.log(O);
          }
        }, startCapture: function(O, q, w) {
          if (O === undefined)
            O = 0;
          if (q === undefined)
            q = false;
          if (w === undefined)
            w = false;
          if (T && this.spector && !this._debugCapture)
            this.spector.startCapture(this.canvas, O, q, w), this._debugCapture = true;
        }, stopCapture: function() {
          if (T && this.spector && this._debugCapture)
            return this.spector.stopCapture();
        }, onCapture: function(O) {
          if (T) {
            var q = this.spector.getResultUI();
            q.display(O), this._debugCapture = false;
          }
        }, onResize: function(O, q) {
          if (q.width !== this.width || q.height !== this.height)
            this.resize(q.width, q.height);
        }, beginCapture: function(O, q) {
          if (O === undefined)
            O = this.width;
          if (q === undefined)
            q = this.height;
          this.renderTarget.bind(true, O, q), this.setProjectionMatrix(O, q);
        }, endCapture: function() {
          return this.renderTarget.unbind(true), this.resetProjectionMatrix(), this.renderTarget;
        }, resize: function(O, q) {
          var w = this.gl;
          return this.width = O, this.height = q, this.setProjectionMatrix(O, q), w.viewport(0, 0, O, q), this.drawingBufferHeight = w.drawingBufferHeight, w.scissor(0, w.drawingBufferHeight - q, O, q), this.defaultScissor[2] = O, this.defaultScissor[3] = q, this.emit(Z.RESIZE, O, q), this;
        }, getCompressedTextures: function() {
          var O = "WEBGL_compressed_texture_", q = "WEBKIT_" + O, w = "EXT_texture_compression_", g = function(x, k) {
            var S = x.getExtension(O + k) || x.getExtension(q + k) || x.getExtension(w + k);
            if (S) {
              var f = {};
              for (var h in S)
                f[S[h]] = h;
              return f;
            }
          }, b = this.gl;
          return { ETC: g(b, "etc"), ETC1: g(b, "etc1"), ATC: g(b, "atc"), ASTC: g(b, "astc"), BPTC: g(b, "bptc"), RGTC: g(b, "rgtc"), PVRTC: g(b, "pvrtc"), S3TC: g(b, "s3tc"), S3TCSRGB: g(b, "s3tc_srgb"), IMG: true };
        }, getCompressedTextureName: function(O, q) {
          var w = this.compression[O.toUpperCase()];
          if (q in w)
            return w[q];
        }, supportsCompressedTexture: function(O, q) {
          var w = this.compression[O.toUpperCase()];
          if (w)
            if (q)
              return q in w;
            else
              return true;
          return false;
        }, getAspectRatio: function() {
          return this.width / this.height;
        }, setProjectionMatrix: function(O, q) {
          if (O !== this.projectionWidth || q !== this.projectionHeight)
            this.projectionWidth = O, this.projectionHeight = q, this.projectionMatrix.ortho(0, O, q, 0, -1000, 1000);
          return this;
        }, resetProjectionMatrix: function() {
          return this.setProjectionMatrix(this.width, this.height);
        }, hasExtension: function(O) {
          return this.supportedExtensions ? this.supportedExtensions.indexOf(O) : false;
        }, getExtension: function(O) {
          if (!this.hasExtension(O))
            return null;
          if (!(O in this.extensions))
            this.extensions[O] = this.gl.getExtension(O);
          return this.extensions[O];
        }, flush: function() {
          this.pipelines.flush();
        }, pushScissor: function(O, q, w, g, b) {
          if (b === undefined)
            b = this.drawingBufferHeight;
          var x = this.scissorStack, k = [O, q, w, g];
          return x.push(k), this.setScissor(O, q, w, g, b), this.currentScissor = k, k;
        }, setScissor: function(O, q, w, g, b) {
          if (b === undefined)
            b = this.drawingBufferHeight;
          var x = this.gl, k = this.currentScissor, S = w > 0 && g > 0;
          if (k && S) {
            var f = k[0], h = k[1], m = k[2], y = k[3];
            S = f !== O || h !== q || m !== w || y !== g;
          }
          if (S)
            this.flush(), x.scissor(O, b - q - g, w, g);
        }, resetScissor: function() {
          var O = this.gl;
          O.enable(O.SCISSOR_TEST);
          var q = this.currentScissor;
          if (q) {
            var w = q[0], g = q[1], b = q[2], x = q[3];
            if (b > 0 && x > 0)
              O.scissor(w, this.drawingBufferHeight - g - x, b, x);
          }
        }, popScissor: function() {
          var O = this.scissorStack;
          O.pop();
          var q = O[O.length - 1];
          if (q)
            this.setScissor(q[0], q[1], q[2], q[3]);
          this.currentScissor = q;
        }, hasActiveStencilMask: function() {
          var O = this.currentMask.mask, q = this.currentCameraMask.mask;
          return O && O.isStencil || q && q.isStencil;
        }, resetViewport: function() {
          var O = this.gl;
          O.viewport(0, 0, this.width, this.height), this.drawingBufferHeight = O.drawingBufferHeight;
        }, setBlendMode: function(O, q) {
          if (q === undefined)
            q = false;
          var w = this.gl, g = this.blendModes[O];
          if (q || O !== K.BlendModes.SKIP_CHECK && this.currentBlendMode !== O) {
            if (this.flush(), w.enable(w.BLEND), w.blendEquation(g.equation), g.func.length > 2)
              w.blendFuncSeparate(g.func[0], g.func[1], g.func[2], g.func[3]);
            else
              w.blendFunc(g.func[0], g.func[1]);
            return this.currentBlendMode = O, true;
          }
          return false;
        }, addBlendMode: function(O, q) {
          var w = this.blendModes.push({ func: O, equation: q });
          return w - 1;
        }, updateBlendMode: function(O, q, w) {
          if (this.blendModes[O]) {
            if (this.blendModes[O].func = q, w)
              this.blendModes[O].equation = w;
          }
          return this;
        }, removeBlendMode: function(O) {
          if (O > 17 && this.blendModes[O])
            this.blendModes.splice(O, 1);
          return this;
        }, pushFramebuffer: function(O, q, w, g, b) {
          if (O === this.currentFramebuffer)
            return this;
          return this.fboStack.push(O), this.setFramebuffer(O, q, w, g, b);
        }, setFramebuffer: function(O, q, w, g, b) {
          if (q === undefined)
            q = false;
          if (w === undefined)
            w = true;
          if (g === undefined)
            g = null;
          if (b === undefined)
            b = false;
          if (O === this.currentFramebuffer)
            return this;
          var x = this.gl, k = this.width, S = this.height;
          if (O && O.renderTexture && w)
            k = O.renderTexture.width, S = O.renderTexture.height;
          else
            this.flush();
          if (O)
            x.bindFramebuffer(x.FRAMEBUFFER, O.webGLFramebuffer);
          else
            x.bindFramebuffer(x.FRAMEBUFFER, null);
          if (w)
            x.viewport(0, 0, k, S);
          if (g)
            x.framebufferTexture2D(x.FRAMEBUFFER, x.COLOR_ATTACHMENT0, x.TEXTURE_2D, g.webGLTexture, 0);
          if (b)
            x.clearColor(0, 0, 0, 0), x.clear(x.COLOR_BUFFER_BIT);
          if (q)
            if (O)
              this.drawingBufferHeight = S, this.pushScissor(0, 0, k, S);
            else
              this.drawingBufferHeight = this.height, this.popScissor();
          return this.currentFramebuffer = O, this;
        }, popFramebuffer: function(O, q) {
          if (O === undefined)
            O = false;
          if (q === undefined)
            q = true;
          var w = this.fboStack;
          w.pop();
          var g = w[w.length - 1];
          if (!g)
            g = null;
          return this.setFramebuffer(g, O, q), g;
        }, restoreFramebuffer: function(O, q) {
          if (O === undefined)
            O = false;
          if (q === undefined)
            q = true;
          var w = this.fboStack, g = w[w.length - 1];
          if (!g)
            g = null;
          this.currentFramebuffer = null, this.setFramebuffer(g, O, q);
        }, setProgram: function(O) {
          if (O !== this.currentProgram)
            return this.flush(), this.gl.useProgram(O.webGLProgram), this.currentProgram = O, true;
          return false;
        }, resetProgram: function() {
          return this.gl.useProgram(this.currentProgram.webGLProgramWrapper), this;
        }, createTextureFromSource: function(O, q, w, g, b) {
          if (b === undefined)
            b = false;
          var x = this.gl, k = x.NEAREST, S = x.NEAREST, f = x.CLAMP_TO_EDGE, h = null;
          q = O ? O.width : q, w = O ? O.height : w;
          var m = D(q, w);
          if (m && !b)
            f = x.REPEAT;
          if (g === K.ScaleModes.LINEAR && this.config.antialias) {
            var y = O && O.compressed, d = !y && m || y && O.mipmaps.length > 1;
            k = this.mipmapFilter && d ? this.mipmapFilter : x.LINEAR, S = x.LINEAR;
          }
          if (!O && typeof q === "number" && typeof w === "number")
            h = this.createTexture2D(0, k, S, f, f, x.RGBA, null, q, w);
          else
            h = this.createTexture2D(0, k, S, f, f, x.RGBA, O);
          return h;
        }, createTexture2D: function(O, q, w, g, b, x, k, S, f, h, m, y) {
          if (typeof S !== "number")
            S = k ? k.width : 1;
          if (typeof f !== "number")
            f = k ? k.height : 1;
          var d = new V(this.gl, O, q, w, g, b, x, k, S, f, h, m, y);
          return this.glTextureWrappers.push(d), d;
        }, createFramebuffer: function(O, q, w, g) {
          this.currentFramebuffer = null;
          var b = new A(this.gl, O, q, w, g);
          return this.glFramebufferWrappers.push(b), b;
        }, beginBitmapMask: function(O, q) {
          var w = this.gl;
          if (w) {
            if (this.flush(), this.maskTarget.bind(true), this.currentCameraMask.mask !== O)
              this.currentMask.mask = O, this.currentMask.camera = q;
          }
        }, drawBitmapMask: function(O, q, w) {
          this.flush(), this.maskSource.bind(), this.setBlendMode(0, true), O.renderWebGL(this, O, q), this.maskSource.unbind(true), this.maskTarget.unbind();
          var g = this.gl, b = this.getCurrentStencilMask();
          if (b)
            g.enable(g.STENCIL_TEST), b.mask.applyStencil(this, b.camera, true);
          else
            this.currentMask.mask = null;
          this.pipelines.set(w), g.activeTexture(g.TEXTURE0), g.bindTexture(g.TEXTURE_2D, this.maskTarget.texture.webGLTexture), g.activeTexture(g.TEXTURE1), g.bindTexture(g.TEXTURE_2D, this.maskSource.texture.webGLTexture);
        }, createProgram: function(O, q) {
          var w = new G(this.gl, O, q);
          return this.glProgramWrappers.push(w), w;
        }, createVertexBuffer: function(O, q) {
          var w = this.gl, g = new X(w, O, w.ARRAY_BUFFER, q);
          return this.glBufferWrappers.push(g), g;
        }, createAttribLocation: function(O, q) {
          var w = new F(this.gl, O, q);
          return this.glAttribLocationWrappers.push(w), w;
        }, createUniformLocation: function(O, q) {
          var w = new j(this.gl, O, q);
          return this.glUniformLocationWrappers.push(w), w;
        }, createIndexBuffer: function(O, q) {
          var w = this.gl, g = new X(w, O, w.ELEMENT_ARRAY_BUFFER, q);
          return this.glBufferWrappers.push(g), g;
        }, deleteTexture: function(O) {
          if (!O)
            return;
          return L(this.glTextureWrappers, O), O.destroy(), this;
        }, deleteFramebuffer: function(O) {
          if (!O)
            return this;
          return L(this.fboStack, O), L(this.glFramebufferWrappers, O), O.destroy(), this;
        }, deleteProgram: function(O) {
          if (O)
            L(this.glProgramWrappers, O), O.destroy();
          return this;
        }, deleteAttribLocation: function(O) {
          if (O)
            L(this.glAttribLocationWrappers, O), O.destroy();
          return this;
        }, deleteUniformLocation: function(O) {
          if (O)
            L(this.glUniformLocationWrappers, O), O.destroy();
          return this;
        }, deleteBuffer: function(O) {
          if (!O)
            return this;
          return L(this.glBufferWrappers, O), O.destroy(), this;
        }, preRenderCamera: function(O) {
          var { x: q, y: w, width: g, height: b, backgroundColor: x } = O;
          if (O.emit(z.PRE_RENDER, O), this.pipelines.preBatchCamera(O), this.pushScissor(q, w, g, b), O.mask)
            this.currentCameraMask.mask = O.mask, this.currentCameraMask.camera = O._maskCamera, O.mask.preRenderWebGL(this, O, O._maskCamera);
          if (x.alphaGL > 0) {
            var k = this.pipelines.setMulti();
            k.drawFillRect(q, w, g, b, I.getTintFromFloats(x.blueGL, x.greenGL, x.redGL, 1), x.alphaGL);
          }
        }, getCurrentStencilMask: function() {
          var O = null, q = this.maskStack, w = this.currentCameraMask;
          if (q.length > 0)
            O = q[q.length - 1];
          else if (w.mask && w.mask.isStencil)
            O = w;
          return O;
        }, postRenderCamera: function(O) {
          var { flashEffect: q, fadeEffect: w } = O;
          if (q.isRunning || (w.isRunning || w.isComplete)) {
            var g = this.pipelines.setMulti();
            q.postRenderWebGL(g, I.getTintFromFloats), w.postRenderWebGL(g, I.getTintFromFloats);
          }
          if (O.dirty = false, this.popScissor(), O.mask)
            this.currentCameraMask.mask = null, O.mask.postRenderWebGL(this, O._maskCamera);
          this.pipelines.postBatchCamera(O), O.emit(z.POST_RENDER, O);
        }, preRender: function() {
          if (this.contextLost)
            return;
          var O = this.gl;
          if (O.bindFramebuffer(O.FRAMEBUFFER, null), this.config.clearBeforeRender) {
            var q = this.config.backgroundColor;
            O.clearColor(q.redGL, q.greenGL, q.blueGL, q.alphaGL), O.clear(O.COLOR_BUFFER_BIT | O.DEPTH_BUFFER_BIT | O.STENCIL_BUFFER_BIT);
          }
          if (O.enable(O.SCISSOR_TEST), this.currentScissor = this.defaultScissor, this.scissorStack.length = 0, this.scissorStack.push(this.currentScissor), this.game.scene.customViewports)
            O.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height);
          this.currentMask.mask = null, this.currentCameraMask.mask = null, this.maskStack.length = 0, this.emit(Z.PRE_RENDER);
        }, render: function(O, q, w) {
          if (this.contextLost)
            return;
          var g = q.length;
          if (this.emit(Z.RENDER, O, w), this.preRenderCamera(w), g === 0) {
            this.setBlendMode(K.BlendModes.NORMAL), this.postRenderCamera(w);
            return;
          }
          this.currentType = "";
          var b = this.currentMask;
          for (var x = 0;x < g; x++) {
            this.finalType = x === g - 1;
            var k = q[x], S = k.mask;
            if (b = this.currentMask, b.mask && b.mask !== S)
              b.mask.postRenderWebGL(this, b.camera);
            if (S && b.mask !== S)
              S.preRenderWebGL(this, k, w);
            if (k.blendMode !== this.currentBlendMode)
              this.setBlendMode(k.blendMode);
            var f = k.type;
            if (f !== this.currentType)
              this.newType = true, this.currentType = f;
            if (!this.finalType)
              this.nextTypeMatch = q[x + 1].type === this.currentType;
            else
              this.nextTypeMatch = false;
            k.renderWebGL(this, k, w), this.newType = false;
          }
          if (b = this.currentMask, b.mask)
            b.mask.postRenderWebGL(this, b.camera);
          this.setBlendMode(K.BlendModes.NORMAL), this.postRenderCamera(w);
        }, postRender: function() {
          if (this.contextLost)
            return;
          this.flush(), this.emit(Z.POST_RENDER);
          var O = this.snapshotState;
          if (O.callback)
            P(this.gl, O), O.callback = null;
        }, clearStencilMask: function() {
          this.gl.disable(this.gl.STENCIL_TEST);
        }, restoreStencilMask: function() {
          var O = this.gl, q = this.getCurrentStencilMask();
          if (q) {
            var w = q.mask;
            if (O.enable(O.STENCIL_TEST), w.invertAlpha)
              O.stencilFunc(O.NOTEQUAL, w.level, 255);
            else
              O.stencilFunc(O.EQUAL, w.level, 255);
          }
        }, snapshot: function(O, q, w) {
          return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, O, q, w);
        }, snapshotArea: function(O, q, w, g, b, x, k) {
          var S = this.snapshotState;
          return S.callback = b, S.type = x, S.encoder = k, S.getPixel = false, S.x = O, S.y = q, S.width = w, S.height = g, this;
        }, snapshotPixel: function(O, q, w) {
          return this.snapshotArea(O, q, 1, 1, w), this.snapshotState.getPixel = true, this;
        }, snapshotFramebuffer: function(O, q, w, g, b, x, k, S, f, h, m) {
          if (b === undefined)
            b = false;
          if (x === undefined)
            x = 0;
          if (k === undefined)
            k = 0;
          if (S === undefined)
            S = q;
          if (f === undefined)
            f = w;
          if (h === "pixel")
            b = true, h = "image/png";
          var y = this.currentFramebuffer;
          this.snapshotArea(x, k, S, f, g, h, m);
          var d = this.snapshotState;
          return d.getPixel = b, d.isFramebuffer = true, d.bufferWidth = q, d.bufferHeight = w, d.width = Math.min(d.width, q), d.height = Math.min(d.height, w), this.setFramebuffer(O), P(this.gl, d), this.setFramebuffer(y), d.callback = null, d.isFramebuffer = false, this;
        }, canvasToTexture: function(O, q, w, g) {
          if (w === undefined)
            w = false;
          if (g === undefined)
            g = false;
          var b = this.gl, x = b.NEAREST, k = b.NEAREST, S = O.width, f = O.height, h = b.CLAMP_TO_EDGE, m = D(S, f);
          if (!w && m)
            h = b.REPEAT;
          if (this.config.antialias)
            x = m && this.mipmapFilter ? this.mipmapFilter : b.LINEAR, k = b.LINEAR;
          if (!q)
            return this.createTexture2D(0, x, k, h, h, b.RGBA, O, S, f, true, false, g);
          else
            return q.update(O, S, f, g, h, h, x, k, q.format), q;
        }, createCanvasTexture: function(O, q, w) {
          if (q === undefined)
            q = false;
          if (w === undefined)
            w = false;
          return this.canvasToTexture(O, null, q, w);
        }, updateCanvasTexture: function(O, q, w, g) {
          if (w === undefined)
            w = false;
          if (g === undefined)
            g = false;
          return this.canvasToTexture(O, q, g, w);
        }, videoToTexture: function(O, q, w, g) {
          if (w === undefined)
            w = false;
          if (g === undefined)
            g = false;
          var b = this.gl, x = b.NEAREST, k = b.NEAREST, S = O.videoWidth, f = O.videoHeight, h = b.CLAMP_TO_EDGE, m = D(S, f);
          if (!w && m)
            h = b.REPEAT;
          if (this.config.antialias)
            x = m && this.mipmapFilter ? this.mipmapFilter : b.LINEAR, k = b.LINEAR;
          if (!q)
            return this.createTexture2D(0, x, k, h, h, b.RGBA, O, S, f, true, true, g);
          else
            return q.update(O, S, f, g, h, h, x, k, q.format), q;
        }, createVideoTexture: function(O, q, w) {
          if (q === undefined)
            q = false;
          if (w === undefined)
            w = false;
          return this.videoToTexture(O, null, q, w);
        }, updateVideoTexture: function(O, q, w, g) {
          if (w === undefined)
            w = false;
          if (g === undefined)
            g = false;
          return this.videoToTexture(O, q, g, w);
        }, createUint8ArrayTexture: function(O, q, w) {
          var g = this.gl, b = g.NEAREST, x = g.NEAREST, k = g.CLAMP_TO_EDGE, S = D(q, w);
          if (S)
            k = g.REPEAT;
          return this.createTexture2D(0, b, x, k, k, g.RGBA, O, q, w);
        }, setTextureFilter: function(O, q) {
          var w = this.gl, g = q === 0 ? w.LINEAR : w.NEAREST;
          w.activeTexture(w.TEXTURE0);
          var b = w.getParameter(w.TEXTURE_BINDING_2D);
          if (w.bindTexture(w.TEXTURE_2D, O.webGLTexture), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MIN_FILTER, g), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MAG_FILTER, g), O.minFilter = g, O.magFilter = g, b)
            w.bindTexture(w.TEXTURE_2D, b);
          return this;
        }, getMaxTextureSize: function() {
          return this.config.maxTextureSize;
        }, destroy: function() {
          this.canvas.removeEventListener("webglcontextlost", this.contextLostHandler, false), this.canvas.removeEventListener("webglcontextrestored", this.contextRestoredHandler, false);
          var O = function(q) {
            q.destroy();
          };
          if (E(this.glAttribLocationWrappers, O), E(this.glBufferWrappers, O), E(this.glFramebufferWrappers, O), E(this.glProgramWrappers, O), E(this.glTextureWrappers, O), E(this.glUniformLocationWrappers, O), this.maskTarget.destroy(), this.maskSource.destroy(), this.pipelines.destroy(), this.removeAllListeners(), this.fboStack = [], this.maskStack = [], this.extensions = {}, this.textureIndexes = [], this.gl = null, this.game = null, this.canvas = null, this.contextLost = true, this.currentMask = null, this.currentCameraMask = null, T)
            this.spector = null;
        } });
        M.exports = v;
      }, 38683: (M, B, $) => {
        var E = $(83419), L = $(95428), z = $(95540), U = $(14500), K = new E({ initialize: function J(Z, D, Q, H, N) {
          this.pipeline = Z, this.name = D, this.renderer = Z.renderer, this.gl = this.renderer.gl, this.fragSrc = H, this.vertSrc = Q, this.program = this.renderer.createProgram(Q, H), this.attributes, this.vertexComponentCount = 0, this.vertexSize = 0, this.uniforms = {}, this.createAttributes(N), this.createUniforms();
        }, createAttributes: function(J) {
          var Z = 0, D = 0, Q = [];
          this.vertexComponentCount = 0;
          for (var H = 0;H < J.length; H++) {
            var N = J[H], W = N.name, R = z(N, "size", 1), Y = z(N, "type", U.FLOAT), I = Y.enum, P = Y.size, X = N.normalized ? true : false;
            if (Q.push({ name: W, size: R, type: I, normalized: X, offset: D, enabled: false, location: -1 }), P === 4)
              Z += R;
            else
              Z++;
            D += R * P;
          }
          this.vertexSize = D, this.vertexComponentCount = Z, this.attributes = Q;
        }, bind: function(J, Z) {
          if (J === undefined)
            J = false;
          if (Z === undefined)
            Z = false;
          if (Z)
            this.pipeline.flush();
          if (this.renderer.setProgram(this.program), J)
            this.setAttribPointers();
          return this;
        }, rebind: function() {
          return this.renderer.setProgram(this.program), this.setAttribPointers(true), this;
        }, setAttribPointers: function(J) {
          if (J === undefined)
            J = false;
          var Z = this.gl, D = this.renderer, Q = this.vertexSize, H = this.attributes, N = this.program;
          for (var W = 0;W < H.length; W++) {
            var R = H[W], Y = R.size, I = R.type, P = R.offset, X = R.enabled, G = R.location, V = R.normalized ? true : false;
            if (J) {
              if (G !== -1)
                D.deleteAttribLocation(G);
              var A = this.renderer.createAttribLocation(N, R.name);
              if (A.webGLAttribLocation >= 0)
                Z.enableVertexAttribArray(A.webGLAttribLocation), Z.vertexAttribPointer(A.webGLAttribLocation, Y, I, V, Q, P), R.enabled = true, R.location = A;
              else if (A.webGLAttribLocation !== -1)
                Z.disableVertexAttribArray(A.webGLAttribLocation);
            } else if (X)
              Z.vertexAttribPointer(G.webGLAttribLocation, Y, I, V, Q, P);
            else if (!X && G !== -1 && G.webGLAttribLocation > -1)
              Z.disableVertexAttribArray(G.webGLAttribLocation), R.location = -1;
          }
          return this;
        }, createUniforms: function() {
          var J = this.gl, Z = this.program, D = this.uniforms, Q, H, N, W = J.getProgramParameter(Z.webGLProgram, J.ACTIVE_UNIFORMS);
          for (Q = 0;Q < W; Q++) {
            var R = J.getActiveUniform(Z.webGLProgram, Q);
            if (R) {
              if (H = R.name, N = this.renderer.createUniformLocation(Z, H), N !== null)
                D[H] = { name: H, location: N, setter: null, value1: null, value2: null, value3: null, value4: null };
              var Y = H.indexOf("[");
              if (Y > 0) {
                if (H = H.substr(0, Y), !D.hasOwnProperty(H)) {
                  if (N = this.renderer.createUniformLocation(Z, H), N !== null)
                    D[H] = { name: H, location: N, setter: null, value1: null, value2: null, value3: null, value4: null };
                }
              }
            }
          }
          return this;
        }, syncUniforms: function() {
          var J = this.gl;
          this.renderer.setProgram(this.program);
          for (var Z in this.uniforms) {
            var D = this.uniforms[Z];
            if (D.setter)
              D.setter.call(J, D.location.webGLUniformLocation, D.value1, D.value2, D.value3, D.value4);
          }
        }, hasUniform: function(J) {
          return this.uniforms.hasOwnProperty(J);
        }, resetUniform: function(J) {
          var Z = this.uniforms[J];
          if (Z)
            Z.value1 = null, Z.value2 = null, Z.value3 = null, Z.value4 = null;
          return this;
        }, setUniform1: function(J, Z, D, Q) {
          var H = this.uniforms[Z];
          if (!H)
            return this;
          if (Q || H.value1 !== D) {
            if (!H.setter)
              H.setter = J;
            H.value1 = D, this.renderer.setProgram(this.program), J.call(this.gl, H.location.webGLUniformLocation, D), this.pipeline.currentShader = this;
          }
          return this;
        }, setUniform2: function(J, Z, D, Q, H) {
          var N = this.uniforms[Z];
          if (!N)
            return this;
          if (H || N.value1 !== D || N.value2 !== Q) {
            if (!N.setter)
              N.setter = J;
            N.value1 = D, N.value2 = Q, this.renderer.setProgram(this.program), J.call(this.gl, N.location.webGLUniformLocation, D, Q), this.pipeline.currentShader = this;
          }
          return this;
        }, setUniform3: function(J, Z, D, Q, H, N) {
          var W = this.uniforms[Z];
          if (!W)
            return this;
          if (N || W.value1 !== D || W.value2 !== Q || W.value3 !== H) {
            if (!W.setter)
              W.setter = J;
            W.value1 = D, W.value2 = Q, W.value3 = H, this.renderer.setProgram(this.program), J.call(this.gl, W.location.webGLUniformLocation, D, Q, H), this.pipeline.currentShader = this;
          }
          return this;
        }, setUniform4: function(J, Z, D, Q, H, N, W) {
          var R = this.uniforms[Z];
          if (!R)
            return this;
          if (W || R.value1 !== D || R.value2 !== Q || R.value3 !== H || R.value4 !== N) {
            if (!R.setter)
              R.setter = J;
            R.value1 = D, R.value2 = Q, R.value3 = H, R.value4 = N, this.renderer.setProgram(this.program), J.call(this.gl, R.location.webGLUniformLocation, D, Q, H, N), this.pipeline.currentShader = this;
          }
          return this;
        }, setBoolean: function(J, Z) {
          return this.setUniform1(this.gl.uniform1i, J, Number(Z));
        }, set1f: function(J, Z) {
          return this.setUniform1(this.gl.uniform1f, J, Z);
        }, set2f: function(J, Z, D) {
          return this.setUniform2(this.gl.uniform2f, J, Z, D);
        }, set3f: function(J, Z, D, Q) {
          return this.setUniform3(this.gl.uniform3f, J, Z, D, Q);
        }, set4f: function(J, Z, D, Q, H) {
          return this.setUniform4(this.gl.uniform4f, J, Z, D, Q, H);
        }, set1fv: function(J, Z) {
          return this.setUniform1(this.gl.uniform1fv, J, Z, true);
        }, set2fv: function(J, Z) {
          return this.setUniform1(this.gl.uniform2fv, J, Z, true);
        }, set3fv: function(J, Z) {
          return this.setUniform1(this.gl.uniform3fv, J, Z, true);
        }, set4fv: function(J, Z) {
          return this.setUniform1(this.gl.uniform4fv, J, Z, true);
        }, set1iv: function(J, Z) {
          return this.setUniform1(this.gl.uniform1iv, J, Z, true);
        }, set2iv: function(J, Z) {
          return this.setUniform1(this.gl.uniform2iv, J, Z, true);
        }, set3iv: function(J, Z) {
          return this.setUniform1(this.gl.uniform3iv, J, Z, true);
        }, set4iv: function(J, Z) {
          return this.setUniform1(this.gl.uniform4iv, J, Z, true);
        }, set1i: function(J, Z) {
          return this.setUniform1(this.gl.uniform1i, J, Z);
        }, set2i: function(J, Z, D) {
          return this.setUniform2(this.gl.uniform2i, J, Z, D);
        }, set3i: function(J, Z, D, Q) {
          return this.setUniform3(this.gl.uniform3i, J, Z, D, Q);
        }, set4i: function(J, Z, D, Q, H) {
          return this.setUniform4(this.gl.uniform4i, J, Z, D, Q, H);
        }, setMatrix2fv: function(J, Z, D) {
          return this.setUniform2(this.gl.uniformMatrix2fv, J, Z, D, true);
        }, setMatrix3fv: function(J, Z, D) {
          return this.setUniform2(this.gl.uniformMatrix3fv, J, Z, D, true);
        }, setMatrix4fv: function(J, Z, D) {
          return this.setUniform2(this.gl.uniformMatrix4fv, J, Z, D, true);
        }, createProgram: function(J, Z) {
          if (J === undefined)
            J = this.vertSrc;
          if (Z === undefined)
            Z = this.fragSrc;
          if (this.program)
            this.renderer.deleteProgram(this.program);
          return this.vertSrc = J, this.fragSrc = Z, this.program = this.renderer.createProgram(J, Z), this.createUniforms(), this.rebind();
        }, destroy: function() {
          var J = this.renderer;
          L(this.uniforms, function(Z) {
            J.deleteUniformLocation(Z.location);
          }), this.uniforms = null, L(this.attributes, function(Z) {
            J.deleteAttribLocation(Z.location);
          }), this.attributes = null, J.deleteProgram(this.program), this.pipeline = null, this.renderer = null, this.gl = null, this.program = null;
        } });
        M.exports = K;
      }, 14500: (M) => {
        var B = { BYTE: { enum: 5120, size: 1 }, UNSIGNED_BYTE: { enum: 5121, size: 1 }, SHORT: { enum: 5122, size: 2 }, UNSIGNED_SHORT: { enum: 5123, size: 2 }, INT: { enum: 5124, size: 4 }, UNSIGNED_INT: { enum: 5125, size: 4 }, FLOAT: { enum: 5126, size: 4 } };
        M.exports = B;
      }, 4159: (M, B, $) => {
        var E = $(14500), L = $(79291), z = { PipelineManager: $(7530), Pipelines: $(96615), RenderTarget: $(32302), Utils: $(70554), WebGLPipeline: $(29100), WebGLRenderer: $(74797), WebGLShader: $(38683), Wrappers: $(9503) };
        z = L(false, z, E), M.exports = z;
      }, 31302: (M, B, $) => {
        var E = $(83419), L = $(95540), z = $(78908), U = $(85191), K = $(14500), J = $(29100), Z = new E({ Extends: J, initialize: function D(Q) {
          Q.fragShader = L(Q, "fragShader", z), Q.vertShader = L(Q, "vertShader", U), Q.batchSize = L(Q, "batchSize", 1), Q.vertices = L(Q, "vertices", [-1, 1, -1, -7, 7, 1]), Q.attributes = L(Q, "attributes", [{ name: "inPosition", size: 2, type: K.FLOAT }]), J.call(this, Q);
        }, boot: function() {
          J.prototype.boot.call(this), this.set1i("uMainSampler", 0), this.set1i("uMaskSampler", 1);
        }, resize: function(D, Q) {
          J.prototype.resize.call(this, D, Q), this.set2f("uResolution", D, Q);
        }, beginMask: function(D, Q, H) {
          this.renderer.beginBitmapMask(D, H);
        }, endMask: function(D, Q, H) {
          var N = this.gl, W = this.renderer, R = D.bitmapMask;
          if (R && N) {
            if (W.drawBitmapMask(R, Q, this), H)
              this.set2f("uResolution", H.width, H.height);
            if (this.set1i("uInvertMaskAlpha", D.invertAlpha), N.drawArrays(this.topology, 0, 3), H)
              this.set2f("uResolution", this.width, this.height);
            N.bindTexture(N.TEXTURE_2D, null);
          }
        } });
        M.exports = Z;
      }, 92651: (M, B, $) => {
        var E = $(83419), L = $(58918), z = $(14811), U = $(95540), K = $(43558), J = $(89350), Z = $(70554), D = new E({ Extends: K, initialize: function Q(H) {
          H.shaders = [Z.setGlowQuality(J.FXGlowFrag, H.game), J.FXShadowFrag, J.FXPixelateFrag, J.FXVignetteFrag, J.FXShineFrag, J.FXBlurLowFrag, J.FXBlurMedFrag, J.FXBlurHighFrag, J.FXGradientFrag, J.FXBloomFrag, J.ColorMatrixFrag, J.FXCircleFrag, J.FXBarrelFrag, J.FXDisplacementFrag, J.FXWipeFrag, J.FXBokehFrag], K.call(this, H);
          var N = this.game;
          this.glow = new L.Glow(N), this.shadow = new L.Shadow(N), this.pixelate = new L.Pixelate(N), this.vignette = new L.Vignette(N), this.shine = new L.Shine(N), this.gradient = new L.Gradient(N), this.circle = new L.Circle(N), this.barrel = new L.Barrel(N), this.wipe = new L.Wipe(N), this.bokeh = new L.Bokeh(N);
          var W = [];
          W[z.GLOW] = this.onGlow, W[z.SHADOW] = this.onShadow, W[z.PIXELATE] = this.onPixelate, W[z.VIGNETTE] = this.onVignette, W[z.SHINE] = this.onShine, W[z.BLUR] = this.onBlur, W[z.GRADIENT] = this.onGradient, W[z.BLOOM] = this.onBloom, W[z.COLOR_MATRIX] = this.onColorMatrix, W[z.CIRCLE] = this.onCircle, W[z.BARREL] = this.onBarrel, W[z.DISPLACEMENT] = this.onDisplacement, W[z.WIPE] = this.onWipe, W[z.BOKEH] = this.onBokeh, this.fxHandlers = W, this.source, this.target, this.swap;
        }, onDraw: function(Q, H, N) {
          this.source = Q, this.target = H, this.swap = N;
          var { width: W, height: R } = Q, Y = this.tempSprite, I = this.fxHandlers;
          if (Y && Y.preFX) {
            var P = Y.preFX.list;
            for (var X = 0;X < P.length; X++) {
              var G = P[X];
              if (G.active)
                I[G.type].call(this, G, W, R);
            }
          }
          this.drawToGame(this.source);
        }, runDraw: function() {
          var Q = this.source, H = this.target;
          this.copy(Q, H), this.source = H, this.target = Q;
        }, onGlow: function(Q, H, N) {
          var W = this.shaders[z.GLOW];
          this.setShader(W), this.glow.onPreRender(Q, W, H, N), this.runDraw();
        }, onShadow: function(Q) {
          var H = this.shaders[z.SHADOW];
          this.setShader(H), this.shadow.onPreRender(Q, H), this.runDraw();
        }, onPixelate: function(Q, H, N) {
          var W = this.shaders[z.PIXELATE];
          this.setShader(W), this.pixelate.onPreRender(Q, W, H, N), this.runDraw();
        }, onVignette: function(Q) {
          var H = this.shaders[z.VIGNETTE];
          this.setShader(H), this.vignette.onPreRender(Q, H), this.runDraw();
        }, onShine: function(Q, H, N) {
          var W = this.shaders[z.SHINE];
          this.setShader(W), this.shine.onPreRender(Q, W, H, N), this.runDraw();
        }, onBlur: function(Q, H, N) {
          var W = U(Q, "quality"), R = this.shaders[z.BLUR + W];
          this.setShader(R), this.set1i("uMainSampler", 0), this.set2f("resolution", H, N), this.set1f("strength", U(Q, "strength")), this.set3fv("color", U(Q, "glcolor"));
          var Y = U(Q, "x"), I = U(Q, "y"), P = U(Q, "steps");
          for (var X = 0;X < P; X++)
            this.set2f("offset", Y, 0), this.runDraw(), this.set2f("offset", 0, I), this.runDraw();
        }, onGradient: function(Q) {
          var H = this.shaders[z.GRADIENT];
          this.setShader(H), this.gradient.onPreRender(Q, H), this.runDraw();
        }, onBloom: function(Q, H, N) {
          var W = this.shaders[z.BLOOM];
          this.copySprite(this.source, this.swap), this.setShader(W), this.set1i("uMainSampler", 0), this.set1f("strength", U(Q, "blurStrength")), this.set3fv("color", U(Q, "glcolor"));
          var R = 2 / H * U(Q, "offsetX"), Y = 2 / N * U(Q, "offsetY"), I = U(Q, "steps");
          for (var P = 0;P < I; P++)
            this.set2f("offset", R, 0), this.runDraw(), this.set2f("offset", 0, Y), this.runDraw();
          this.blendFrames(this.swap, this.source, this.target, U(Q, "strength")), this.copySprite(this.target, this.source);
        }, onColorMatrix: function(Q) {
          this.setShader(this.colorMatrixShader), this.set1fv("uColorMatrix", Q.getData()), this.set1f("uAlpha", Q.alpha), this.runDraw();
        }, onCircle: function(Q, H, N) {
          var W = this.shaders[z.CIRCLE];
          this.setShader(W), this.circle.onPreRender(Q, W, H, N), this.runDraw();
        }, onBarrel: function(Q) {
          var H = this.shaders[z.BARREL];
          this.setShader(H), this.barrel.onPreRender(Q, H), this.runDraw();
        }, onDisplacement: function(Q) {
          this.setShader(this.shaders[z.DISPLACEMENT]), this.set1i("uDisplacementSampler", 1), this.set2f("amount", Q.x, Q.y), this.bindTexture(Q.glTexture, 1), this.runDraw();
        }, onWipe: function(Q) {
          var H = this.shaders[z.WIPE];
          this.setShader(H), this.wipe.onPreRender(Q, H), this.runDraw();
        }, onBokeh: function(Q, H, N) {
          var W = this.shaders[z.BOKEH];
          this.setShader(W), this.bokeh.onPreRender(Q, W, H, N), this.runDraw();
        }, destroy: function() {
          return this.glow.destroy(), this.shadow.destroy(), this.pixelate.destroy(), this.vignette.destroy(), this.shine.destroy(), this.gradient.destroy(), this.circle.destroy(), this.barrel.destroy(), this.wipe.destroy(), this.bokeh.destroy(), this.fxHandlers = null, this.source = null, this.target = null, this.swap = null, K.prototype.destroy.call(this), this;
        } });
        M.exports = D;
      }, 96569: (M, B, $) => {
        var E = $(83419), L = $(95540), z = $(31063), U = $(57516), K = $(61340), J = $(26099), Z = $(29100), D = new E({ Extends: U, initialize: function Q(H) {
          var N = L(H, "fragShader", z);
          H.fragShader = N.replace("%LIGHT_COUNT%", H.game.renderer.config.maxLights), U.call(this, H), this.inverseRotationMatrix = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), this.currentNormalMap, this.lightsActive = true, this.tempVec2 = new J, this._tempMatrix = new K, this._tempMatrix2 = new K;
        }, boot: function() {
          Z.prototype.boot.call(this);
        }, onRender: function(Q, H) {
          var N = Q.sys.lights;
          if (this.lightsActive = false, !N || !N.active)
            return;
          var W = N.getLights(H), R = W.length;
          this.lightsActive = true;
          var Y, I = this.renderer, P = I.height, X = H.matrix, G = this.tempVec2;
          this.set1i("uMainSampler", 0), this.set1i("uNormSampler", 1), this.set2f("uResolution", this.width / 2, this.height / 2), this.set4f("uCamera", H.x, H.y, H.rotation, H.zoom), this.set3f("uAmbientLightColor", N.ambientColor.r, N.ambientColor.g, N.ambientColor.b), this.set1i("uLightCount", R);
          for (Y = 0;Y < R; Y++) {
            var V = W[Y].light, A = V.color, F = "uLights[" + Y + "].";
            X.transformPoint(V.x, V.y, G), this.set2f(F + "position", G.x - H.scrollX * V.scrollFactorX * H.zoom, P - (G.y - H.scrollY * V.scrollFactorY * H.zoom)), this.set3f(F + "color", A.r, A.g, A.b), this.set1f(F + "intensity", V.intensity), this.set1f(F + "radius", V.radius);
          }
          this.currentNormalMapRotation = null;
        }, setNormalMapRotation: function(Q) {
          if (Q !== this.currentNormalMapRotation || this.vertexCount === 0) {
            if (this.vertexCount > 0)
              this.flush();
            var H = this.inverseRotationMatrix;
            if (Q) {
              var N = -Q, W = Math.cos(N), R = Math.sin(N);
              H[1] = R, H[3] = -R, H[0] = H[4] = W;
            } else
              H[0] = H[4] = 1, H[1] = H[3] = 0;
            this.setMatrix3fv("uInverseRotationMatrix", false, H), this.currentNormalMapRotation = Q;
          }
        }, setTexture2D: function(Q, H) {
          var N = this.renderer;
          if (Q === undefined)
            Q = N.whiteTexture;
          var W = this.getNormalMap(H);
          if (this.isNewNormalMap(Q, W))
            this.flush(), this.createBatch(Q), this.addTextureToBatch(W), this.currentNormalMap = W;
          var R = 0;
          if (H && H.parentContainer) {
            var Y = H.getWorldTransformMatrix(this._tempMatrix, this._tempMatrix2);
            R = Y.rotationNormalized;
          } else if (H)
            R = H.rotation;
          return this.setNormalMapRotation(R), 0;
        }, setGameObject: function(Q, H) {
          if (H === undefined)
            H = Q.frame;
          var N = H.glTexture, W = this.getNormalMap(Q);
          if (this.isNewNormalMap(N, W))
            this.flush(), this.createBatch(N), this.addTextureToBatch(W), this.currentNormalMap = W;
          if (Q.parentContainer) {
            var R = Q.getWorldTransformMatrix(this._tempMatrix, this._tempMatrix2);
            this.setNormalMapRotation(R.rotationNormalized);
          } else
            this.setNormalMapRotation(Q.rotation);
          return 0;
        }, isNewNormalMap: function(Q, H) {
          return this.currentTexture !== Q || this.currentNormalMap !== H;
        }, getNormalMap: function(Q) {
          var H;
          if (!Q)
            return this.renderer.normalTexture;
          else if (Q.displayTexture)
            H = Q.displayTexture.dataSource[Q.displayFrame.sourceIndex];
          else if (Q.texture)
            H = Q.texture.dataSource[Q.frame.sourceIndex];
          else if (Q.tileset)
            if (Array.isArray(Q.tileset))
              H = Q.tileset[0].image.dataSource[0];
            else
              H = Q.tileset.image.dataSource[0];
          if (!H)
            return this.renderer.normalTexture;
          return H.glTexture;
        }, batchSprite: function(Q, H, N) {
          if (this.lightsActive)
            U.prototype.batchSprite.call(this, Q, H, N);
        }, batchTexture: function(Q, H, N, W, R, Y, I, P, X, G, V, A, F, j, T, C, v, O, q, w, g, b, x, k, S, f, h, m, y, d, p, u) {
          if (this.lightsActive)
            U.prototype.batchTexture.call(this, Q, H, N, W, R, Y, I, P, X, G, V, A, F, j, T, C, v, O, q, w, g, b, x, k, S, f, h, m, y, d, p, u);
        }, batchTextureFrame: function(Q, H, N, W, R, Y, I) {
          if (this.lightsActive)
            U.prototype.batchTextureFrame.call(this, Q, H, N, W, R, Y, I);
        } });
        M.exports = D;
      }, 56527: (M, B, $) => {
        var E = $(83419), L = $(95540), z = $(57516), U = $(45561), K = $(60722), J = $(14500), Z = $(29100), D = new E({ Extends: z, initialize: function Q(H) {
          H.fragShader = L(H, "fragShader", U), H.vertShader = L(H, "vertShader", K), H.attributes = L(H, "attributes", [{ name: "inPosition", size: 2 }, { name: "inTexCoord", size: 2 }, { name: "inTexId" }, { name: "inTintEffect" }, { name: "inTint", size: 4, type: J.UNSIGNED_BYTE, normalized: true }]), H.forceZero = true, H.resizeUniform = "uResolution", z.call(this, H);
        }, boot: function() {
          Z.prototype.boot.call(this);
          var Q = this.renderer;
          this.set1i("uMainSampler", 0), this.set2f("uResolution", Q.width, Q.height), this.set1i("uRoundPixels", Q.config.roundPixels);
        } });
        M.exports = D;
      }, 57516: (M, B, $) => {
        var E = $(83419), L = $(94811), z = $(95540), U = $(98840), K = $(44667), J = $(61340), Z = $(70554), D = $(14500), Q = $(29100), H = new E({ Extends: Q, initialize: function N(W) {
          var R = W.game.renderer, Y = z(W, "fragShader", U);
          W.fragShader = Z.parseFragmentShaderMaxTextures(Y, R.maxTextures), W.vertShader = z(W, "vertShader", K), W.attributes = z(W, "attributes", [{ name: "inPosition", size: 2 }, { name: "inTexCoord", size: 2 }, { name: "inTexId" }, { name: "inTintEffect" }, { name: "inTint", size: 4, type: D.UNSIGNED_BYTE, normalized: true }]), W.resizeUniform = "uResolution", Q.call(this, W), this._tempMatrix1 = new J, this._tempMatrix2 = new J, this._tempMatrix3 = new J, this.calcMatrix = new J, this.tempTriangle = [{ x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }], this.strokeTint = { TL: 0, TR: 0, BL: 0, BR: 0 }, this.fillTint = { TL: 0, TR: 0, BL: 0, BR: 0 }, this.currentFrame = { u0: 0, v0: 0, u1: 1, v1: 1 }, this.firstQuad = [0, 0, 0, 0, 0], this.prevQuad = [0, 0, 0, 0, 0], this.polygonCache = [];
        }, boot: function() {
          Q.prototype.boot.call(this);
          var N = this.renderer;
          this.set1iv("uMainSampler", N.textureIndexes), this.set2f("uResolution", N.width, N.height), this.set1i("uRoundPixels", N.config.roundPixels);
        }, batchSprite: function(N, W, R) {
          this.manager.set(this, N);
          var Y = this._tempMatrix1, I = this._tempMatrix2, P = this._tempMatrix3, X = N.frame, G = X.glTexture, V = X.u0, A = X.v0, F = X.u1, j = X.v1, T = X.x, C = X.y, v = X.cutWidth, O = X.cutHeight, q = X.customPivot, w = N.displayOriginX, g = N.displayOriginY, b = -w + T, x = -g + C;
          if (N.isCropped) {
            var k = N._crop;
            if (k.flipX !== N.flipX || k.flipY !== N.flipY)
              X.updateCropUVs(k, N.flipX, N.flipY);
            V = k.u0, A = k.v0, F = k.u1, j = k.v1, v = k.width, O = k.height, T = k.x, C = k.y, b = -w + T, x = -g + C;
          }
          var S = 1, f = 1;
          if (N.flipX) {
            if (!q)
              b += -X.realWidth + w * 2;
            S = -1;
          }
          if (N.flipY) {
            if (!q)
              x += -X.realHeight + g * 2;
            f = -1;
          }
          var { x: h, y: m } = N;
          if (I.applyITRS(h, m, N.rotation, N.scaleX * S, N.scaleY * f), Y.copyFrom(W.matrix), R)
            Y.multiplyWithOffset(R, -W.scrollX * N.scrollFactorX, -W.scrollY * N.scrollFactorY), I.e = h, I.f = m;
          else
            I.e -= W.scrollX * N.scrollFactorX, I.f -= W.scrollY * N.scrollFactorY;
          Y.multiply(I, P);
          var y = P.setQuad(b, x, b + v, x + O), d = Z.getTintAppendFloatAlpha, p = W.alpha, u = d(N.tintTopLeft, p * N._alphaTL), s = d(N.tintTopRight, p * N._alphaTR), c = d(N.tintBottomLeft, p * N._alphaBL), n = d(N.tintBottomRight, p * N._alphaBR);
          if (this.shouldFlush(6))
            this.flush();
          var _ = this.setGameObject(N, X);
          this.manager.preBatch(N), this.currentShader.set1i("uRoundPixels", W.roundPixels), this.batchQuad(N, y[0], y[1], y[2], y[3], y[4], y[5], y[6], y[7], V, A, F, j, u, s, c, n, N.tintFill, G, _), this.manager.postBatch(N);
        }, batchTexture: function(N, W, R, Y, I, P, X, G, V, A, F, j, T, C, v, O, q, w, g, b, x, k, S, f, h, m, y, d, p, u, s, c, n) {
          if (n === undefined)
            n = false;
          this.manager.set(this, N);
          var _ = this._tempMatrix1, l = this._tempMatrix2, i = this._tempMatrix3, t = w / R + y, $0 = g / Y + d, e = (w + b) / R + y, o = (g + x) / Y + d, r = X, a = G, J0 = -O, Q0 = -q;
          if (N.isCropped) {
            var D0 = N._crop, z0 = D0.width, K0 = D0.height;
            r = z0, a = K0, X = z0, G = K0, w = D0.x, g = D0.y;
            var Z0 = w, W0 = g;
            if (j)
              Z0 = b - D0.x - z0;
            if (T)
              W0 = x - D0.y - K0;
            t = Z0 / R + y, $0 = W0 / Y + d, e = (Z0 + z0) / R + y, o = (W0 + K0) / Y + d, J0 = -O + w, Q0 = -q + g;
          }
          if (T = T ^ (!s && W.isRenderTexture ? 1 : 0), j)
            r *= -1, J0 += X;
          if (T)
            a *= -1, Q0 += G;
          if (l.applyITRS(I, P, F, V, A), _.copyFrom(p.matrix), u)
            _.multiplyWithOffset(u, -p.scrollX * C, -p.scrollY * v), l.e = I, l.f = P;
          else
            l.e -= p.scrollX * C, l.f -= p.scrollY * v;
          _.multiply(l, i);
          var U0 = i.setQuad(J0, Q0, J0 + r, Q0 + a);
          if (c === undefined || c === null)
            c = this.setTexture2D(W);
          if (N && !n)
            this.manager.preBatch(N);
          if (this.currentShader.set1i("uRoundPixels", p.roundPixels), this.batchQuad(N, U0[0], U0[1], U0[2], U0[3], U0[4], U0[5], U0[6], U0[7], t, $0, e, o, k, S, f, h, m, W, c), N && !n)
            this.manager.postBatch(N);
        }, batchTextureFrame: function(N, W, R, Y, I, P, X) {
          this.manager.set(this);
          var G = this._tempMatrix1.copyFrom(P), V = this._tempMatrix2;
          if (X)
            G.multiply(X, V);
          else
            V = G;
          var A = V.setQuad(W, R, W + N.width, R + N.height), F = this.setTexture2D(N.source.glTexture);
          Y = Z.getTintAppendFloatAlpha(Y, I), this.batchQuad(null, A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], N.u0, N.v0, N.u1, N.v1, Y, Y, Y, Y, 0, N.glTexture, F);
        }, batchFillRect: function(N, W, R, Y, I, P) {
          this.renderer.pipelines.set(this);
          var X = this.calcMatrix;
          if (P)
            P.multiply(I, X);
          var G = X.setQuad(N, W, N + R, W + Y), V = this.fillTint;
          this.batchQuad(null, G[0], G[1], G[2], G[3], G[4], G[5], G[6], G[7], 0, 0, 1, 1, V.TL, V.TR, V.BL, V.BR, 2);
        }, batchFillTriangle: function(N, W, R, Y, I, P, X, G) {
          this.renderer.pipelines.set(this);
          var V = this.calcMatrix;
          if (G)
            G.multiply(X, V);
          var A = V.getX(N, W), F = V.getY(N, W), j = V.getX(R, Y), T = V.getY(R, Y), C = V.getX(I, P), v = V.getY(I, P), O = this.fillTint;
          this.currentShader.set1i("uRoundPixels", false), this.batchTri(null, A, F, j, T, C, v, 0, 0, 1, 1, O.TL, O.TR, O.BL, 2);
        }, batchStrokeTriangle: function(N, W, R, Y, I, P, X, G, V) {
          var A = this.tempTriangle;
          A[0].x = N, A[0].y = W, A[0].width = X, A[1].x = R, A[1].y = Y, A[1].width = X, A[2].x = I, A[2].y = P, A[2].width = X, A[3].x = N, A[3].y = W, A[3].width = X, this.batchStrokePath(A, X, false, G, V);
        }, batchFillPath: function(N, W, R) {
          this.renderer.pipelines.set(this);
          var Y = this.calcMatrix;
          if (R)
            R.multiply(W, Y);
          var I = N.length, P = this.polygonCache, X, G, V = this.fillTint.TL, A = this.fillTint.TR, F = this.fillTint.BL;
          for (var j = 0;j < I; ++j)
            G = N[j], P.push(G.x, G.y);
          X = L(P), I = X.length, this.currentShader.set1i("uRoundPixels", false);
          for (var T = 0;T < I; T += 3) {
            var C = X[T + 0] * 2, v = X[T + 1] * 2, O = X[T + 2] * 2, q = P[C + 0], w = P[C + 1], g = P[v + 0], b = P[v + 1], x = P[O + 0], k = P[O + 1], S = Y.getX(q, w), f = Y.getY(q, w), h = Y.getX(g, b), m = Y.getY(g, b), y = Y.getX(x, k), d = Y.getY(x, k);
            this.batchTri(null, S, f, h, m, y, d, 0, 0, 1, 1, V, A, F, 2);
          }
          P.length = 0;
        }, batchStrokePath: function(N, W, R, Y, I) {
          this.renderer.pipelines.set(this), this.prevQuad[4] = 0, this.firstQuad[4] = 0;
          var P = N.length - 1;
          for (var X = 0;X < P; X++) {
            var G = N[X], V = N[X + 1];
            this.batchLine(G.x, G.y, V.x, V.y, G.width / 2, V.width / 2, W, X, !R && X === P - 1, Y, I);
          }
        }, batchLine: function(N, W, R, Y, I, P, X, G, V, A, F) {
          this.renderer.pipelines.set(this);
          var j = this.calcMatrix;
          if (F)
            F.multiply(A, j);
          var T = R - N, C = Y - W, v = Math.sqrt(T * T + C * C);
          if (v === 0)
            return;
          var O = I * (Y - W) / v, q = I * (N - R) / v, w = P * (Y - W) / v, g = P * (N - R) / v, b = R - w, x = Y - g, k = N - O, S = W - q, f = R + w, h = Y + g, m = N + O, y = W + q, d = j.getX(b, x), p = j.getY(b, x), u = j.getX(k, S), s = j.getY(k, S), c = j.getX(f, h), n = j.getY(f, h), _ = j.getX(m, y), l = j.getY(m, y), i = this.strokeTint, t = i.TL, $0 = i.TR, e = i.BL, o = i.BR;
          if (this.currentShader.set1i("uRoundPixels", false), this.batchQuad(null, _, l, u, s, d, p, c, n, 0, 0, 1, 1, t, $0, e, o, 2), X <= 2)
            return;
          var r = this.prevQuad, a = this.firstQuad;
          if (G > 0 && r[4])
            this.batchQuad(null, _, l, u, s, r[0], r[1], r[2], r[3], 0, 0, 1, 1, t, $0, e, o, 2);
          else
            a[0] = _, a[1] = l, a[2] = u, a[3] = s, a[4] = 1;
          if (V && a[4])
            this.batchQuad(null, d, p, c, n, a[0], a[1], a[2], a[3], 0, 0, 1, 1, t, $0, e, o, 2);
          else
            r[0] = d, r[1] = p, r[2] = c, r[3] = n, r[4] = 1;
        }, destroy: function() {
          return this._tempMatrix1.destroy(), this._tempMatrix2.destroy(), this._tempMatrix3.destroy(), this._tempMatrix1 = null, this._tempMatrix1 = null, this._tempMatrix1 = null, Q.prototype.destroy.call(this), this;
        } });
        M.exports = H;
      }, 43439: (M, B, $) => {
        var E = $(83419), L = $(95540), z = $(4127), U = $(89924), K = $(29100), J = new E({ Extends: K, initialize: function Z(D) {
          D.vertShader = L(D, "vertShader", U), D.fragShader = L(D, "fragShader", z), D.attributes = L(D, "attributes", [{ name: "inPosition", size: 2 }, { name: "inLightPosition", size: 2 }, { name: "inLightRadius" }, { name: "inLightAttenuation" }, { name: "inLightColor", size: 4 }]), K.call(this, D);
        }, onRender: function(Z, D) {
          this.set2f("uResolution", this.width, this.height), this.set1f("uCameraZoom", D.zoom);
        }, batchPointLight: function(Z, D, Q, H, N, W, R, Y, I, P, X, G) {
          var { color: V, intensity: A, radius: F, attenuation: j } = Z, T = V.r * A, C = V.g * A, v = V.b * A, O = D.alpha * Z.alpha;
          if (this.shouldFlush(6))
            this.flush();
          if (!this.currentBatch)
            this.setTexture2D();
          this.batchLightVert(Q, H, X, G, F, j, T, C, v, O), this.batchLightVert(N, W, X, G, F, j, T, C, v, O), this.batchLightVert(R, Y, X, G, F, j, T, C, v, O), this.batchLightVert(Q, H, X, G, F, j, T, C, v, O), this.batchLightVert(R, Y, X, G, F, j, T, C, v, O), this.batchLightVert(I, P, X, G, F, j, T, C, v, O), this.currentBatch.count = this.vertexCount - this.currentBatch.start;
        }, batchLightVert: function(Z, D, Q, H, N, W, R, Y, I, P) {
          var X = this.vertexViewF32, G = this.vertexCount * this.currentShader.vertexComponentCount - 1;
          X[++G] = Z, X[++G] = D, X[++G] = Q, X[++G] = H, X[++G] = N, X[++G] = W, X[++G] = R, X[++G] = Y, X[++G] = I, X[++G] = P, this.vertexCount++;
        } });
        M.exports = J;
      }, 84057: (M, B, $) => {
        var E = $(83419), L = $(89422), z = $(95540), U = $(27681), K = $(49627), J = $(29100), Z = new E({ Extends: J, initialize: function D(Q) {
          if (Q.renderTarget = z(Q, "renderTarget", 1), Q.fragShader = z(Q, "fragShader", U), Q.vertShader = z(Q, "vertShader", K), Q.attributes = z(Q, "attributes", [{ name: "inPosition", size: 2 }, { name: "inTexCoord", size: 2 }]), Q.batchSize = 1, Q.vertices = [-1, -1, 0, 0, -1, 1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1, 1, -1, 1, 0], J.call(this, Q), this.isPostFX = true, this.gameObject, this.controller, this.colorMatrix = new L, this.fullFrame1, this.fullFrame2, this.halfFrame1, this.halfFrame2, this.renderer.isBooted)
            this.manager = this.renderer.pipelines;
        }, bootFX: function() {
          J.prototype.boot.call(this);
          var D = this.manager.UTILITY_PIPELINE;
          this.fullFrame1 = D.fullFrame1, this.fullFrame2 = D.fullFrame2, this.halfFrame1 = D.halfFrame1, this.halfFrame2 = D.halfFrame2;
          var Q = this.renderer;
          this.set1i("uMainSampler", 0), this.set2f("uResolution", Q.width, Q.height), this.set1i("uRoundPixels", Q.config.roundPixels);
          var H = this.renderTargets;
          for (var N = 0;N < H.length; N++)
            H[N].autoResize = true;
        }, postBatch: function(D) {
          if (!this.hasBooted) {
            if (this.bootFX(), this.currentRenderTarget)
              this.currentRenderTarget.bind();
          }
          return this.onDraw(this.currentRenderTarget), this.onPostBatch(D), this;
        }, onDraw: function(D) {
          this.bindAndDraw(D);
        }, getController: function(D) {
          if (D !== undefined)
            return D;
          else if (this.controller)
            return this.controller;
          else
            return this;
        }, copySprite: function(D, Q, H) {
          if (H === undefined)
            H = false;
          var N = this.gl;
          N.activeTexture(N.TEXTURE0), N.bindTexture(N.TEXTURE_2D, D.texture.webGLTexture);
          var W = N.getParameter(N.FRAMEBUFFER_BINDING);
          if (N.bindFramebuffer(N.FRAMEBUFFER, Q.framebuffer.webGLFramebuffer), N.framebufferTexture2D(N.FRAMEBUFFER, N.COLOR_ATTACHMENT0, N.TEXTURE_2D, Q.texture.webGLTexture, 0), N.clearColor(0, 0, 0, 0), N.clear(N.COLOR_BUFFER_BIT), N.bufferData(N.ARRAY_BUFFER, this.vertexData, N.STATIC_DRAW), N.drawArrays(N.TRIANGLES, 0, 6), H)
            N.bindTexture(N.TEXTURE_2D, null), N.bindFramebuffer(N.FRAMEBUFFER, W);
        }, copyFrame: function(D, Q, H, N, W) {
          this.manager.copyFrame(D, Q, H, N, W);
        }, copyToGame: function(D) {
          this.manager.copyToGame(D);
        }, drawFrame: function(D, Q, H) {
          this.manager.drawFrame(D, Q, H, this.colorMatrix);
        }, blendFrames: function(D, Q, H, N, W) {
          this.manager.blendFrames(D, Q, H, N, W);
        }, blendFramesAdditive: function(D, Q, H, N, W) {
          this.manager.blendFramesAdditive(D, Q, H, N, W);
        }, clearFrame: function(D, Q) {
          this.manager.clearFrame(D, Q);
        }, blitFrame: function(D, Q, H, N, W, R) {
          this.manager.blitFrame(D, Q, H, N, W, R);
        }, copyFrameRect: function(D, Q, H, N, W, R, Y, I) {
          this.manager.copyFrameRect(D, Q, H, N, W, R, Y, I);
        }, bindAndDraw: function(D, Q, H, N, W) {
          if (H === undefined)
            H = true;
          if (N === undefined)
            N = true;
          var R = this.gl, Y = this.renderer;
          if (this.bind(W), this.set1i("uMainSampler", 0), Q) {
            if (R.viewport(0, 0, Q.width, Q.height), R.bindFramebuffer(R.FRAMEBUFFER, Q.framebuffer.webGLFramebuffer), R.framebufferTexture2D(R.FRAMEBUFFER, R.COLOR_ATTACHMENT0, R.TEXTURE_2D, Q.texture.webGLTexture, 0), H) {
              if (N)
                R.clearColor(0, 0, 0, 0);
              else
                R.clearColor(0, 0, 0, 1);
              R.clear(R.COLOR_BUFFER_BIT);
            }
          } else if (Y.popFramebuffer(false, false), !Y.currentFramebuffer)
            R.viewport(0, 0, Y.width, Y.height);
          if (Y.restoreStencilMask(), R.activeTexture(R.TEXTURE0), R.bindTexture(R.TEXTURE_2D, D.texture.webGLTexture), R.bufferData(R.ARRAY_BUFFER, this.vertexData, R.STATIC_DRAW), R.drawArrays(R.TRIANGLES, 0, 6), Q)
            R.bindTexture(R.TEXTURE_2D, null), R.bindFramebuffer(R.FRAMEBUFFER, Y.currentFramebuffer.webGLFramebuffer);
        }, destroy: function() {
          if (this.controller)
            this.controller.destroy();
          return this.gameObject = null, this.controller = null, this.colorMatrix = null, this.fullFrame1 = null, this.fullFrame2 = null, this.halfFrame1 = null, this.halfFrame2 = null, this.manager.removePostPipeline(this), J.prototype.destroy.call(this), this;
        } });
        M.exports = Z;
      }, 43558: (M, B, $) => {
        var E = $(10312), L = $(67502), z = $(83419), U = $(96293), K = $(95540), J = $(57516), Z = $(27681), D = $(87841), Q = $(32302), H = $(45561), N = $(60722), W = $(29100), R = new z({ Extends: J, initialize: function Y(I) {
          var P = K(I, "fragShader", Z), X = K(I, "vertShader", N), G = K(I, "drawShader", Z), V = [{ name: "DrawSprite", fragShader: H, vertShader: N }, { name: "CopySprite", fragShader: P, vertShader: X }, { name: "DrawGame", fragShader: G, vertShader: N }, { name: "ColorMatrix", fragShader: U }], A = K(I, "shaders", []);
          if (I.shaders = V.concat(A), !I.vertShader)
            I.vertShader = X;
          if (I.batchSize = 1, J.call(this, I), this.isPreFX = true, this.customMainSampler = null, this.drawSpriteShader, this.copyShader, this.gameShader, this.colorMatrixShader, this.quadVertexData, this.quadVertexBuffer, this.quadVertexViewF32, this.spriteBounds = new D, this.targetBounds = new D, this.fsTarget, this.tempSprite, this.renderer.isBooted)
            this.manager = this.renderer.pipelines, this.boot();
        }, boot: function() {
          W.prototype.boot.call(this);
          var Y = this.shaders, I = this.renderer;
          this.drawSpriteShader = Y[0], this.copyShader = Y[1], this.gameShader = Y[2], this.colorMatrixShader = Y[3], this.fsTarget = new Q(I, I.width, I.height, 1, 0, true, true), this.renderTargets = this.manager.renderTargets.concat(this.fsTarget);
          var P = new ArrayBuffer(168);
          this.quadVertexData = P, this.quadVertexViewF32 = new Float32Array(P), this.quadVertexBuffer = I.createVertexBuffer(P, this.gl.STATIC_DRAW), this.onResize(I.width, I.height), this.currentShader = this.copyShader, this.set2f("uResolution", I.width, I.height), this.set1i("uRoundPixels", I.config.roundPixels);
        }, onResize: function(Y, I) {
          var P = this.quadVertexViewF32;
          P[1] = I, P[22] = I, P[14] = Y, P[28] = Y, P[35] = Y, P[36] = I;
        }, batchQuad: function(Y, I, P, X, G, V, A, F, j, T, C, v, O, q, w, g, b, x, k) {
          var S = Math.min(I, X, V, F), f = Math.min(P, G, A, j), h = Math.max(I, X, V, F), m = Math.max(P, G, A, j), y = h - S, d = m - f, p = this.spriteBounds.setTo(S, f, y, d), u = Y ? Y.preFX.padding : 0, s = y + u * 2, c = d + u * 2, n = Math.abs(Math.max(s, c)), _ = this.manager.getRenderTarget(n), l = this.targetBounds.setTo(0, 0, _.width, _.height);
          L(l, p.centerX, p.centerY), this.tempSprite = Y;
          var i = this.gl, t = this.renderer;
          if (t.clearStencilMask(), this.setShader(this.drawSpriteShader), this.set1i("uMainSampler", 0), this.set2f("uResolution", t.width, t.height), this.set1i("uRoundPixels", t.config.roundPixels), this.flipProjectionMatrix(true), Y)
            this.onDrawSprite(Y, _), Y.preFX.onFX(this);
          var $0 = this.fsTarget;
          return this.flush(), i.viewport(0, 0, t.width, t.height), i.bindFramebuffer(i.FRAMEBUFFER, $0.framebuffer.webGLFramebuffer), i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, $0.texture.webGLTexture, 0), i.clearColor(0, 0, 0, 0), i.clear(i.COLOR_BUFFER_BIT), this.setTexture2D(k), this.batchVert(I, P, T, C, 0, x, q), this.batchVert(X, G, T, O, 0, x, g), this.batchVert(V, A, v, O, 0, x, b), this.batchVert(I, P, T, C, 0, x, q), this.batchVert(V, A, v, O, 0, x, b), this.batchVert(F, j, v, C, 0, x, w), this.flush(), this.flipProjectionMatrix(false), i.activeTexture(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, _.texture.webGLTexture), i.copyTexSubImage2D(i.TEXTURE_2D, 0, 0, 0, l.x, l.y, l.width, l.height), i.bindFramebuffer(i.FRAMEBUFFER, null), i.bindTexture(i.TEXTURE_2D, null), this.onBatch(Y), this.currentShader = this.copyShader, this.onDraw(_, this.manager.getSwapRenderTarget(), this.manager.getAltSwapRenderTarget()), true;
        }, onDrawSprite: function() {
        }, onCopySprite: function() {
        }, copySprite: function(Y, I, P, X, G, V, A) {
          if (P === undefined)
            P = true;
          if (X === undefined)
            X = true;
          if (G === undefined)
            G = false;
          if (A === undefined)
            A = this.copyShader;
          var F = this.gl, j = this.tempSprite;
          if (V)
            A = this.colorMatrixShader;
          this.currentShader = A;
          var T = this.setVertexBuffer(this.quadVertexBuffer);
          A.bind(T, false);
          var C = this.renderer;
          if (this.set1i("uMainSampler", 0), this.set2f("uResolution", C.width, C.height), this.set1i("uRoundPixels", C.config.roundPixels), j.preFX.onFXCopy(this), this.onCopySprite(Y, I, j), V)
            this.set1fv("uColorMatrix", V.getData()), this.set1f("uAlpha", V.alpha);
          if (F.activeTexture(F.TEXTURE0), F.bindTexture(F.TEXTURE_2D, Y.texture.webGLTexture), Y.height > I.height)
            F.viewport(0, 0, Y.width, Y.height), this.setTargetUVs(Y, I);
          else {
            var v = I.height - Y.height;
            F.viewport(0, v, Y.width, Y.height), this.resetUVs();
          }
          if (F.bindFramebuffer(F.FRAMEBUFFER, I.framebuffer.webGLFramebuffer), F.framebufferTexture2D(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, F.TEXTURE_2D, I.texture.webGLTexture, 0), P)
            F.clearColor(0, 0, 0, Number(!X)), F.clear(F.COLOR_BUFFER_BIT);
          if (G) {
            var O = this.renderer.currentBlendMode;
            this.renderer.setBlendMode(E.ERASE);
          }
          if (F.bufferData(F.ARRAY_BUFFER, this.quadVertexData, F.STATIC_DRAW), F.drawArrays(F.TRIANGLES, 0, 6), G)
            this.renderer.setBlendMode(O);
          F.bindFramebuffer(F.FRAMEBUFFER, null);
        }, copy: function(Y, I) {
          var P = this.gl;
          this.set1i("uMainSampler", 0), P.activeTexture(P.TEXTURE0), P.bindTexture(P.TEXTURE_2D, Y.texture.webGLTexture), P.viewport(0, 0, Y.width, Y.height), this.setUVs(0, 0, 0, 1, 1, 1, 1, 0), P.bindFramebuffer(P.FRAMEBUFFER, I.framebuffer.webGLFramebuffer), P.framebufferTexture2D(P.FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_2D, I.texture.webGLTexture, 0), P.clearColor(0, 0, 0, 0), P.clear(P.COLOR_BUFFER_BIT), P.bufferData(P.ARRAY_BUFFER, this.quadVertexData, P.STATIC_DRAW), P.drawArrays(P.TRIANGLES, 0, 6), P.bindFramebuffer(P.FRAMEBUFFER, null);
        }, blendFrames: function(Y, I, P, X, G) {
          this.manager.blendFrames(Y, I, P, X, G);
        }, blendFramesAdditive: function(Y, I, P, X, G) {
          this.manager.blendFramesAdditive(Y, I, P, X, G);
        }, drawToGame: function(Y) {
          this.currentShader = null, this.setShader(this.copyShader), this.bindAndDraw(Y);
        }, copyToGame: function(Y) {
          this.currentShader = null, this.setShader(this.gameShader), this.bindAndDraw(Y);
        }, bindAndDraw: function(Y) {
          var I = this.gl, P = this.renderer;
          if (this.set1i("uMainSampler", 0), this.customMainSampler)
            this.setTexture2D(this.customMainSampler);
          else
            this.setTexture2D(Y.texture);
          var X = this._tempMatrix1.loadIdentity(), G = this.targetBounds.x, V = this.targetBounds.y, A = G + Y.width, F = V + Y.height, j = X.getX(G, V), T = X.getX(G, F), C = X.getX(A, F), v = X.getX(A, V), O = X.getY(G, V), q = X.getY(G, F), w = X.getY(A, F), g = X.getY(A, V), b = 16777215;
          if (this.batchVert(j, O, 0, 0, 0, 0, b), this.batchVert(T, q, 0, 1, 0, 0, b), this.batchVert(C, w, 1, 1, 0, 0, b), this.batchVert(j, O, 0, 0, 0, 0, b), this.batchVert(C, w, 1, 1, 0, 0, b), this.batchVert(v, g, 1, 0, 0, 0, b), P.restoreFramebuffer(false, true), !P.currentFramebuffer)
            I.viewport(0, 0, P.width, P.height);
          P.restoreStencilMask(), this.flush(), this.tempSprite = null;
        }, onDraw: function(Y) {
          this.drawToGame(Y);
        }, setUVs: function(Y, I, P, X, G, V, A, F) {
          var j = this.quadVertexViewF32;
          j[2] = Y, j[3] = I, j[9] = P, j[10] = X, j[16] = G, j[17] = V, j[23] = Y, j[24] = I, j[30] = G, j[31] = V, j[37] = A, j[38] = F;
        }, setTargetUVs: function(Y, I) {
          var P = I.height / Y.height;
          if (P > 0.5)
            P = 0.5 - (P - 0.5);
          else
            P = 0.5 + (0.5 - P);
          this.setUVs(0, P, 0, 1 + P, 1, 1 + P, 1, P);
        }, resetUVs: function() {
          this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
        }, destroy: function() {
          return this.renderer.deleteBuffer(this.quadVertexBuffer), this.drawSpriteShader = null, this.copyShader = null, this.gameShader = null, this.colorMatrixShader = null, this.quadVertexData = null, this.quadVertexBuffer = null, this.quadVertexViewF32 = null, this.fsTarget = null, this.tempSprite = null, J.prototype.destroy.call(this), this;
        } });
        M.exports = R;
      }, 81041: (M, B, $) => {
        var E = $(83419), L = $(95540), z = $(57516), U = new E({ Extends: z, initialize: function K(J) {
          J.topology = 5, J.batchSize = L(J, "batchSize", 256), z.call(this, J);
        } });
        M.exports = U;
      }, 12385: (M, B, $) => {
        var E = $(83419), L = $(95540), z = $(57516), U = $(45561), K = $(60722), J = $(29100), Z = new E({ Extends: z, initialize: function D(Q) {
          Q.fragShader = L(Q, "fragShader", U), Q.vertShader = L(Q, "vertShader", K), Q.forceZero = true, z.call(this, Q);
        }, boot: function() {
          J.prototype.boot.call(this);
          var D = this.renderer;
          this.set1i("uMainSampler", 0), this.set2f("uResolution", D.width, D.height), this.set1i("uRoundPixels", D.config.roundPixels);
        } });
        M.exports = Z;
      }, 7589: (M, B, $) => {
        var E = $(35407), L = $(10312), z = $(83419), U = $(89422), K = $(96293), J = $(36682), Z = $(95540), D = $(48247), Q = $(49627), H = $(29100), N = new z({ Extends: H, initialize: function W(R) {
          R.renderTarget = Z(R, "renderTarget", [{ scale: 1, autoResize: true }, { scale: 1, autoResize: true }, { scale: 0.5, autoResize: true }, { scale: 0.5, autoResize: true }]), R.vertShader = Z(R, "vertShader", Q), R.shaders = Z(R, "shaders", [{ name: "Copy", fragShader: J }, { name: "AddBlend", fragShader: E }, { name: "LinearBlend", fragShader: D }, { name: "ColorMatrix", fragShader: K }]), R.attributes = Z(R, "attributes", [{ name: "inPosition", size: 2 }, { name: "inTexCoord", size: 2 }]), R.vertices = [-1, -1, 0, 0, -1, 1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1, 1, -1, 1, 0], R.batchSize = 1, H.call(this, R), this.colorMatrix = new U, this.copyShader, this.addShader, this.linearShader, this.colorMatrixShader, this.fullFrame1, this.fullFrame2, this.halfFrame1, this.halfFrame2;
        }, boot: function() {
          H.prototype.boot.call(this);
          var W = this.shaders, R = this.renderTargets;
          this.copyShader = W[0], this.addShader = W[1], this.linearShader = W[2], this.colorMatrixShader = W[3], this.fullFrame1 = R[0], this.fullFrame2 = R[1], this.halfFrame1 = R[2], this.halfFrame2 = R[3];
        }, copyFrame: function(W, R, Y, I, P) {
          if (Y === undefined)
            Y = 1;
          if (I === undefined)
            I = true;
          if (P === undefined)
            P = true;
          var X = this.gl;
          if (this.setShader(this.copyShader), this.set1i("uMainSampler", 0), this.set1f("uBrightness", Y), X.activeTexture(X.TEXTURE0), X.bindTexture(X.TEXTURE_2D, W.texture.webGLTexture), R)
            X.viewport(0, 0, R.width, R.height), X.bindFramebuffer(X.FRAMEBUFFER, R.framebuffer.webGLFramebuffer), X.framebufferTexture2D(X.FRAMEBUFFER, X.COLOR_ATTACHMENT0, X.TEXTURE_2D, R.texture.webGLTexture, 0);
          else
            X.viewport(0, 0, W.width, W.height);
          if (I) {
            if (P)
              X.clearColor(0, 0, 0, 0);
            else
              X.clearColor(0, 0, 0, 1);
            X.clear(X.COLOR_BUFFER_BIT);
          }
          X.bufferData(X.ARRAY_BUFFER, this.vertexData, X.STATIC_DRAW), X.drawArrays(X.TRIANGLES, 0, 6), X.bindFramebuffer(X.FRAMEBUFFER, null), X.bindTexture(X.TEXTURE_2D, null);
        }, blitFrame: function(W, R, Y, I, P, X, G) {
          if (Y === undefined)
            Y = 1;
          if (I === undefined)
            I = true;
          if (P === undefined)
            P = true;
          if (X === undefined)
            X = false;
          if (G === undefined)
            G = false;
          var V = this.gl;
          if (this.setShader(this.copyShader), this.set1i("uMainSampler", 0), this.set1f("uBrightness", Y), V.activeTexture(V.TEXTURE0), V.bindTexture(V.TEXTURE_2D, W.texture.webGLTexture), W.height > R.height)
            V.viewport(0, 0, W.width, W.height), this.setTargetUVs(W, R);
          else {
            var A = R.height - W.height;
            V.viewport(0, A, W.width, W.height);
          }
          if (V.bindFramebuffer(V.FRAMEBUFFER, R.framebuffer.webGLFramebuffer), V.framebufferTexture2D(V.FRAMEBUFFER, V.COLOR_ATTACHMENT0, V.TEXTURE_2D, R.texture.webGLTexture, 0), I) {
            if (P)
              V.clearColor(0, 0, 0, 0);
            else
              V.clearColor(0, 0, 0, 1);
            V.clear(V.COLOR_BUFFER_BIT);
          }
          if (X) {
            var F = this.renderer.currentBlendMode;
            this.renderer.setBlendMode(L.ERASE);
          }
          if (G)
            this.flipY();
          if (V.bufferData(V.ARRAY_BUFFER, this.vertexData, V.STATIC_DRAW), V.drawArrays(V.TRIANGLES, 0, 6), X)
            this.renderer.setBlendMode(F);
          V.bindFramebuffer(V.FRAMEBUFFER, null), V.bindTexture(V.TEXTURE_2D, null), this.resetUVs();
        }, copyFrameRect: function(W, R, Y, I, P, X, G, V) {
          if (G === undefined)
            G = true;
          if (V === undefined)
            V = true;
          var A = this.gl;
          if (A.bindFramebuffer(A.FRAMEBUFFER, W.framebuffer.webGLFramebuffer), A.framebufferTexture2D(A.FRAMEBUFFER, A.COLOR_ATTACHMENT0, A.TEXTURE_2D, W.texture.webGLTexture, 0), G) {
            if (V)
              A.clearColor(0, 0, 0, 0);
            else
              A.clearColor(0, 0, 0, 1);
            A.clear(A.COLOR_BUFFER_BIT);
          }
          A.activeTexture(A.TEXTURE0), A.bindTexture(A.TEXTURE_2D, R.texture.webGLTexture), A.copyTexSubImage2D(A.TEXTURE_2D, 0, 0, 0, Y, I, P, X), A.bindFramebuffer(A.FRAMEBUFFER, null), A.bindTexture(A.TEXTURE_2D, null);
        }, copyToGame: function(W) {
          var R = this.gl;
          this.setShader(this.copyShader), this.set1i("uMainSampler", 0), this.set1f("uBrightness", 1), this.renderer.popFramebuffer(), R.activeTexture(R.TEXTURE0), R.bindTexture(R.TEXTURE_2D, W.texture.webGLTexture), R.bufferData(R.ARRAY_BUFFER, this.vertexData, R.STATIC_DRAW), R.drawArrays(R.TRIANGLES, 0, 6);
        }, drawFrame: function(W, R, Y, I) {
          if (Y === undefined)
            Y = true;
          if (I === undefined)
            I = this.colorMatrix;
          var P = this.gl;
          if (this.setShader(this.colorMatrixShader), this.set1i("uMainSampler", 0), this.set1fv("uColorMatrix", I.getData()), this.set1f("uAlpha", I.alpha), P.activeTexture(P.TEXTURE0), P.bindTexture(P.TEXTURE_2D, W.texture.webGLTexture), R)
            P.viewport(0, 0, R.width, R.height), P.bindFramebuffer(P.FRAMEBUFFER, R.framebuffer.webGLFramebuffer), P.framebufferTexture2D(P.FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_2D, R.texture.webGLTexture, 0);
          else
            P.viewport(0, 0, W.width, W.height);
          if (Y)
            P.clearColor(0, 0, 0, 0);
          else
            P.clearColor(0, 0, 0, 1);
          P.clear(P.COLOR_BUFFER_BIT), P.bufferData(P.ARRAY_BUFFER, this.vertexData, P.STATIC_DRAW), P.drawArrays(P.TRIANGLES, 0, 6), P.bindFramebuffer(P.FRAMEBUFFER, null), P.bindTexture(P.TEXTURE_2D, null);
        }, blendFrames: function(W, R, Y, I, P, X) {
          if (I === undefined)
            I = 1;
          if (P === undefined)
            P = true;
          if (X === undefined)
            X = this.linearShader;
          var G = this.gl;
          if (this.setShader(X), this.set1i("uMainSampler1", 0), this.set1i("uMainSampler2", 1), this.set1f("uStrength", I), G.activeTexture(G.TEXTURE0), G.bindTexture(G.TEXTURE_2D, W.texture.webGLTexture), G.activeTexture(G.TEXTURE1), G.bindTexture(G.TEXTURE_2D, R.texture.webGLTexture), Y)
            G.bindFramebuffer(G.FRAMEBUFFER, Y.framebuffer.webGLFramebuffer), G.framebufferTexture2D(G.FRAMEBUFFER, G.COLOR_ATTACHMENT0, G.TEXTURE_2D, Y.texture.webGLTexture, 0), G.viewport(0, 0, Y.width, Y.height);
          else
            G.viewport(0, 0, W.width, W.height);
          if (P)
            G.clearColor(0, 0, 0, 0);
          else
            G.clearColor(0, 0, 0, 1);
          G.clear(G.COLOR_BUFFER_BIT), G.bufferData(G.ARRAY_BUFFER, this.vertexData, G.STATIC_DRAW), G.drawArrays(G.TRIANGLES, 0, 6), G.bindFramebuffer(G.FRAMEBUFFER, null), G.bindTexture(G.TEXTURE_2D, null);
        }, blendFramesAdditive: function(W, R, Y, I, P) {
          this.blendFrames(W, R, Y, I, P, this.addShader);
        }, clearFrame: function(W, R) {
          if (R === undefined)
            R = true;
          var Y = this.gl;
          if (Y.viewport(0, 0, W.width, W.height), Y.bindFramebuffer(Y.FRAMEBUFFER, W.framebuffer.webGLFramebuffer), R)
            Y.clearColor(0, 0, 0, 0);
          else
            Y.clearColor(0, 0, 0, 1);
          Y.clear(Y.COLOR_BUFFER_BIT);
          var I = this.renderer.currentFramebuffer;
          Y.bindFramebuffer(Y.FRAMEBUFFER, I.webGLFramebuffer);
        }, setUVs: function(W, R, Y, I, P, X, G, V) {
          var A = this.vertexViewF32;
          A[2] = W, A[3] = R, A[6] = Y, A[7] = I, A[10] = P, A[11] = X, A[14] = W, A[15] = R, A[18] = P, A[19] = X, A[22] = G, A[23] = V;
        }, setTargetUVs: function(W, R) {
          var Y = R.height / W.height;
          if (Y > 0.5)
            Y = 0.5 - (Y - 0.5);
          else
            Y = 0.5 + (0.5 - Y);
          this.setUVs(0, Y, 0, 1 + Y, 1, 1 + Y, 1, Y);
        }, flipX: function() {
          this.setUVs(1, 0, 1, 1, 0, 1, 0, 0);
        }, flipY: function() {
          this.setUVs(0, 1, 0, 0, 1, 0, 1, 1);
        }, resetUVs: function() {
          this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);
        } });
        M.exports = N;
      }, 36060: (M) => {
        var B = { BITMAPMASK_PIPELINE: "BitmapMaskPipeline", LIGHT_PIPELINE: "Light2D", POINTLIGHT_PIPELINE: "PointLightPipeline", SINGLE_PIPELINE: "SinglePipeline", MULTI_PIPELINE: "MultiPipeline", ROPE_PIPELINE: "RopePipeline", GRAPHICS_PIPELINE: "GraphicsPipeline", POSTFX_PIPELINE: "PostFXPipeline", UTILITY_PIPELINE: "UtilityPipeline", MOBILE_PIPELINE: "MobilePipeline", FX_PIPELINE: "FxPipeline" };
        M.exports = B;
      }, 84817: (M) => {
        M.exports = "pipelineafterflush";
      }, 36712: (M) => {
        M.exports = "pipelinebeforeflush";
      }, 40285: (M) => {
        M.exports = "pipelinebind";
      }, 65918: (M) => {
        M.exports = "pipelineboot";
      }, 92852: (M) => {
        M.exports = "pipelinedestroy";
      }, 56072: (M) => {
        M.exports = "pipelinerebind";
      }, 57566: (M) => {
        M.exports = "pipelineresize";
      }, 77085: (M, B, $) => {
        M.exports = { AFTER_FLUSH: $(84817), BEFORE_FLUSH: $(36712), BIND: $(40285), BOOT: $(65918), DESTROY: $(92852), REBIND: $(56072), RESIZE: $(57566) };
      }, 54812: (M, B, $) => {
        var E = $(83419), L = $(99155), z = $(84057), U = new E({ Extends: z, initialize: function K(J) {
          z.call(this, { game: J, fragShader: L }), this.amount = 1;
        }, onPreRender: function(K, J) {
          K = this.getController(K), this.set1f("amount", K.amount, J);
        } });
        M.exports = U;
      }, 67329: (M, B, $) => {
        var E = $(83419), L = $(24400), z = $(84057), U = new E({ Extends: z, initialize: function K(J) {
          z.call(this, { game: J, fragShader: L }), this.steps = 4, this.offsetX = 1, this.offsetY = 1, this.blurStrength = 1, this.strength = 1, this.glcolor = [1, 1, 1];
        }, onPreRender: function(K) {
          K = this.getController(K), this.set1f("strength", K.blurStrength), this.set3fv("color", K.glcolor);
        }, onDraw: function(K) {
          var J = this.getController(), Z = this.fullFrame1, D = this.fullFrame2;
          this.copyFrame(K, D);
          var Q = 2 / K.width * J.offsetX, H = 2 / K.height * J.offsetY;
          for (var N = 0;N < J.steps; N++)
            this.set2f("offset", Q, 0), this.copySprite(K, Z), this.set2f("offset", 0, H), this.copySprite(Z, K);
          this.blendFrames(D, K, Z, J.strength), this.copyToGame(Z);
        } });
        M.exports = U;
      }, 8861: (M, B, $) => {
        var E = $(83419), L = $(41514), z = $(51078), U = $(94328), K = $(84057), J = new E({ Extends: K, initialize: function Z(D) {
          K.call(this, { game: D, shaders: [{ name: "Gaussian5", fragShader: L }, { name: "Gaussian9", fragShader: z }, { name: "Gaussian13", fragShader: U }] }), this.activeShader = this.shaders[0], this.x = 2, this.y = 2, this.steps = 4, this.strength = 1, this.glcolor = [1, 1, 1];
        }, setQualityLow: function() {
          return this.activeShader = this.shaders[0], this;
        }, setQualityMedium: function() {
          return this.activeShader = this.shaders[1], this;
        }, setQualityHigh: function() {
          return this.activeShader = this.shaders[2], this;
        }, onDraw: function(Z) {
          var D = this.getController(), Q = this.gl, H = this.fullFrame1, N = Q.getParameter(Q.FRAMEBUFFER_BINDING);
          this.bind(this.shaders[D.quality]), Q.activeTexture(Q.TEXTURE0), Q.viewport(0, 0, Z.width, Z.height), this.set1i("uMainSampler", 0), this.set2f("resolution", Z.width, Z.height), this.set1f("strength", D.strength), this.set3fv("color", D.glcolor);
          for (var W = 0;W < D.steps; W++)
            this.set2f("offset", D.x, 0), this.copySprite(Z, H), this.set2f("offset", 0, D.y), this.copySprite(H, Z);
          Q.bindFramebuffer(Q.FRAMEBUFFER, N), Q.bindTexture(Q.TEXTURE_2D, null), this.copyToGame(Z);
        } });
        M.exports = J;
      }, 51051: (M, B, $) => {
        var E = $(83419), L = $(90610), z = $(84057), U = new E({ Extends: z, initialize: function K(J) {
          z.call(this, { game: J, fragShader: L }), this.isTiltShift = false, this.strength = 1, this.blurX = 1, this.blurY = 1, this.radius = 0.5, this.amount = 1, this.contrast = 0.2;
        }, onPreRender: function(K, J, Z, D) {
          if (K = this.getController(K), this.set1f("radius", K.radius, J), this.set1f("amount", K.amount, J), this.set1f("contrast", K.contrast, J), this.set1f("strength", K.strength, J), this.set2f("blur", K.blurX, K.blurY, J), this.setBoolean("isTiltShift", K.isTiltShift, J), Z && D)
            this.set2f("resolution", Z, D, J);
        }, onDraw: function(K) {
          this.set2f("resolution", K.width, K.height), this.bindAndDraw(K);
        } });
        M.exports = U;
      }, 89428: (M, B, $) => {
        var E = $(83419), L = $(91899), z = $(84057), U = new E({ Extends: z, initialize: function K(J) {
          z.call(this, { game: J, fragShader: L }), this.scale = 1, this.feather = 0.005, this.thickness = 8, this.glcolor = [1, 0.2, 0.7], this.glcolor2 = [1, 0, 0, 0.4];
        }, onPreRender: function(K, J, Z, D) {
          if (K = this.getController(K), this.set1f("scale", K.scale, J), this.set1f("feather", K.feather, J), this.set1f("thickness", K.thickness, J), this.set3fv("color", K.glcolor, J), this.set4fv("backgroundColor", K.glcolor2, J), Z && D)
            this.set2f("resolution", Z, D, J);
        }, onDraw: function(K) {
          this.set2f("resolution", K.width, K.height), this.bindAndDraw(K);
        } });
        M.exports = U;
      }, 88904: (M, B, $) => {
        var E = $(83419), L = $(84057), z = new E({ Extends: L, initialize: function U(K) {
          L.call(this, { game: K });
        }, onDraw: function(U) {
          var K = this.fullFrame1;
          if (this.controller)
            this.manager.drawFrame(U, K, true, this.controller);
          else
            this.drawFrame(U, K);
          this.copyToGame(K);
        } });
        M.exports = z;
      }, 63563: (M, B, $) => {
        var E = $(83419), L = $(47838), z = $(84057), U = new E({ Extends: z, initialize: function K(J) {
          z.call(this, { game: J, fragShader: L }), this.x = 0.005, this.y = 0.005, this.glTexture;
        }, onBoot: function() {
          this.setTexture("__WHITE");
        }, setTexture: function(K) {
          var J = this.game.textures.getFrame(K);
          if (J)
            this.glTexture = J.glTexture;
        }, onDraw: function(K) {
          var J = this.getController(), Z = this.fullFrame1;
          this.bind(), this.set1i("uMainSampler", 0), this.set1i("uDisplacementSampler", 1), this.set2f("amount", J.x, J.y), this.bindTexture(J.glTexture, 1), this.copySprite(K, Z), this.copyToGame(Z);
        } });
        M.exports = U;
      }, 94045: (M, B, $) => {
        var E = $(83419), L = $(95540), z = $(98656), U = $(84057), K = $(70554), J = new E({ Extends: U, initialize: function Z(D, Q) {
          var H = L(Q, "quality", 0.1), N = L(Q, "distance", 10);
          U.call(this, { game: D, fragShader: K.setGlowQuality(z, D, H, N) }), this.outerStrength = 4, this.innerStrength = 0, this.knockout = false, this.glcolor = [1, 1, 1, 1];
        }, onPreRender: function(Z, D, Q, H) {
          if (Z = this.getController(Z), this.set1f("outerStrength", Z.outerStrength, D), this.set1f("innerStrength", Z.innerStrength, D), this.set4fv("glowColor", Z.glcolor, D), this.setBoolean("knockout", Z.knockout, D), Q && H)
            this.set2f("resolution", Q, H, D);
        }, onDraw: function(Z) {
          this.set2f("resolution", Z.width, Z.height), this.bindAndDraw(Z);
        } });
        M.exports = J;
      }, 74088: (M, B, $) => {
        var E = $(83419), L = $(70463), z = $(84057), U = new E({ Extends: z, initialize: function K(J) {
          z.call(this, { game: J, fragShader: L }), this.alpha = 0.2, this.size = 0, this.fromX = 0, this.fromY = 0, this.toX = 0, this.toY = 1, this.glcolor1 = [255, 0, 0], this.glcolor2 = [0, 255, 0];
        }, onPreRender: function(K, J) {
          K = this.getController(K), this.set1f("alpha", K.alpha, J), this.set1i("size", K.size, J), this.set3fv("color1", K.glcolor1, J), this.set3fv("color2", K.glcolor2, J), this.set2f("positionFrom", K.fromX, K.fromY, J), this.set2f("positionTo", K.toX, K.toY, J);
        } });
        M.exports = U;
      }, 99636: (M, B, $) => {
        var E = $(83419), L = $(50831), z = $(84057), U = new E({ Extends: z, initialize: function K(J) {
          z.call(this, { game: J, fragShader: L }), this.amount = 1;
        }, onPreRender: function(K, J, Z, D) {
          if (K = this.getController(K), this.set1f("amount", K.amount, J), Z && D)
            this.set2f("resolution", Z, D, J);
        }, onDraw: function(K) {
          this.set2f("resolution", K.width, K.height), this.bindAndDraw(K);
        } });
        M.exports = U;
      }, 34700: (M, B, $) => {
        var E = $(83419), L = $(92595), z = $(84057), U = new E({ Extends: z, initialize: function K(J) {
          z.call(this, { game: J, fragShader: L }), this.x = 0, this.y = 0, this.decay = 0.1, this.power = 1, this.glcolor = [0, 0, 0, 1], this.samples = 6, this.intensity = 1;
        }, onPreRender: function(K, J) {
          K = this.getController(K);
          var Z = K.samples;
          this.set1i("samples", Z, J), this.set1f("intensity", K.intensity, J), this.set1f("decay", K.decay, J), this.set1f("power", K.power / Z, J), this.set2f("lightPosition", K.x, K.y, J), this.set4fv("color", K.glcolor, J);
        } });
        M.exports = U;
      }, 91157: (M, B, $) => {
        var E = $(83419), L = $(72464), z = $(84057), U = new E({ Extends: z, initialize: function K(J) {
          z.call(this, { game: J, fragShader: L }), this.speed = 0.5, this.lineWidth = 0.5, this.gradient = 3, this.reveal = false;
        }, onPreRender: function(K, J, Z, D) {
          if (K = this.getController(K), this.setTime("time", J), this.set1f("speed", K.speed, J), this.set1f("lineWidth", K.lineWidth, J), this.set1f("gradient", K.gradient, J), this.setBoolean("reveal", K.reveal, J), Z && D)
            this.set2f("resolution", Z, D, J);
        }, onDraw: function(K) {
          this.set2f("resolution", K.width, K.height), this.bindAndDraw(K);
        } });
        M.exports = U;
      }, 27797: (M, B, $) => {
        var E = $(83419), L = $(39249), z = $(84057), U = new E({ Extends: z, initialize: function K(J) {
          z.call(this, { game: J, fragShader: L }), this.x = 0.5, this.y = 0.5, this.radius = 0.5, this.strength = 0.5;
        }, onPreRender: function(K, J) {
          K = this.getController(K), this.set1f("radius", K.radius, J), this.set1f("strength", K.strength, J), this.set2f("position", K.x, K.y, J);
        } });
        M.exports = U;
      }, 67603: (M, B, $) => {
        var E = $(83419), L = $(2878), z = $(84057), U = new E({ Extends: z, initialize: function K(J) {
          z.call(this, { game: J, fragShader: L }), this.progress = 0, this.wipeWidth = 0.1, this.direction = 0, this.axis = 0, this.reveal = false;
        }, onPreRender: function(K, J) {
          K = this.getController(K);
          var { progress: Z, wipeWidth: D, direction: Q, axis: H } = K;
          this.set4f("config", Z, D, Q, H, J), this.setBoolean("reveal", K.reveal, J);
        } });
        M.exports = U;
      }, 58918: (M, B, $) => {
        var E = { Barrel: $(54812), Bloom: $(67329), Blur: $(8861), Bokeh: $(51051), Circle: $(89428), ColorMatrix: $(88904), Displacement: $(63563), Glow: $(94045), Gradient: $(74088), Pixelate: $(99636), Shadow: $(34700), Shine: $(91157), Vignette: $(27797), Wipe: $(67603) };
        M.exports = E;
      }, 96615: (M, B, $) => {
        var E = $(36060), L = $(79291), z = { FX: $(58918), BitmapMaskPipeline: $(31302), Events: $(77085), FXPipeline: $(92651), LightPipeline: $(96569), MobilePipeline: $(56527), MultiPipeline: $(57516), PointLightPipeline: $(43439), PostFXPipeline: $(84057), PreFXPipeline: $(43558), RopePipeline: $(81041), SinglePipeline: $(12385), UtilityPipeline: $(7589) };
        z = L(false, z, E), M.exports = z;
      }, 35407: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_ADD_BLEND_FS", "precision mediump float;", "uniform sampler2D uMainSampler1;", "uniform sampler2D uMainSampler2;", "uniform float uStrength;", "varying vec2 outTexCoord;", "void main ()", "{", "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);", "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);", "    gl_FragColor = frame1 + frame2 * uStrength;", "}"].join("\n");
      }, 78908: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_BITMAP_MASK_FS", "precision mediump float;", "uniform vec2 uResolution;", "uniform sampler2D uMainSampler;", "uniform sampler2D uMaskSampler;", "uniform bool uInvertMaskAlpha;", "void main ()", "{", "    vec2 uv = gl_FragCoord.xy / uResolution;", "    vec4 mainColor = texture2D(uMainSampler, uv);", "    vec4 maskColor = texture2D(uMaskSampler, uv);", "    if (!uInvertMaskAlpha)", "    {", "        mainColor *= maskColor.a;", "    }", "    else", "    {", "        mainColor *= (1.0 - maskColor.a);", "    }", "    gl_FragColor = mainColor;", "}"].join("\n");
      }, 85191: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_BITMAP_MASK_VS", "precision mediump float;", "attribute vec2 inPosition;", "void main ()", "{", "    gl_Position = vec4(inPosition, 0.0, 1.0);", "}"].join("\n");
      }, 96293: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_COLORMATRIX_FS", "precision mediump float;", "uniform sampler2D uMainSampler;", "uniform float uColorMatrix[20];", "uniform float uAlpha;", "varying vec2 outTexCoord;", "void main ()", "{", "    vec4 c = texture2D(uMainSampler, outTexCoord);", "    if (uAlpha == 0.0)", "    {", "        gl_FragColor = c;", "        return;", "    }", "    if (c.a > 0.0)", "    {", "        c.rgb /= c.a;", "    }", "    vec4 result;", "    result.r = (uColorMatrix[0] * c.r) + (uColorMatrix[1] * c.g) + (uColorMatrix[2] * c.b) + (uColorMatrix[3] * c.a) + uColorMatrix[4];", "    result.g = (uColorMatrix[5] * c.r) + (uColorMatrix[6] * c.g) + (uColorMatrix[7] * c.b) + (uColorMatrix[8] * c.a) + uColorMatrix[9];", "    result.b = (uColorMatrix[10] * c.r) + (uColorMatrix[11] * c.g) + (uColorMatrix[12] * c.b) + (uColorMatrix[13] * c.a) + uColorMatrix[14];", "    result.a = (uColorMatrix[15] * c.r) + (uColorMatrix[16] * c.g) + (uColorMatrix[17] * c.b) + (uColorMatrix[18] * c.a) + uColorMatrix[19];", "    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);", "    rgb *= result.a;", "    gl_FragColor = vec4(rgb, result.a);", "}"].join("\n");
      }, 36682: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_COPY_FS", "precision mediump float;", "uniform sampler2D uMainSampler;", "uniform float uBrightness;", "varying vec2 outTexCoord;", "void main ()", "{", "    gl_FragColor = texture2D(uMainSampler, outTexCoord) * uBrightness;", "}"].join("\n");
      }, 99155: (M) => {
        M.exports = ["#define SHADER_NAME BARREL_FS", "precision mediump float;", "uniform sampler2D uMainSampler;", "uniform float amount;", "varying vec2 outTexCoord;", "vec2 Distort(vec2 p)", "{", "    float theta  = atan(p.y, p.x);", "    float radius = length(p);", "    radius = pow(radius, amount);", "    p.x = radius * cos(theta);", "    p.y = radius * sin(theta);", "    return 0.5 * (p + 1.0);", "}", "void main()", "{", "    vec2 xy = 2.0 * outTexCoord - 1.0;", "    vec2 texCoord = outTexCoord;", "    if (length(xy) < 1.0)", "    {", "        texCoord = Distort(xy);", "    }", "    gl_FragColor = texture2D(uMainSampler, texCoord);", "}"].join("\n");
      }, 24400: (M) => {
        M.exports = ["#define SHADER_NAME BLOOM_FS", "precision mediump float;", "uniform sampler2D uMainSampler;", "uniform vec2 offset;", "uniform float strength;", "uniform vec3 color;", "varying vec2 outTexCoord;", "void main ()", "{", "    vec4 sum = texture2D(uMainSampler, outTexCoord) * 0.204164 * strength;", "    sum = sum + texture2D(uMainSampler, outTexCoord + offset * 1.407333) * 0.304005;", "    sum = sum + texture2D(uMainSampler, outTexCoord - offset * 1.407333) * 0.304005;", "    sum = sum + texture2D(uMainSampler, outTexCoord + offset * 3.294215) * 0.093913;", "    gl_FragColor = (sum + texture2D(uMainSampler, outTexCoord - offset * 3.294215) * 0.093913) * vec4(color, 1);", "}"].join("\n");
      }, 94328: (M) => {
        M.exports = ["#define SHADER_NAME BLUR_HIGH_FS", "precision mediump float;", "uniform sampler2D uMainSampler;", "uniform vec2 resolution;", "uniform vec2 offset;", "uniform float strength;", "uniform vec3 color;", "varying vec2 outTexCoord;", "void main ()", "{", "    vec2 uv = outTexCoord;", "    vec4 col = vec4(0.0);", "    vec2 off1 = vec2(1.411764705882353) * offset * strength;", "    vec2 off2 = vec2(3.2941176470588234) * offset * strength;", "    vec2 off3 = vec2(5.176470588235294) * offset * strength;", "    col += texture2D(uMainSampler, uv) * 0.1964825501511404;", "    col += texture2D(uMainSampler, uv + (off1 / resolution)) * 0.2969069646728344;", "    col += texture2D(uMainSampler, uv - (off1 / resolution)) * 0.2969069646728344;", "    col += texture2D(uMainSampler, uv + (off2 / resolution)) * 0.09447039785044732;", "    col += texture2D(uMainSampler, uv - (off2 / resolution)) * 0.09447039785044732;", "    col += texture2D(uMainSampler, uv + (off3 / resolution)) * 0.010381362401148057;", "    col += texture2D(uMainSampler, uv - (off3 / resolution)) * 0.010381362401148057;", "    gl_FragColor = col * vec4(color, 1.0);", "}"].join("\n");
      }, 41514: (M) => {
        M.exports = ["#define SHADER_NAME BLUR_LOW_FS", "precision mediump float;", "uniform sampler2D uMainSampler;", "uniform vec2 resolution;", "uniform vec2 offset;", "uniform float strength;", "uniform vec3 color;", "varying vec2 outTexCoord;", "void main ()", "{", "    vec2 uv = outTexCoord;", "    vec4 col = vec4(0.0);", "    vec2 offset = vec2(1.333) * offset * strength;", "    col += texture2D(uMainSampler, uv) * 0.29411764705882354;", "    col += texture2D(uMainSampler, uv + (offset / resolution)) * 0.35294117647058826;", "    col += texture2D(uMainSampler, uv - (offset / resolution)) * 0.35294117647058826;", "    gl_FragColor = col * vec4(color, 1.0);", "}"].join("\n");
      }, 51078: (M) => {
        M.exports = ["#define SHADER_NAME BLUR_MED_FS", "precision mediump float;", "uniform sampler2D uMainSampler;", "uniform vec2 resolution;", "uniform vec2 offset;", "uniform float strength;", "uniform vec3 color;", "varying vec2 outTexCoord;", "void main ()", "{", "    vec2 uv = outTexCoord;", "    vec4 col = vec4(0.0);", "    vec2 off1 = vec2(1.3846153846) * offset * strength;", "    vec2 off2 = vec2(3.2307692308) * offset * strength;", "    col += texture2D(uMainSampler, uv) * 0.2270270270;", "    col += texture2D(uMainSampler, uv + (off1 / resolution)) * 0.3162162162;", "    col += texture2D(uMainSampler, uv - (off1 / resolution)) * 0.3162162162;", "    col += texture2D(uMainSampler, uv + (off2 / resolution)) * 0.0702702703;", "    col += texture2D(uMainSampler, uv - (off2 / resolution)) * 0.0702702703;", "    gl_FragColor = col * vec4(color, 1.0);", "}"].join("\n");
      }, 90610: (M) => {
        M.exports = ["#define SHADER_NAME BOKEH_FS", "precision mediump float;", "#define ITERATIONS 100.0", "#define ONEOVER_ITR 1.0 / ITERATIONS", "#define PI 3.141596", "#define GOLDEN_ANGLE 2.39996323", "uniform sampler2D uMainSampler;", "uniform vec2 resolution;", "uniform float radius;", "uniform float amount;", "uniform float contrast;", "uniform bool isTiltShift;", "uniform float strength;", "uniform vec2 blur;", "varying vec2 outTexCoord;", "vec2 Sample (in float theta, inout float r)", "{", "    r += 1.0 / r;", "    return (r - 1.0) * vec2(cos(theta), sin(theta)) * 0.06;", "}", "vec3 Bokeh (sampler2D tex, vec2 uv, float radius)", "{", "    vec3 acc = vec3(0.0);", "    vec3 div = vec3(0.0);", "    vec2 pixel = vec2(resolution.y / resolution.x, 1.0) * radius * .025;", "    float r = 1.0;", "    for (float j = 0.0; j < GOLDEN_ANGLE * ITERATIONS; j += GOLDEN_ANGLE)", "    {", "        vec3 col = texture2D(tex, uv + pixel * Sample(j, r)).xyz;", "        col = contrast > 0.0 ? col * col * (1.0 + contrast) : col;", "        vec3 bokeh = vec3(0.5) + pow(col, vec3(10.0)) * amount;", "        acc += col * bokeh;", "        div += bokeh;", "    }", "    return acc / div;", "}", "void main ()", "{", "    float shift = 1.0;", "    if (isTiltShift)", "    {", "        vec2 uv = vec2(gl_FragCoord.xy / resolution + vec2(-0.5, -0.5)) * 2.0;", "        float centerStrength = 1.0;", "        shift = length(uv * blur * strength) * centerStrength;", "    }", "    gl_FragColor = vec4(Bokeh(uMainSampler, outTexCoord * vec2(1.0, 1.0), radius * shift), 0.0);", "}"].join("\n");
      }, 91899: (M) => {
        M.exports = ["#define SHADER_NAME CIRCLE_FS", "precision mediump float;", "uniform sampler2D uMainSampler;", "uniform vec2 resolution;", "uniform vec3 color;", "uniform vec4 backgroundColor;", "uniform float thickness;", "uniform float scale;", "uniform float feather;", "varying vec2 outTexCoord;", "void main ()", "{", "    vec4 texture = texture2D(uMainSampler, outTexCoord);", "    vec2 position = (gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;", "    float aspectRatio = resolution.x / resolution.y;", "    position.x *= aspectRatio;", "    float grad = length(position);", "    float outer = aspectRatio;", "    float inner = outer - (thickness * 2.0 / resolution.y);", "    if (aspectRatio >= 1.0)", "    {", "        float f = 2.0 + (resolution.y / resolution.x);", "        outer = 1.0;", "        inner = 1.0 - (thickness * f / resolution.x);", "    }", "    outer *= scale;", "    inner *= scale;", "    float circle = smoothstep(outer, outer - 0.01, grad);", "    float ring = circle - smoothstep(inner, inner - feather, grad);", "    texture = mix(backgroundColor * backgroundColor.a, texture, texture.a);", "    texture = (texture * (circle - ring));", "    gl_FragColor = vec4(texture.rgb + (ring * color), texture.a);", "}"].join("\n");
      }, 47838: (M) => {
        M.exports = ["#define SHADER_NAME DISPLACEMENT_FS", "precision mediump float;", "uniform sampler2D uMainSampler;", "uniform sampler2D uDisplacementSampler;", "uniform vec2 amount;", "varying vec2 outTexCoord;", "void main ()", "{", "    vec2 disp = (-vec2(0.5, 0.5) + texture2D(uDisplacementSampler, outTexCoord).rr) * amount;", "    gl_FragColor = texture2D(uMainSampler, outTexCoord + disp).rgba;", "}"].join("\n");
      }, 98656: (M) => {
        M.exports = ["#define SHADER_NAME GLOW_FS", "precision mediump float;", "uniform sampler2D uMainSampler;", "varying vec2 outTexCoord;", "uniform float outerStrength;", "uniform float innerStrength;", "uniform vec2 resolution;", "uniform vec4 glowColor;", "uniform bool knockout;", "const float PI = 3.14159265358979323846264;", "const float DIST = __DIST__;", "const float SIZE = min(__SIZE__, PI * 2.0);", "const float STEP = ceil(PI * 2.0 / SIZE);", "const float MAX_ALPHA = STEP * DIST * (DIST + 1.0) / 2.0;", "void main ()", "{", "    vec2 px = vec2(1.0 / resolution.x, 1.0 / resolution.y);", "    float totalAlpha = 0.0;", "    vec2 direction;", "    vec2 displaced;", "    vec4 color;", "    for (float angle = 0.0; angle < PI * 2.0; angle += SIZE)", "    {", "        direction = vec2(cos(angle), sin(angle)) * px;", "        for (float curDistance = 0.0; curDistance < DIST; curDistance++)", "        {", "            displaced = outTexCoord + direction * (curDistance + 1.0);", "            color = texture2D(uMainSampler, displaced);", "            totalAlpha += (DIST - curDistance) * color.a;", "        }", "    }", "    color = texture2D(uMainSampler, outTexCoord);", "    float alphaRatio = (totalAlpha / MAX_ALPHA);", "    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * color.a;", "    float innerGlowStrength = min(1.0, innerGlowAlpha);", "    vec4 innerColor = mix(color, glowColor, innerGlowStrength);", "    float outerGlowAlpha = alphaRatio * outerStrength * (1.0 - color.a);", "    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);", "    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;", "    if (knockout)", "    {", "        float resultAlpha = outerGlowAlpha + innerGlowAlpha;", "        gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);", "    }", "    else", "    {", "        gl_FragColor = innerColor + outerGlowColor;", "    }", "}"].join("\n");
      }, 70463: (M) => {
        M.exports = ["#define SHADER_NAME GRADIENT_FS", "#define SRGB_TO_LINEAR(c) pow((c), vec3(2.2))", "#define LINEAR_TO_SRGB(c) pow((c), vec3(1.0 / 2.2))", "#define SRGB(r, g, b) SRGB_TO_LINEAR(vec3(float(r), float(g), float(b)) / 255.0)", "precision mediump float;", "uniform sampler2D uMainSampler;", "uniform vec2 positionFrom;", "uniform vec2 positionTo;", "uniform vec3 color1;", "uniform vec3 color2;", "uniform float alpha;", "uniform int size;", "varying vec2 outTexCoord;", "float gradientNoise(in vec2 uv)", "{", "    const vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);", "    return fract(magic.z * fract(dot(uv, magic.xy)));", "}", "float stepped (in float s, in float scale, in int steps)", "{", "    return steps > 0 ? floor( s / ((1.0 * scale) / float(steps))) * 1.0 / float(steps - 1) : s;", "}", "void main ()", "{", "    vec2 a = positionFrom;", "    vec2 b = positionTo;", "    vec2 ba = b - a;", "    float d = dot(outTexCoord - a, ba) / dot(ba, ba);", "    float t = size > 0 ? stepped(d, 1.0, size) : d;", "    t = smoothstep(0.0, 1.0, clamp(t, 0.0, 1.0));", "    vec3 color = mix(SRGB(color1.r, color1.g, color1.b), SRGB(color2.r, color2.g, color2.b), t);", "    color = LINEAR_TO_SRGB(color);", "    color += (1.0 / 255.0) * gradientNoise(outTexCoord) - (0.5 / 255.0);", "    vec4 texture = texture2D(uMainSampler, outTexCoord);", "    gl_FragColor = vec4(mix(color.rgb, texture.rgb, alpha), 1.0) * texture.a;", "}"].join("\n");
      }, 50831: (M) => {
        M.exports = ["#define SHADER_NAME PIXELATE_FS", "precision mediump float;", "uniform sampler2D uMainSampler;", "uniform vec2 resolution;", "uniform float amount;", "varying vec2 outTexCoord;", "void main ()", "{", "    float pixelSize = floor(2.0 + amount);", "    vec2 center = pixelSize * floor(outTexCoord * resolution / pixelSize) + pixelSize * vec2(0.5, 0.5);", "    vec2 corner1 = center + pixelSize * vec2(-0.5, -0.5);", "    vec2 corner2 = center + pixelSize * vec2(+0.5, -0.5);", "    vec2 corner3 = center + pixelSize * vec2(+0.5, +0.5);", "    vec2 corner4 = center + pixelSize * vec2(-0.5, +0.5);", "    vec4 pixel = 0.4 * texture2D(uMainSampler, center / resolution);", "    pixel += 0.15 * texture2D(uMainSampler, corner1 / resolution);", "    pixel += 0.15 * texture2D(uMainSampler, corner2 / resolution);", "    pixel += 0.15 * texture2D(uMainSampler, corner3 / resolution);", "    pixel += 0.15 * texture2D(uMainSampler, corner4 / resolution);", "    gl_FragColor = pixel;", "}"].join("\n");
      }, 92595: (M) => {
        M.exports = ["#define SHADER_NAME SHADOW_FS", "precision mediump float;", "uniform sampler2D uMainSampler;", "varying vec2 outTexCoord;", "uniform vec2 lightPosition;", "uniform vec4 color;", "uniform float decay;", "uniform float power;", "uniform float intensity;", "uniform int samples;", "const int MAX = 12;", "void main ()", "{", "    vec4 texture = texture2D(uMainSampler, outTexCoord);", "    vec2 pc = (lightPosition - outTexCoord) * intensity;", "    float shadow = 0.0;", "    float limit = max(float(MAX), float(samples));", "    for (int i = 0; i < MAX; ++i)", "    {", "        if (i >= samples)", "        {", "            break;", "        }", "        shadow += texture2D(uMainSampler, outTexCoord + float(i) * decay / limit * pc).a * power;", "    }", "    float mask = 1.0 - texture.a;", "    gl_FragColor = mix(texture, color, shadow * mask);", "}"].join("\n");
      }, 72464: (M) => {
        M.exports = ["#define SHADER_NAME SHINE_FS", "precision mediump float;", "uniform sampler2D uMainSampler;", "uniform vec2 resolution;", "uniform bool reveal;", "uniform float speed;", "uniform float time;", "uniform float lineWidth;", "uniform float gradient;", "varying vec2 outTexCoord;", "void main ()", "{", "	vec2 uv = gl_FragCoord.xy / resolution.xy;", "    vec4 tex = texture2D(uMainSampler, outTexCoord);", "    vec4 col1 = vec4(0.3, 0.0, 0.0, 1.0);", "    vec4 col2 = vec4(0.85, 0.85, 0.85, 1.0);", "    uv.x = uv.x - mod(time * speed, 2.0) + 0.5;", "    float y = uv.x * gradient;", "    float s = smoothstep(y - lineWidth, y, uv.y) - smoothstep(y, y + lineWidth, uv.y);", "    gl_FragColor = (((s * col1) + (s * col2)) * tex);", "    if (!reveal)", "    {", "        gl_FragColor += tex;", "    }", "}"].join("\n");
      }, 39249: (M) => {
        M.exports = ["#define SHADER_NAME VIGNETTE_FS", "precision mediump float;", "uniform sampler2D uMainSampler;", "uniform float radius;", "uniform float strength;", "uniform vec2 position;", "varying vec2 outTexCoord;", "void main ()", "{", "    vec4 col = vec4(1.0);", "    float d = length(outTexCoord - position);", "    if (d <= radius)", "    {", "        float g = d / radius;", "        g = sin(g * 3.14 * strength);", "    	col = vec4(g * g * g);", "    }", "    vec4 texture = texture2D(uMainSampler, outTexCoord);", "    gl_FragColor = texture * (1.0 - col);", "}"].join("\n");
      }, 2878: (M) => {
        M.exports = ["#define SHADER_NAME WIPE_FS", "precision mediump float;", "uniform sampler2D uMainSampler;", "uniform vec4 config;", "uniform bool reveal;", "varying vec2 outTexCoord;", "void main ()", "{", "    vec2 uv = outTexCoord;", "    vec4 color0;", "    vec4 color1;", "    if (reveal)", "    {", "        color0 = vec4(0);", "        color1 = texture2D(uMainSampler, uv);", "    }", "    else", "    {", "        color0 = texture2D(uMainSampler, uv);", "        color1 = vec4(0);", "    }", "    float distance = config.x;", "    float width = config.y;", "    float direction = config.z;", "    float axis = uv.x;", "    if (config.w == 1.0)", "    {", "        axis = uv.y;", "    }", "    float adjust = mix(width, -width, distance);", "    float value = smoothstep(distance - width, distance + width, abs(direction - axis) + adjust);", "    gl_FragColor = mix(color1, color0, value);", "}"].join("\n");
      }, 31063: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_LIGHT_FS", "precision mediump float;", "struct Light", "{", "    vec2 position;", "    vec3 color;", "    float intensity;", "    float radius;", "};", "const int kMaxLights = %LIGHT_COUNT%;", "uniform vec4 uCamera; /* x, y, rotation, zoom */", "uniform vec2 uResolution;", "uniform sampler2D uMainSampler;", "uniform sampler2D uNormSampler;", "uniform vec3 uAmbientLightColor;", "uniform Light uLights[kMaxLights];", "uniform mat3 uInverseRotationMatrix;", "uniform int uLightCount;", "varying vec2 outTexCoord;", "varying float outTexId;", "varying float outTintEffect;", "varying vec4 outTint;", "void main ()", "{", "    vec3 finalColor = vec3(0.0, 0.0, 0.0);", "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);", "    vec4 texture = texture2D(uMainSampler, outTexCoord);", "    vec4 color = texture * texel;", "    if (outTintEffect == 1.0)", "    {", "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);", "    }", "    else if (outTintEffect == 2.0)", "    {", "        color = texel;", "    }", "    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;", "    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));", "    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;", "    for (int index = 0; index < kMaxLights; ++index)", "    {", "        if (index < uLightCount)", "        {", "            Light light = uLights[index];", "            vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);", "            vec3 lightNormal = normalize(lightDir);", "            float distToSurf = length(lightDir) * uCamera.w;", "            float diffuseFactor = max(dot(normal, lightNormal), 0.0);", "            float radius = (light.radius / res.x * uCamera.w) * uCamera.w;", "            float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);", "            vec3 diffuse = light.color * diffuseFactor;", "            finalColor += (attenuation * diffuse) * light.intensity;", "        }", "    }", "    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);", "    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);", "}"].join("\n");
      }, 48247: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_LINEAR_BLEND_FS", "precision mediump float;", "uniform sampler2D uMainSampler1;", "uniform sampler2D uMainSampler2;", "uniform float uStrength;", "varying vec2 outTexCoord;", "void main ()", "{", "    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);", "    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);", "    gl_FragColor = mix(frame1, frame2 * uStrength, 0.5);", "}"].join("\n");
      }, 41214: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_MESH_FS", "precision mediump float;", "uniform vec3 uLightPosition;", "uniform vec3 uLightAmbient;", "uniform vec3 uLightDiffuse;", "uniform vec3 uLightSpecular;", "uniform vec3 uFogColor;", "uniform float uFogNear;", "uniform float uFogFar;", "uniform vec3 uMaterialAmbient;", "uniform vec3 uMaterialDiffuse;", "uniform vec3 uMaterialSpecular;", "uniform float uMaterialShine;", "uniform vec3 uCameraPosition;", "uniform sampler2D uTexture;", "varying vec2 vTextureCoord;", "varying vec3 vNormal;", "varying vec3 vPosition;", "void main (void)", "{", "    vec4 color = texture2D(uTexture, vTextureCoord);", "    vec3 ambient = uLightAmbient * uMaterialAmbient;", "    vec3 norm = normalize(vNormal);", "    vec3 lightDir = normalize(uLightPosition - vPosition);", "    float diff = max(dot(norm, lightDir), 0.0);", "    vec3 diffuse = uLightDiffuse * (diff * uMaterialDiffuse);", "    vec3 viewDir = normalize(uCameraPosition - vPosition);", "    vec3 reflectDir = reflect(-lightDir, norm);", "    float spec = pow(max(dot(viewDir, reflectDir), 0.0), uMaterialShine);", "    vec3 specular = uLightSpecular * (spec * uMaterialSpecular);", "    vec3 result = (ambient + diffuse + specular) * color.rgb;", "    float depth = gl_FragCoord.z / gl_FragCoord.w;", "    float fogFactor = smoothstep(uFogNear, uFogFar, depth);", "    gl_FragColor.rgb = mix(result.rgb, uFogColor, fogFactor);", "    gl_FragColor.a = color.a;", "}"].join("\n");
      }, 39653: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_MESH_VS", "precision mediump float;", "attribute vec3 aVertexPosition;", "attribute vec3 aVertexNormal;", "attribute vec2 aTextureCoord;", "uniform mat4 uViewProjectionMatrix;", "uniform mat4 uModelMatrix;", "uniform mat4 uNormalMatrix;", "varying vec2 vTextureCoord;", "varying vec3 vNormal;", "varying vec3 vPosition;", "void main ()", "{", "    vTextureCoord = aTextureCoord;", "    vPosition = vec3(uModelMatrix * vec4(aVertexPosition, 1.0));", "    vNormal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));", "    gl_Position = uViewProjectionMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);", "}"].join("\n");
      }, 62143: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_MOBILE_FS", "#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "#else", "precision mediump float;", "#endif", "uniform sampler2D uMainSampler;", "varying vec2 outTexCoord;", "varying float outTintEffect;", "varying vec4 outTint;", "void main ()", "{", "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);", "    vec4 texture = texture2D(uMainSampler, outTexCoord);", "    vec4 color = texture * texel;", "    if (outTintEffect == 1.0)", "    {", "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);", "    }", "    else if (outTintEffect == 2.0)", "    {", "        color = texel;", "    }", "    gl_FragColor = color;", "}"].join("\n");
      }, 47940: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_MOBILE_VS", "precision mediump float;", "uniform mat4 uProjectionMatrix;", "uniform int uRoundPixels;", "uniform vec2 uResolution;", "attribute vec2 inPosition;", "attribute vec2 inTexCoord;", "attribute float inTexId;", "attribute float inTintEffect;", "attribute vec4 inTint;", "varying vec2 outTexCoord;", "varying float outTintEffect;", "varying vec4 outTint;", "void main ()", "{", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "    if (uRoundPixels == 1)", "    {", "        gl_Position.xy = floor(((gl_Position.xy + 1.0) * 0.5 * uResolution) + 0.5) / uResolution * 2.0 - 1.0;", "    }", "    outTexCoord = inTexCoord;", "    outTint = inTint;", "    outTintEffect = inTintEffect;", "}"].join("\n");
      }, 98840: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_MULTI_FS", "#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "#else", "precision mediump float;", "#endif", "uniform sampler2D uMainSampler[%count%];", "varying vec2 outTexCoord;", "varying float outTexId;", "varying float outTintEffect;", "varying vec4 outTint;", "void main ()", "{", "    vec4 texture;", "    %forloop%", "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);", "    vec4 color = texture * texel;", "    if (outTintEffect == 1.0)", "    {", "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);", "    }", "    else if (outTintEffect == 2.0)", "    {", "        color = texel;", "    }", "    gl_FragColor = color;", "}"].join("\n");
      }, 44667: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_MULTI_VS", "precision mediump float;", "uniform mat4 uProjectionMatrix;", "uniform int uRoundPixels;", "uniform vec2 uResolution;", "attribute vec2 inPosition;", "attribute vec2 inTexCoord;", "attribute float inTexId;", "attribute float inTintEffect;", "attribute vec4 inTint;", "varying vec2 outTexCoord;", "varying float outTexId;", "varying float outTintEffect;", "varying vec4 outTint;", "void main ()", "{", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "    if (uRoundPixels == 1)", "    {", "        gl_Position.xy = floor(((gl_Position.xy + 1.0) * 0.5 * uResolution) + 0.5) / uResolution * 2.0 - 1.0;", "    }", "    outTexCoord = inTexCoord;", "    outTexId = inTexId;", "    outTint = inTint;", "    outTintEffect = inTintEffect;", "}"].join("\n");
      }, 4127: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_POINTLIGHT_FS", "precision mediump float;", "uniform vec2 uResolution;", "uniform float uCameraZoom;", "varying vec4 lightPosition;", "varying vec4 lightColor;", "varying float lightRadius;", "varying float lightAttenuation;", "void main ()", "{", "    vec2 center = (lightPosition.xy + 1.0) * (uResolution.xy * 0.5);", "    float distToSurf = length(center - gl_FragCoord.xy);", "    float radius = 1.0 - distToSurf / (lightRadius * uCameraZoom);", "    float intensity = smoothstep(0.0, 1.0, radius * lightAttenuation);", "    vec4 color = vec4(intensity, intensity, intensity, 0.0) * lightColor;", "    gl_FragColor = vec4(color.rgb * lightColor.a, color.a);", "}"].join("\n");
      }, 89924: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_POINTLIGHT_VS", "precision mediump float;", "uniform mat4 uProjectionMatrix;", "attribute vec2 inPosition;", "attribute vec2 inLightPosition;", "attribute vec4 inLightColor;", "attribute float inLightRadius;", "attribute float inLightAttenuation;", "varying vec4 lightPosition;", "varying vec4 lightColor;", "varying float lightRadius;", "varying float lightAttenuation;", "void main ()", "{", "    lightColor = inLightColor;", "    lightRadius = inLightRadius;", "    lightAttenuation = inLightAttenuation;", "    lightPosition = uProjectionMatrix * vec4(inLightPosition, 1.0, 1.0);", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "}"].join("\n");
      }, 27681: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_POSTFX_FS", "precision mediump float;", "uniform sampler2D uMainSampler;", "varying vec2 outTexCoord;", "void main ()", "{", "    gl_FragColor = texture2D(uMainSampler, outTexCoord);", "}"].join("\n");
      }, 49627: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_QUAD_VS", "precision mediump float;", "attribute vec2 inPosition;", "attribute vec2 inTexCoord;", "varying vec2 outFragCoord;", "varying vec2 outTexCoord;", "void main ()", "{", "    outFragCoord = inPosition.xy * 0.5 + 0.5;", "    outTexCoord = inTexCoord;", "    gl_Position = vec4(inPosition, 0, 1);", "}"].join("\n");
      }, 45561: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_SINGLE_FS", "#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "#else", "precision mediump float;", "#endif", "uniform sampler2D uMainSampler;", "varying vec2 outTexCoord;", "varying float outTintEffect;", "varying vec4 outTint;", "void main ()", "{", "    vec4 texture = texture2D(uMainSampler, outTexCoord);", "    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);", "    vec4 color = texture * texel;", "    if (outTintEffect == 1.0)", "    {", "        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);", "    }", "    else if (outTintEffect == 2.0)", "    {", "        color = texel;", "    }", "    gl_FragColor = color;", "}"].join("\n");
      }, 60722: (M) => {
        M.exports = ["#define SHADER_NAME PHASER_SINGLE_VS", "precision mediump float;", "uniform mat4 uProjectionMatrix;", "uniform int uRoundPixels;", "uniform vec2 uResolution;", "attribute vec2 inPosition;", "attribute vec2 inTexCoord;", "attribute float inTexId;", "attribute float inTintEffect;", "attribute vec4 inTint;", "varying vec2 outTexCoord;", "varying float outTintEffect;", "varying vec4 outTint;", "void main ()", "{", "    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);", "    if (uRoundPixels == 1)", "    {", "        gl_Position.xy = floor(((gl_Position.xy + 1.0) * 0.5 * uResolution) + 0.5) / uResolution * 2.0 - 1.0;", "    }", "    outTexCoord = inTexCoord;", "    outTint = inTint;", "    outTintEffect = inTintEffect;", "}"].join("\n");
      }, 89350: (M, B, $) => {
        M.exports = { AddBlendFrag: $(35407), BitmapMaskFrag: $(78908), BitmapMaskVert: $(85191), ColorMatrixFrag: $(96293), CopyFrag: $(36682), FXBarrelFrag: $(99155), FXBloomFrag: $(24400), FXBlurHighFrag: $(94328), FXBlurLowFrag: $(41514), FXBlurMedFrag: $(51078), FXBokehFrag: $(90610), FXCircleFrag: $(91899), FXDisplacementFrag: $(47838), FXGlowFrag: $(98656), FXGradientFrag: $(70463), FXPixelateFrag: $(50831), FXShadowFrag: $(92595), FXShineFrag: $(72464), FXVignetteFrag: $(39249), FXWipeFrag: $(2878), LightFrag: $(31063), LinearBlendFrag: $(48247), MeshFrag: $(41214), MeshVert: $(39653), MobileFrag: $(62143), MobileVert: $(47940), MultiFrag: $(98840), MultiVert: $(44667), PointLightFrag: $(4127), PointLightVert: $(89924), PostFXFrag: $(27681), QuadVert: $(49627), SingleFrag: $(45561), SingleVert: $(60722) };
      }, 93567: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U, K, J) {
          this.webGLAttribLocation = -1, this.gl = U, this.program = K, this.name = J, this.createResource();
        }, createResource: function() {
          if (this.program.webGLProgram === null) {
            this.webGLAttribLocation = -1;
            return;
          }
          var z = this.gl;
          if (z.isContextLost())
            return;
          this.webGLAttribLocation = z.getAttribLocation(this.program.webGLProgram, this.name);
        }, destroy: function() {
          this.gl = null, this.program = null, this.name = null, this.webGLAttribLocation = -1;
        } });
        M.exports = L;
      }, 26128: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U, K, J, Z) {
          this.webGLBuffer = null, this.gl = U, this.initialDataOrSize = K, this.bufferType = J, this.bufferUsage = Z, this.createResource();
        }, createResource: function() {
          if (this.initialDataOrSize === null)
            return;
          var z = this.gl;
          if (z.isContextLost())
            return;
          var U = this.bufferType, K = z.createBuffer();
          this.webGLBuffer = K, z.bindBuffer(U, this.webGLBuffer), z.bufferData(U, this.initialDataOrSize, this.bufferUsage), z.bindBuffer(U, null);
        }, destroy: function() {
          var z = this.gl;
          if (!z.isContextLost())
            z.deleteBuffer(this.webGLBuffer);
          this.webGLBuffer = null, this.initialDataOrSize = null, this.gl = null;
        } });
        M.exports = L;
      }, 84387: (M, B, $) => {
        var E = $(83419), L = { 36054: "Incomplete Attachment", 36055: "Missing Attachment", 36057: "Incomplete Dimensions", 36061: "Framebuffer Unsupported" }, z = new E({ initialize: function U(K, J, Z, D, Q) {
          this.webGLFramebuffer = null, this.gl = K, this.width = J, this.height = Z, this.renderTexture = D, this.addDepthStencilBuffer = !!Q, this.createResource();
        }, createResource: function() {
          var U = this.gl;
          if (U.isContextLost())
            return;
          var K = this.renderTexture, J = 0, Z = U.createFramebuffer();
          if (this.webGLFramebuffer = Z, U.bindFramebuffer(U.FRAMEBUFFER, Z), K.isRenderTexture = true, K.isAlphaPremultiplied = false, U.framebufferTexture2D(U.FRAMEBUFFER, U.COLOR_ATTACHMENT0, U.TEXTURE_2D, K.webGLTexture, 0), J = U.checkFramebufferStatus(U.FRAMEBUFFER), J !== U.FRAMEBUFFER_COMPLETE)
            throw new Error("Framebuffer status: " + (L[J] || J));
          if (this.addDepthStencilBuffer) {
            var D = U.createRenderbuffer();
            U.bindRenderbuffer(U.RENDERBUFFER, D), U.renderbufferStorage(U.RENDERBUFFER, U.DEPTH_STENCIL, this.width, this.height), U.framebufferRenderbuffer(U.FRAMEBUFFER, U.DEPTH_STENCIL_ATTACHMENT, U.RENDERBUFFER, D);
          }
          U.bindFramebuffer(U.FRAMEBUFFER, null);
        }, destroy: function() {
          if (this.webGLFramebuffer === null)
            return;
          var U = this.gl;
          if (!U.isContextLost()) {
            U.bindFramebuffer(U.FRAMEBUFFER, this.webGLFramebuffer);
            var K = U.getFramebufferAttachmentParameter(U.FRAMEBUFFER, U.COLOR_ATTACHMENT0, U.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME);
            if (K !== null)
              U.framebufferTexture2D(U.FRAMEBUFFER, U.COLOR_ATTACHMENT0, U.TEXTURE_2D, null, 0), U.deleteTexture(K);
            var J = U.getFramebufferAttachmentParameter(U.FRAMEBUFFER, U.DEPTH_STENCIL_ATTACHMENT, U.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME);
            if (J !== null)
              U.deleteRenderbuffer(J);
            U.bindFramebuffer(U.FRAMEBUFFER, null), U.deleteFramebuffer(this.webGLFramebuffer);
          }
          this.renderTexture = null, this.webGLFramebuffer = null, this.gl = null;
        } });
        M.exports = z;
      }, 1482: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U, K, J) {
          this.webGLProgram = null, this.gl = U, this.vertexSource = K, this.fragmentSource = J, this.createResource();
        }, createResource: function() {
          var z = this.gl;
          if (z.isContextLost())
            return;
          var U = z.createProgram(), K = z.createShader(z.VERTEX_SHADER), J = z.createShader(z.FRAGMENT_SHADER);
          z.shaderSource(K, this.vertexSource), z.shaderSource(J, this.fragmentSource), z.compileShader(K), z.compileShader(J);
          var Z = "Shader failed:\n";
          if (!z.getShaderParameter(K, z.COMPILE_STATUS))
            throw new Error("Vertex " + Z + z.getShaderInfoLog(K));
          if (!z.getShaderParameter(J, z.COMPILE_STATUS))
            throw new Error("Fragment " + Z + z.getShaderInfoLog(J));
          if (z.attachShader(U, K), z.attachShader(U, J), z.linkProgram(U), !z.getProgramParameter(U, z.LINK_STATUS))
            throw new Error("Link " + Z + z.getProgramInfoLog(U));
          z.useProgram(U), this.webGLProgram = U;
        }, destroy: function() {
          if (!this.webGLProgram)
            return;
          if (!this.gl.isContextLost())
            this.gl.deleteProgram(this.webGLProgram);
          this.webGLProgram = null, this.gl = null;
        } });
        M.exports = L;
      }, 82751: (M, B, $) => {
        var E = $(83419), L = $(50030), z = new E({ initialize: function U(K, J, Z, D, Q, H, N, W, R, Y, I, P, X) {
          this.webGLTexture = null, this.isRenderTexture = false, this.gl = K, this.mipLevel = J, this.minFilter = Z, this.magFilter = D, this.wrapT = Q, this.wrapS = H, this.format = N, this.pixels = W, this.width = R, this.height = Y, this.pma = I === undefined || I === null ? true : I, this.forceSize = !!P, this.flipY = !!X, this.__SPECTOR_Metadata = {}, this.createResource();
        }, createResource: function() {
          var U = this.gl;
          if (U.isContextLost())
            return;
          if (this.pixels instanceof z) {
            this.webGLTexture = this.pixels.webGLTexture;
            return;
          }
          var K = U.createTexture();
          K.__SPECTOR_Metadata = this.__SPECTOR_Metadata, this.webGLTexture = K, this._processTexture();
        }, update: function(U, K, J, Z, D, Q, H, N, W) {
          if (K === 0 || J === 0)
            return;
          this.pixels = U, this.width = K, this.height = J, this.flipY = Z, this.wrapS = D, this.wrapT = Q, this.minFilter = H, this.magFilter = N, this.format = W;
          var R = this.gl;
          if (R.isContextLost())
            return;
          this._processTexture();
        }, _processTexture: function() {
          var U = this.gl;
          U.activeTexture(U.TEXTURE0);
          var K = U.getParameter(U.TEXTURE_BINDING_2D);
          U.bindTexture(U.TEXTURE_2D, this.webGLTexture), U.texParameteri(U.TEXTURE_2D, U.TEXTURE_MIN_FILTER, this.minFilter), U.texParameteri(U.TEXTURE_2D, U.TEXTURE_MAG_FILTER, this.magFilter), U.texParameteri(U.TEXTURE_2D, U.TEXTURE_WRAP_S, this.wrapS), U.texParameteri(U.TEXTURE_2D, U.TEXTURE_WRAP_T, this.wrapT), U.pixelStorei(U.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.pma), U.pixelStorei(U.UNPACK_FLIP_Y_WEBGL, this.flipY);
          var J = this.pixels, Z = this.mipLevel, D = this.width, Q = this.height, H = this.format, N = false;
          if (J === null || J === undefined)
            U.texImage2D(U.TEXTURE_2D, Z, H, D, Q, 0, H, U.UNSIGNED_BYTE, null), N = L(D, Q);
          else if (J.compressed) {
            D = J.width, Q = J.height, N = J.generateMipmap;
            for (var W = 0;W < J.mipmaps.length; W++)
              U.compressedTexImage2D(U.TEXTURE_2D, W, J.internalFormat, J.mipmaps[W].width, J.mipmaps[W].height, 0, J.mipmaps[W].data);
          } else if (J instanceof Uint8Array)
            U.texImage2D(U.TEXTURE_2D, Z, H, D, Q, 0, H, U.UNSIGNED_BYTE, J), N = L(D, Q);
          else {
            if (!this.forceSize)
              D = J.width, Q = J.height;
            U.texImage2D(U.TEXTURE_2D, Z, H, H, U.UNSIGNED_BYTE, J), N = L(D, Q);
          }
          if (N)
            U.generateMipmap(U.TEXTURE_2D);
          if (K)
            U.bindTexture(U.TEXTURE_2D, K);
          else
            U.bindTexture(U.TEXTURE_2D, null);
        }, spectorMetadata: { get: function() {
          return this.__SPECTOR_Metadata;
        }, set: function(U) {
          if (this.__SPECTOR_Metadata = U, !this.gl.isContextLost())
            this.webGLTexture.__SPECTOR_Metadata = U;
        } }, destroy: function() {
          if (this.webGLTexture === null)
            return;
          if (!this.gl.isContextLost()) {
            if (!(this.pixels instanceof z))
              this.gl.deleteTexture(this.webGLTexture);
          }
          this.pixels = null, this.webGLTexture = null, this.gl = null;
        } });
        M.exports = z;
      }, 57183: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U, K, J) {
          this.webGLUniformLocation = null, this.gl = U, this.program = K, this.name = J, this.createResource();
        }, createResource: function() {
          if (this.program.webGLProgram === null) {
            this.webGLUniformLocation = null;
            return;
          }
          var z = this.gl;
          if (z.isContextLost())
            return;
          this.webGLUniformLocation = z.getUniformLocation(this.program.webGLProgram, this.name);
        }, destroy: function() {
          this.gl = null, this.program = null, this.name = null, this.webGLUniformLocation = null;
        } });
        M.exports = L;
      }, 9503: (M, B, $) => {
        var E = { WebGLAttribLocationWrapper: $(93567), WebGLBufferWrapper: $(26128), WebGLProgramWrapper: $(1482), WebGLTextureWrapper: $(82751), WebGLFramebufferWrapper: $(84387), WebGLUniformLocationWrapper: $(57183) };
        M.exports = E;
      }, 76531: (M, B, $) => {
        var E = $(13560), L = $(83419), z = $(50792), U = $(97480), K = $(8443), J = $(57811), Z = $(74403), D = $(45818), Q = $(29747), H = $(87841), N = $(86555), W = $(56583), R = $(26099), Y = $(38058), I = new L({ Extends: z, initialize: function P(X) {
          z.call(this), this.game = X, this.canvas, this.canvasBounds = new H, this.parent = null, this.parentIsWindow = false, this.parentSize = new N, this.gameSize = new N, this.baseSize = new N, this.displaySize = new N, this.scaleMode = E.SCALE_MODE.NONE, this.zoom = 1, this._resetZoom = false, this.displayScale = new R(1, 1), this.autoRound = false, this.autoCenter = E.CENTER.NO_CENTER, this.orientation = E.ORIENTATION.LANDSCAPE, this.fullscreen, this.fullscreenTarget = null, this._createdFullscreenTarget = false, this.dirty = false, this.resizeInterval = 500, this._lastCheck = 0, this._checkOrientation = false, this.domlisteners = { orientationChange: Q, windowResize: Q, fullScreenChange: Q, fullScreenError: Q };
        }, preBoot: function() {
          this.parseConfig(this.game.config), this.game.events.once(K.BOOT, this.boot, this);
        }, boot: function() {
          var P = this.game;
          if (this.canvas = P.canvas, this.fullscreen = P.device.fullscreen, this.scaleMode !== E.SCALE_MODE.RESIZE && this.scaleMode !== E.SCALE_MODE.EXPAND)
            this.displaySize.setAspectMode(this.scaleMode);
          if (this.scaleMode === E.SCALE_MODE.NONE)
            this.resize(this.width, this.height);
          else {
            if (this.getParentBounds(), this.parentSize.width > 0 && this.parentSize.height > 0)
              this.displaySize.setParent(this.parentSize);
            this.refresh();
          }
          P.events.on(K.PRE_STEP, this.step, this), P.events.once(K.READY, this.refresh, this), P.events.once(K.DESTROY, this.destroy, this), this.startListeners();
        }, parseConfig: function(P) {
          this.getParent(P), this.getParentBounds();
          var { width: X, height: G, scaleMode: V, zoom: A, autoRound: F } = P;
          if (typeof X === "string")
            if (X.substr(-1) !== "%")
              X = parseInt(X, 10);
            else {
              var j = this.parentSize.width;
              if (j === 0)
                j = window.innerWidth;
              var T = parseInt(X, 10) / 100;
              X = Math.floor(j * T);
            }
          if (typeof G === "string")
            if (G.substr(-1) !== "%")
              G = parseInt(G, 10);
            else {
              var C = this.parentSize.height;
              if (C === 0)
                C = window.innerHeight;
              var v = parseInt(G, 10) / 100;
              G = Math.floor(C * v);
            }
          if (this.scaleMode = V, this.autoRound = F, this.autoCenter = P.autoCenter, this.resizeInterval = P.resizeInterval, F)
            X = Math.floor(X), G = Math.floor(G);
          if (this.gameSize.setSize(X, G), A === E.ZOOM.MAX_ZOOM)
            A = this.getMaxZoom();
          if (this.zoom = A, A !== 1)
            this._resetZoom = true;
          if (this.baseSize.setSize(X, G), F)
            this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height);
          if (P.minWidth > 0)
            this.displaySize.setMin(P.minWidth * A, P.minHeight * A);
          if (P.maxWidth > 0)
            this.displaySize.setMax(P.maxWidth * A, P.maxHeight * A);
          if (this.displaySize.setSize(X, G), P.snapWidth > 0 || P.snapHeight > 0)
            this.displaySize.setSnap(P.snapWidth, P.snapHeight);
          this.orientation = D(X, G);
        }, getParent: function(P) {
          var X = P.parent;
          if (X === null)
            return;
          if (this.parent = Z(X), this.parentIsWindow = this.parent === document.body, P.expandParent && P.scaleMode !== E.SCALE_MODE.NONE) {
            var G = this.parent.getBoundingClientRect();
            if (this.parentIsWindow || G.height === 0) {
              if (document.documentElement.style.height = "100%", document.body.style.height = "100%", G = this.parent.getBoundingClientRect(), !this.parentIsWindow && G.height === 0)
                this.parent.style.overflow = "hidden", this.parent.style.width = "100%", this.parent.style.height = "100%";
            }
          }
          if (P.fullscreenTarget && !this.fullscreenTarget)
            this.fullscreenTarget = Z(P.fullscreenTarget);
        }, getParentBounds: function() {
          if (!this.parent)
            return false;
          var P = this.parentSize, X = this.parent.getBoundingClientRect();
          if (this.parentIsWindow && this.game.device.os.iOS)
            X.height = J(true);
          var { width: G, height: V } = X;
          if (P.width !== G || P.height !== V)
            return P.setSize(G, V), true;
          else if (this.canvas) {
            var A = this.canvasBounds, F = this.canvas.getBoundingClientRect();
            if (F.x !== A.x || F.y !== A.y)
              return true;
          }
          return false;
        }, lockOrientation: function(P) {
          var X = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;
          if (X)
            return X.call(screen, P);
          return false;
        }, setParentSize: function(P, X) {
          return this.parentSize.setSize(P, X), this.refresh();
        }, setGameSize: function(P, X) {
          var G = this.autoRound;
          if (G)
            P = Math.floor(P), X = Math.floor(X);
          var V = this.width, A = this.height;
          if (this.gameSize.resize(P, X), this.baseSize.resize(P, X), G)
            this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height);
          return this.displaySize.setAspectRatio(P / X), this.canvas.width = this.baseSize.width, this.canvas.height = this.baseSize.height, this.refresh(V, A);
        }, resize: function(P, X) {
          var G = this.zoom, V = this.autoRound;
          if (V)
            P = Math.floor(P), X = Math.floor(X);
          var A = this.width, F = this.height;
          if (this.gameSize.resize(P, X), this.baseSize.resize(P, X), V)
            this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height);
          this.displaySize.setSize(P * G, X * G), this.canvas.width = this.baseSize.width, this.canvas.height = this.baseSize.height;
          var j = this.canvas.style, T = P * G, C = X * G;
          if (V)
            T = Math.floor(T), C = Math.floor(C);
          if (T !== P || C !== X)
            j.width = T + "px", j.height = C + "px";
          return this.refresh(A, F);
        }, setZoom: function(P) {
          return this.zoom = P, this._resetZoom = true, this.refresh();
        }, setMaxZoom: function() {
          return this.zoom = this.getMaxZoom(), this._resetZoom = true, this.refresh();
        }, setSnap: function(P, X) {
          if (P === undefined)
            P = 0;
          if (X === undefined)
            X = P;
          return this.displaySize.setSnap(P, X), this.refresh();
        }, refresh: function(P, X) {
          if (P === undefined)
            P = this.width;
          if (X === undefined)
            X = this.height;
          this.updateScale(), this.updateBounds(), this.updateOrientation(), this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height);
          var G = this.game.domContainer;
          if (G) {
            this.baseSize.setCSS(G);
            var V = this.canvas.style, A = G.style;
            A.transform = "scale(" + this.displaySize.width / this.baseSize.width + "," + this.displaySize.height / this.baseSize.height + ")", A.marginLeft = V.marginLeft, A.marginTop = V.marginTop;
          }
          return this.emit(U.RESIZE, this.gameSize, this.baseSize, this.displaySize, P, X), this;
        }, updateOrientation: function() {
          if (this._checkOrientation) {
            this._checkOrientation = false;
            var P = D(this.width, this.height);
            if (P !== this.orientation)
              this.orientation = P, this.emit(U.ORIENTATION_CHANGE, P);
          }
        }, updateScale: function() {
          var P = this.canvas.style, X = this.gameSize.width, G = this.gameSize.height, V, A, F = this.zoom, j = this.autoRound;
          if (this.scaleMode === E.SCALE_MODE.NONE) {
            if (this.displaySize.setSize(X * F, G * F), V = this.displaySize.width, A = this.displaySize.height, j)
              V = Math.floor(V), A = Math.floor(A);
            if (this._resetZoom)
              P.width = V + "px", P.height = A + "px", this._resetZoom = false;
          } else if (this.scaleMode === E.SCALE_MODE.RESIZE) {
            if (this.displaySize.setSize(this.parentSize.width, this.parentSize.height), this.gameSize.setSize(this.displaySize.width, this.displaySize.height), this.baseSize.setSize(this.displaySize.width, this.displaySize.height), V = this.displaySize.width, A = this.displaySize.height, j)
              V = Math.floor(V), A = Math.floor(A);
            this.canvas.width = V, this.canvas.height = A;
          } else if (this.scaleMode === E.SCALE_MODE.EXPAND) {
            if (this.displaySize.setSize(this.parentSize.width, this.parentSize.height), V = this.displaySize.width, A = this.displaySize.height, j)
              V = Math.floor(V), A = Math.floor(A);
            P.width = V + "px", P.height = A + "px";
            var T = this.parentSize.width / this.gameSize.width, C = this.parentSize.height / this.gameSize.height;
            if (T < C)
              this.baseSize.setSize(this.gameSize.width, this.parentSize.height / T);
            else
              this.baseSize.setSize(this.displaySize.width / C, this.gameSize.height);
            if (V = this.baseSize.width, A = this.baseSize.height, j)
              V = Math.floor(V), A = Math.floor(A);
            this.canvas.width = V, this.canvas.height = A;
          } else {
            if (this.displaySize.setSize(this.parentSize.width, this.parentSize.height), V = this.displaySize.width, A = this.displaySize.height, j)
              V = Math.floor(V), A = Math.floor(A);
            P.width = V + "px", P.height = A + "px";
          }
          this.getParentBounds(), this.updateCenter();
        }, getMaxZoom: function() {
          var P = W(this.parentSize.width, this.gameSize.width, 0, true), X = W(this.parentSize.height, this.gameSize.height, 0, true);
          return Math.max(Math.min(P, X), 1);
        }, updateCenter: function() {
          var P = this.autoCenter;
          if (P === E.CENTER.NO_CENTER)
            return;
          var X = this.canvas, G = X.style, V = X.getBoundingClientRect(), A = V.width, F = V.height, j = Math.floor((this.parentSize.width - A) / 2), T = Math.floor((this.parentSize.height - F) / 2);
          if (P === E.CENTER.CENTER_HORIZONTALLY)
            T = 0;
          else if (P === E.CENTER.CENTER_VERTICALLY)
            j = 0;
          G.marginLeft = j + "px", G.marginTop = T + "px";
        }, updateBounds: function() {
          var P = this.canvasBounds, X = this.canvas.getBoundingClientRect();
          P.x = X.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0), P.y = X.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0), P.width = X.width, P.height = X.height;
        }, transformX: function(P) {
          return (P - this.canvasBounds.left) * this.displayScale.x;
        }, transformY: function(P) {
          return (P - this.canvasBounds.top) * this.displayScale.y;
        }, startFullscreen: function(P) {
          if (P === undefined)
            P = { navigationUI: "hide" };
          var X = this.fullscreen;
          if (!X.available) {
            this.emit(U.FULLSCREEN_UNSUPPORTED);
            return;
          }
          if (!X.active) {
            var G = this.getFullscreenTarget();
            if (X.keyboard)
              G[X.request](Element.ALLOW_KEYBOARD_INPUT);
            else
              G[X.request](P);
          }
        }, fullscreenSuccessHandler: function() {
          this.getParentBounds(), this.refresh(), this.emit(U.ENTER_FULLSCREEN);
        }, fullscreenErrorHandler: function(P) {
          this.removeFullscreenTarget(), this.emit(U.FULLSCREEN_FAILED, P);
        }, getFullscreenTarget: function() {
          if (!this.fullscreenTarget) {
            var P = document.createElement("div");
            P.style.margin = "0", P.style.padding = "0", P.style.width = "100%", P.style.height = "100%", this.fullscreenTarget = P, this._createdFullscreenTarget = true;
          }
          if (this._createdFullscreenTarget) {
            var X = this.canvas.parentNode;
            X.insertBefore(this.fullscreenTarget, this.canvas), this.fullscreenTarget.appendChild(this.canvas);
          }
          return this.fullscreenTarget;
        }, removeFullscreenTarget: function() {
          if (this._createdFullscreenTarget) {
            var P = this.fullscreenTarget;
            if (P && P.parentNode) {
              var X = P.parentNode;
              X.insertBefore(this.canvas, P), X.removeChild(P);
            }
          }
        }, stopFullscreen: function() {
          var P = this.fullscreen;
          if (!P.available)
            return this.emit(U.FULLSCREEN_UNSUPPORTED), false;
          if (P.active)
            document[P.cancel]();
          this.removeFullscreenTarget(), this.getParentBounds(), this.emit(U.LEAVE_FULLSCREEN), this.refresh();
        }, toggleFullscreen: function(P) {
          if (this.fullscreen.active)
            this.stopFullscreen();
          else
            this.startFullscreen(P);
        }, startListeners: function() {
          var P = this, X = this.domlisteners;
          if (X.orientationChange = function() {
            P.updateBounds(), P._checkOrientation = true, P.dirty = true, P.refresh();
          }, X.windowResize = function() {
            P.updateBounds(), P.dirty = true;
          }, window.addEventListener("orientationchange", X.orientationChange, false), window.addEventListener("resize", X.windowResize, false), this.fullscreen.available) {
            X.fullScreenChange = function(V) {
              return P.onFullScreenChange(V);
            }, X.fullScreenError = function(V) {
              return P.onFullScreenError(V);
            };
            var G = ["webkit", "moz", ""];
            G.forEach(function(V) {
              document.addEventListener(V + "fullscreenchange", X.fullScreenChange, false), document.addEventListener(V + "fullscreenerror", X.fullScreenError, false);
            }), document.addEventListener("MSFullscreenChange", X.fullScreenChange, false), document.addEventListener("MSFullscreenError", X.fullScreenError, false);
          }
        }, onFullScreenChange: function() {
          if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement)
            this.fullscreenSuccessHandler();
          else
            this.stopFullscreen();
        }, onFullScreenError: function() {
          this.removeFullscreenTarget();
        }, getViewPort: function(P, X) {
          if (!(P instanceof Y))
            X = P, P = undefined;
          if (X === undefined)
            X = new H;
          var G = this.baseSize, V = this.parentSize, A = this.canvasBounds, F = this.displayScale, j = A.x >= 0 ? 0 : -(A.x * F.x), T = A.y >= 0 ? 0 : -(A.y * F.y), C;
          if (V.width >= A.width)
            C = G.width;
          else
            C = G.width - (A.width - V.width) * F.x;
          var v;
          if (V.height >= A.height)
            v = G.height;
          else
            v = G.height - (A.height - V.height) * F.y;
          if (X.setTo(j, T, C, v), P)
            X.width /= P.zoomX, X.height /= P.zoomY, X.centerX = P.centerX + P.scrollX, X.centerY = P.centerY + P.scrollY;
          return X;
        }, step: function(P, X) {
          if (!this.parent)
            return;
          if (this._lastCheck += X, this.dirty || this._lastCheck > this.resizeInterval) {
            if (this.getParentBounds())
              this.refresh();
            this.dirty = false, this._lastCheck = 0;
          }
        }, stopListeners: function() {
          var P = this.domlisteners;
          window.removeEventListener("orientationchange", P.orientationChange, false), window.removeEventListener("resize", P.windowResize, false);
          var X = ["webkit", "moz", ""];
          X.forEach(function(G) {
            document.removeEventListener(G + "fullscreenchange", P.fullScreenChange, false), document.removeEventListener(G + "fullscreenerror", P.fullScreenError, false);
          }), document.removeEventListener("MSFullscreenChange", P.fullScreenChange, false), document.removeEventListener("MSFullscreenError", P.fullScreenError, false);
        }, destroy: function() {
          this.removeAllListeners(), this.stopListeners(), this.game = null, this.canvas = null, this.canvasBounds = null, this.parent = null, this.fullscreenTarget = null, this.parentSize.destroy(), this.gameSize.destroy(), this.baseSize.destroy(), this.displaySize.destroy();
        }, isFullscreen: { get: function() {
          return this.fullscreen.active;
        } }, width: { get: function() {
          return this.gameSize.width;
        } }, height: { get: function() {
          return this.gameSize.height;
        } }, isPortrait: { get: function() {
          return this.orientation === E.ORIENTATION.PORTRAIT;
        } }, isLandscape: { get: function() {
          return this.orientation === E.ORIENTATION.LANDSCAPE;
        } }, isGamePortrait: { get: function() {
          return this.height > this.width;
        } }, isGameLandscape: { get: function() {
          return this.width > this.height;
        } } });
        M.exports = I;
      }, 64743: (M) => {
        M.exports = { NO_CENTER: 0, CENTER_BOTH: 1, CENTER_HORIZONTALLY: 2, CENTER_VERTICALLY: 3 };
      }, 39218: (M) => {
        M.exports = { LANDSCAPE: "landscape-primary", PORTRAIT: "portrait-primary" };
      }, 81050: (M) => {
        M.exports = { NONE: 0, WIDTH_CONTROLS_HEIGHT: 1, HEIGHT_CONTROLS_WIDTH: 2, FIT: 3, ENVELOP: 4, RESIZE: 5, EXPAND: 6 };
      }, 80805: (M) => {
        M.exports = { NO_ZOOM: 1, ZOOM_2X: 2, ZOOM_4X: 4, MAX_ZOOM: -1 };
      }, 13560: (M, B, $) => {
        var E = { CENTER: $(64743), ORIENTATION: $(39218), SCALE_MODE: $(81050), ZOOM: $(80805) };
        M.exports = E;
      }, 56139: (M) => {
        M.exports = "enterfullscreen";
      }, 2336: (M) => {
        M.exports = "fullscreenfailed";
      }, 47412: (M) => {
        M.exports = "fullscreenunsupported";
      }, 51452: (M) => {
        M.exports = "leavefullscreen";
      }, 20666: (M) => {
        M.exports = "orientationchange";
      }, 47945: (M) => {
        M.exports = "resize";
      }, 97480: (M, B, $) => {
        M.exports = { ENTER_FULLSCREEN: $(56139), FULLSCREEN_FAILED: $(2336), FULLSCREEN_UNSUPPORTED: $(47412), LEAVE_FULLSCREEN: $(51452), ORIENTATION_CHANGE: $(20666), RESIZE: $(47945) };
      }, 93364: (M, B, $) => {
        var E = $(79291), L = $(13560), z = { Center: $(64743), Events: $(97480), Orientation: $(39218), ScaleManager: $(76531), ScaleModes: $(81050), Zoom: $(80805) };
        z = E(false, z, L.CENTER), z = E(false, z, L.ORIENTATION), z = E(false, z, L.SCALE_MODE), z = E(false, z, L.ZOOM), M.exports = z;
      }, 27397: (M, B, $) => {
        var E = $(95540), L = $(35355), z = function(U) {
          var K = U.game.config.defaultPhysicsSystem, J = E(U.settings, "physics", false);
          if (!K && !J)
            return;
          var Z = [];
          if (K)
            Z.push(L(K + "Physics"));
          if (J) {
            for (var D in J)
              if (D = L(D.concat("Physics")), Z.indexOf(D) === -1)
                Z.push(D);
          }
          return Z;
        };
        M.exports = z;
      }, 52106: (M, B, $) => {
        var E = $(95540), L = function(z) {
          var U = z.plugins.getDefaultScenePlugins(), K = E(z.settings, "plugins", false);
          if (Array.isArray(K))
            return K;
          else if (U)
            return U;
          else
            return [];
        };
        M.exports = L;
      }, 87033: (M) => {
        var B = { game: "game", renderer: "renderer", anims: "anims", cache: "cache", plugins: "plugins", registry: "registry", scale: "scale", sound: "sound", textures: "textures", events: "events", cameras: "cameras", add: "add", make: "make", scenePlugin: "scene", displayList: "children", lights: "lights", data: "data", input: "input", load: "load", time: "time", tweens: "tweens", arcadePhysics: "physics", impactPhysics: "impact", matterPhysics: "matter" };
        M.exports = B;
      }, 97482: (M, B, $) => {
        var E = $(83419), L = $(2368), z = new E({ initialize: function U(K) {
          this.sys = new L(this, K), this.game, this.anims, this.cache, this.registry, this.sound, this.textures, this.events, this.cameras, this.add, this.make, this.scene, this.children, this.lights, this.data, this.input, this.load, this.time, this.tweens, this.physics, this.matter, this.scale, this.plugins, this.renderer;
        }, update: function() {
        } });
        M.exports = z;
      }, 60903: (M, B, $) => {
        var E = $(83419), L = $(89993), z = $(44594), U = $(8443), K = $(35154), J = $(54899), Z = $(29747), D = $(97482), Q = $(2368), H = new E({ initialize: function N(W, R) {
          if (this.game = W, this.keys = {}, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this._data = {}, this.isProcessing = false, this.isBooted = false, this.customViewports = 0, this.systemScene, R) {
            if (!Array.isArray(R))
              R = [R];
            for (var Y = 0;Y < R.length; Y++)
              this._pending.push({ key: "default", scene: R[Y], autoStart: Y === 0, data: {} });
          }
          W.events.once(U.READY, this.bootQueue, this);
        }, bootQueue: function() {
          if (this.isBooted)
            return;
          this.systemScene = this.createSceneFromInstance("__SYSTEM", new D), this.game.events.emit(U.SYSTEM_READY, this.systemScene, this);
          var N, W, R, Y;
          for (N = 0;N < this._pending.length; N++) {
            W = this._pending[N], R = W.key, Y = W.scene;
            var I;
            if (Y instanceof D)
              I = this.createSceneFromInstance(R, Y);
            else if (typeof Y === "object")
              I = this.createSceneFromObject(R, Y);
            else if (typeof Y === "function")
              I = this.createSceneFromFunction(R, Y);
            if (R = I.sys.settings.key, this.keys[R] = I, this.scenes.push(I), this._data[R]) {
              if (I.sys.settings.data = this._data[R].data, this._data[R].autoStart)
                W.autoStart = true;
            }
            if (W.autoStart || I.sys.settings.active)
              this._start.push(R);
          }
          this._pending.length = 0, this._data = {}, this.isBooted = true;
          for (N = 0;N < this._start.length; N++)
            W = this._start[N], this.start(W);
          this._start.length = 0;
        }, processQueue: function() {
          var N = this._pending.length, W = this._queue.length;
          if (N === 0 && W === 0)
            return;
          var R, Y;
          if (N) {
            for (R = 0;R < N; R++)
              Y = this._pending[R], this.add(Y.key, Y.scene, Y.autoStart, Y.data);
            for (R = 0;R < this._start.length; R++)
              Y = this._start[R], this.start(Y);
            this._start.length = 0, this._pending.length = 0;
          }
          for (R = 0;R < this._queue.length; R++)
            Y = this._queue[R], this[Y.op](Y.keyA, Y.keyB);
          this._queue.length = 0;
        }, add: function(N, W, R, Y) {
          if (R === undefined)
            R = false;
          if (Y === undefined)
            Y = {};
          if (this.isProcessing || !this.isBooted) {
            if (this._pending.push({ key: N, scene: W, autoStart: R, data: Y }), !this.isBooted)
              this._data[N] = { data: Y };
            return null;
          }
          N = this.getKey(N, W);
          var I;
          if (W instanceof D)
            I = this.createSceneFromInstance(N, W);
          else if (typeof W === "object")
            W.key = N, I = this.createSceneFromObject(N, W);
          else if (typeof W === "function")
            I = this.createSceneFromFunction(N, W);
          if (I.sys.settings.data = Y, N = I.sys.settings.key, this.keys[N] = I, this.scenes.push(I), R || I.sys.settings.active)
            if (this._pending.length)
              this._start.push(N);
            else
              this.start(N);
          return I;
        }, remove: function(N) {
          if (this.isProcessing)
            this._queue.push({ op: "remove", keyA: N, keyB: null });
          else {
            var W = this.getScene(N);
            if (!W || W.sys.isTransitioning())
              return this;
            var R = this.scenes.indexOf(W), Y = W.sys.settings.key;
            if (R > -1) {
              if (delete this.keys[Y], this.scenes.splice(R, 1), this._start.indexOf(Y) > -1)
                R = this._start.indexOf(Y), this._start.splice(R, 1);
              W.sys.destroy();
            }
          }
          return this;
        }, bootScene: function(N) {
          var W = N.sys, R = W.settings;
          if (W.sceneUpdate = Z, N.init) {
            if (N.init.call(N, R.data), R.status = L.INIT, R.isTransition)
              W.events.emit(z.TRANSITION_INIT, R.transitionFrom, R.transitionDuration);
          }
          var Y;
          if (W.load)
            Y = W.load, Y.reset();
          if (Y && N.preload)
            N.preload.call(N), R.status = L.LOADING, Y.once(J.COMPLETE, this.loadComplete, this), Y.start();
          else
            this.create(N);
        }, loadComplete: function(N) {
          if (this.game.sound && this.game.sound.onBlurPausedSounds)
            this.game.sound.unlock();
          this.create(N.scene);
        }, payloadComplete: function(N) {
          this.bootScene(N.scene);
        }, update: function(N, W) {
          this.processQueue(), this.isProcessing = true;
          for (var R = this.scenes.length - 1;R >= 0; R--) {
            var Y = this.scenes[R].sys;
            if (Y.settings.status > L.START && Y.settings.status <= L.RUNNING)
              Y.step(N, W);
            if (Y.scenePlugin && Y.scenePlugin._target)
              Y.scenePlugin.step(N, W);
          }
        }, render: function(N) {
          for (var W = 0;W < this.scenes.length; W++) {
            var R = this.scenes[W].sys;
            if (R.settings.visible && R.settings.status >= L.LOADING && R.settings.status < L.SLEEPING)
              R.render(N);
          }
          this.isProcessing = false;
        }, create: function(N) {
          var W = N.sys, R = W.settings;
          if (N.create) {
            if (R.status = L.CREATING, N.create.call(N, R.data), R.status === L.DESTROYED)
              return;
          }
          if (R.isTransition)
            W.events.emit(z.TRANSITION_START, R.transitionFrom, R.transitionDuration);
          if (N.update)
            W.sceneUpdate = N.update;
          R.status = L.RUNNING, W.events.emit(z.CREATE, N);
        }, createSceneFromFunction: function(N, W) {
          var R = new W;
          if (R instanceof D) {
            var Y = R.sys.settings.key;
            if (Y !== "")
              N = Y;
            if (this.keys.hasOwnProperty(N))
              throw new Error("Cannot add a Scene with duplicate key: " + N);
            return this.createSceneFromInstance(N, R);
          } else
            return R.sys = new Q(R), R.sys.settings.key = N, R.sys.init(this.game), R;
        }, createSceneFromInstance: function(N, W) {
          var R = W.sys.settings.key;
          if (R === "")
            W.sys.settings.key = N;
          return W.sys.init(this.game), W;
        }, createSceneFromObject: function(N, W) {
          var R = new D(W), Y = R.sys.settings.key;
          if (Y !== "")
            N = Y;
          else
            R.sys.settings.key = N;
          R.sys.init(this.game);
          var I = ["init", "preload", "create", "update", "render"];
          for (var P = 0;P < I.length; P++) {
            var X = K(W, I[P], null);
            if (X)
              R[I[P]] = X;
          }
          if (W.hasOwnProperty("extend"))
            for (var G in W.extend) {
              if (!W.extend.hasOwnProperty(G))
                continue;
              var V = W.extend[G];
              if (G === "data" && R.hasOwnProperty("data") && typeof V === "object")
                R.data.merge(V);
              else if (G !== "sys")
                R[G] = V;
            }
          return R;
        }, getKey: function(N, W) {
          if (!N)
            N = "default";
          if (typeof W === "function")
            return N;
          else if (W instanceof D)
            N = W.sys.settings.key;
          else if (typeof W === "object" && W.hasOwnProperty("key"))
            N = W.key;
          if (this.keys.hasOwnProperty(N))
            throw new Error("Cannot add a Scene with duplicate key: " + N);
          else
            return N;
        }, getScenes: function(N, W) {
          if (N === undefined)
            N = true;
          if (W === undefined)
            W = false;
          var R = [], Y = this.scenes;
          for (var I = 0;I < Y.length; I++) {
            var P = Y[I];
            if (P && (!N || N && P.sys.isActive()))
              R.push(P);
          }
          return W ? R.reverse() : R;
        }, getScene: function(N) {
          if (typeof N === "string") {
            if (this.keys[N])
              return this.keys[N];
          } else
            for (var W = 0;W < this.scenes.length; W++)
              if (N === this.scenes[W])
                return N;
          return null;
        }, isActive: function(N) {
          var W = this.getScene(N);
          if (W)
            return W.sys.isActive();
          return null;
        }, isPaused: function(N) {
          var W = this.getScene(N);
          if (W)
            return W.sys.isPaused();
          return null;
        }, isVisible: function(N) {
          var W = this.getScene(N);
          if (W)
            return W.sys.isVisible();
          return null;
        }, isSleeping: function(N) {
          var W = this.getScene(N);
          if (W)
            return W.sys.isSleeping();
          return null;
        }, pause: function(N, W) {
          var R = this.getScene(N);
          if (R)
            R.sys.pause(W);
          return this;
        }, resume: function(N, W) {
          var R = this.getScene(N);
          if (R)
            R.sys.resume(W);
          return this;
        }, sleep: function(N, W) {
          var R = this.getScene(N);
          if (R && !R.sys.isTransitioning())
            R.sys.sleep(W);
          return this;
        }, wake: function(N, W) {
          var R = this.getScene(N);
          if (R)
            R.sys.wake(W);
          return this;
        }, run: function(N, W) {
          var R = this.getScene(N);
          if (!R) {
            for (var Y = 0;Y < this._pending.length; Y++)
              if (this._pending[Y].key === N) {
                this.queueOp("start", N, W);
                break;
              }
            return this;
          }
          if (R.sys.isSleeping())
            R.sys.wake(W);
          else if (R.sys.isPaused())
            R.sys.resume(W);
          else
            this.start(N, W);
        }, start: function(N, W) {
          if (!this.isBooted)
            return this._data[N] = { autoStart: true, data: W }, this;
          var R = this.getScene(N);
          if (!R)
            return console.warn("Scene not found for key: " + N), this;
          var Y = R.sys, I = Y.settings.status;
          if (I >= L.START && I <= L.CREATING)
            return this;
          else if (I >= L.RUNNING && I <= L.SLEEPING)
            Y.shutdown(), Y.sceneUpdate = Z, Y.start(W);
          else {
            Y.sceneUpdate = Z, Y.start(W);
            var P;
            if (Y.load)
              P = Y.load;
            if (P && Y.settings.hasOwnProperty("pack")) {
              if (P.reset(), P.addPack({ payload: Y.settings.pack }))
                return Y.settings.status = L.LOADING, P.once(J.COMPLETE, this.payloadComplete, this), P.start(), this;
            }
          }
          return this.bootScene(R), this;
        }, stop: function(N, W) {
          var R = this.getScene(N);
          if (R && !R.sys.isTransitioning() && R.sys.settings.status !== L.SHUTDOWN) {
            var Y = R.sys.load;
            if (Y)
              Y.off(J.COMPLETE, this.loadComplete, this), Y.off(J.COMPLETE, this.payloadComplete, this);
            R.sys.shutdown(W);
          }
          return this;
        }, switch: function(N, W) {
          var R = this.getScene(N), Y = this.getScene(W);
          if (R && Y && R !== Y)
            if (this.sleep(N), this.isSleeping(W))
              this.wake(W);
            else
              this.start(W);
          return this;
        }, getAt: function(N) {
          return this.scenes[N];
        }, getIndex: function(N) {
          var W = this.getScene(N);
          return this.scenes.indexOf(W);
        }, bringToTop: function(N) {
          if (this.isProcessing)
            this._queue.push({ op: "bringToTop", keyA: N, keyB: null });
          else {
            var W = this.getIndex(N);
            if (W !== -1 && W < this.scenes.length) {
              var R = this.getScene(N);
              this.scenes.splice(W, 1), this.scenes.push(R);
            }
          }
          return this;
        }, sendToBack: function(N) {
          if (this.isProcessing)
            this._queue.push({ op: "sendToBack", keyA: N, keyB: null });
          else {
            var W = this.getIndex(N);
            if (W !== -1 && W > 0) {
              var R = this.getScene(N);
              this.scenes.splice(W, 1), this.scenes.unshift(R);
            }
          }
          return this;
        }, moveDown: function(N) {
          if (this.isProcessing)
            this._queue.push({ op: "moveDown", keyA: N, keyB: null });
          else {
            var W = this.getIndex(N);
            if (W > 0) {
              var R = W - 1, Y = this.getScene(N), I = this.getAt(R);
              this.scenes[W] = I, this.scenes[R] = Y;
            }
          }
          return this;
        }, moveUp: function(N) {
          if (this.isProcessing)
            this._queue.push({ op: "moveUp", keyA: N, keyB: null });
          else {
            var W = this.getIndex(N);
            if (W < this.scenes.length - 1) {
              var R = W + 1, Y = this.getScene(N), I = this.getAt(R);
              this.scenes[W] = I, this.scenes[R] = Y;
            }
          }
          return this;
        }, moveAbove: function(N, W) {
          if (N === W)
            return this;
          if (this.isProcessing)
            this._queue.push({ op: "moveAbove", keyA: N, keyB: W });
          else {
            var R = this.getIndex(N), Y = this.getIndex(W);
            if (R !== -1 && Y !== -1 && Y < R) {
              var I = this.getAt(Y);
              this.scenes.splice(Y, 1), this.scenes.splice(R + (Y > R), 0, I);
            }
          }
          return this;
        }, moveBelow: function(N, W) {
          if (N === W)
            return this;
          if (this.isProcessing)
            this._queue.push({ op: "moveBelow", keyA: N, keyB: W });
          else {
            var R = this.getIndex(N), Y = this.getIndex(W);
            if (R !== -1 && Y !== -1 && Y > R) {
              var I = this.getAt(Y);
              if (this.scenes.splice(Y, 1), R === 0)
                this.scenes.unshift(I);
              else
                this.scenes.splice(R - (Y < R), 0, I);
            }
          }
          return this;
        }, queueOp: function(N, W, R) {
          return this._queue.push({ op: N, keyA: W, keyB: R }), this;
        }, swapPosition: function(N, W) {
          if (N === W)
            return this;
          if (this.isProcessing)
            this._queue.push({ op: "swapPosition", keyA: N, keyB: W });
          else {
            var R = this.getIndex(N), Y = this.getIndex(W);
            if (R !== Y && R !== -1 && Y !== -1) {
              var I = this.getAt(R);
              this.scenes[R] = this.scenes[Y], this.scenes[Y] = I;
            }
          }
          return this;
        }, dump: function() {
          var N = [], W = ["pending", "init", "start", "loading", "creating", "running", "paused", "sleeping", "shutdown", "destroyed"];
          for (var R = 0;R < this.scenes.length; R++) {
            var Y = this.scenes[R].sys, I = Y.settings.visible && (Y.settings.status === L.RUNNING || Y.settings.status === L.PAUSED) ? "[*] " : "[-] ";
            I += Y.settings.key + " (" + W[Y.settings.status] + ")", N.push(I);
          }
          console.log(N.join("\n"));
        }, destroy: function() {
          for (var N = 0;N < this.scenes.length; N++) {
            var W = this.scenes[N].sys;
            W.destroy();
          }
          this.systemScene.sys.destroy(), this.update = Z, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this.game = null, this.systemScene = null;
        } });
        M.exports = H;
      }, 52209: (M, B, $) => {
        var E = $(45319), L = $(83419), z = $(44594), U = $(95540), K = $(37277), J = new L({ initialize: function Z(D) {
          this.scene = D, this.systems = D.sys, this.settings = D.sys.settings, this.key = D.sys.settings.key, this.manager = D.sys.game.scene, this.transitionProgress = 0, this._elapsed = 0, this._target = null, this._duration = 0, this._onUpdate, this._onUpdateScope, this._willSleep = false, this._willRemove = false, D.sys.events.once(z.BOOT, this.boot, this), D.sys.events.on(z.START, this.pluginStart, this);
        }, boot: function() {
          this.systems.events.once(z.DESTROY, this.destroy, this);
        }, pluginStart: function() {
          this._target = null, this.systems.events.once(z.SHUTDOWN, this.shutdown, this);
        }, start: function(Z, D) {
          if (Z === undefined)
            Z = this.key;
          return this.manager.queueOp("stop", this.key), this.manager.queueOp("start", Z, D), this;
        }, restart: function(Z) {
          var D = this.key;
          return this.manager.queueOp("stop", D), this.manager.queueOp("start", D, Z), this;
        }, transition: function(Z) {
          if (Z === undefined)
            Z = {};
          var D = U(Z, "target", false), Q = this.manager.getScene(D);
          if (!D || !this.checkValidTransition(Q))
            return false;
          var H = U(Z, "duration", 1000);
          this._elapsed = 0, this._target = Q, this._duration = H, this._willSleep = U(Z, "sleep", false), this._willRemove = U(Z, "remove", false);
          var N = U(Z, "onUpdate", null);
          if (N)
            this._onUpdate = N, this._onUpdateScope = U(Z, "onUpdateScope", this.scene);
          var W = U(Z, "allowInput", false);
          this.settings.transitionAllowInput = W;
          var R = Q.sys.settings;
          if (R.isTransition = true, R.transitionFrom = this.scene, R.transitionDuration = H, R.transitionAllowInput = W, U(Z, "moveAbove", false))
            this.manager.moveAbove(this.key, D);
          else if (U(Z, "moveBelow", false))
            this.manager.moveBelow(this.key, D);
          if (Q.sys.isSleeping())
            Q.sys.wake(U(Z, "data"));
          else
            this.manager.start(D, U(Z, "data"));
          var Y = U(Z, "onStart", null), I = U(Z, "onStartScope", this.scene);
          if (Y)
            Y.call(I, this.scene, Q, H);
          return this.systems.events.emit(z.TRANSITION_OUT, Q, H), true;
        }, checkValidTransition: function(Z) {
          if (!Z || Z.sys.isActive() || Z.sys.isTransitioning() || Z === this.scene || this.systems.isTransitioning())
            return false;
          return true;
        }, step: function(Z, D) {
          if (this._elapsed += D, this.transitionProgress = E(this._elapsed / this._duration, 0, 1), this._onUpdate)
            this._onUpdate.call(this._onUpdateScope, this.transitionProgress);
          if (this._elapsed >= this._duration)
            this.transitionComplete();
        }, transitionComplete: function() {
          var Z = this._target.sys, D = this._target.sys.settings;
          if (Z.events.emit(z.TRANSITION_COMPLETE, this.scene), D.isTransition = false, D.transitionFrom = null, this._duration = 0, this._target = null, this._onUpdate = null, this._onUpdateScope = null, this._willRemove)
            this.manager.remove(this.key);
          else if (this._willSleep)
            this.systems.sleep();
          else
            this.manager.stop(this.key);
        }, add: function(Z, D, Q, H) {
          return this.manager.add(Z, D, Q, H);
        }, launch: function(Z, D) {
          if (Z && Z !== this.key)
            this.manager.queueOp("start", Z, D);
          return this;
        }, run: function(Z, D) {
          if (Z && Z !== this.key)
            this.manager.queueOp("run", Z, D);
          return this;
        }, pause: function(Z, D) {
          if (Z === undefined)
            Z = this.key;
          return this.manager.queueOp("pause", Z, D), this;
        }, resume: function(Z, D) {
          if (Z === undefined)
            Z = this.key;
          return this.manager.queueOp("resume", Z, D), this;
        }, sleep: function(Z, D) {
          if (Z === undefined)
            Z = this.key;
          return this.manager.queueOp("sleep", Z, D), this;
        }, wake: function(Z, D) {
          if (Z === undefined)
            Z = this.key;
          return this.manager.queueOp("wake", Z, D), this;
        }, switch: function(Z) {
          if (Z !== this.key)
            this.manager.queueOp("switch", this.key, Z);
          return this;
        }, stop: function(Z, D) {
          if (Z === undefined)
            Z = this.key;
          return this.manager.queueOp("stop", Z, D), this;
        }, setActive: function(Z, D, Q) {
          if (D === undefined)
            D = this.key;
          var H = this.manager.getScene(D);
          if (H)
            H.sys.setActive(Z, Q);
          return this;
        }, setVisible: function(Z, D) {
          if (D === undefined)
            D = this.key;
          var Q = this.manager.getScene(D);
          if (Q)
            Q.sys.setVisible(Z);
          return this;
        }, isSleeping: function(Z) {
          if (Z === undefined)
            Z = this.key;
          return this.manager.isSleeping(Z);
        }, isActive: function(Z) {
          if (Z === undefined)
            Z = this.key;
          return this.manager.isActive(Z);
        }, isPaused: function(Z) {
          if (Z === undefined)
            Z = this.key;
          return this.manager.isPaused(Z);
        }, isVisible: function(Z) {
          if (Z === undefined)
            Z = this.key;
          return this.manager.isVisible(Z);
        }, swapPosition: function(Z, D) {
          if (D === undefined)
            D = this.key;
          if (Z !== D)
            this.manager.swapPosition(Z, D);
          return this;
        }, moveAbove: function(Z, D) {
          if (D === undefined)
            D = this.key;
          if (Z !== D)
            this.manager.moveAbove(Z, D);
          return this;
        }, moveBelow: function(Z, D) {
          if (D === undefined)
            D = this.key;
          if (Z !== D)
            this.manager.moveBelow(Z, D);
          return this;
        }, remove: function(Z) {
          if (Z === undefined)
            Z = this.key;
          return this.manager.remove(Z), this;
        }, moveUp: function(Z) {
          if (Z === undefined)
            Z = this.key;
          return this.manager.moveUp(Z), this;
        }, moveDown: function(Z) {
          if (Z === undefined)
            Z = this.key;
          return this.manager.moveDown(Z), this;
        }, bringToTop: function(Z) {
          if (Z === undefined)
            Z = this.key;
          return this.manager.bringToTop(Z), this;
        }, sendToBack: function(Z) {
          if (Z === undefined)
            Z = this.key;
          return this.manager.sendToBack(Z), this;
        }, get: function(Z) {
          return this.manager.getScene(Z);
        }, getStatus: function(Z) {
          var D = this.manager.getScene(Z);
          if (D)
            return D.sys.getStatus();
        }, getIndex: function(Z) {
          if (Z === undefined)
            Z = this.key;
          return this.manager.getIndex(Z);
        }, shutdown: function() {
          var Z = this.systems.events;
          Z.off(z.SHUTDOWN, this.shutdown, this), Z.off(z.TRANSITION_OUT);
        }, destroy: function() {
          this.shutdown(), this.scene.sys.events.off(z.START, this.start, this), this.scene = null, this.systems = null, this.settings = null, this.manager = null;
        } });
        K.register("ScenePlugin", J, "scenePlugin"), M.exports = J;
      }, 55681: (M, B, $) => {
        var E = $(89993), L = $(35154), z = $(46975), U = $(87033), K = { create: function(J) {
          if (typeof J === "string")
            J = { key: J };
          else if (J === undefined)
            J = {};
          return { status: E.PENDING, key: L(J, "key", ""), active: L(J, "active", false), visible: L(J, "visible", true), isBooted: false, isTransition: false, transitionFrom: null, transitionDuration: 0, transitionAllowInput: true, data: {}, pack: L(J, "pack", false), cameras: L(J, "cameras", null), map: L(J, "map", z(U, L(J, "mapAdd", {}))), physics: L(J, "physics", {}), loader: L(J, "loader", {}), plugins: L(J, "plugins", false), input: L(J, "input", {}) };
        } };
        M.exports = K;
      }, 2368: (M, B, $) => {
        var E = $(83419), L = $(89993), z = $(42363), U = $(44594), K = $(27397), J = $(52106), Z = $(29747), D = $(55681), Q = new E({ initialize: function H(N, W) {
          this.scene = N, this.game, this.renderer, this.config = W, this.settings = D.create(W), this.canvas, this.context, this.anims, this.cache, this.plugins, this.registry, this.scale, this.sound, this.textures, this.add, this.cameras, this.displayList, this.events, this.make, this.scenePlugin, this.updateList, this.sceneUpdate = Z;
        }, init: function(H) {
          this.settings.status = L.INIT, this.sceneUpdate = Z, this.game = H, this.renderer = H.renderer, this.canvas = H.canvas, this.context = H.context;
          var N = H.plugins;
          this.plugins = N, N.addToScene(this, z.Global, [z.CoreScene, J(this), K(this)]), this.events.emit(U.BOOT, this), this.settings.isBooted = true;
        }, step: function(H, N) {
          var W = this.events;
          W.emit(U.PRE_UPDATE, H, N), W.emit(U.UPDATE, H, N), this.sceneUpdate.call(this.scene, H, N), W.emit(U.POST_UPDATE, H, N);
        }, render: function(H) {
          var N = this.displayList;
          N.depthSort(), this.events.emit(U.PRE_RENDER, H), this.cameras.render(H, N), this.events.emit(U.RENDER, H);
        }, queueDepthSort: function() {
          this.displayList.queueDepthSort();
        }, depthSort: function() {
          this.displayList.depthSort();
        }, pause: function(H) {
          var N = this.settings, W = this.getStatus();
          if (W !== L.CREATING && W !== L.RUNNING)
            console.warn("Cannot pause non-running Scene", N.key);
          else if (this.settings.active)
            N.status = L.PAUSED, N.active = false, this.events.emit(U.PAUSE, this, H);
          return this;
        }, resume: function(H) {
          var N = this.events, W = this.settings;
          if (!this.settings.active)
            W.status = L.RUNNING, W.active = true, N.emit(U.RESUME, this, H);
          return this;
        }, sleep: function(H) {
          var N = this.settings, W = this.getStatus();
          if (W !== L.CREATING && W !== L.RUNNING)
            console.warn("Cannot sleep non-running Scene", N.key);
          else
            N.status = L.SLEEPING, N.active = false, N.visible = false, this.events.emit(U.SLEEP, this, H);
          return this;
        }, wake: function(H) {
          var N = this.events, W = this.settings;
          if (W.status = L.RUNNING, W.active = true, W.visible = true, N.emit(U.WAKE, this, H), W.isTransition)
            N.emit(U.TRANSITION_WAKE, W.transitionFrom, W.transitionDuration);
          return this;
        }, getData: function() {
          return this.settings.data;
        }, getStatus: function() {
          return this.settings.status;
        }, canInput: function() {
          var H = this.settings.status;
          return H > L.PENDING && H <= L.RUNNING;
        }, isSleeping: function() {
          return this.settings.status === L.SLEEPING;
        }, isActive: function() {
          return this.settings.status === L.RUNNING;
        }, isPaused: function() {
          return this.settings.status === L.PAUSED;
        }, isTransitioning: function() {
          return this.settings.isTransition || this.scenePlugin._target !== null;
        }, isTransitionOut: function() {
          return this.scenePlugin._target !== null && this.scenePlugin._duration > 0;
        }, isTransitionIn: function() {
          return this.settings.isTransition;
        }, isVisible: function() {
          return this.settings.visible;
        }, setVisible: function(H) {
          return this.settings.visible = H, this;
        }, setActive: function(H, N) {
          if (H)
            return this.resume(N);
          else
            return this.pause(N);
        }, start: function(H) {
          var N = this.events, W = this.settings;
          if (H)
            W.data = H;
          W.status = L.START, W.active = true, W.visible = true, N.emit(U.START, this), N.emit(U.READY, this, H);
        }, shutdown: function(H) {
          var N = this.events, W = this.settings;
          N.off(U.TRANSITION_INIT), N.off(U.TRANSITION_START), N.off(U.TRANSITION_COMPLETE), N.off(U.TRANSITION_OUT), W.status = L.SHUTDOWN, W.active = false, W.visible = false, N.emit(U.SHUTDOWN, this, H);
        }, destroy: function() {
          var H = this.events, N = this.settings;
          N.status = L.DESTROYED, N.active = false, N.visible = false, H.emit(U.DESTROY, this), H.removeAllListeners();
          var W = ["scene", "game", "anims", "cache", "plugins", "registry", "sound", "textures", "add", "camera", "displayList", "events", "make", "scenePlugin", "updateList"];
          for (var R = 0;R < W.length; R++)
            this[W[R]] = null;
        } });
        M.exports = Q;
      }, 89993: (M) => {
        var B = { PENDING: 0, INIT: 1, START: 2, LOADING: 3, CREATING: 4, RUNNING: 5, PAUSED: 6, SLEEPING: 7, SHUTDOWN: 8, DESTROYED: 9 };
        M.exports = B;
      }, 69830: (M) => {
        M.exports = "addedtoscene";
      }, 7919: (M) => {
        M.exports = "boot";
      }, 46763: (M) => {
        M.exports = "create";
      }, 11763: (M) => {
        M.exports = "destroy";
      }, 71555: (M) => {
        M.exports = "pause";
      }, 36735: (M) => {
        M.exports = "postupdate";
      }, 3809: (M) => {
        M.exports = "prerender";
      }, 90716: (M) => {
        M.exports = "preupdate";
      }, 58262: (M) => {
        M.exports = "ready";
      }, 91633: (M) => {
        M.exports = "removedfromscene";
      }, 10319: (M) => {
        M.exports = "render";
      }, 87132: (M) => {
        M.exports = "resume";
      }, 81961: (M) => {
        M.exports = "shutdown";
      }, 90194: (M) => {
        M.exports = "sleep";
      }, 6265: (M) => {
        M.exports = "start";
      }, 33178: (M) => {
        M.exports = "transitioncomplete";
      }, 43063: (M) => {
        M.exports = "transitioninit";
      }, 11259: (M) => {
        M.exports = "transitionout";
      }, 61611: (M) => {
        M.exports = "transitionstart";
      }, 45209: (M) => {
        M.exports = "transitionwake";
      }, 22966: (M) => {
        M.exports = "update";
      }, 21747: (M) => {
        M.exports = "wake";
      }, 44594: (M, B, $) => {
        M.exports = { ADDED_TO_SCENE: $(69830), BOOT: $(7919), CREATE: $(46763), DESTROY: $(11763), PAUSE: $(71555), POST_UPDATE: $(36735), PRE_RENDER: $(3809), PRE_UPDATE: $(90716), READY: $(58262), REMOVED_FROM_SCENE: $(91633), RENDER: $(10319), RESUME: $(87132), SHUTDOWN: $(81961), SLEEP: $(90194), START: $(6265), TRANSITION_COMPLETE: $(33178), TRANSITION_INIT: $(43063), TRANSITION_OUT: $(11259), TRANSITION_START: $(61611), TRANSITION_WAKE: $(45209), UPDATE: $(22966), WAKE: $(21747) };
      }, 62194: (M, B, $) => {
        var E = $(89993), L = $(79291), z = { Events: $(44594), GetPhysicsPlugins: $(27397), GetScenePlugins: $(52106), SceneManager: $(60903), ScenePlugin: $(52209), Settings: $(55681), Systems: $(2368) };
        z = L(false, z, E), M.exports = z;
      }, 30341: (M, B, $) => {
        var E = $(83419), L = $(50792), z = $(14463), U = $(79291), K = $(29747), J = new E({ Extends: L, initialize: function Z(D, Q, H) {
          L.call(this), this.manager = D, this.key = Q, this.isPlaying = false, this.isPaused = false, this.totalRate = 1, this.duration = this.duration || 0, this.totalDuration = this.totalDuration || 0, this.config = { mute: false, volume: 1, rate: 1, detune: 0, seek: 0, loop: false, delay: 0, pan: 0 }, this.currentConfig = this.config, this.config = U(this.config, H), this.markers = {}, this.currentMarker = null, this.pendingRemove = false;
        }, addMarker: function(Z) {
          if (!Z || !Z.name || typeof Z.name !== "string")
            return false;
          if (this.markers[Z.name])
            return console.error("addMarker " + Z.name + " already exists in Sound"), false;
          return Z = U(true, { name: "", start: 0, duration: this.totalDuration - (Z.start || 0), config: { mute: false, volume: 1, rate: 1, detune: 0, seek: 0, loop: false, delay: 0, pan: 0 } }, Z), this.markers[Z.name] = Z, true;
        }, updateMarker: function(Z) {
          if (!Z || !Z.name || typeof Z.name !== "string")
            return false;
          if (!this.markers[Z.name])
            return console.warn("Audio Marker: " + Z.name + " missing in Sound: " + this.key), false;
          return this.markers[Z.name] = U(true, this.markers[Z.name], Z), true;
        }, removeMarker: function(Z) {
          var D = this.markers[Z];
          if (!D)
            return null;
          return this.markers[Z] = null, D;
        }, play: function(Z, D) {
          if (Z === undefined)
            Z = "";
          if (typeof Z === "object")
            D = Z, Z = "";
          if (typeof Z !== "string")
            return false;
          if (!Z)
            this.currentMarker = null, this.currentConfig = this.config, this.duration = this.totalDuration;
          else {
            if (!this.markers[Z])
              return console.warn("Marker: " + Z + " missing in Sound: " + this.key), false;
            this.currentMarker = this.markers[Z], this.currentConfig = this.currentMarker.config, this.duration = this.currentMarker.duration;
          }
          return this.resetConfig(), this.currentConfig = U(this.currentConfig, D), this.isPlaying = true, this.isPaused = false, true;
        }, pause: function() {
          if (this.isPaused || !this.isPlaying)
            return false;
          return this.isPlaying = false, this.isPaused = true, true;
        }, resume: function() {
          if (!this.isPaused || this.isPlaying)
            return false;
          return this.isPlaying = true, this.isPaused = false, true;
        }, stop: function() {
          if (!this.isPaused && !this.isPlaying)
            return false;
          return this.isPlaying = false, this.isPaused = false, this.resetConfig(), true;
        }, applyConfig: function() {
          this.mute = this.currentConfig.mute, this.volume = this.currentConfig.volume, this.rate = this.currentConfig.rate, this.detune = this.currentConfig.detune, this.loop = this.currentConfig.loop, this.pan = this.currentConfig.pan;
        }, resetConfig: function() {
          this.currentConfig.seek = 0, this.currentConfig.delay = 0;
        }, update: K, calculateRate: function() {
          var Z = 1.0005777895065548, D = this.currentConfig.detune + this.manager.detune, Q = Math.pow(Z, D);
          this.totalRate = this.currentConfig.rate * this.manager.rate * Q;
        }, destroy: function() {
          if (this.pendingRemove)
            return;
          this.stop(), this.emit(z.DESTROY, this), this.removeAllListeners(), this.pendingRemove = true, this.manager = null, this.config = null, this.currentConfig = null, this.markers = null, this.currentMarker = null;
        } });
        M.exports = J;
      }, 85034: (M, B, $) => {
        var E = $(83419), L = $(41786), z = $(50792), U = $(14463), K = $(8443), J = $(46710), Z = $(58731), D = $(29747), Q = $(26099), H = new E({ Extends: z, initialize: function N(W) {
          z.call(this), this.game = W, this.jsonCache = W.cache.json, this.sounds = [], this.mute = false, this.volume = 1, this.pauseOnBlur = true, this._rate = 1, this._detune = 0, this.locked = this.locked || false, this.unlocked = false, this.gameLostFocus = false, this.listenerPosition = new Q, W.events.on(K.BLUR, this.onGameBlur, this), W.events.on(K.FOCUS, this.onGameFocus, this), W.events.on(K.PRE_STEP, this.update, this), W.events.once(K.DESTROY, this.destroy, this);
        }, add: D, addAudioSprite: function(N, W) {
          if (W === undefined)
            W = {};
          var R = this.add(N, W);
          R.spritemap = this.jsonCache.get(N).spritemap;
          for (var Y in R.spritemap) {
            if (!R.spritemap.hasOwnProperty(Y))
              continue;
            var I = L(W), P = R.spritemap[Y];
            I.loop = P.hasOwnProperty("loop") ? P.loop : false, R.addMarker({ name: Y, start: P.start, duration: P.end - P.start, config: I });
          }
          return R;
        }, get: function(N) {
          return Z(this.sounds, "key", N);
        }, getAll: function(N) {
          if (N)
            return J(this.sounds, "key", N);
          else
            return J(this.sounds);
        }, getAllPlaying: function() {
          return J(this.sounds, "isPlaying", true);
        }, play: function(N, W) {
          var R = this.add(N);
          if (R.once(U.COMPLETE, R.destroy, R), W)
            if (W.name)
              return R.addMarker(W), R.play(W.name);
            else
              return R.play(W);
          else
            return R.play();
        }, playAudioSprite: function(N, W, R) {
          var Y = this.addAudioSprite(N);
          return Y.once(U.COMPLETE, Y.destroy, Y), Y.play(W, R);
        }, remove: function(N) {
          var W = this.sounds.indexOf(N);
          if (W !== -1)
            return N.destroy(), this.sounds.splice(W, 1), true;
          return false;
        }, removeAll: function() {
          this.sounds.forEach(function(N) {
            N.destroy();
          }), this.sounds.length = 0;
        }, removeByKey: function(N) {
          var W = 0;
          for (var R = this.sounds.length - 1;R >= 0; R--) {
            var Y = this.sounds[R];
            if (Y.key === N)
              Y.destroy(), this.sounds.splice(R, 1), W++;
          }
          return W;
        }, pauseAll: function() {
          this.forEachActiveSound(function(N) {
            N.pause();
          }), this.emit(U.PAUSE_ALL, this);
        }, resumeAll: function() {
          this.forEachActiveSound(function(N) {
            N.resume();
          }), this.emit(U.RESUME_ALL, this);
        }, setListenerPosition: D, stopAll: function() {
          this.forEachActiveSound(function(N) {
            N.stop();
          }), this.emit(U.STOP_ALL, this);
        }, stopByKey: function(N) {
          var W = 0;
          return this.getAll(N).forEach(function(R) {
            if (R.stop())
              W++;
          }), W;
        }, unlock: D, onBlur: D, onFocus: D, onGameBlur: function() {
          if (this.gameLostFocus = true, this.pauseOnBlur)
            this.onBlur();
        }, onGameFocus: function() {
          if (this.gameLostFocus = false, this.pauseOnBlur)
            this.onFocus();
        }, update: function(N, W) {
          if (this.unlocked)
            this.unlocked = false, this.locked = false, this.emit(U.UNLOCKED, this);
          for (var R = this.sounds.length - 1;R >= 0; R--)
            if (this.sounds[R].pendingRemove)
              this.sounds.splice(R, 1);
          this.sounds.forEach(function(Y) {
            Y.update(N, W);
          });
        }, destroy: function() {
          this.game.events.off(K.BLUR, this.onGameBlur, this), this.game.events.off(K.FOCUS, this.onGameFocus, this), this.game.events.off(K.PRE_STEP, this.update, this), this.removeAllListeners(), this.removeAll(), this.sounds.length = 0, this.sounds = null, this.listenerPosition = null, this.game = null;
        }, forEachActiveSound: function(N, W) {
          var R = this;
          this.sounds.forEach(function(Y, I) {
            if (Y && !Y.pendingRemove)
              N.call(W || R, Y, I, R.sounds);
          });
        }, setRate: function(N) {
          return this.rate = N, this;
        }, rate: { get: function() {
          return this._rate;
        }, set: function(N) {
          this._rate = N, this.forEachActiveSound(function(W) {
            W.calculateRate();
          }), this.emit(U.GLOBAL_RATE, this, N);
        } }, setDetune: function(N) {
          return this.detune = N, this;
        }, detune: { get: function() {
          return this._detune;
        }, set: function(N) {
          this._detune = N, this.forEachActiveSound(function(W) {
            W.calculateRate();
          }), this.emit(U.GLOBAL_DETUNE, this, N);
        } } });
        M.exports = H;
      }, 14747: (M, B, $) => {
        var E = $(33684), L = $(25960), z = $(57490), U = { create: function(K) {
          var J = K.config.audio, Z = K.device.audio;
          if (J.noAudio || !Z.webAudio && !Z.audioData)
            return new L(K);
          if (Z.webAudio && !J.disableWebAudio)
            return new z(K);
          return new E(K);
        } };
        M.exports = U;
      }, 19723: (M) => {
        M.exports = "complete";
      }, 98882: (M) => {
        M.exports = "decodedall";
      }, 57506: (M) => {
        M.exports = "decoded";
      }, 73146: (M) => {
        M.exports = "destroy";
      }, 11305: (M) => {
        M.exports = "detune";
      }, 40577: (M) => {
        M.exports = "detune";
      }, 30333: (M) => {
        M.exports = "mute";
      }, 20394: (M) => {
        M.exports = "rate";
      }, 21802: (M) => {
        M.exports = "volume";
      }, 1299: (M) => {
        M.exports = "looped";
      }, 99190: (M) => {
        M.exports = "loop";
      }, 97125: (M) => {
        M.exports = "mute";
      }, 89259: (M) => {
        M.exports = "pan";
      }, 79986: (M) => {
        M.exports = "pauseall";
      }, 17586: (M) => {
        M.exports = "pause";
      }, 19618: (M) => {
        M.exports = "play";
      }, 42306: (M) => {
        M.exports = "rate";
      }, 10387: (M) => {
        M.exports = "resumeall";
      }, 48959: (M) => {
        M.exports = "resume";
      }, 9960: (M) => {
        M.exports = "seek";
      }, 19180: (M) => {
        M.exports = "stopall";
      }, 98328: (M) => {
        M.exports = "stop";
      }, 50401: (M) => {
        M.exports = "unlocked";
      }, 52498: (M) => {
        M.exports = "volume";
      }, 14463: (M, B, $) => {
        M.exports = { COMPLETE: $(19723), DECODED: $(57506), DECODED_ALL: $(98882), DESTROY: $(73146), DETUNE: $(11305), GLOBAL_DETUNE: $(40577), GLOBAL_MUTE: $(30333), GLOBAL_RATE: $(20394), GLOBAL_VOLUME: $(21802), LOOP: $(99190), LOOPED: $(1299), MUTE: $(97125), PAN: $(89259), PAUSE_ALL: $(79986), PAUSE: $(17586), PLAY: $(19618), RATE: $(42306), RESUME_ALL: $(10387), RESUME: $(48959), SEEK: $(9960), STOP_ALL: $(19180), STOP: $(98328), UNLOCKED: $(50401), VOLUME: $(52498) };
      }, 64895: (M, B, $) => {
        var E = $(30341), L = $(83419), z = $(14463), U = $(45319), K = new L({ Extends: E, initialize: function J(Z, D, Q) {
          if (Q === undefined)
            Q = {};
          if (this.tags = Z.game.cache.audio.get(D), !this.tags)
            throw new Error('No cached audio asset with key "' + D);
          this.audio = null, this.startTime = 0, this.previousTime = 0, this.duration = this.tags[0].duration, this.totalDuration = this.tags[0].duration, E.call(this, Z, D, Q);
        }, play: function(J, Z) {
          if (this.manager.isLocked(this, "play", [J, Z]))
            return false;
          if (!E.prototype.play.call(this, J, Z))
            return false;
          if (!this.pickAndPlayAudioTag())
            return false;
          return this.emit(z.PLAY, this), true;
        }, pause: function() {
          if (this.manager.isLocked(this, "pause"))
            return false;
          if (this.startTime > 0)
            return false;
          if (!E.prototype.pause.call(this))
            return false;
          return this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.stopAndReleaseAudioTag(), this.emit(z.PAUSE, this), true;
        }, resume: function() {
          if (this.manager.isLocked(this, "resume"))
            return false;
          if (this.startTime > 0)
            return false;
          if (!E.prototype.resume.call(this))
            return false;
          if (!this.pickAndPlayAudioTag())
            return false;
          return this.emit(z.RESUME, this), true;
        }, stop: function() {
          if (this.manager.isLocked(this, "stop"))
            return false;
          if (!E.prototype.stop.call(this))
            return false;
          return this.stopAndReleaseAudioTag(), this.emit(z.STOP, this), true;
        }, pickAndPlayAudioTag: function() {
          if (!this.pickAudioTag())
            return this.reset(), false;
          var J = this.currentConfig.seek, Z = this.currentConfig.delay, D = (this.currentMarker ? this.currentMarker.start : 0) + J;
          if (this.previousTime = D, this.audio.currentTime = D, this.applyConfig(), Z === 0) {
            if (this.startTime = 0, this.audio.paused)
              this.playCatchPromise();
          } else if (this.startTime = window.performance.now() + Z * 1000, !this.audio.paused)
            this.audio.pause();
          return this.resetConfig(), true;
        }, pickAudioTag: function() {
          if (this.audio)
            return true;
          for (var J = 0;J < this.tags.length; J++) {
            var Z = this.tags[J];
            if (Z.dataset.used === "false")
              return Z.dataset.used = "true", this.audio = Z, true;
          }
          if (!this.manager.override)
            return false;
          var D = [];
          this.manager.forEachActiveSound(function(H) {
            if (H.key === this.key && H.audio)
              D.push(H);
          }, this), D.sort(function(H, N) {
            if (H.loop === N.loop)
              return N.seek / N.duration - H.seek / H.duration;
            return H.loop ? 1 : -1;
          });
          var Q = D[0];
          return this.audio = Q.audio, Q.reset(), Q.audio = null, Q.startTime = 0, Q.previousTime = 0, true;
        }, playCatchPromise: function() {
          var J = this.audio.play();
          if (J)
            J.catch(function(Z) {
              console.warn(Z);
            });
        }, stopAndReleaseAudioTag: function() {
          if (this.startTime = 0, this.previousTime = 0, this.audio)
            this.audio.pause(), this.audio.dataset.used = "false", this.audio = null;
        }, reset: function() {
          E.prototype.stop.call(this);
        }, onBlur: function() {
          this.isPlaying = false, this.isPaused = true, this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.currentConfig.delay = Math.max(0, (this.startTime - window.performance.now()) / 1000), this.stopAndReleaseAudioTag();
        }, onFocus: function() {
          this.isPlaying = true, this.isPaused = false, this.pickAndPlayAudioTag();
        }, update: function(J) {
          if (!this.isPlaying)
            return;
          if (this.startTime > 0) {
            if (this.startTime < J - this.manager.audioPlayDelay)
              this.audio.currentTime += Math.max(0, J - this.startTime) / 1000, this.startTime = 0, this.previousTime = this.audio.currentTime, this.playCatchPromise();
            return;
          }
          var Z = this.currentMarker ? this.currentMarker.start : 0, D = Z + this.duration, Q = this.audio.currentTime;
          if (this.currentConfig.loop) {
            if (Q >= D - this.manager.loopEndOffset)
              this.audio.currentTime = Z + Math.max(0, Q - D), Q = this.audio.currentTime;
            else if (Q < Z)
              this.audio.currentTime += Z, Q = this.audio.currentTime;
            if (Q < this.previousTime)
              this.emit(z.LOOPED, this);
          } else if (Q >= D) {
            this.reset(), this.stopAndReleaseAudioTag(), this.emit(z.COMPLETE, this);
            return;
          }
          this.previousTime = Q;
        }, destroy: function() {
          if (E.prototype.destroy.call(this), this.tags = null, this.audio)
            this.stopAndReleaseAudioTag();
        }, updateMute: function() {
          if (this.audio)
            this.audio.muted = this.currentConfig.mute || this.manager.mute;
        }, updateVolume: function() {
          if (this.audio)
            this.audio.volume = U(this.currentConfig.volume * this.manager.volume, 0, 1);
        }, calculateRate: function() {
          if (E.prototype.calculateRate.call(this), this.audio)
            this.audio.playbackRate = this.totalRate;
        }, mute: { get: function() {
          return this.currentConfig.mute;
        }, set: function(J) {
          if (this.currentConfig.mute = J, this.manager.isLocked(this, "mute", J))
            return;
          this.updateMute(), this.emit(z.MUTE, this, J);
        } }, setMute: function(J) {
          return this.mute = J, this;
        }, volume: { get: function() {
          return this.currentConfig.volume;
        }, set: function(J) {
          if (this.currentConfig.volume = J, this.manager.isLocked(this, "volume", J))
            return;
          this.updateVolume(), this.emit(z.VOLUME, this, J);
        } }, setVolume: function(J) {
          return this.volume = J, this;
        }, rate: { get: function() {
          return this.currentConfig.rate;
        }, set: function(J) {
          if (this.currentConfig.rate = J, this.manager.isLocked(this, z.RATE, J))
            return;
          else
            this.calculateRate(), this.emit(z.RATE, this, J);
        } }, setRate: function(J) {
          return this.rate = J, this;
        }, detune: { get: function() {
          return this.currentConfig.detune;
        }, set: function(J) {
          if (this.currentConfig.detune = J, this.manager.isLocked(this, z.DETUNE, J))
            return;
          else
            this.calculateRate(), this.emit(z.DETUNE, this, J);
        } }, setDetune: function(J) {
          return this.detune = J, this;
        }, seek: { get: function() {
          if (this.isPlaying)
            return this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0);
          else if (this.isPaused)
            return this.currentConfig.seek;
          else
            return 0;
        }, set: function(J) {
          if (this.manager.isLocked(this, "seek", J))
            return;
          if (this.startTime > 0)
            return;
          if (this.isPlaying || this.isPaused) {
            if (J = Math.min(Math.max(0, J), this.duration), this.isPlaying)
              this.previousTime = J, this.audio.currentTime = J;
            else if (this.isPaused)
              this.currentConfig.seek = J;
            this.emit(z.SEEK, this, J);
          }
        } }, setSeek: function(J) {
          return this.seek = J, this;
        }, loop: { get: function() {
          return this.currentConfig.loop;
        }, set: function(J) {
          if (this.currentConfig.loop = J, this.manager.isLocked(this, "loop", J))
            return;
          if (this.audio)
            this.audio.loop = J;
          this.emit(z.LOOP, this, J);
        } }, setLoop: function(J) {
          return this.loop = J, this;
        }, pan: { get: function() {
          return this.currentConfig.pan;
        }, set: function(J) {
          this.currentConfig.pan = J, this.emit(z.PAN, this, J);
        } }, setPan: function(J) {
          return this.pan = J, this;
        } });
        M.exports = K;
      }, 33684: (M, B, $) => {
        var E = $(85034), L = $(83419), z = $(14463), U = $(64895), K = new L({ Extends: E, initialize: function J(Z) {
          this.override = true, this.audioPlayDelay = 0.1, this.loopEndOffset = 0.05, this.onBlurPausedSounds = [], this.locked = "ontouchstart" in window, this.lockedActionsQueue = this.locked ? [] : null, this._mute = false, this._volume = 1, E.call(this, Z);
        }, add: function(J, Z) {
          var D = new U(this, J, Z);
          return this.sounds.push(D), D;
        }, unlock: function() {
          this.locked = false;
          var J = this;
          if (this.game.cache.audio.entries.each(function(H, N) {
            for (var W = 0;W < N.length; W++)
              if (N[W].dataset.locked === "true")
                return J.locked = true, false;
            return true;
          }), !this.locked)
            return;
          var Z = false, D = function() {
            Z = true;
          }, Q = function() {
            if (Z) {
              Z = false;
              return;
            }
            document.body.removeEventListener("touchmove", D), document.body.removeEventListener("touchend", Q);
            var H = [];
            if (J.game.cache.audio.entries.each(function(W, R) {
              for (var Y = 0;Y < R.length; Y++) {
                var I = R[Y];
                if (I.dataset.locked === "true")
                  H.push(I);
              }
              return true;
            }), H.length === 0)
              return;
            var N = H[H.length - 1];
            N.oncanplaythrough = function() {
              N.oncanplaythrough = null, H.forEach(function(W) {
                W.dataset.locked = "false";
              }), J.unlocked = true;
            }, H.forEach(function(W) {
              W.load();
            });
          };
          this.once(z.UNLOCKED, function() {
            this.forEachActiveSound(function(N) {
              if (N.currentMarker === null && N.duration === 0)
                N.duration = N.tags[0].duration;
              N.totalDuration = N.tags[0].duration;
            });
            while (this.lockedActionsQueue.length) {
              var H = this.lockedActionsQueue.shift();
              if (H.sound[H.prop].apply)
                H.sound[H.prop].apply(H.sound, H.value || []);
              else
                H.sound[H.prop] = H.value;
            }
          }, this), document.body.addEventListener("touchmove", D, false), document.body.addEventListener("touchend", Q, false);
        }, onBlur: function() {
          this.forEachActiveSound(function(J) {
            if (J.isPlaying)
              this.onBlurPausedSounds.push(J), J.onBlur();
          });
        }, onFocus: function() {
          this.onBlurPausedSounds.forEach(function(J) {
            J.onFocus();
          }), this.onBlurPausedSounds.length = 0;
        }, destroy: function() {
          E.prototype.destroy.call(this), this.onBlurPausedSounds.length = 0, this.onBlurPausedSounds = null;
        }, isLocked: function(J, Z, D) {
          if (J.tags[0].dataset.locked === "true")
            return this.lockedActionsQueue.push({ sound: J, prop: Z, value: D }), true;
          return false;
        }, setMute: function(J) {
          return this.mute = J, this;
        }, mute: { get: function() {
          return this._mute;
        }, set: function(J) {
          this._mute = J, this.forEachActiveSound(function(Z) {
            Z.updateMute();
          }), this.emit(z.GLOBAL_MUTE, this, J);
        } }, setVolume: function(J) {
          return this.volume = J, this;
        }, volume: { get: function() {
          return this._volume;
        }, set: function(J) {
          this._volume = J, this.forEachActiveSound(function(Z) {
            Z.updateVolume();
          }), this.emit(z.GLOBAL_VOLUME, this, J);
        } } });
        M.exports = K;
      }, 23717: (M, B, $) => {
        M.exports = { SoundManagerCreator: $(14747), Events: $(14463), BaseSound: $(30341), BaseSoundManager: $(85034), WebAudioSound: $(71741), WebAudioSoundManager: $(57490), HTML5AudioSound: $(64895), HTML5AudioSoundManager: $(33684), NoAudioSound: $(4603), NoAudioSoundManager: $(25960) };
      }, 4603: (M, B, $) => {
        var E = $(30341), L = $(83419), z = $(50792), U = $(79291), K = $(29747), J = function() {
          return false;
        }, Z = function() {
          return null;
        }, D = function() {
          return this;
        }, Q = new L({ Extends: z, initialize: function H(N, W, R) {
          if (R === undefined)
            R = {};
          z.call(this), this.manager = N, this.key = W, this.isPlaying = false, this.isPaused = false, this.totalRate = 1, this.duration = 0, this.totalDuration = 0, this.config = U({ mute: false, volume: 1, rate: 1, detune: 0, seek: 0, loop: false, delay: 0, pan: 0 }, R), this.currentConfig = this.config, this.mute = false, this.volume = 1, this.rate = 1, this.detune = 0, this.seek = 0, this.loop = false, this.pan = 0, this.markers = {}, this.currentMarker = null, this.pendingRemove = false;
        }, addMarker: J, updateMarker: J, removeMarker: Z, play: J, pause: J, resume: J, stop: J, setMute: D, setVolume: D, setRate: D, setDetune: D, setSeek: D, setLoop: D, setPan: D, applyConfig: Z, resetConfig: Z, update: K, calculateRate: Z, destroy: function() {
          E.prototype.destroy.call(this);
        } });
        M.exports = Q;
      }, 25960: (M, B, $) => {
        var E = $(85034), L = $(83419), z = $(50792), U = $(4603), K = $(29747), J = new L({ Extends: z, initialize: function Z(D) {
          z.call(this), this.game = D, this.sounds = [], this.mute = false, this.volume = 1, this.rate = 1, this.detune = 0, this.pauseOnBlur = true, this.locked = false;
        }, add: function(Z, D) {
          var Q = new U(this, Z, D);
          return this.sounds.push(Q), Q;
        }, addAudioSprite: function(Z, D) {
          var Q = this.add(Z, D);
          return Q.spritemap = {}, Q;
        }, get: function(Z) {
          return E.prototype.get.call(this, Z);
        }, getAll: function(Z) {
          return E.prototype.getAll.call(this, Z);
        }, play: function(Z, D) {
          return false;
        }, playAudioSprite: function(Z, D, Q) {
          return false;
        }, remove: function(Z) {
          return E.prototype.remove.call(this, Z);
        }, removeAll: function() {
          return E.prototype.removeAll.call(this);
        }, removeByKey: function(Z) {
          return E.prototype.removeByKey.call(this, Z);
        }, stopByKey: function(Z) {
          return E.prototype.stopByKey.call(this, Z);
        }, onBlur: K, onFocus: K, onGameBlur: K, onGameFocus: K, pauseAll: K, resumeAll: K, stopAll: K, update: K, setRate: K, setDetune: K, setMute: K, setVolume: K, unlock: K, forEachActiveSound: function(Z, D) {
          E.prototype.forEachActiveSound.call(this, Z, D);
        }, destroy: function() {
          E.prototype.destroy.call(this);
        } });
        M.exports = J;
      }, 71741: (M, B, $) => {
        var E = $(30341), L = $(83419), z = $(14463), U = $(95540), K = new L({ Extends: E, initialize: function J(Z, D, Q) {
          if (Q === undefined)
            Q = {};
          if (this.audioBuffer = Z.game.cache.audio.get(D), !this.audioBuffer)
            throw new Error('Audio key "' + D + '" missing from cache');
          if (this.source = null, this.loopSource = null, this.muteNode = Z.context.createGain(), this.volumeNode = Z.context.createGain(), this.pannerNode = null, this.spatialNode = null, this.spatialSource = null, this.playTime = 0, this.startTime = 0, this.loopTime = 0, this.rateUpdates = [], this.hasEnded = false, this.hasLooped = false, this.muteNode.connect(this.volumeNode), Z.context.createPanner)
            this.spatialNode = Z.context.createPanner(), this.volumeNode.connect(this.spatialNode);
          if (Z.context.createStereoPanner) {
            if (this.pannerNode = Z.context.createStereoPanner(), Z.context.createPanner)
              this.spatialNode.connect(this.pannerNode);
            else
              this.volumeNode.connect(this.pannerNode);
            this.pannerNode.connect(Z.destination);
          } else if (Z.context.createPanner)
            this.spatialNode.connect(Z.destination);
          else
            this.volumeNode.connect(Z.destination);
          this.duration = this.audioBuffer.duration, this.totalDuration = this.audioBuffer.duration, E.call(this, Z, D, Q);
        }, play: function(J, Z) {
          if (!E.prototype.play.call(this, J, Z))
            return false;
          return this.stopAndRemoveBufferSource(), this.createAndStartBufferSource(), this.emit(z.PLAY, this), true;
        }, pause: function() {
          if (this.manager.context.currentTime < this.startTime)
            return false;
          if (!E.prototype.pause.call(this))
            return false;
          return this.currentConfig.seek = this.getCurrentTime(), this.stopAndRemoveBufferSource(), this.emit(z.PAUSE, this), true;
        }, resume: function() {
          if (this.manager.context.currentTime < this.startTime)
            return false;
          if (!E.prototype.resume.call(this))
            return false;
          return this.createAndStartBufferSource(), this.emit(z.RESUME, this), true;
        }, stop: function() {
          if (!E.prototype.stop.call(this))
            return false;
          return this.stopAndRemoveBufferSource(), this.emit(z.STOP, this), true;
        }, createAndStartBufferSource: function() {
          var J = this.currentConfig.seek, Z = this.currentConfig.delay, D = this.manager.context.currentTime + Z, Q = (this.currentMarker ? this.currentMarker.start : 0) + J, H = this.duration - J;
          this.playTime = D - J, this.startTime = D, this.source = this.createBufferSource(), this.applyConfig(), this.source.start(Math.max(0, D), Math.max(0, Q), Math.max(0, H)), this.resetConfig();
        }, createAndStartLoopBufferSource: function() {
          var J = this.getLoopTime(), Z = this.currentMarker ? this.currentMarker.start : 0, D = this.duration;
          this.loopTime = J, this.loopSource = this.createBufferSource(), this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0), this.loopSource.start(Math.max(0, J), Math.max(0, Z), Math.max(0, D));
        }, createBufferSource: function() {
          var J = this, Z = this.manager.context.createBufferSource();
          return Z.buffer = this.audioBuffer, Z.connect(this.muteNode), Z.onended = function(D) {
            if (D.target === J.source)
              if (J.currentConfig.loop)
                J.hasLooped = true;
              else
                J.hasEnded = true;
          }, Z;
        }, stopAndRemoveBufferSource: function() {
          if (this.source) {
            var J = this.source;
            this.source = null, J.stop(), J.disconnect();
          }
          this.playTime = 0, this.startTime = 0, this.hasEnded = false, this.stopAndRemoveLoopBufferSource();
        }, stopAndRemoveLoopBufferSource: function() {
          if (this.loopSource)
            this.loopSource.stop(), this.loopSource.disconnect(), this.loopSource = null;
          this.loopTime = 0;
        }, applyConfig: function() {
          this.rateUpdates.length = 0, this.rateUpdates.push({ time: 0, rate: 1 });
          var J = this.currentConfig.source;
          if (J && this.manager.context.createPanner) {
            var Z = this.spatialNode;
            if (Z.panningModel = U(J, "panningModel", "equalpower"), Z.distanceModel = U(J, "distanceModel", "inverse"), Z.orientationX.value = U(J, "orientationX", 0), Z.orientationY.value = U(J, "orientationY", 0), Z.orientationZ.value = U(J, "orientationZ", -1), Z.refDistance = U(J, "refDistance", 1), Z.maxDistance = U(J, "maxDistance", 1e4), Z.rolloffFactor = U(J, "rolloffFactor", 1), Z.coneInnerAngle = U(J, "coneInnerAngle", 360), Z.coneOuterAngle = U(J, "coneOuterAngle", 0), Z.coneOuterGain = U(J, "coneOuterGain", 0), this.spatialSource = U(J, "follow", null), !this.spatialSource)
              Z.positionX.value = U(J, "x", 0), Z.positionY.value = U(J, "y", 0), Z.positionZ.value = U(J, "z", 0);
          }
          E.prototype.applyConfig.call(this);
        }, x: { get: function() {
          if (this.spatialNode)
            return this.spatialNode.positionX;
          else
            return 0;
        }, set: function(J) {
          if (this.spatialNode)
            this.spatialNode.positionX.value = J;
        } }, y: { get: function() {
          if (this.spatialNode)
            return this.spatialNode.positionY;
          else
            return 0;
        }, set: function(J) {
          if (this.spatialNode)
            this.spatialNode.positionY.value = J;
        } }, update: function() {
          if (this.isPlaying && this.spatialSource) {
            var J = U(this.spatialSource, "x", null), Z = U(this.spatialSource, "y", null);
            if (J && J !== this._spatialx)
              this._spatialx = this.spatialNode.positionX.value = J;
            if (Z && Z !== this._spatialy)
              this._spatialy = this.spatialNode.positionY.value = Z;
          }
          if (this.hasEnded)
            E.prototype.stop.call(this), this.stopAndRemoveBufferSource(), this.emit(z.COMPLETE, this);
          else if (this.hasLooped)
            this.hasLooped = false, this.source = this.loopSource, this.loopSource = null, this.playTime = this.startTime = this.loopTime, this.rateUpdates.length = 0, this.rateUpdates.push({ time: 0, rate: this.totalRate }), this.createAndStartLoopBufferSource(), this.emit(z.LOOPED, this);
        }, destroy: function() {
          if (this.pendingRemove)
            return;
          if (E.prototype.destroy.call(this), this.audioBuffer = null, this.stopAndRemoveBufferSource(), this.muteNode.disconnect(), this.muteNode = null, this.volumeNode.disconnect(), this.volumeNode = null, this.pannerNode)
            this.pannerNode.disconnect(), this.pannerNode = null;
          if (this.spatialNode)
            this.spatialNode.disconnect(), this.spatialNode = null, this.spatialSource = null;
          this.rateUpdates.length = 0, this.rateUpdates = null;
        }, calculateRate: function() {
          E.prototype.calculateRate.call(this);
          var J = this.manager.context.currentTime;
          if (this.source && typeof this.totalRate === "number")
            this.source.playbackRate.setValueAtTime(this.totalRate, J);
          if (this.isPlaying) {
            if (this.rateUpdates.push({ time: Math.max(this.startTime, J) - this.playTime, rate: this.totalRate }), this.loopSource)
              this.stopAndRemoveLoopBufferSource(), this.createAndStartLoopBufferSource();
          }
        }, getCurrentTime: function() {
          var J = 0;
          for (var Z = 0;Z < this.rateUpdates.length; Z++) {
            var D = 0;
            if (Z < this.rateUpdates.length - 1)
              D = this.rateUpdates[Z + 1].time;
            else
              D = this.manager.context.currentTime - this.playTime;
            J += (D - this.rateUpdates[Z].time) * this.rateUpdates[Z].rate;
          }
          return J;
        }, getLoopTime: function() {
          var J = 0;
          for (var Z = 0;Z < this.rateUpdates.length - 1; Z++)
            J += (this.rateUpdates[Z + 1].time - this.rateUpdates[Z].time) * this.rateUpdates[Z].rate;
          var D = this.rateUpdates[this.rateUpdates.length - 1];
          return this.playTime + D.time + (this.duration - J) / D.rate;
        }, rate: { get: function() {
          return this.currentConfig.rate;
        }, set: function(J) {
          this.currentConfig.rate = J, this.calculateRate(), this.emit(z.RATE, this, J);
        } }, setRate: function(J) {
          return this.rate = J, this;
        }, detune: { get: function() {
          return this.currentConfig.detune;
        }, set: function(J) {
          this.currentConfig.detune = J, this.calculateRate(), this.emit(z.DETUNE, this, J);
        } }, setDetune: function(J) {
          return this.detune = J, this;
        }, mute: { get: function() {
          return this.muteNode.gain.value === 0;
        }, set: function(J) {
          this.currentConfig.mute = J, this.muteNode.gain.setValueAtTime(J ? 0 : 1, 0), this.emit(z.MUTE, this, J);
        } }, setMute: function(J) {
          return this.mute = J, this;
        }, volume: { get: function() {
          return this.volumeNode.gain.value;
        }, set: function(J) {
          this.currentConfig.volume = J, this.volumeNode.gain.setValueAtTime(J, 0), this.emit(z.VOLUME, this, J);
        } }, setVolume: function(J) {
          return this.volume = J, this;
        }, seek: { get: function() {
          if (this.isPlaying) {
            if (this.manager.context.currentTime < this.startTime)
              return this.startTime - this.playTime;
            return this.getCurrentTime();
          } else if (this.isPaused)
            return this.currentConfig.seek;
          else
            return 0;
        }, set: function(J) {
          if (this.manager.context.currentTime < this.startTime)
            return;
          if (this.isPlaying || this.isPaused) {
            if (J = Math.min(Math.max(0, J), this.duration), this.currentConfig.seek = J, this.isPlaying)
              this.stopAndRemoveBufferSource(), this.createAndStartBufferSource();
            this.emit(z.SEEK, this, J);
          }
        } }, setSeek: function(J) {
          return this.seek = J, this;
        }, loop: { get: function() {
          return this.currentConfig.loop;
        }, set: function(J) {
          if (this.currentConfig.loop = J, this.isPlaying) {
            if (this.stopAndRemoveLoopBufferSource(), J)
              this.createAndStartLoopBufferSource();
          }
          this.emit(z.LOOP, this, J);
        } }, setLoop: function(J) {
          return this.loop = J, this;
        }, pan: { get: function() {
          if (this.pannerNode)
            return this.pannerNode.pan.value;
          else
            return 0;
        }, set: function(J) {
          if (this.currentConfig.pan = J, this.pannerNode)
            this.pannerNode.pan.setValueAtTime(J, this.manager.context.currentTime);
          this.emit(z.PAN, this, J);
        } }, setPan: function(J) {
          return this.pan = J, this;
        } });
        M.exports = K;
      }, 57490: (M, B, $) => {
        var E = $(53134), L = $(85034), z = $(83419), U = $(14463), K = $(8443), J = $(71741), Z = $(95540), D = new z({ Extends: L, initialize: function Q(H) {
          if (this.context = this.createAudioContext(H), this.masterMuteNode = this.context.createGain(), this.masterVolumeNode = this.context.createGain(), this.masterMuteNode.connect(this.masterVolumeNode), this.masterVolumeNode.connect(this.context.destination), this.destination = this.masterMuteNode, this.locked = this.context.state === "suspended" && (("ontouchstart" in window) || ("onclick" in window)), L.call(this, H), this.locked && H.isBooted)
            this.unlock();
          else
            H.events.once(K.BOOT, this.unlock, this);
        }, createAudioContext: function(Q) {
          var H = Q.config.audio;
          if (H.context)
            return H.context.resume(), H.context;
          if (window.hasOwnProperty("AudioContext"))
            return new AudioContext;
          else if (window.hasOwnProperty("webkitAudioContext"))
            return new window.webkitAudioContext;
        }, setAudioContext: function(Q) {
          if (this.context)
            this.context.close();
          if (this.masterMuteNode)
            this.masterMuteNode.disconnect();
          if (this.masterVolumeNode)
            this.masterVolumeNode.disconnect();
          return this.context = Q, this.masterMuteNode = Q.createGain(), this.masterVolumeNode = Q.createGain(), this.masterMuteNode.connect(this.masterVolumeNode), this.masterVolumeNode.connect(Q.destination), this.destination = this.masterMuteNode, this;
        }, add: function(Q, H) {
          var N = new J(this, Q, H);
          return this.sounds.push(N), N;
        }, decodeAudio: function(Q, H) {
          var N;
          if (!Array.isArray(Q))
            N = [{ key: Q, data: H }];
          else
            N = Q;
          var W = this.game.cache.audio, R = N.length;
          for (var Y = 0;Y < N.length; Y++) {
            var I = N[Y], P = I.key, X = I.data;
            if (typeof X === "string")
              X = E(X);
            var G = function(A, F) {
              if (W.add(A, F), this.emit(U.DECODED, A), R--, R === 0)
                this.emit(U.DECODED_ALL);
            }.bind(this, P), V = function(A, F) {
              if (console.error("Error decoding audio: " + A + " - ", F ? F.message : ""), R--, R === 0)
                this.emit(U.DECODED_ALL);
            }.bind(this, P);
            this.context.decodeAudioData(X, G, V);
          }
        }, setListenerPosition: function(Q, H) {
          if (Q === undefined)
            Q = this.game.scale.width / 2;
          if (H === undefined)
            H = this.game.scale.height / 2;
          return this.listenerPosition.set(Q, H), this;
        }, unlock: function() {
          var Q = this, H = document.body, N = function W() {
            if (Q.context && H) {
              var R = H.removeEventListener.bind(H);
              Q.context.resume().then(function() {
                R("touchstart", W), R("touchend", W), R("click", W), R("keydown", W), Q.unlocked = true;
              }, function() {
                R("touchstart", W), R("touchend", W), R("click", W), R("keydown", W);
              });
            }
          };
          if (H)
            H.addEventListener("touchstart", N, false), H.addEventListener("touchend", N, false), H.addEventListener("click", N, false), H.addEventListener("keydown", N, false);
        }, onBlur: function() {
          if (!this.locked)
            this.context.suspend();
        }, onFocus: function() {
          var Q = this.context;
          if (Q && !this.locked && (Q.state === "suspended" || Q.state === "interrupted"))
            Q.resume();
        }, update: function(Q, H) {
          var N = this.context.listener;
          if (N && N.positionX !== undefined) {
            var W = Z(this.listenerPosition, "x", null), R = Z(this.listenerPosition, "y", null);
            if (W && W !== this._spatialx)
              this._spatialx = N.positionX.value = W;
            if (R && R !== this._spatialy)
              this._spatialy = N.positionY.value = R;
          }
          if (L.prototype.update.call(this, Q, H), !this.gameLostFocus)
            this.onFocus();
        }, destroy: function() {
          if (this.destination = null, this.masterVolumeNode.disconnect(), this.masterVolumeNode = null, this.masterMuteNode.disconnect(), this.masterMuteNode = null, this.game.config.audio.context)
            this.context.suspend();
          else {
            var Q = this;
            this.context.close().then(function() {
              Q.context = null;
            });
          }
          L.prototype.destroy.call(this);
        }, setMute: function(Q) {
          return this.mute = Q, this;
        }, mute: { get: function() {
          return this.masterMuteNode.gain.value === 0;
        }, set: function(Q) {
          this.masterMuteNode.gain.setValueAtTime(Q ? 0 : 1, 0), this.emit(U.GLOBAL_MUTE, this, Q);
        } }, setVolume: function(Q) {
          return this.volume = Q, this;
        }, volume: { get: function() {
          return this.masterVolumeNode.gain.value;
        }, set: function(Q) {
          this.masterVolumeNode.gain.setValueAtTime(Q, 0), this.emit(U.GLOBAL_VOLUME, this, Q);
        } } });
        M.exports = D;
      }, 73162: (M, B, $) => {
        var E = $(37105), L = $(83419), z = $(29747), U = $(19186), K = new L({ initialize: function J(Z) {
          this.parent = Z, this.list = [], this.position = 0, this.addCallback = z, this.removeCallback = z, this._sortKey = "";
        }, add: function(J, Z) {
          if (Z)
            return E.Add(this.list, J);
          else
            return E.Add(this.list, J, 0, this.addCallback, this);
        }, addAt: function(J, Z, D) {
          if (D)
            return E.AddAt(this.list, J, Z);
          else
            return E.AddAt(this.list, J, Z, 0, this.addCallback, this);
        }, getAt: function(J) {
          return this.list[J];
        }, getIndex: function(J) {
          return this.list.indexOf(J);
        }, sort: function(J, Z) {
          if (!J)
            return this;
          if (Z === undefined)
            Z = function(D, Q) {
              return D[J] - Q[J];
            };
          return U(this.list, Z), this;
        }, getByName: function(J) {
          return E.GetFirst(this.list, "name", J);
        }, getRandom: function(J, Z) {
          return E.GetRandom(this.list, J, Z);
        }, getFirst: function(J, Z, D, Q) {
          return E.GetFirst(this.list, J, Z, D, Q);
        }, getAll: function(J, Z, D, Q) {
          return E.GetAll(this.list, J, Z, D, Q);
        }, count: function(J, Z) {
          return E.CountAllMatching(this.list, J, Z);
        }, swap: function(J, Z) {
          E.Swap(this.list, J, Z);
        }, moveTo: function(J, Z) {
          return E.MoveTo(this.list, J, Z);
        }, moveAbove: function(J, Z) {
          return E.MoveAbove(this.list, J, Z);
        }, moveBelow: function(J, Z) {
          return E.MoveBelow(this.list, J, Z);
        }, remove: function(J, Z) {
          if (Z)
            return E.Remove(this.list, J);
          else
            return E.Remove(this.list, J, this.removeCallback, this);
        }, removeAt: function(J, Z) {
          if (Z)
            return E.RemoveAt(this.list, J);
          else
            return E.RemoveAt(this.list, J, this.removeCallback, this);
        }, removeBetween: function(J, Z, D) {
          if (D)
            return E.RemoveBetween(this.list, J, Z);
          else
            return E.RemoveBetween(this.list, J, Z, this.removeCallback, this);
        }, removeAll: function(J) {
          var Z = this.list.length;
          while (Z--)
            this.remove(this.list[Z], J);
          return this;
        }, bringToTop: function(J) {
          return E.BringToTop(this.list, J);
        }, sendToBack: function(J) {
          return E.SendToBack(this.list, J);
        }, moveUp: function(J) {
          return E.MoveUp(this.list, J), J;
        }, moveDown: function(J) {
          return E.MoveDown(this.list, J), J;
        }, reverse: function() {
          return this.list.reverse(), this;
        }, shuffle: function() {
          return E.Shuffle(this.list), this;
        }, replace: function(J, Z) {
          return E.Replace(this.list, J, Z);
        }, exists: function(J) {
          return this.list.indexOf(J) > -1;
        }, setAll: function(J, Z, D, Q) {
          return E.SetAll(this.list, J, Z, D, Q), this;
        }, each: function(J, Z) {
          var D = [null];
          for (var Q = 2;Q < arguments.length; Q++)
            D.push(arguments[Q]);
          for (Q = 0;Q < this.list.length; Q++)
            D[0] = this.list[Q], J.apply(Z, D);
        }, shutdown: function() {
          this.removeAll(), this.list = [];
        }, destroy: function() {
          this.removeAll(), this.parent = null, this.addCallback = null, this.removeCallback = null;
        }, length: { get: function() {
          return this.list.length;
        } }, first: { get: function() {
          if (this.position = 0, this.list.length > 0)
            return this.list[0];
          else
            return null;
        } }, last: { get: function() {
          if (this.list.length > 0)
            return this.position = this.list.length - 1, this.list[this.position];
          else
            return null;
        } }, next: { get: function() {
          if (this.position < this.list.length)
            return this.position++, this.list[this.position];
          else
            return null;
        } }, previous: { get: function() {
          if (this.position > 0)
            return this.position--, this.list[this.position];
          else
            return null;
        } } });
        M.exports = K;
      }, 90330: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U) {
          this.entries = {}, this.size = 0, this.setAll(U);
        }, setAll: function(z) {
          if (Array.isArray(z))
            for (var U = 0;U < z.length; U++)
              this.set(z[U][0], z[U][1]);
          return this;
        }, set: function(z, U) {
          if (!this.has(z))
            this.size++;
          return this.entries[z] = U, this;
        }, get: function(z) {
          if (this.has(z))
            return this.entries[z];
        }, getArray: function() {
          var z = [], U = this.entries;
          for (var K in U)
            z.push(U[K]);
          return z;
        }, has: function(z) {
          return this.entries.hasOwnProperty(z);
        }, delete: function(z) {
          if (this.has(z))
            delete this.entries[z], this.size--;
          return this;
        }, clear: function() {
          return Object.keys(this.entries).forEach(function(z) {
            delete this.entries[z];
          }, this), this.size = 0, this;
        }, keys: function() {
          return Object.keys(this.entries);
        }, values: function() {
          var z = [], U = this.entries;
          for (var K in U)
            z.push(U[K]);
          return z;
        }, dump: function() {
          var z = this.entries;
          console.group("Map");
          for (var U in z)
            console.log(U, z[U]);
          console.groupEnd();
        }, each: function(z) {
          var U = this.entries;
          for (var K in U)
            if (z(K, U[K]) === false)
              break;
          return this;
        }, contains: function(z) {
          var U = this.entries;
          for (var K in U)
            if (U[K] === z)
              return true;
          return false;
        }, merge: function(z, U) {
          if (U === undefined)
            U = false;
          var K = this.entries, J = z.entries;
          for (var Z in J)
            if (K.hasOwnProperty(Z) && U)
              K[Z] = J[Z];
            else
              this.set(Z, J[Z]);
          return this;
        } });
        M.exports = L;
      }, 25774: (M, B, $) => {
        var E = $(83419), L = $(50792), z = $(82348), U = new E({ Extends: L, initialize: function K() {
          L.call(this), this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0, this.checkQueue = false;
        }, isActive: function(K) {
          return this._active.indexOf(K) > -1;
        }, isPending: function(K) {
          return this._toProcess > 0 && this._pending.indexOf(K) > -1;
        }, isDestroying: function(K) {
          return this._destroy.indexOf(K) > -1;
        }, add: function(K) {
          if (this.checkQueue && (this.isActive(K) && !this.isDestroying(K)) || this.isPending(K))
            return K;
          return this._pending.push(K), this._toProcess++, K;
        }, remove: function(K) {
          if (this.isPending(K)) {
            var J = this._pending, Z = J.indexOf(K);
            if (Z !== -1)
              J.splice(Z, 1);
          } else if (this.isActive(K))
            this._destroy.push(K), this._toProcess++;
          return K;
        }, removeAll: function() {
          var K = this._active, J = this._destroy, Z = K.length;
          while (Z--)
            J.push(K[Z]), this._toProcess++;
          return this;
        }, update: function() {
          if (this._toProcess === 0)
            return this._active;
          var K = this._destroy, J = this._active, Z, D;
          for (Z = 0;Z < K.length; Z++) {
            D = K[Z];
            var Q = J.indexOf(D);
            if (Q !== -1)
              J.splice(Q, 1), this.emit(z.PROCESS_QUEUE_REMOVE, D);
          }
          K.length = 0, K = this._pending;
          for (Z = 0;Z < K.length; Z++)
            if (D = K[Z], !this.checkQueue || this.checkQueue && J.indexOf(D) === -1)
              J.push(D), this.emit(z.PROCESS_QUEUE_ADD, D);
          return K.length = 0, this._toProcess = 0, J;
        }, getActive: function() {
          return this._active;
        }, length: { get: function() {
          return this._active.length;
        } }, destroy: function() {
          this._toProcess = 0, this._pending = [], this._active = [], this._destroy = [];
        } });
        M.exports = U;
      }, 59542: (M, B, $) => {
        var E = $(43886);
        function L(X) {
          var G = [".left", ".top", ".right", ".bottom"];
          if (!(this instanceof L))
            return new L(X, G);
          this._maxEntries = Math.max(4, X || 9), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
        }
        L.prototype = { all: function() {
          return this._all(this.data, []);
        }, search: function(X) {
          var G = this.data, V = [], A = this.toBBox;
          if (!Y(X, G))
            return V;
          var F = [], j, T, C, v;
          while (G) {
            for (j = 0, T = G.children.length;j < T; j++)
              if (C = G.children[j], v = G.leaf ? A(C) : C, Y(X, v))
                if (G.leaf)
                  V.push(C);
                else if (R(X, v))
                  this._all(C, V);
                else
                  F.push(C);
            G = F.pop();
          }
          return V;
        }, collides: function(X) {
          var G = this.data, V = this.toBBox;
          if (!Y(X, G))
            return false;
          var A = [], F, j, T, C;
          while (G) {
            for (F = 0, j = G.children.length;F < j; F++)
              if (T = G.children[F], C = G.leaf ? V(T) : T, Y(X, C)) {
                if (G.leaf || R(X, C))
                  return true;
                A.push(T);
              }
            G = A.pop();
          }
          return false;
        }, load: function(X) {
          if (!(X && X.length))
            return this;
          if (X.length < this._minEntries) {
            for (var G = 0, V = X.length;G < V; G++)
              this.insert(X[G]);
            return this;
          }
          var A = this._build(X.slice(), 0, X.length - 1, 0);
          if (!this.data.children.length)
            this.data = A;
          else if (this.data.height === A.height)
            this._splitRoot(this.data, A);
          else {
            if (this.data.height < A.height) {
              var F = this.data;
              this.data = A, A = F;
            }
            this._insert(A, this.data.height - A.height - 1, true);
          }
          return this;
        }, insert: function(X) {
          if (X)
            this._insert(X, this.data.height - 1);
          return this;
        }, clear: function() {
          return this.data = I([]), this;
        }, remove: function(X, G) {
          if (!X)
            return this;
          var V = this.data, A = this.toBBox(X), F = [], j = [], T, C, v, O;
          while (V || F.length) {
            if (!V)
              V = F.pop(), C = F[F.length - 1], T = j.pop(), O = true;
            if (V.leaf) {
              if (v = z(X, V.children, G), v !== -1)
                return V.children.splice(v, 1), F.push(V), this._condense(F), this;
            }
            if (!O && !V.leaf && R(V, A))
              F.push(V), j.push(T), T = 0, C = V, V = V.children[0];
            else if (C)
              T++, V = C.children[T], O = false;
            else
              V = null;
          }
          return this;
        }, toBBox: function(X) {
          return X;
        }, compareMinX: Z, compareMinY: D, toJSON: function() {
          return this.data;
        }, fromJSON: function(X) {
          return this.data = X, this;
        }, _all: function(X, G) {
          var V = [];
          while (X) {
            if (X.leaf)
              G.push.apply(G, X.children);
            else
              V.push.apply(V, X.children);
            X = V.pop();
          }
          return G;
        }, _build: function(X, G, V, A) {
          var F = V - G + 1, j = this._maxEntries, T;
          if (F <= j)
            return T = I(X.slice(G, V + 1)), U(T, this.toBBox), T;
          if (!A)
            A = Math.ceil(Math.log(F) / Math.log(j)), j = Math.ceil(F / Math.pow(j, A - 1));
          T = I([]), T.leaf = false, T.height = A;
          var C = Math.ceil(F / j), v = C * Math.ceil(Math.sqrt(j)), O, q, w, g;
          P(X, G, V, v, this.compareMinX);
          for (O = G;O <= V; O += v) {
            w = Math.min(O + v - 1, V), P(X, O, w, C, this.compareMinY);
            for (q = O;q <= w; q += C)
              g = Math.min(q + C - 1, w), T.children.push(this._build(X, q, g, A - 1));
          }
          return U(T, this.toBBox), T;
        }, _chooseSubtree: function(X, G, V, A) {
          var F, j, T, C, v, O, q, w;
          while (true) {
            if (A.push(G), G.leaf || A.length - 1 === V)
              break;
            q = w = Infinity;
            for (F = 0, j = G.children.length;F < j; F++)
              if (T = G.children[F], v = Q(T), O = N(X, T) - v, O < w)
                w = O, q = v < q ? v : q, C = T;
              else if (O === w) {
                if (v < q)
                  q = v, C = T;
              }
            G = C || G.children[0];
          }
          return G;
        }, _insert: function(X, G, V) {
          var A = this.toBBox, F = V ? X : A(X), j = [], T = this._chooseSubtree(F, this.data, G, j);
          T.children.push(X), J(T, F);
          while (G >= 0)
            if (j[G].children.length > this._maxEntries)
              this._split(j, G), G--;
            else
              break;
          this._adjustParentBBoxes(F, j, G);
        }, _split: function(X, G) {
          var V = X[G], A = V.children.length, F = this._minEntries;
          this._chooseSplitAxis(V, F, A);
          var j = this._chooseSplitIndex(V, F, A), T = I(V.children.splice(j, V.children.length - j));
          if (T.height = V.height, T.leaf = V.leaf, U(V, this.toBBox), U(T, this.toBBox), G)
            X[G - 1].children.push(T);
          else
            this._splitRoot(V, T);
        }, _splitRoot: function(X, G) {
          this.data = I([X, G]), this.data.height = X.height + 1, this.data.leaf = false, U(this.data, this.toBBox);
        }, _chooseSplitIndex: function(X, G, V) {
          var A, F, j, T, C, v, O, q;
          v = O = Infinity;
          for (A = G;A <= V - G; A++)
            if (F = K(X, 0, A, this.toBBox), j = K(X, A, V, this.toBBox), T = W(F, j), C = Q(F) + Q(j), T < v)
              v = T, q = A, O = C < O ? C : O;
            else if (T === v) {
              if (C < O)
                O = C, q = A;
            }
          return q;
        }, _chooseSplitAxis: function(X, G, V) {
          var A = X.leaf ? this.compareMinX : Z, F = X.leaf ? this.compareMinY : D, j = this._allDistMargin(X, G, V, A), T = this._allDistMargin(X, G, V, F);
          if (j < T)
            X.children.sort(A);
        }, _allDistMargin: function(X, G, V, A) {
          X.children.sort(A);
          var F = this.toBBox, j = K(X, 0, G, F), T = K(X, V - G, V, F), C = H(j) + H(T), v, O;
          for (v = G;v < V - G; v++)
            O = X.children[v], J(j, X.leaf ? F(O) : O), C += H(j);
          for (v = V - G - 1;v >= G; v--)
            O = X.children[v], J(T, X.leaf ? F(O) : O), C += H(T);
          return C;
        }, _adjustParentBBoxes: function(X, G, V) {
          for (var A = V;A >= 0; A--)
            J(G[A], X);
        }, _condense: function(X) {
          for (var G = X.length - 1, V;G >= 0; G--)
            if (X[G].children.length === 0)
              if (G > 0)
                V = X[G - 1].children, V.splice(V.indexOf(X[G]), 1);
              else
                this.clear();
            else
              U(X[G], this.toBBox);
        }, compareMinX: function(X, G) {
          return X.left - G.left;
        }, compareMinY: function(X, G) {
          return X.top - G.top;
        }, toBBox: function(X) {
          return { minX: X.left, minY: X.top, maxX: X.right, maxY: X.bottom };
        } };
        function z(X, G, V) {
          if (!V)
            return G.indexOf(X);
          for (var A = 0;A < G.length; A++)
            if (V(X, G[A]))
              return A;
          return -1;
        }
        function U(X, G) {
          K(X, 0, X.children.length, G, X);
        }
        function K(X, G, V, A, F) {
          if (!F)
            F = I(null);
          F.minX = Infinity, F.minY = Infinity, F.maxX = (-Infinity), F.maxY = (-Infinity);
          for (var j = G, T;j < V; j++)
            T = X.children[j], J(F, X.leaf ? A(T) : T);
          return F;
        }
        function J(X, G) {
          return X.minX = Math.min(X.minX, G.minX), X.minY = Math.min(X.minY, G.minY), X.maxX = Math.max(X.maxX, G.maxX), X.maxY = Math.max(X.maxY, G.maxY), X;
        }
        function Z(X, G) {
          return X.minX - G.minX;
        }
        function D(X, G) {
          return X.minY - G.minY;
        }
        function Q(X) {
          return (X.maxX - X.minX) * (X.maxY - X.minY);
        }
        function H(X) {
          return X.maxX - X.minX + (X.maxY - X.minY);
        }
        function N(X, G) {
          return (Math.max(G.maxX, X.maxX) - Math.min(G.minX, X.minX)) * (Math.max(G.maxY, X.maxY) - Math.min(G.minY, X.minY));
        }
        function W(X, G) {
          var V = Math.max(X.minX, G.minX), A = Math.max(X.minY, G.minY), F = Math.min(X.maxX, G.maxX), j = Math.min(X.maxY, G.maxY);
          return Math.max(0, F - V) * Math.max(0, j - A);
        }
        function R(X, G) {
          return X.minX <= G.minX && X.minY <= G.minY && G.maxX <= X.maxX && G.maxY <= X.maxY;
        }
        function Y(X, G) {
          return G.minX <= X.maxX && G.minY <= X.maxY && G.maxX >= X.minX && G.maxY >= X.minY;
        }
        function I(X) {
          return { children: X, height: 1, leaf: true, minX: Infinity, minY: Infinity, maxX: (-Infinity), maxY: (-Infinity) };
        }
        function P(X, G, V, A, F) {
          var j = [G, V], T;
          while (j.length) {
            if (V = j.pop(), G = j.pop(), V - G <= A)
              continue;
            T = G + Math.ceil((V - G) / A / 2) * A, E(X, T, G, V, F), j.push(G, T, T, V);
          }
        }
        M.exports = L;
      }, 35072: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U) {
          if (this.entries = [], Array.isArray(U))
            for (var K = 0;K < U.length; K++)
              this.set(U[K]);
        }, set: function(z) {
          if (this.entries.indexOf(z) === -1)
            this.entries.push(z);
          return this;
        }, get: function(z, U) {
          for (var K = 0;K < this.entries.length; K++) {
            var J = this.entries[K];
            if (J[z] === U)
              return J;
          }
        }, getArray: function() {
          return this.entries.slice(0);
        }, delete: function(z) {
          var U = this.entries.indexOf(z);
          if (U > -1)
            this.entries.splice(U, 1);
          return this;
        }, dump: function() {
          console.group("Set");
          for (var z = 0;z < this.entries.length; z++) {
            var U = this.entries[z];
            console.log(U);
          }
          console.groupEnd();
        }, each: function(z, U) {
          var K, J = this.entries.slice(), Z = J.length;
          if (U) {
            for (K = 0;K < Z; K++)
              if (z.call(U, J[K], K) === false)
                break;
          } else
            for (K = 0;K < Z; K++)
              if (z(J[K], K) === false)
                break;
          return this;
        }, iterate: function(z, U) {
          var K, J = this.entries.length;
          if (U) {
            for (K = 0;K < J; K++)
              if (z.call(U, this.entries[K], K) === false)
                break;
          } else
            for (K = 0;K < J; K++)
              if (z(this.entries[K], K) === false)
                break;
          return this;
        }, iterateLocal: function(z) {
          var U, K = [];
          for (U = 1;U < arguments.length; U++)
            K.push(arguments[U]);
          var J = this.entries.length;
          for (U = 0;U < J; U++) {
            var Z = this.entries[U];
            Z[z].apply(Z, K);
          }
          return this;
        }, clear: function() {
          return this.entries.length = 0, this;
        }, contains: function(z) {
          return this.entries.indexOf(z) > -1;
        }, union: function(z) {
          var U = new L;
          return z.entries.forEach(function(K) {
            U.set(K);
          }), this.entries.forEach(function(K) {
            U.set(K);
          }), U;
        }, intersect: function(z) {
          var U = new L;
          return this.entries.forEach(function(K) {
            if (z.contains(K))
              U.set(K);
          }), U;
        }, difference: function(z) {
          var U = new L;
          return this.entries.forEach(function(K) {
            if (!z.contains(K))
              U.set(K);
          }), U;
        }, size: { get: function() {
          return this.entries.length;
        }, set: function(z) {
          if (z < this.entries.length)
            return this.entries.length = z;
          else
            return this.entries.length;
        } } });
        M.exports = L;
      }, 86555: (M, B, $) => {
        var E = $(45319), L = $(83419), z = $(56583), U = $(26099), K = new L({ initialize: function J(Z, D, Q, H) {
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = Z;
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = null;
          this._width = Z, this._height = D, this._parent = H, this.aspectMode = Q, this.aspectRatio = D === 0 ? 1 : Z / D, this.minWidth = 0, this.minHeight = 0, this.maxWidth = Number.MAX_VALUE, this.maxHeight = Number.MAX_VALUE, this.snapTo = new U;
        }, setAspectMode: function(J) {
          if (J === undefined)
            J = 0;
          return this.aspectMode = J, this.setSize(this._width, this._height);
        }, setSnap: function(J, Z) {
          if (J === undefined)
            J = 0;
          if (Z === undefined)
            Z = J;
          return this.snapTo.set(J, Z), this.setSize(this._width, this._height);
        }, setParent: function(J) {
          return this._parent = J, this.setSize(this._width, this._height);
        }, setMin: function(J, Z) {
          if (J === undefined)
            J = 0;
          if (Z === undefined)
            Z = J;
          return this.minWidth = E(J, 0, this.maxWidth), this.minHeight = E(Z, 0, this.maxHeight), this.setSize(this._width, this._height);
        }, setMax: function(J, Z) {
          if (J === undefined)
            J = Number.MAX_VALUE;
          if (Z === undefined)
            Z = J;
          return this.maxWidth = E(J, this.minWidth, Number.MAX_VALUE), this.maxHeight = E(Z, this.minHeight, Number.MAX_VALUE), this.setSize(this._width, this._height);
        }, setSize: function(J, Z) {
          if (J === undefined)
            J = 0;
          if (Z === undefined)
            Z = J;
          switch (this.aspectMode) {
            case K.NONE:
              this._width = this.getNewWidth(z(J, this.snapTo.x)), this._height = this.getNewHeight(z(Z, this.snapTo.y)), this.aspectRatio = this._height === 0 ? 1 : this._width / this._height;
              break;
            case K.WIDTH_CONTROLS_HEIGHT:
              this._width = this.getNewWidth(z(J, this.snapTo.x)), this._height = this.getNewHeight(this._width * (1 / this.aspectRatio), false);
              break;
            case K.HEIGHT_CONTROLS_WIDTH:
              this._height = this.getNewHeight(z(Z, this.snapTo.y)), this._width = this.getNewWidth(this._height * this.aspectRatio, false);
              break;
            case K.FIT:
              this.constrain(J, Z, true);
              break;
            case K.ENVELOP:
              this.constrain(J, Z, false);
              break;
          }
          return this;
        }, setAspectRatio: function(J) {
          return this.aspectRatio = J, this.setSize(this._width, this._height);
        }, resize: function(J, Z) {
          return this._width = this.getNewWidth(z(J, this.snapTo.x)), this._height = this.getNewHeight(z(Z, this.snapTo.y)), this.aspectRatio = this._height === 0 ? 1 : this._width / this._height, this;
        }, getNewWidth: function(J, Z) {
          if (Z === undefined)
            Z = true;
          if (J = E(J, this.minWidth, this.maxWidth), Z && this._parent && J > this._parent.width)
            J = Math.max(this.minWidth, this._parent.width);
          return J;
        }, getNewHeight: function(J, Z) {
          if (Z === undefined)
            Z = true;
          if (J = E(J, this.minHeight, this.maxHeight), Z && this._parent && J > this._parent.height)
            J = Math.max(this.minHeight, this._parent.height);
          return J;
        }, constrain: function(J, Z, D) {
          if (J === undefined)
            J = 0;
          if (Z === undefined)
            Z = J;
          if (D === undefined)
            D = true;
          J = this.getNewWidth(J), Z = this.getNewHeight(Z);
          var Q = this.snapTo, H = Z === 0 ? 1 : J / Z;
          if (D && this.aspectRatio > H || !D && this.aspectRatio < H) {
            if (J = z(J, Q.x), Z = J / this.aspectRatio, Q.y > 0)
              Z = z(Z, Q.y), J = Z * this.aspectRatio;
          } else if (D && this.aspectRatio < H || !D && this.aspectRatio > H) {
            if (Z = z(Z, Q.y), J = Z * this.aspectRatio, Q.x > 0)
              J = z(J, Q.x), Z = J * (1 / this.aspectRatio);
          }
          return this._width = J, this._height = Z, this;
        }, fitTo: function(J, Z) {
          return this.constrain(J, Z, true);
        }, envelop: function(J, Z) {
          return this.constrain(J, Z, false);
        }, setWidth: function(J) {
          return this.setSize(J, this._height);
        }, setHeight: function(J) {
          return this.setSize(this._width, J);
        }, toString: function() {
          return "[{ Size (width=" + this._width + " height=" + this._height + " aspectRatio=" + this.aspectRatio + " aspectMode=" + this.aspectMode + ") }]";
        }, setCSS: function(J) {
          if (J && J.style)
            J.style.width = this._width + "px", J.style.height = this._height + "px";
        }, copy: function(J) {
          return J.setAspectMode(this.aspectMode), J.aspectRatio = this.aspectRatio, J.setSize(this.width, this.height);
        }, destroy: function() {
          this._parent = null, this.snapTo = null;
        }, width: { get: function() {
          return this._width;
        }, set: function(J) {
          this.setSize(J, this._height);
        } }, height: { get: function() {
          return this._height;
        }, set: function(J) {
          this.setSize(this._width, J);
        } } });
        K.NONE = 0, K.WIDTH_CONTROLS_HEIGHT = 1, K.HEIGHT_CONTROLS_WIDTH = 2, K.FIT = 3, K.ENVELOP = 4, M.exports = K;
      }, 15238: (M) => {
        M.exports = "add";
      }, 56187: (M) => {
        M.exports = "remove";
      }, 82348: (M, B, $) => {
        M.exports = { PROCESS_QUEUE_ADD: $(15238), PROCESS_QUEUE_REMOVE: $(56187) };
      }, 41392: (M, B, $) => {
        M.exports = { Events: $(82348), List: $(73162), Map: $(90330), ProcessQueue: $(25774), RTree: $(59542), Set: $(35072), Size: $(86555) };
      }, 57382: (M, B, $) => {
        var E = $(83419), L = $(45319), z = $(40987), U = $(8054), K = $(50030), J = $(79237), Z = new E({ Extends: J, initialize: function D(Q, H, N, W, R) {
          if (J.call(this, Q, H, N, W, R), this.add("__BASE", 0, 0, 0, W, R), this._source = this.frames.__BASE.source, this.canvas = this._source.image, this.context = this.canvas.getContext("2d", { willReadFrequently: true }), this.width = W, this.height = R, this.imageData = this.context.getImageData(0, 0, W, R), this.data = null, this.imageData)
            this.data = this.imageData.data;
          if (this.pixels = null, this.buffer, this.data)
            if (this.imageData.data.buffer)
              this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer);
            else if (window.ArrayBuffer)
              this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer);
            else
              this.pixels = this.imageData.data;
        }, update: function() {
          if (this.imageData = this.context.getImageData(0, 0, this.width, this.height), this.data = this.imageData.data, this.imageData.data.buffer)
            this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer);
          else if (window.ArrayBuffer)
            this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer);
          else
            this.pixels = this.imageData.data;
          if (this.manager.game.config.renderType === U.WEBGL)
            this.refresh();
          return this;
        }, draw: function(D, Q, H, N) {
          if (N === undefined)
            N = true;
          if (this.context.drawImage(H, D, Q), N)
            this.update();
          return this;
        }, drawFrame: function(D, Q, H, N, W) {
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = true;
          var R = this.manager.getFrame(D, Q);
          if (R) {
            var { canvasData: Y, cutWidth: I, cutHeight: P } = R, X = R.source.resolution;
            if (this.context.drawImage(R.source.image, Y.x, Y.y, I, P, H, N, I / X, P / X), W)
              this.update();
          }
          return this;
        }, setPixel: function(D, Q, H, N, W, R) {
          if (R === undefined)
            R = 255;
          D = Math.abs(Math.floor(D)), Q = Math.abs(Math.floor(Q));
          var Y = this.getIndex(D, Q);
          if (Y > -1) {
            var I = this.context.getImageData(D, Q, 1, 1);
            I.data[0] = H, I.data[1] = N, I.data[2] = W, I.data[3] = R, this.context.putImageData(I, D, Q);
          }
          return this;
        }, putData: function(D, Q, H, N, W, R, Y) {
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = 0;
          if (R === undefined)
            R = D.width;
          if (Y === undefined)
            Y = D.height;
          return this.context.putImageData(D, Q, H, N, W, R, Y), this;
        }, getData: function(D, Q, H, N) {
          D = L(Math.floor(D), 0, this.width - 1), Q = L(Math.floor(Q), 0, this.height - 1), H = L(H, 1, this.width - D), N = L(N, 1, this.height - Q);
          var W = this.context.getImageData(D, Q, H, N);
          return W;
        }, getPixel: function(D, Q, H) {
          if (!H)
            H = new z;
          var N = this.getIndex(D, Q);
          if (N > -1) {
            var W = this.data, R = W[N + 0], Y = W[N + 1], I = W[N + 2], P = W[N + 3];
            H.setTo(R, Y, I, P);
          }
          return H;
        }, getPixels: function(D, Q, H, N) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = this.width;
          if (N === undefined)
            N = H;
          D = Math.abs(Math.round(D)), Q = Math.abs(Math.round(Q));
          var W = L(D, 0, this.width), R = L(D + H, 0, this.width), Y = L(Q, 0, this.height), I = L(Q + N, 0, this.height), P = new z, X = [];
          for (var G = Y;G < I; G++) {
            var V = [];
            for (var A = W;A < R; A++)
              P = this.getPixel(A, G, P), V.push({ x: A, y: G, color: P.color, alpha: P.alphaGL });
            X.push(V);
          }
          return X;
        }, getIndex: function(D, Q) {
          if (D = Math.abs(Math.round(D)), Q = Math.abs(Math.round(Q)), D < this.width && Q < this.height)
            return (D + Q * this.width) * 4;
          else
            return -1;
        }, refresh: function() {
          return this._source.update(), this;
        }, getCanvas: function() {
          return this.canvas;
        }, getContext: function() {
          return this.context;
        }, clear: function(D, Q, H, N, W) {
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = this.width;
          if (N === undefined)
            N = this.height;
          if (W === undefined)
            W = true;
          if (this.context.clearRect(D, Q, H, N), W)
            this.update();
          return this;
        }, setSize: function(D, Q) {
          if (Q === undefined)
            Q = D;
          if (D !== this.width || Q !== this.height)
            this.canvas.width = D, this.canvas.height = Q, this._source.width = D, this._source.height = Q, this._source.isPowerOf2 = K(D, Q), this.frames.__BASE.setSize(D, Q, 0, 0), this.width = D, this.height = Q, this.refresh();
          return this;
        }, destroy: function() {
          J.prototype.destroy.call(this), this._source = null, this.canvas = null, this.context = null, this.imageData = null, this.data = null, this.pixels = null, this.buffer = null;
        } });
        M.exports = Z;
      }, 81320: (M, B, $) => {
        var E = $(10312), L = $(71911), z = $(27919), U = $(83419), K = $(8054), J = $(4327), Z = $(95540), D = $(36060), Q = $(32302), H = $(79237), N = $(70554), W = new U({ Extends: H, initialize: function R(Y, I, P, X) {
          if (P === undefined)
            P = 256;
          if (X === undefined)
            X = 256;
          this.type = "DynamicTexture";
          var G = Y.game.renderer, V = G && G.type === K.CANVAS, A = V ? z.create2D(this, P, X) : [this];
          H.call(this, Y, I, A, P, X), this.add("__BASE", 0, 0, 0, P, X), this.renderer = G, this.width = -1, this.height = -1, this.isDrawing = false, this.canvas = V ? A : null, this.context = V ? A.getContext("2d", { willReadFrequently: true }) : null, this.dirty = false, this.isSpriteTexture = true, this._eraseMode = false, this.camera = new L(0, 0, P, X).setScene(Y.game.scene.systemScene, false), this.renderTarget = !V ? new Q(G, P, X, 1, 0, false, true, true, false) : null, this.pipeline = !V ? G.pipelines.get(D.SINGLE_PIPELINE) : null, this.setSize(P, X);
        }, setSize: function(R, Y) {
          if (Y === undefined)
            Y = R;
          var I = this.get(), P = I.source;
          if (R !== this.width || Y !== this.height) {
            if (this.canvas)
              this.canvas.width = R, this.canvas.height = Y;
            var X = this.renderTarget;
            if (X) {
              if (X.willResize(R, Y))
                X.resize(R, Y);
              if (X.texture !== P.glTexture)
                this.renderer.deleteTexture(P.glTexture);
              this.setFromRenderTarget();
            }
            this.camera.setSize(R, Y), P.width = R, P.height = Y, I.setSize(R, Y), this.width = R, this.height = Y;
          } else {
            var G = this.getSourceImage();
            if (I.cutX + R > G.width)
              R = G.width - I.cutX;
            if (I.cutY + Y > G.height)
              Y = G.height - I.cutY;
            I.setSize(R, Y, I.cutX, I.cutY);
          }
          return this;
        }, setFromRenderTarget: function() {
          var R = this.get(), Y = R.source, I = this.renderTarget;
          return Y.isRenderTexture = true, Y.isGLTexture = true, Y.glTexture = I.texture, this;
        }, setIsSpriteTexture: function(R) {
          return this.isSpriteTexture = R, this;
        }, fill: function(R, Y, I, P, X, G) {
          var V = this.camera, A = this.renderer;
          if (Y === undefined)
            Y = 1;
          if (I === undefined)
            I = 0;
          if (P === undefined)
            P = 0;
          if (X === undefined)
            X = this.width;
          if (G === undefined)
            G = this.height;
          var F = R >> 16 & 255, j = R >> 8 & 255, T = R & 255, C = this.renderTarget;
          if (V.preRender(), C) {
            C.bind(true);
            var v = this.pipeline.manager.set(this.pipeline), O = A.width / C.width, q = A.height / C.height, w = C.height - (P + G);
            v.drawFillRect(I * O, w * q, X * O, G * q, N.getTintFromFloats(T / 255, j / 255, F / 255, 1), Y), C.unbind(true);
          } else {
            var g = this.context;
            A.setContext(g), g.globalCompositeOperation = "source-over", g.fillStyle = "rgba(" + F + "," + j + "," + T + "," + Y + ")", g.fillRect(I, P, X, G), A.setContext();
          }
          return this.dirty = true, this;
        }, clear: function() {
          if (this.dirty) {
            var R = this.context, Y = this.renderTarget;
            if (Y)
              Y.clear();
            else if (R)
              R.save(), R.setTransform(1, 0, 0, 1, 0, 0), R.clearRect(0, 0, this.width, this.height), R.restore();
            this.dirty = false;
          }
          return this;
        }, stamp: function(R, Y, I, P, X) {
          if (I === undefined)
            I = 0;
          if (P === undefined)
            P = 0;
          var G = Z(X, "alpha", 1), V = Z(X, "tint", 16777215), A = Z(X, "angle", 0), F = Z(X, "rotation", 0), j = Z(X, "scale", 1), T = Z(X, "scaleX", j), C = Z(X, "scaleY", j), v = Z(X, "originX", 0.5), O = Z(X, "originY", 0.5), q = Z(X, "blendMode", 0), w = Z(X, "erase", false), g = Z(X, "skipBatch", false), b = this.manager.resetStamp(G, V);
          if (b.setAngle(0), A !== 0)
            b.setAngle(A);
          else if (F !== 0)
            b.setRotation(F);
          if (b.setScale(T, C), b.setTexture(R, Y), b.setOrigin(v, O), b.setBlendMode(q), w)
            this._eraseMode = true;
          if (!g)
            this.draw(b, I, P);
          else
            this.batchGameObject(b, I, P);
          if (w)
            this._eraseMode = false;
          return this;
        }, erase: function(R, Y, I) {
          return this._eraseMode = true, this.draw(R, Y, I), this._eraseMode = false, this;
        }, draw: function(R, Y, I, P, X) {
          return this.beginDraw(), this.batchDraw(R, Y, I, P, X), this.endDraw(), this;
        }, drawFrame: function(R, Y, I, P, X, G) {
          return this.beginDraw(), this.batchDrawFrame(R, Y, I, P, X, G), this.endDraw(), this;
        }, repeat: function(R, Y, I, P, X, G, V, A, F) {
          if (I === undefined)
            I = 0;
          if (P === undefined)
            P = 0;
          if (X === undefined)
            X = this.width;
          if (G === undefined)
            G = this.height;
          if (V === undefined)
            V = 1;
          if (A === undefined)
            A = 16777215;
          if (F === undefined)
            F = false;
          if (R instanceof J)
            Y = R;
          else
            Y = this.manager.getFrame(R, Y);
          if (!Y)
            return this;
          var j = this.manager.resetStamp(V, A);
          j.setFrame(Y), j.setOrigin(0);
          var { width: T, height: C } = Y;
          X = Math.floor(X), G = Math.floor(G);
          var v = Math.ceil(X / T), O = Math.ceil(G / C), q = v * T - X, w = O * C - G;
          if (q > 0)
            q = T - q;
          if (w > 0)
            w = C - w;
          if (I < 0)
            v += Math.ceil(Math.abs(I) / T);
          if (P < 0)
            O += Math.ceil(Math.abs(P) / C);
          var g = I, b = P, x = false, k = this.manager.stampCrop.setTo(0, 0, T, C);
          if (!F)
            this.beginDraw();
          for (var S = 0;S < O; S++) {
            if (b + C < 0) {
              b += C;
              continue;
            }
            for (var f = 0;f < v; f++) {
              if (x = false, g + T < 0) {
                g += T;
                continue;
              } else if (g < 0)
                x = true, k.width = T + g, k.x = T - k.width;
              if (b < 0)
                x = true, k.height = C + b, k.y = C - k.height;
              if (q > 0 && f === v - 1)
                x = true, k.width = q;
              if (w > 0 && S === O - 1)
                x = true, k.height = w;
              if (x)
                j.setCrop(k);
              this.batchGameObject(j, g, b), j.isCropped = false, k.setTo(0, 0, T, C), g += T;
            }
            g = I, b += C;
          }
          if (!F)
            this.endDraw();
          return this;
        }, beginDraw: function() {
          if (!this.isDrawing) {
            var R = this.camera, Y = this.renderer, I = this.renderTarget;
            if (R.preRender(), I)
              Y.beginCapture(I.width, I.height);
            else
              Y.setContext(this.context);
            this.isDrawing = true;
          }
          return this;
        }, batchDraw: function(R, Y, I, P, X) {
          if (!Array.isArray(R))
            R = [R];
          return this.batchList(R, Y, I, P, X), this;
        }, batchDrawFrame: function(R, Y, I, P, X, G) {
          if (I === undefined)
            I = 0;
          if (P === undefined)
            P = 0;
          if (X === undefined)
            X = 1;
          if (G === undefined)
            G = 16777215;
          var V = this.manager.getFrame(R, Y);
          if (V)
            if (this.renderTarget)
              this.pipeline.batchTextureFrame(V, I, P, G, X, this.camera.matrix, null);
            else
              this.batchTextureFrame(V, I, P, X, G);
          return this;
        }, endDraw: function(R) {
          if (R === undefined)
            R = this._eraseMode;
          if (this.isDrawing) {
            var Y = this.renderer, I = this.renderTarget;
            if (I) {
              var P = Y.endCapture(), X = Y.pipelines.setUtility();
              X.blitFrame(P, I, 1, false, false, R, this.isSpriteTexture), Y.resetScissor(), Y.resetViewport();
            } else
              Y.setContext();
            this.dirty = true, this.isDrawing = false;
          }
          return this;
        }, batchList: function(R, Y, I, P, X) {
          var G = R.length;
          if (G === 0)
            return;
          for (var V = 0;V < G; V++) {
            var A = R[V];
            if (!A || A === this)
              continue;
            if (A.renderWebGL || A.renderCanvas)
              this.batchGameObject(A, Y, I);
            else if (A.isParent || A.list)
              this.batchGroup(A.getChildren(), Y, I);
            else if (typeof A === "string")
              this.batchTextureFrameKey(A, null, Y, I, P, X);
            else if (A instanceof J)
              this.batchTextureFrame(A, Y, I, P, X);
            else if (Array.isArray(A))
              this.batchList(A, Y, I, P, X);
          }
        }, batchGroup: function(R, Y, I) {
          if (Y === undefined)
            Y = 0;
          if (I === undefined)
            I = 0;
          for (var P = 0;P < R.length; P++) {
            var X = R[P];
            if (X.willRender(this.camera))
              this.batchGameObject(X, X.x + Y, X.y + I);
          }
        }, batchGameObject: function(R, Y, I) {
          if (Y === undefined)
            Y = R.x;
          if (I === undefined)
            I = R.y;
          var { x: P, y: X } = R, G = this.camera, V = this.renderer, A = this._eraseMode, F = R.mask;
          if (R.setPosition(Y, I), this.canvas) {
            if (A) {
              var j = R.blendMode;
              R.blendMode = E.ERASE;
            }
            if (F)
              F.preRenderCanvas(V, R, G);
            if (R.renderCanvas(V, R, G, null), F)
              F.postRenderCanvas(V, R, G);
            if (A)
              R.blendMode = j;
          } else if (V) {
            if (F)
              F.preRenderWebGL(V, R, G);
            if (!A)
              V.setBlendMode(R.blendMode);
            if (R.renderWebGL(V, R, G), F)
              F.postRenderWebGL(V, G, this.renderTarget);
          }
          R.setPosition(P, X);
        }, batchTextureFrameKey: function(R, Y, I, P, X, G) {
          var V = this.manager.getFrame(R, Y);
          if (V)
            this.batchTextureFrame(V, I, P, X, G);
        }, batchTextureFrame: function(R, Y, I, P, X) {
          if (Y === undefined)
            Y = 0;
          if (I === undefined)
            I = 0;
          if (P === undefined)
            P = 1;
          if (X === undefined)
            X = 16777215;
          var G = this.camera.matrix, V = this.renderTarget;
          if (V)
            this.pipeline.batchTextureFrame(R, Y, I, X, P, G, null);
          else {
            var A = this.context, F = R.canvasData, j = R.source.image;
            if (A.save(), A.globalCompositeOperation = this._eraseMode ? "destination-out" : "source-over", A.globalAlpha = P, G.setToContext(A), F.width > 0 && F.height > 0)
              A.drawImage(j, F.x, F.y, F.width, F.height, Y, I, F.width, F.height);
            A.restore();
          }
        }, snapshotArea: function(R, Y, I, P, X, G, V) {
          if (this.renderTarget)
            this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, X, false, R, Y, I, P, G, V);
          else
            this.renderer.snapshotCanvas(this.canvas, X, false, R, Y, I, P, G, V);
          return this;
        }, snapshot: function(R, Y, I) {
          return this.snapshotArea(0, 0, this.width, this.height, R, Y, I);
        }, snapshotPixel: function(R, Y, I) {
          return this.snapshotArea(R, Y, 1, 1, I, "pixel");
        }, getWebGLTexture: function() {
          if (this.renderTarget)
            return this.renderTarget.texture;
        }, renderWebGL: function(R, Y, I, P) {
          var X = this.manager.resetStamp();
          X.setTexture(this), X.setOrigin(0), X.renderWebGL(R, X, I, P);
        }, renderCanvas: function() {
        }, destroy: function() {
          var R = this.manager.stamp;
          if (R && R.texture === this)
            this.manager.resetStamp();
          if (H.prototype.destroy.call(this), z.remove(this.canvas), this.renderTarget)
            this.renderTarget.destroy();
          this.camera.destroy(), this.canvas = null, this.context = null, this.renderer = null;
        } });
        M.exports = W;
      }, 4327: (M, B, $) => {
        var E = $(83419), L = $(45319), z = $(79291), U = new E({ initialize: function K(J, Z, D, Q, H, N, W) {
          this.texture = J, this.name = Z, this.source = J.source[D], this.sourceIndex = D, this.cutX, this.cutY, this.cutWidth, this.cutHeight, this.x = 0, this.y = 0, this.width, this.height, this.halfWidth, this.halfHeight, this.centerX, this.centerY, this.pivotX = 0, this.pivotY = 0, this.customPivot = false, this.rotated = false, this.autoRound = -1, this.customData = {}, this.u0 = 0, this.v0 = 0, this.u1 = 0, this.v1 = 0, this.data = { cut: { x: 0, y: 0, w: 0, h: 0, r: 0, b: 0 }, trim: false, sourceSize: { w: 0, h: 0 }, spriteSourceSize: { x: 0, y: 0, w: 0, h: 0, r: 0, b: 0 }, radius: 0, drawImage: { x: 0, y: 0, width: 0, height: 0 }, is3Slice: false, scale9: false, scale9Borders: { x: 0, y: 0, w: 0, h: 0 } }, this.setSize(N, W, Q, H);
        }, setSize: function(K, J, Z, D) {
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = 0;
          this.cutX = Z, this.cutY = D, this.cutWidth = K, this.cutHeight = J, this.width = K, this.height = J, this.halfWidth = Math.floor(K * 0.5), this.halfHeight = Math.floor(J * 0.5), this.centerX = Math.floor(K / 2), this.centerY = Math.floor(J / 2);
          var Q = this.data, H = Q.cut;
          H.x = Z, H.y = D, H.w = K, H.h = J, H.r = Z + K, H.b = D + J, Q.sourceSize.w = K, Q.sourceSize.h = J, Q.spriteSourceSize.w = K, Q.spriteSourceSize.h = J, Q.radius = 0.5 * Math.sqrt(K * K + J * J);
          var N = Q.drawImage;
          return N.x = Z, N.y = D, N.width = K, N.height = J, this.updateUVs();
        }, setTrim: function(K, J, Z, D, Q, H) {
          var N = this.data, W = N.spriteSourceSize;
          return N.trim = true, N.sourceSize.w = K, N.sourceSize.h = J, W.x = Z, W.y = D, W.w = Q, W.h = H, W.r = Z + Q, W.b = D + H, this.x = Z, this.y = D, this.width = Q, this.height = H, this.halfWidth = Q * 0.5, this.halfHeight = H * 0.5, this.centerX = Math.floor(Q / 2), this.centerY = Math.floor(H / 2), this.updateUVs();
        }, setScale9: function(K, J, Z, D) {
          var Q = this.data;
          return Q.scale9 = true, Q.is3Slice = J === 0 && D === this.height, Q.scale9Borders.x = K, Q.scale9Borders.y = J, Q.scale9Borders.w = Z, Q.scale9Borders.h = D, this;
        }, setCropUVs: function(K, J, Z, D, Q, H, N) {
          var W = this.cutX, R = this.cutY, Y = this.cutWidth, I = this.cutHeight, P = this.realWidth, X = this.realHeight;
          J = L(J, 0, P), Z = L(Z, 0, X), D = L(D, 0, P - J), Q = L(Q, 0, X - Z);
          var G = W + J, V = R + Z, A = D, F = Q, j = this.data;
          if (j.trim) {
            var T = j.spriteSourceSize;
            D = L(D, 0, Y - J), Q = L(Q, 0, I - Z);
            var C = J + D, v = Z + Q, O = !(T.r < J || T.b < Z || T.x > C || T.y > v);
            if (O) {
              var q = Math.max(T.x, J), w = Math.max(T.y, Z), g = Math.min(T.r, C) - q, b = Math.min(T.b, v) - w;
              if (A = g, F = b, H)
                G = W + (Y - (q - T.x) - g);
              else
                G = W + (q - T.x);
              if (N)
                V = R + (I - (w - T.y) - b);
              else
                V = R + (w - T.y);
              J = q, Z = w, D = g, Q = b;
            } else
              G = 0, V = 0, A = 0, F = 0;
          } else {
            if (H)
              G = W + (Y - J - D);
            if (N)
              V = R + (I - Z - Q);
          }
          var x = this.source.width, k = this.source.height;
          return K.u0 = Math.max(0, G / x), K.v0 = Math.max(0, V / k), K.u1 = Math.min(1, (G + A) / x), K.v1 = Math.min(1, (V + F) / k), K.x = J, K.y = Z, K.cx = G, K.cy = V, K.cw = A, K.ch = F, K.width = D, K.height = Q, K.flipX = H, K.flipY = N, K;
        }, updateCropUVs: function(K, J, Z) {
          return this.setCropUVs(K, K.x, K.y, K.width, K.height, J, Z);
        }, setUVs: function(K, J, Z, D, Q, H) {
          var N = this.data.drawImage;
          return N.width = K, N.height = J, this.u0 = Z, this.v0 = D, this.u1 = Q, this.v1 = H, this;
        }, updateUVs: function() {
          var K = this.cutX, J = this.cutY, Z = this.cutWidth, D = this.cutHeight, Q = this.data.drawImage;
          Q.width = Z, Q.height = D;
          var H = this.source.width, N = this.source.height;
          return this.u0 = K / H, this.v0 = J / N, this.u1 = (K + Z) / H, this.v1 = (J + D) / N, this;
        }, updateUVsInverted: function() {
          var K = this.source.width, J = this.source.height;
          return this.u0 = (this.cutX + this.cutHeight) / K, this.v0 = this.cutY / J, this.u1 = this.cutX / K, this.v1 = (this.cutY + this.cutWidth) / J, this;
        }, clone: function() {
          var K = new U(this.texture, this.name, this.sourceIndex);
          return K.cutX = this.cutX, K.cutY = this.cutY, K.cutWidth = this.cutWidth, K.cutHeight = this.cutHeight, K.x = this.x, K.y = this.y, K.width = this.width, K.height = this.height, K.halfWidth = this.halfWidth, K.halfHeight = this.halfHeight, K.centerX = this.centerX, K.centerY = this.centerY, K.rotated = this.rotated, K.data = z(true, K.data, this.data), K.updateUVs(), K;
        }, destroy: function() {
          this.texture = null, this.source = null, this.customData = null, this.data = null;
        }, glTexture: { get: function() {
          return this.source.glTexture;
        } }, realWidth: { get: function() {
          return this.data.sourceSize.w;
        } }, realHeight: { get: function() {
          return this.data.sourceSize.h;
        } }, radius: { get: function() {
          return this.data.radius;
        } }, trimmed: { get: function() {
          return this.data.trim;
        } }, scale9: { get: function() {
          return this.data.scale9;
        } }, is3Slice: { get: function() {
          return this.data.is3Slice;
        } }, canvasData: { get: function() {
          return this.data.drawImage;
        } } });
        M.exports = U;
      }, 79237: (M, B, $) => {
        var E = $(83419), L = $(4327), z = $(11876), U = 'Texture "%s" has no frame "%s"', K = new E({ initialize: function J(Z, D, Q, H, N) {
          if (!Array.isArray(Q))
            Q = [Q];
          this.manager = Z, this.key = D, this.source = [], this.dataSource = [], this.frames = {}, this.customData = {}, this.firstFrame = "__BASE", this.frameTotal = 0;
          for (var W = 0;W < Q.length; W++)
            this.source.push(new z(this, Q[W], H, N));
        }, add: function(J, Z, D, Q, H, N) {
          if (this.has(J))
            return null;
          var W = new L(this, J, Z, D, Q, H, N);
          if (this.frames[J] = W, this.firstFrame === "__BASE")
            this.firstFrame = J;
          return this.frameTotal++, W;
        }, remove: function(J) {
          if (this.has(J)) {
            var Z = this.get(J);
            return Z.destroy(), delete this.frames[J], true;
          }
          return false;
        }, has: function(J) {
          return this.frames.hasOwnProperty(J);
        }, get: function(J) {
          if (!J)
            J = this.firstFrame;
          var Z = this.frames[J];
          if (!Z)
            console.warn(U, this.key, J), Z = this.frames[this.firstFrame];
          return Z;
        }, getTextureSourceIndex: function(J) {
          for (var Z = 0;Z < this.source.length; Z++)
            if (this.source[Z] === J)
              return Z;
          return -1;
        }, getFramesFromTextureSource: function(J, Z) {
          if (Z === undefined)
            Z = false;
          var D = [];
          for (var Q in this.frames) {
            if (Q === "__BASE" && !Z)
              continue;
            var H = this.frames[Q];
            if (H.sourceIndex === J)
              D.push(H);
          }
          return D;
        }, getFrameBounds: function(J) {
          if (J === undefined)
            J = 0;
          var Z = this.getFramesFromTextureSource(J), D = Infinity, Q = Infinity, H = 0, N = 0;
          for (var W = 0;W < Z.length; W++) {
            var R = Z[W];
            if (R.cutX < D)
              D = R.cutX;
            if (R.cutY < Q)
              Q = R.cutY;
            if (R.cutX + R.cutWidth > H)
              H = R.cutX + R.cutWidth;
            if (R.cutY + R.cutHeight > N)
              N = R.cutY + R.cutHeight;
          }
          return { x: D, y: Q, width: H - D, height: N - Q };
        }, getFrameNames: function(J) {
          if (J === undefined)
            J = false;
          var Z = Object.keys(this.frames);
          if (!J) {
            var D = Z.indexOf("__BASE");
            if (D !== -1)
              Z.splice(D, 1);
          }
          return Z;
        }, getSourceImage: function(J) {
          if (J === undefined || J === null || this.frameTotal === 1)
            J = "__BASE";
          var Z = this.frames[J];
          if (Z)
            return Z.source.image;
          else
            return console.warn(U, this.key, J), this.frames.__BASE.source.image;
        }, getDataSourceImage: function(J) {
          if (J === undefined || J === null || this.frameTotal === 1)
            J = "__BASE";
          var Z = this.frames[J], D;
          if (!Z)
            console.warn(U, this.key, J), D = this.frames.__BASE.sourceIndex;
          else
            D = Z.sourceIndex;
          return this.dataSource[D].image;
        }, setDataSource: function(J) {
          if (!Array.isArray(J))
            J = [J];
          for (var Z = 0;Z < J.length; Z++) {
            var D = this.source[Z];
            this.dataSource.push(new z(this, J[Z], D.width, D.height));
          }
        }, setFilter: function(J) {
          var Z;
          for (Z = 0;Z < this.source.length; Z++)
            this.source[Z].setFilter(J);
          for (Z = 0;Z < this.dataSource.length; Z++)
            this.dataSource[Z].setFilter(J);
        }, destroy: function() {
          var J, Z = this.source, D = this.dataSource;
          for (J = 0;J < Z.length; J++)
            if (Z[J])
              Z[J].destroy();
          for (J = 0;J < D.length; J++)
            if (D[J])
              D[J].destroy();
          for (var Q in this.frames) {
            var H = this.frames[Q];
            if (H)
              H.destroy();
          }
          this.source = [], this.dataSource = [], this.frames = {}, this.manager.removeKey(this.key), this.manager = null;
        } });
        M.exports = K;
      }, 17130: (M, B, $) => {
        var E = $(27919), L = $(57382), z = $(83419), U = $(40987), K = $(8054), J = $(81320), Z = $(50792), D = $(69442), Q = $(4327), H = $(8443), N = $(99584), W = $(35154), R = $(88571), Y = $(41212), I = $(61309), P = $(87841), X = $(79237), G = new z({ Extends: Z, initialize: function V(A) {
          Z.call(this), this.game = A, this.name = "TextureManager", this.list = {}, this._tempCanvas = E.create2D(this), this._tempContext = this._tempCanvas.getContext("2d", { willReadFrequently: true }), this._pending = 0, this.stamp, this.stampCrop = new P, this.silentWarnings = false, A.events.once(H.BOOT, this.boot, this);
        }, boot: function() {
          this._pending = 3, this.on(D.LOAD, this.updatePending, this), this.on(D.ERROR, this.updatePending, this);
          var V = this.game.config;
          if (this.addBase64("__DEFAULT", V.defaultImage), this.addBase64("__MISSING", V.missingImage), this.addBase64("__WHITE", V.whiteImage), this.game.renderer && this.game.renderer.gl)
            this.addUint8Array("__NORMAL", new Uint8Array([127, 127, 255, 255]), 1, 1);
          this.game.events.once(H.DESTROY, this.destroy, this), this.game.events.once(H.SYSTEM_READY, function(A) {
            this.stamp = new R(A).setOrigin(0);
          }, this);
        }, updatePending: function() {
          if (this._pending--, this._pending === 0)
            this.off(D.LOAD), this.off(D.ERROR), this.emit(D.READY);
        }, checkKey: function(V) {
          if (this.exists(V)) {
            if (!this.silentWarnings)
              console.error("Texture key already in use: " + V);
            return false;
          }
          return true;
        }, remove: function(V) {
          if (typeof V === "string")
            if (this.exists(V))
              V = this.get(V);
            else {
              if (!this.silentWarnings)
                console.warn("No texture found matching key: " + V);
              return this;
            }
          var A = V.key;
          if (this.list.hasOwnProperty(A))
            V.destroy(), this.emit(D.REMOVE, A), this.emit(D.REMOVE_KEY + A);
          return this;
        }, removeKey: function(V) {
          if (this.list.hasOwnProperty(V))
            delete this.list[V];
          return this;
        }, addBase64: function(V, A) {
          if (this.checkKey(V)) {
            var F = this, j = new Image;
            j.onerror = function() {
              F.emit(D.ERROR, V);
            }, j.onload = function() {
              var T = F.create(V, j);
              I.Image(T, 0), F.emit(D.ADD, V, T), F.emit(D.ADD_KEY + V, T), F.emit(D.LOAD, V, T);
            }, j.src = A;
          }
          return this;
        }, getBase64: function(V, A, F, j) {
          if (F === undefined)
            F = "image/png";
          if (j === undefined)
            j = 0.92;
          var T = "", C = this.getFrame(V, A);
          if (C && (C.source.isRenderTexture || C.source.isGLTexture)) {
            if (!this.silentWarnings)
              console.warn("Cannot getBase64 from WebGL Texture");
          } else if (C) {
            var v = C.canvasData, O = E.create2D(this, v.width, v.height), q = O.getContext("2d", { willReadFrequently: true });
            if (v.width > 0 && v.height > 0)
              q.drawImage(C.source.image, v.x, v.y, v.width, v.height, 0, 0, v.width, v.height);
            T = O.toDataURL(F, j), E.remove(O);
          }
          return T;
        }, addImage: function(V, A, F) {
          var j = null;
          if (this.checkKey(V)) {
            if (j = this.create(V, A), I.Image(j, 0), F)
              j.setDataSource(F);
            this.emit(D.ADD, V, j), this.emit(D.ADD_KEY + V, j);
          }
          return j;
        }, addGLTexture: function(V, A) {
          var F = null;
          if (this.checkKey(V)) {
            var { width: j, height: T } = A;
            F = this.create(V, A, j, T), F.add("__BASE", 0, 0, 0, j, T), this.emit(D.ADD, V, F), this.emit(D.ADD_KEY + V, F);
          }
          return F;
        }, addCompressedTexture: function(V, A, F) {
          var j = null;
          if (this.checkKey(V)) {
            if (j = this.create(V, A), j.add("__BASE", 0, 0, 0, A.width, A.height), F) {
              var T = function(v, O, q) {
                if (Array.isArray(q.textures) || Array.isArray(q.frames))
                  I.JSONArray(v, O, q);
                else
                  I.JSONHash(v, O, q);
              };
              if (Array.isArray(F))
                for (var C = 0;C < F.length; C++)
                  T(j, C, F[C]);
              else
                T(j, 0, F);
            }
            this.emit(D.ADD, V, j), this.emit(D.ADD_KEY + V, j);
          }
          return j;
        }, addRenderTexture: function(V, A) {
          var F = null;
          if (this.checkKey(V))
            F = this.create(V, A), F.add("__BASE", 0, 0, 0, A.width, A.height), this.emit(D.ADD, V, F), this.emit(D.ADD_KEY + V, F);
          return F;
        }, generate: function(V, A) {
          if (this.checkKey(V)) {
            var F = E.create(this, 1, 1);
            return A.canvas = F, N(A), this.addCanvas(V, F);
          } else
            return null;
        }, createCanvas: function(V, A, F) {
          if (A === undefined)
            A = 256;
          if (F === undefined)
            F = 256;
          if (this.checkKey(V)) {
            var j = E.create(this, A, F, K.CANVAS, true);
            return this.addCanvas(V, j);
          }
          return null;
        }, addCanvas: function(V, A, F) {
          if (F === undefined)
            F = false;
          var j = null;
          if (F)
            j = new L(this, V, A, A.width, A.height);
          else if (this.checkKey(V))
            j = new L(this, V, A, A.width, A.height), this.list[V] = j, this.emit(D.ADD, V, j), this.emit(D.ADD_KEY + V, j);
          return j;
        }, addDynamicTexture: function(V, A, F) {
          var j = null;
          if (typeof V === "string" && !this.exists(V))
            j = new J(this, V, A, F);
          else
            j = V, V = j.key;
          if (this.checkKey(V))
            this.list[V] = j, this.emit(D.ADD, V, j), this.emit(D.ADD_KEY + V, j);
          else
            j = null;
          return j;
        }, addAtlas: function(V, A, F, j) {
          if (Array.isArray(F.textures) || Array.isArray(F.frames))
            return this.addAtlasJSONArray(V, A, F, j);
          else
            return this.addAtlasJSONHash(V, A, F, j);
        }, addAtlasJSONArray: function(V, A, F, j) {
          var T = null;
          if (A instanceof X)
            V = A.key, T = A;
          else if (this.checkKey(V))
            T = this.create(V, A);
          if (T) {
            if (Array.isArray(F)) {
              var C = F.length === 1;
              for (var v = 0;v < T.source.length; v++) {
                var O = C ? F[0] : F[v];
                I.JSONArray(T, v, O);
              }
            } else
              I.JSONArray(T, 0, F);
            if (j)
              T.setDataSource(j);
            this.emit(D.ADD, V, T), this.emit(D.ADD_KEY + V, T);
          }
          return T;
        }, addAtlasJSONHash: function(V, A, F, j) {
          var T = null;
          if (A instanceof X)
            V = A.key, T = A;
          else if (this.checkKey(V))
            T = this.create(V, A);
          if (T) {
            if (Array.isArray(F))
              for (var C = 0;C < F.length; C++)
                I.JSONHash(T, C, F[C]);
            else
              I.JSONHash(T, 0, F);
            if (j)
              T.setDataSource(j);
            this.emit(D.ADD, V, T), this.emit(D.ADD_KEY + V, T);
          }
          return T;
        }, addAtlasXML: function(V, A, F, j) {
          var T = null;
          if (A instanceof X)
            V = A.key, T = A;
          else if (this.checkKey(V))
            T = this.create(V, A);
          if (T) {
            if (I.AtlasXML(T, 0, F), j)
              T.setDataSource(j);
            this.emit(D.ADD, V, T), this.emit(D.ADD_KEY + V, T);
          }
          return T;
        }, addUnityAtlas: function(V, A, F, j) {
          var T = null;
          if (A instanceof X)
            V = A.key, T = A;
          else if (this.checkKey(V))
            T = this.create(V, A);
          if (T) {
            if (I.UnityYAML(T, 0, F), j)
              T.setDataSource(j);
            this.emit(D.ADD, V, T), this.emit(D.ADD_KEY + V, T);
          }
          return T;
        }, addSpriteSheet: function(V, A, F, j) {
          var T = null;
          if (A instanceof X)
            V = A.key, T = A;
          else if (this.checkKey(V))
            T = this.create(V, A);
          if (T) {
            var C = T.source[0].width, v = T.source[0].height;
            if (I.SpriteSheet(T, 0, 0, 0, C, v, F), j)
              T.setDataSource(j);
            this.emit(D.ADD, V, T), this.emit(D.ADD_KEY + V, T);
          }
          return T;
        }, addSpriteSheetFromAtlas: function(V, A) {
          if (!this.checkKey(V))
            return null;
          var F = W(A, "atlas", null), j = W(A, "frame", null);
          if (!F || !j)
            return;
          var T = this.get(F), C = T.get(j);
          if (C) {
            var v = C.source.image;
            if (!v)
              v = C.source.glTexture;
            var O = this.create(V, v);
            if (C.trimmed)
              I.SpriteSheetFromAtlas(O, C, A);
            else
              I.SpriteSheet(O, 0, C.cutX, C.cutY, C.cutWidth, C.cutHeight, A);
            return this.emit(D.ADD, V, O), this.emit(D.ADD_KEY + V, O), O;
          }
        }, addUint8Array: function(V, A, F, j) {
          if (!this.checkKey(V) || A.length / 4 !== F * j)
            return null;
          var T = this.create(V, A, F, j);
          return T.add("__BASE", 0, 0, 0, F, j), this.emit(D.ADD, V, T), this.emit(D.ADD_KEY + V, T), T;
        }, create: function(V, A, F, j) {
          var T = null;
          if (this.checkKey(V))
            T = new X(this, V, A, F, j), this.list[V] = T;
          return T;
        }, exists: function(V) {
          return this.list.hasOwnProperty(V);
        }, get: function(V) {
          if (V === undefined)
            V = "__DEFAULT";
          if (this.list[V])
            return this.list[V];
          else if (V instanceof X)
            return V;
          else if (V instanceof Q)
            return V.texture;
          else
            return this.list.__MISSING;
        }, cloneFrame: function(V, A) {
          if (this.list[V])
            return this.list[V].get(A).clone();
        }, getFrame: function(V, A) {
          if (this.list[V])
            return this.list[V].get(A);
        }, parseFrame: function(V) {
          if (!V)
            return;
          else if (typeof V === "string")
            return this.getFrame(V);
          else if (Array.isArray(V) && V.length === 2)
            return this.getFrame(V[0], V[1]);
          else if (Y(V))
            return this.getFrame(V.key, V.frame);
          else if (V instanceof X)
            return V.get();
          else if (V instanceof Q)
            return V;
        }, getTextureKeys: function() {
          var V = [];
          for (var A in this.list)
            if (A !== "__DEFAULT" && A !== "__MISSING" && A !== "__WHITE" && A !== "__NORMAL")
              V.push(A);
          return V;
        }, getPixel: function(V, A, F, j) {
          var T = this.getFrame(F, j);
          if (T) {
            V -= T.x, A -= T.y;
            var C = T.data.cut;
            if (V += C.x, A += C.y, V >= C.x && V < C.r && A >= C.y && A < C.b) {
              var v = this._tempContext;
              v.clearRect(0, 0, 1, 1), v.drawImage(T.source.image, V, A, 1, 1, 0, 0, 1, 1);
              var O = v.getImageData(0, 0, 1, 1);
              return new U(O.data[0], O.data[1], O.data[2], O.data[3]);
            }
          }
          return null;
        }, getPixelAlpha: function(V, A, F, j) {
          var T = this.getFrame(F, j);
          if (T) {
            V -= T.x, A -= T.y;
            var C = T.data.cut;
            if (V += C.x, A += C.y, V >= C.x && V < C.r && A >= C.y && A < C.b) {
              var v = this._tempContext;
              v.clearRect(0, 0, 1, 1), v.drawImage(T.source.image, V, A, 1, 1, 0, 0, 1, 1);
              var O = v.getImageData(0, 0, 1, 1);
              return O.data[3];
            }
          }
          return null;
        }, setTexture: function(V, A, F) {
          if (this.list[A])
            V.texture = this.list[A], V.frame = V.texture.get(F);
          return V;
        }, renameTexture: function(V, A) {
          var F = this.get(V);
          if (F && V !== A)
            return F.key = A, this.list[A] = F, delete this.list[V], true;
          return false;
        }, each: function(V, A) {
          var F = [null];
          for (var j = 1;j < arguments.length; j++)
            F.push(arguments[j]);
          for (var T in this.list)
            F[0] = this.list[T], V.apply(A, F);
        }, resetStamp: function(V, A) {
          if (V === undefined)
            V = 1;
          if (A === undefined)
            A = 16777215;
          var F = this.stamp;
          return F.setCrop(), F.setPosition(0), F.setAngle(0), F.setScale(1), F.setAlpha(V), F.setTint(A), F.setTexture("__WHITE"), F;
        }, destroy: function() {
          for (var V in this.list)
            this.list[V].destroy();
          this.list = {}, this.stamp.destroy(), this.game = null, this.stamp = null, E.remove(this._tempCanvas);
        } });
        M.exports = G;
      }, 11876: (M, B, $) => {
        var E = $(27919), L = $(83419), z = $(50030), U = $(29795), K = $(82751), J = new L({ initialize: function Z(D, Q, H, N, W) {
          if (W === undefined)
            W = false;
          var R = D.manager.game;
          this.renderer = R.renderer, this.texture = D, this.source = Q, this.image = Q.compressed ? null : Q, this.compressionAlgorithm = Q.compressed ? Q.format : null, this.resolution = 1, this.width = H || Q.naturalWidth || Q.videoWidth || Q.width || 0, this.height = N || Q.naturalHeight || Q.videoHeight || Q.height || 0, this.scaleMode = U.DEFAULT, this.isCanvas = Q instanceof HTMLCanvasElement, this.isVideo = window.hasOwnProperty("HTMLVideoElement") && Q instanceof HTMLVideoElement, this.isRenderTexture = Q.type === "RenderTexture" || Q.type === "DynamicTexture", this.isGLTexture = Q instanceof K, this.isPowerOf2 = z(this.width, this.height), this.glTexture = null, this.flipY = W, this.init(R);
        }, init: function(Z) {
          var D = this.renderer;
          if (D) {
            var Q = this.source;
            if (D.gl) {
              var H = this.image, N = this.flipY, W = this.width, R = this.height, Y = this.scaleMode;
              if (this.isCanvas)
                this.glTexture = D.createCanvasTexture(H, false, N);
              else if (this.isVideo)
                this.glTexture = D.createVideoTexture(H, false, N);
              else if (this.isRenderTexture)
                this.glTexture = D.createTextureFromSource(null, W, R, Y);
              else if (this.isGLTexture)
                this.glTexture = Q;
              else if (this.compressionAlgorithm)
                this.glTexture = D.createTextureFromSource(Q, undefined, undefined, Y);
              else if (Q instanceof Uint8Array)
                this.glTexture = D.createUint8ArrayTexture(Q, W, R, Y);
              else
                this.glTexture = D.createTextureFromSource(H, W, R, Y);
            } else if (this.isRenderTexture)
              this.image = Q.canvas;
          }
          if (!Z.config.antialias)
            this.setFilter(1);
        }, setFilter: function(Z) {
          if (this.renderer && this.renderer.gl)
            this.renderer.setTextureFilter(this.glTexture, Z);
          this.scaleMode = Z;
        }, setFlipY: function(Z) {
          if (Z === undefined)
            Z = true;
          if (Z === this.flipY)
            return this;
          return this.flipY = Z, this.update(), this;
        }, update: function() {
          var Z = this.renderer, D = this.image, Q = this.flipY, H = Z.gl;
          if (H && this.isCanvas)
            Z.updateCanvasTexture(D, this.glTexture, Q);
          else if (H && this.isVideo)
            Z.updateVideoTexture(D, this.glTexture, Q);
        }, destroy: function() {
          if (this.glTexture)
            this.renderer.deleteTexture(this.glTexture);
          if (this.isCanvas)
            E.remove(this.image);
          this.renderer = null, this.texture = null, this.source = null, this.image = null, this.glTexture = null;
        } });
        M.exports = J;
      }, 19673: (M) => {
        var B = { LINEAR: 0, NEAREST: 1 };
        M.exports = B;
      }, 44538: (M) => {
        M.exports = "addtexture";
      }, 63486: (M) => {
        M.exports = "addtexture-";
      }, 94851: (M) => {
        M.exports = "onerror";
      }, 29099: (M) => {
        M.exports = "onload";
      }, 8678: (M) => {
        M.exports = "ready";
      }, 86415: (M) => {
        M.exports = "removetexture";
      }, 30879: (M) => {
        M.exports = "removetexture-";
      }, 69442: (M, B, $) => {
        M.exports = { ADD: $(44538), ADD_KEY: $(63486), ERROR: $(94851), LOAD: $(29099), READY: $(8678), REMOVE: $(86415), REMOVE_KEY: $(30879) };
      }, 27458: (M, B, $) => {
        var E = $(79291), L = $(19673), z = { CanvasTexture: $(57382), DynamicTexture: $(81320), Events: $(69442), FilterMode: L, Frame: $(4327), Parsers: $(61309), Texture: $(79237), TextureManager: $(17130), TextureSource: $(11876) };
        z = E(false, z, L), M.exports = z;
      }, 89905: (M) => {
        var B = function($, E, L) {
          if (!L.getElementsByTagName("TextureAtlas")) {
            console.warn("Invalid Texture Atlas XML given");
            return;
          }
          var z = $.source[E];
          $.add("__BASE", E, 0, 0, z.width, z.height);
          var U = L.getElementsByTagName("SubTexture"), K;
          for (var J = 0;J < U.length; J++) {
            var Z = U[J].attributes, D = Z.name.value, Q = parseInt(Z.x.value, 10), H = parseInt(Z.y.value, 10), N = parseInt(Z.width.value, 10), W = parseInt(Z.height.value, 10);
            if (K = $.add(D, E, Q, H, N, W), Z.frameX) {
              var R = Math.abs(parseInt(Z.frameX.value, 10)), Y = Math.abs(parseInt(Z.frameY.value, 10)), I = parseInt(Z.frameWidth.value, 10), P = parseInt(Z.frameHeight.value, 10);
              K.setTrim(N, W, R, Y, I, P);
            }
          }
          return $;
        };
        M.exports = B;
      }, 72893: (M) => {
        var B = function($, E) {
          var L = $.source[E];
          return $.add("__BASE", E, 0, 0, L.width, L.height), $;
        };
        M.exports = B;
      }, 4832: (M) => {
        var B = function($, E) {
          var L = $.source[E];
          return $.add("__BASE", E, 0, 0, L.width, L.height), $;
        };
        M.exports = B;
      }, 78566: (M, B, $) => {
        var E = $(41786), L = function(z, U, K) {
          if (!K.frames && !K.textures) {
            console.warn("Invalid Texture Atlas JSON Array");
            return;
          }
          var J = z.source[U];
          z.add("__BASE", U, 0, 0, J.width, J.height);
          var Z = Array.isArray(K.textures) ? K.textures[U].frames : K.frames, D;
          for (var Q = 0;Q < Z.length; Q++) {
            var H = Z[Q];
            if (D = z.add(H.filename, U, H.frame.x, H.frame.y, H.frame.w, H.frame.h), !D) {
              console.warn("Invalid atlas json, frame already exists: " + H.filename);
              continue;
            }
            if (H.trimmed)
              D.setTrim(H.sourceSize.w, H.sourceSize.h, H.spriteSourceSize.x, H.spriteSourceSize.y, H.spriteSourceSize.w, H.spriteSourceSize.h);
            if (H.rotated)
              D.rotated = true, D.updateUVsInverted();
            var N = H.anchor || H.pivot;
            if (N)
              D.customPivot = true, D.pivotX = N.x, D.pivotY = N.y;
            if (H.scale9Borders)
              D.setScale9(H.scale9Borders.x, H.scale9Borders.y, H.scale9Borders.w, H.scale9Borders.h);
            D.customData = E(H);
          }
          for (var W in K) {
            if (W === "frames")
              continue;
            if (Array.isArray(K[W]))
              z.customData[W] = K[W].slice(0);
            else
              z.customData[W] = K[W];
          }
          return z;
        };
        M.exports = L;
      }, 39711: (M, B, $) => {
        var E = $(41786), L = function(z, U, K) {
          if (!K.frames) {
            console.warn("Invalid Texture Atlas JSON Hash given, missing \'frames\' Object");
            return;
          }
          var J = z.source[U];
          z.add("__BASE", U, 0, 0, J.width, J.height);
          var Z = K.frames, D;
          for (var Q in Z) {
            if (!Z.hasOwnProperty(Q))
              continue;
            var H = Z[Q];
            if (D = z.add(Q, U, H.frame.x, H.frame.y, H.frame.w, H.frame.h), !D) {
              console.warn("Invalid atlas json, frame already exists: " + Q);
              continue;
            }
            if (H.trimmed)
              D.setTrim(H.sourceSize.w, H.sourceSize.h, H.spriteSourceSize.x, H.spriteSourceSize.y, H.spriteSourceSize.w, H.spriteSourceSize.h);
            if (H.rotated)
              D.rotated = true, D.updateUVsInverted();
            var N = H.anchor || H.pivot;
            if (N)
              D.customPivot = true, D.pivotX = N.x, D.pivotY = N.y;
            if (H.scale9Borders)
              D.setScale9(H.scale9Borders.x, H.scale9Borders.y, H.scale9Borders.w, H.scale9Borders.h);
            D.customData = E(H);
          }
          for (var W in K) {
            if (W === "frames")
              continue;
            if (Array.isArray(K[W]))
              z.customData[W] = K[W].slice(0);
            else
              z.customData[W] = K[W];
          }
          return z;
        };
        M.exports = L;
      }, 31403: (M) => {
        var B = function($) {
          var E = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], L, z = new Uint8Array($, 0, 12);
          for (L = 0;L < z.length; L++)
            if (z[L] !== E[L]) {
              console.warn("KTXParser - Invalid file format");
              return;
            }
          var U = Uint32Array.BYTES_PER_ELEMENT, K = new DataView($, 12, 13 * U), J = K.getUint32(0, true) === 67305985, Z = K.getUint32(1 * U, J);
          if (Z !== 0) {
            console.warn("KTXParser - Only compressed formats supported");
            return;
          }
          var D = K.getUint32(4 * U, J), Q = K.getUint32(6 * U, J), H = K.getUint32(7 * U, J), N = Math.max(1, K.getUint32(11 * U, J)), W = K.getUint32(12 * U, J), R = new Array(N), Y = 64 + W, I = Q, P = H;
          for (L = 0;L < N; L++) {
            var X = new Int32Array($, Y, 1)[0];
            Y += 4, R[L] = { data: new Uint8Array($, Y, X), width: I, height: P }, I = Math.max(1, I >> 1), P = Math.max(1, P >> 1), Y += X;
          }
          return { mipmaps: R, width: Q, height: H, internalFormat: D, compressed: true, generateMipmap: false };
        };
        M.exports = B;
      }, 82038: (M) => {
        function B(A, F, j, T, C, v, O) {
          if (O === undefined)
            O = 16;
          return Math.floor((A + j) / C) * Math.floor((F + T) / v) * O;
        }
        function $(A, F) {
          return A = Math.max(A, 16), F = Math.max(F, 8), A * F / 4;
        }
        function E(A, F) {
          return A = Math.max(A, 8), F = Math.max(F, 8), A * F / 2;
        }
        function L(A, F) {
          return Math.ceil(A / 4) * Math.ceil(F / 4) * 16;
        }
        function z(A, F) {
          return B(A, F, 3, 3, 4, 4, 8);
        }
        function U(A, F) {
          return B(A, F, 3, 3, 4, 4);
        }
        function K(A, F) {
          return B(A, F, 4, 3, 5, 4);
        }
        function J(A, F) {
          return B(A, F, 4, 4, 5, 5);
        }
        function Z(A, F) {
          return B(A, F, 5, 4, 6, 5);
        }
        function D(A, F) {
          return B(A, F, 5, 5, 6, 6);
        }
        function Q(A, F) {
          return B(A, F, 7, 4, 8, 5);
        }
        function H(A, F) {
          return B(A, F, 7, 5, 8, 6);
        }
        function N(A, F) {
          return B(A, F, 7, 7, 8, 8);
        }
        function W(A, F) {
          return B(A, F, 9, 4, 10, 5);
        }
        function R(A, F) {
          return B(A, F, 9, 5, 10, 6);
        }
        function Y(A, F) {
          return B(A, F, 9, 7, 10, 8);
        }
        function I(A, F) {
          return B(A, F, 9, 9, 10, 10);
        }
        function P(A, F) {
          return B(A, F, 11, 9, 12, 10);
        }
        function X(A, F) {
          return B(A, F, 11, 11, 12, 12);
        }
        var G = { 0: { sizeFunc: $, glFormat: [35841] }, 1: { sizeFunc: $, glFormat: [35843] }, 2: { sizeFunc: E, glFormat: [35840] }, 3: { sizeFunc: E, glFormat: [35842] }, 6: { sizeFunc: z, glFormat: [36196] }, 7: { sizeFunc: z, glFormat: [33776, 35916] }, 8: { sizeFunc: U, glFormat: [33777, 35917] }, 9: { sizeFunc: U, glFormat: [33778, 35918] }, 11: { sizeFunc: U, glFormat: [33779, 35919] }, 14: { sizeFunc: L, glFormat: [36494, 36495] }, 15: { sizeFunc: L, glFormat: [36492, 36493] }, 22: { sizeFunc: z, glFormat: [37492, 37493] }, 23: { sizeFunc: U, glFormat: [37496, 37497] }, 24: { sizeFunc: z, glFormat: [37494, 37495] }, 25: { sizeFunc: z, glFormat: [37488] }, 26: { sizeFunc: U, glFormat: [37490] }, 27: { sizeFunc: U, glFormat: [37808, 37840] }, 28: { sizeFunc: K, glFormat: [37809, 37841] }, 29: { sizeFunc: J, glFormat: [37810, 37842] }, 30: { sizeFunc: Z, glFormat: [37811, 37843] }, 31: { sizeFunc: D, glFormat: [37812, 37844] }, 32: { sizeFunc: Q, glFormat: [37813, 37845] }, 33: { sizeFunc: H, glFormat: [37814, 37846] }, 34: { sizeFunc: N, glFormat: [37815, 37847] }, 35: { sizeFunc: W, glFormat: [37816, 37848] }, 36: { sizeFunc: R, glFormat: [37817, 37849] }, 37: { sizeFunc: Y, glFormat: [37818, 37850] }, 38: { sizeFunc: I, glFormat: [37819, 37851] }, 39: { sizeFunc: P, glFormat: [37820, 37852] }, 40: { sizeFunc: X, glFormat: [37821, 37853] } }, V = function(A) {
          var F = new Uint32Array(A, 0, 13), j = F[0], T = j === 55727696, C = T ? F[2] : F[3], v = F[4], O = G[C].glFormat[v], q = G[C].sizeFunc, w = F[11], g = F[7], b = F[6], x = 52 + F[12], k = new Uint8Array(A, x), S = new Array(w), f = 0, h = g, m = b;
          for (var y = 0;y < w; y++) {
            var d = q(h, m);
            S[y] = { data: new Uint8Array(k.buffer, k.byteOffset + f, d), width: h, height: m }, h = Math.max(1, h >> 1), m = Math.max(1, m >> 1), f += d;
          }
          return { mipmaps: S, width: g, height: b, internalFormat: O, compressed: true, generateMipmap: false };
        };
        M.exports = V;
      }, 75549: (M, B, $) => {
        var E = $(95540), L = function(z, U, K, J, Z, D, Q) {
          var H = E(Q, "frameWidth", null), N = E(Q, "frameHeight", H);
          if (H === null)
            throw new Error("TextureManager.SpriteSheet: Invalid frameWidth given.");
          var W = z.source[U];
          z.add("__BASE", U, 0, 0, W.width, W.height);
          var R = E(Q, "startFrame", 0), Y = E(Q, "endFrame", -1), I = E(Q, "margin", 0), P = E(Q, "spacing", 0), X = Math.floor((Z - I + P) / (H + P)), G = Math.floor((D - I + P) / (N + P)), V = X * G;
          if (V === 0)
            console.warn("SpriteSheet frame dimensions will result in zero frames for texture:", z.key);
          if (R > V || R < -V)
            R = 0;
          if (R < 0)
            R = V + R;
          if (Y === -1 || Y > V || Y < R)
            Y = V;
          var A = I, F = I, j = 0, T = 0, C = 0;
          for (var v = 0;v < V; v++) {
            j = 0, T = 0;
            var O = A + H, q = F + N;
            if (O > Z)
              j = O - Z;
            if (q > D)
              T = q - D;
            if (v >= R && v <= Y)
              z.add(C, U, K + A, J + F, H - j, N - T), C++;
            if (A += H + P, A + H > Z)
              A = I, F += N + P;
          }
          return z;
        };
        M.exports = L;
      }, 47534: (M, B, $) => {
        var E = $(95540), L = function(z, U, K) {
          var J = E(K, "frameWidth", null), Z = E(K, "frameHeight", J);
          if (!J)
            throw new Error("TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.");
          var D = z.source[0];
          z.add("__BASE", 0, 0, 0, D.width, D.height);
          var Q = E(K, "startFrame", 0), H = E(K, "endFrame", -1), N = E(K, "margin", 0), W = E(K, "spacing", 0), R = U.cutX, Y = U.cutY, I = U.cutWidth, P = U.cutHeight, X = U.realWidth, G = U.realHeight, V = Math.floor((X - N + W) / (J + W)), A = Math.floor((G - N + W) / (Z + W)), F = V * A, j = U.x, T = J - j, C = J - (X - I - j), v = U.y, O = Z - v, q = Z - (G - P - v);
          if (Q > F || Q < -F)
            Q = 0;
          if (Q < 0)
            Q = F + Q;
          if (H !== -1)
            F = Q + (H + 1);
          var w, g = N, b = N, x = 0, k = 0;
          for (var S = 0;S < A; S++) {
            var f = S === 0, h = S === A - 1;
            for (var m = 0;m < V; m++) {
              var y = m === 0, d = m === V - 1;
              if (w = z.add(x, k, R + g, Y + b, J, Z), y || f || d || h) {
                var p = y ? j : 0, u = f ? v : 0, s = 0, c = 0;
                if (y)
                  s += J - T;
                if (d)
                  s += J - C;
                if (f)
                  c += Z - O;
                if (h)
                  c += Z - q;
                var n = J - s, _ = Z - c;
                w.cutWidth = n, w.cutHeight = _, w.setTrim(J, Z, p, u, n, _);
              }
              if (g += W, y)
                g += T;
              else if (d)
                g += C;
              else
                g += J;
              x++;
            }
            if (g = N, b += W, f)
              b += O;
            else if (h)
              b += q;
            else
              b += Z;
          }
          return z;
        };
        M.exports = L;
      }, 86147: (M) => {
        var B = 0, $ = function(L, z, U, K) {
          var J = B - K.y - K.height;
          L.add(U, z, K.x, J, K.width, K.height);
        }, E = function(L, z, U) {
          var K = L.source[z];
          L.add("__BASE", z, 0, 0, K.width, K.height), B = K.height;
          var J = U.split("\n"), Z = /^[ ]*(- )*(\w+)+[: ]+(.*)/, D = "", Q = "", H = { x: 0, y: 0, width: 0, height: 0 };
          for (var N = 0;N < J.length; N++) {
            var W = J[N].match(Z);
            if (!W)
              continue;
            var R = W[1] === "- ", Y = W[2], I = W[3];
            if (R) {
              if (Q !== D)
                $(L, z, Q, H), D = Q;
              H = { x: 0, y: 0, width: 0, height: 0 };
            }
            if (Y === "name") {
              Q = I;
              continue;
            }
            switch (Y) {
              case "x":
              case "y":
              case "width":
              case "height":
                H[Y] = parseInt(I, 10);
                break;
            }
          }
          if (Q !== D)
            $(L, z, Q, H);
          return L;
        };
        M.exports = E;
      }, 55222: (M, B, $) => {
        var E = $(50030), L = function(D) {
          var Q = D.mipmaps;
          for (var H = 1;H < Q.length; H++) {
            var N = Q[H].width, W = Q[H].height;
            if (!E(N, W))
              return console.warn("Mip level " + H + " is not a power-of-two size: " + N + "x" + W), false;
          }
          var R = Z[D.internalFormat];
          if (!R)
            return console.warn("No format checker found for internal format " + D.internalFormat + ". Assuming valid."), true;
          return R(D);
        };
        function z(D) {
          var Q = D.mipmaps;
          for (var H = 0;H < Q.length; H++) {
            var N = Q[H].width, W = Q[H].height;
            if ((N << H) % 4 !== 0 || (W << H) % 4 !== 0)
              return console.warn("BPTC, RGTC, and S3TC dimensions must be a multiple of 4 pixels, and each successive mip level must be half the size of the previous level, rounded down. Mip level " + H + " is " + N + "x" + W), false;
          }
          return true;
        }
        function U() {
          return true;
        }
        function K(D) {
          var Q = D.mipmaps, H = Q[0];
          if (!E(H.width, H.height))
            return console.warn("PVRTC base dimensions must be power of two. Base level is " + H.width + "x" + H.height), false;
          return true;
        }
        function J(D) {
          var Q = D.mipmaps, H = Q[0];
          if (H.width % 4 !== 0 || H.height % 4 !== 0)
            return console.warn("S3TC SRGB base dimensions must be a multiple of 4 pixels. Base level is " + H.width + "x" + H.height + " pixels"), false;
          return true;
        }
        var Z = { 37488: U, 37489: U, 37490: U, 37491: U, 37492: U, 37493: U, 37494: U, 37495: U, 37496: U, 37497: U, 36196: U, 37808: U, 37809: U, 37810: U, 37811: U, 37812: U, 37813: U, 37814: U, 37815: U, 37816: U, 37817: U, 37818: U, 37819: U, 37820: U, 37821: U, 37840: U, 37841: U, 37842: U, 37843: U, 37844: U, 37845: U, 37846: U, 37847: U, 37848: U, 37849: U, 37850: U, 37851: U, 37852: U, 37853: U, 36492: z, 36493: z, 36494: z, 36495: z, 36283: z, 36284: z, 36285: z, 36286: z, 35840: K, 35841: K, 35842: K, 35843: K, 33776: z, 33777: z, 33778: z, 33779: z, 35916: J, 35917: J, 35918: J, 35919: J };
        M.exports = L;
      }, 61309: (M, B, $) => {
        M.exports = { AtlasXML: $(89905), Canvas: $(72893), Image: $(4832), JSONArray: $(78566), JSONHash: $(39711), KTXParser: $(31403), PVRParser: $(82038), SpriteSheet: $(75549), SpriteSheetFromAtlas: $(47534), UnityYAML: $(86147) };
      }, 80341: (M) => {
        M.exports = { CSV: 0, TILED_JSON: 1, ARRAY_2D: 2, WELTMEISTER: 3 };
      }, 16536: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U, K, J, Z, D, Q, H) {
          if (J === undefined || J <= 0)
            J = 32;
          if (Z === undefined || Z <= 0)
            Z = 32;
          if (D === undefined)
            D = 0;
          if (Q === undefined)
            Q = 0;
          this.name = U, this.firstgid = K | 0, this.imageWidth = J | 0, this.imageHeight = Z | 0, this.imageMargin = D | 0, this.imageSpacing = Q | 0, this.properties = H || {}, this.images = [], this.total = 0;
        }, containsImageIndex: function(z) {
          return z >= this.firstgid && z < this.firstgid + this.total;
        }, addImage: function(z, U) {
          return this.images.push({ gid: z, image: U }), this.total++, this;
        } });
        M.exports = L;
      }, 27462: (M, B, $) => {
        var E = $(83419), L = new E({ initialize: function z(U) {
          if (this.gids = [], U !== undefined)
            for (var K = 0;K < U.length; ++K) {
              var J = U[K];
              for (var Z = 0;Z < J.total; ++Z)
                this.gids[J.firstgid + Z] = J;
            }
          this._gids = this.gids;
        }, enabled: { get: function() {
          return !!this.gids;
        }, set: function(z) {
          this.gids = z ? this._gids : undefined;
        } }, getTypeIncludingTile: function(z) {
          if (z.type !== undefined && z.type !== "")
            return z.type;
          if (!this.gids || z.gid === undefined)
            return;
          var U = this.gids[z.gid];
          if (!U)
            return;
          var K = U.getTileData(z.gid);
          if (!K)
            return;
          return K.type;
        }, setTextureAndFrame: function(z, U, K, J) {
          if (U === null && this.gids && J.gid !== undefined) {
            var Z = this.gids[J.gid];
            if (Z) {
              if (U === null && Z.image !== undefined)
                U = Z.image.key;
              if (K === null)
                K = J.gid - Z.firstgid;
              if (!z.scene.textures.getFrame(U, K))
                U = null, K = null;
            }
          }
          z.setTexture(U, K);
        }, setPropertiesFromTiledObject: function(z, U) {
          if (this.gids !== undefined && U.gid !== undefined) {
            var K = this.gids[U.gid];
            if (K !== undefined)
              this.setFromJSON(z, K.getTileProperties(U.gid));
          }
          this.setFromJSON(z, U.properties);
        }, setFromJSON: function(z, U) {
          if (!U)
            return;
          if (Array.isArray(U)) {
            for (var K = 0;K < U.length; K++) {
              var J = U[K];
              if (z[J.name] !== undefined)
                z[J.name] = J.value;
              else
                z.setData(J.name, J.value);
            }
            return;
          }
          for (var Z in U)
            if (z[Z] !== undefined)
              z[Z] = U[Z];
            else
              z.setData(Z, U[Z]);
        } });
        M.exports = L;
      }, 31989: (M, B, $) => {
        var E = $(80341), L = $(87010), z = $(46177), U = $(49075), K = function(J, Z, D, Q, H, N, W, R) {
          if (D === undefined)
            D = 32;
          if (Q === undefined)
            Q = 32;
          if (H === undefined)
            H = 10;
          if (N === undefined)
            N = 10;
          if (R === undefined)
            R = false;
          var Y = null;
          if (Array.isArray(W)) {
            var I = Z !== undefined ? Z : "map";
            Y = z(I, E.ARRAY_2D, W, D, Q, R);
          } else if (Z !== undefined) {
            var P = J.cache.tilemap.get(Z);
            if (!P)
              console.warn("No map data found for key " + Z);
            else
              Y = z(Z, P.format, P.data, D, Q, R);
          }
          if (Y === null)
            Y = new L({ tileWidth: D, tileHeight: Q, width: H, height: N });
          return new U(J, Y);
        };
        M.exports = K;
      }, 23029: (M, B, $) => {
        var E = $(83419), L = $(31401), z = $(91907), U = $(62644), K = $(93232), J = new E({ Mixins: [L.AlphaSingle, L.Flip, L.Visible], initialize: function Z(D, Q, H, N, W, R, Y, I) {
          this.layer = D, this.index = Q, this.x = H, this.y = N, this.width = W, this.height = R, this.right, this.bottom, this.baseWidth = Y !== undefined ? Y : W, this.baseHeight = I !== undefined ? I : R, this.pixelX = 0, this.pixelY = 0, this.updatePixelXY(), this.properties = {}, this.rotation = 0, this.collideLeft = false, this.collideRight = false, this.collideUp = false, this.collideDown = false, this.faceLeft = false, this.faceRight = false, this.faceTop = false, this.faceBottom = false, this.collisionCallback = undefined, this.collisionCallbackContext = this, this.tint = 16777215, this.tintFill = false, this.physics = {};
        }, containsPoint: function(Z, D) {
          return !(Z < this.pixelX || D < this.pixelY || Z > this.right || D > this.bottom);
        }, copy: function(Z) {
          return this.index = Z.index, this.alpha = Z.alpha, this.properties = U(Z.properties), this.visible = Z.visible, this.setFlip(Z.flipX, Z.flipY), this.tint = Z.tint, this.rotation = Z.rotation, this.collideUp = Z.collideUp, this.collideDown = Z.collideDown, this.collideLeft = Z.collideLeft, this.collideRight = Z.collideRight, this.collisionCallback = Z.collisionCallback, this.collisionCallbackContext = Z.collisionCallbackContext, this;
        }, getCollisionGroup: function() {
          return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null;
        }, getTileData: function() {
          return this.tileset ? this.tileset.getTileData(this.index) : null;
        }, getLeft: function(Z) {
          var D = this.tilemapLayer;
          if (D) {
            var Q = D.tileToWorldXY(this.x, this.y, undefined, Z);
            return Q.x;
          }
          return this.x * this.baseWidth;
        }, getRight: function(Z) {
          var D = this.tilemapLayer;
          return D ? this.getLeft(Z) + this.width * D.scaleX : this.getLeft(Z) + this.width;
        }, getTop: function(Z) {
          var D = this.tilemapLayer;
          if (D) {
            var Q = D.tileToWorldXY(this.x, this.y, undefined, Z);
            return Q.y;
          }
          return this.y * this.baseWidth - (this.height - this.baseHeight);
        }, getBottom: function(Z) {
          var D = this.tilemapLayer;
          return D ? this.getTop(Z) + this.height * D.scaleY : this.getTop(Z) + this.height;
        }, getBounds: function(Z, D) {
          if (D === undefined)
            D = new K;
          return D.x = this.getLeft(Z), D.y = this.getTop(Z), D.width = this.getRight(Z) - D.x, D.height = this.getBottom(Z) - D.y, D;
        }, getCenterX: function(Z) {
          return (this.getLeft(Z) + this.getRight(Z)) / 2;
        }, getCenterY: function(Z) {
          return (this.getTop(Z) + this.getBottom(Z)) / 2;
        }, intersects: function(Z, D, Q, H) {
          return !(Q <= this.pixelX || H <= this.pixelY || Z >= this.right || D >= this.bottom);
        }, isInteresting: function(Z, D) {
          if (Z && D)
            return this.canCollide || this.hasInterestingFace;
          else if (Z)
            return this.collides;
          else if (D)
            return this.hasInterestingFace;
          return false;
        }, resetCollision: function(Z) {
          if (Z === undefined)
            Z = true;
          if (this.collideLeft = false, this.collideRight = false, this.collideUp = false, this.collideDown = false, this.faceTop = false, this.faceBottom = false, this.faceLeft = false, this.faceRight = false, Z) {
            var D = this.tilemapLayer;
            if (D)
              this.tilemapLayer.calculateFacesAt(this.x, this.y);
          }
          return this;
        }, resetFaces: function() {
          return this.faceTop = false, this.faceBottom = false, this.faceLeft = false, this.faceRight = false, this;
        }, setCollision: function(Z, D, Q, H, N) {
          if (D === undefined)
            D = Z;
          if (Q === undefined)
            Q = Z;
          if (H === undefined)
            H = Z;
          if (N === undefined)
            N = true;
          if (this.collideLeft = Z, this.collideRight = D, this.collideUp = Q, this.collideDown = H, this.faceLeft = Z, this.faceRight = D, this.faceTop = Q, this.faceBottom = H, N) {
            var W = this.tilemapLayer;
            if (W)
              this.tilemapLayer.calculateFacesAt(this.x, this.y);
          }
          return this;
        }, setCollisionCallback: function(Z, D) {
          if (Z === null)
            this.collisionCallback = undefined, this.collisionCallbackContext = undefined;
          else
            this.collisionCallback = Z, this.collisionCallbackContext = D;
          return this;
        }, setSize: function(Z, D, Q, H) {
          if (Z !== undefined)
            this.width = Z;
          if (D !== undefined)
            this.height = D;
          if (Q !== undefined)
            this.baseWidth = Q;
          if (H !== undefined)
            this.baseHeight = H;
          return this.updatePixelXY(), this;
        }, updatePixelXY: function() {
          var Z = this.layer.orientation;
          if (Z === z.ORTHOGONAL)
            this.pixelX = this.x * this.baseWidth, this.pixelY = this.y * this.baseHeight;
          else if (Z === z.ISOMETRIC)
            this.pixelX = (this.x - this.y) * this.baseWidth * 0.5, this.pixelY = (this.x + this.y) * this.baseHeight * 0.5;
          else if (Z === z.STAGGERED)
            this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2), this.pixelY = this.y * (this.baseHeight / 2);
          else if (Z === z.HEXAGONAL) {
            var D = this.layer.staggerAxis, Q = this.layer.staggerIndex, H = this.layer.hexSideLength, N, W;
            if (D === "y") {
              if (W = (this.baseHeight - H) / 2 + H, Q === "odd")
                this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);
              else
                this.pixelX = this.x * this.baseWidth - this.y % 2 * (this.baseWidth / 2);
              this.pixelY = this.y * W;
            } else if (D === "x")
              if (N = (this.baseWidth - H) / 2 + H, this.pixelX = this.x * N, Q === "odd")
                this.pixelY = this.y * this.baseHeight + this.x % 2 * (this.baseHeight / 2);
              else
                this.pixelY = this.y * this.baseHeight - this.x % 2 * (this.baseHeight / 2);
          }
          return this.right = this.pixelX + this.baseWidth, this.bottom = this.pixelY + this.baseHeight, this;
        }, destroy: function() {
          this.collisionCallback = undefined, this.collisionCallbackContext = undefined, this.properties = undefined;
        }, canCollide: { get: function() {
          return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback !== undefined;
        } }, collides: { get: function() {
          return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
        } }, hasInterestingFace: { get: function() {
          return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight;
        } }, tileset: { get: function() {
          var Z = this.layer.tilemapLayer;
          if (Z) {
            var D = Z.gidMap[this.index];
            if (D)
              return D;
          }
          return null;
        } }, tilemapLayer: { get: function() {
          return this.layer.tilemapLayer;
        } }, tilemap: { get: function() {
          var Z = this.tilemapLayer;
          return Z ? Z.tilemap : null;
        } } });
        M.exports = J;
      }, 49075: (M, B, $) => {
        var E = $(84101), L = $(83419), z = $(39506), U = $(80341), K = $(95540), J = $(14977), Z = $(27462), D = $(91907), Q = $(36305), H = $(19133), N = $(68287), W = $(23029), R = $(81086), Y = $(20442), I = $(33629), P = new L({ initialize: function X(G, V) {
          this.scene = G, this.tileWidth = V.tileWidth, this.tileHeight = V.tileHeight, this.width = V.width, this.height = V.height, this.orientation = V.orientation, this.renderOrder = V.renderOrder, this.format = V.format, this.version = V.version, this.properties = V.properties, this.widthInPixels = V.widthInPixels, this.heightInPixels = V.heightInPixels, this.imageCollections = V.imageCollections, this.images = V.images, this.layers = V.layers, this.tiles = V.tiles, this.tilesets = V.tilesets, this.objects = V.objects, this.currentLayerIndex = 0, this.hexSideLength = V.hexSideLength;
          var A = this.orientation;
          this._convert = { WorldToTileXY: R.GetWorldToTileXYFunction(A), WorldToTileX: R.GetWorldToTileXFunction(A), WorldToTileY: R.GetWorldToTileYFunction(A), TileToWorldXY: R.GetTileToWorldXYFunction(A), TileToWorldX: R.GetTileToWorldXFunction(A), TileToWorldY: R.GetTileToWorldYFunction(A), GetTileCorners: R.GetTileCornersFunction(A) };
        }, setRenderOrder: function(X) {
          var G = ["right-down", "left-down", "right-up", "left-up"];
          if (typeof X === "number")
            X = G[X];
          if (G.indexOf(X) > -1)
            this.renderOrder = X;
          return this;
        }, addTilesetImage: function(X, G, V, A, F, j, T, C) {
          if (X === undefined)
            return null;
          if (G === undefined || G === null)
            G = X;
          var v = this.scene.sys.textures;
          if (!v.exists(G))
            return console.warn('Texture key "%s" not found', G), null;
          var O = v.get(G), q = this.getTilesetIndex(X);
          if (q === null && this.format === U.TILED_JSON)
            return console.warn('Tilemap has no tileset "%s". Its tilesets are %o', X, this.tilesets), null;
          var w = this.tilesets[q];
          if (w)
            return w.setTileSize(V, A), w.setSpacing(F, j), w.setImage(O), w;
          if (V === undefined)
            V = this.tileWidth;
          if (A === undefined)
            A = this.tileHeight;
          if (F === undefined)
            F = 0;
          if (j === undefined)
            j = 0;
          if (T === undefined)
            T = 0;
          if (C === undefined)
            C = { x: 0, y: 0 };
          return w = new I(X, T, V, A, F, j, undefined, undefined, C), w.setImage(O), this.tilesets.push(w), this.tiles = E(this), w;
        }, copy: function(X, G, V, A, F, j, T, C) {
          if (C = this.getLayer(C), C !== null)
            return R.Copy(X, G, V, A, F, j, T, C), this;
          else
            return null;
        }, createBlankLayer: function(X, G, V, A, F, j, T, C) {
          if (V === undefined)
            V = 0;
          if (A === undefined)
            A = 0;
          if (F === undefined)
            F = this.width;
          if (j === undefined)
            j = this.height;
          if (T === undefined)
            T = this.tileWidth;
          if (C === undefined)
            C = this.tileHeight;
          var v = this.getLayerIndex(X);
          if (v !== null)
            return console.warn("Invalid Tilemap Layer ID: " + X), null;
          var O = new J({ name: X, tileWidth: T, tileHeight: C, width: F, height: j, orientation: this.orientation }), q;
          for (var w = 0;w < j; w++) {
            q = [];
            for (var g = 0;g < F; g++)
              q.push(new W(O, -1, g, w, T, C, this.tileWidth, this.tileHeight));
            O.data.push(q);
          }
          this.layers.push(O), this.currentLayerIndex = this.layers.length - 1;
          var b = new Y(this.scene, this, this.currentLayerIndex, G, V, A);
          return b.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(b), b;
        }, createLayer: function(X, G, V, A) {
          var F = this.getLayerIndex(X);
          if (F === null) {
            if (console.warn("Invalid Tilemap Layer ID: " + X), typeof X === "string")
              console.warn("Valid tilelayer names: %o", this.getTileLayerNames());
            return null;
          }
          var j = this.layers[F];
          if (j.tilemapLayer)
            return console.warn("Tilemap Layer ID already exists:" + X), null;
          if (this.currentLayerIndex = F, V === undefined)
            V = j.x;
          if (A === undefined)
            A = j.y;
          var T = new Y(this.scene, this, F, G, V, A);
          return T.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(T), T;
        }, createFromObjects: function(X, G, V) {
          if (V === undefined)
            V = true;
          var A = [], F = this.getObjectLayer(X);
          if (!F)
            return console.warn("createFromObjects: Invalid objectLayerName given: " + X), A;
          var j = new Z(V ? this.tilesets : undefined);
          if (!Array.isArray(G))
            G = [G];
          var T = F.objects;
          for (var C = 0;C < G.length; C++) {
            var v = G[C], O = K(v, "id", null), q = K(v, "gid", null), w = K(v, "name", null), g = K(v, "type", null);
            j.enabled = !K(v, "ignoreTileset", null);
            var b, x = [];
            for (var k = 0;k < T.length; k++)
              if (b = T[k], O === null && q === null && w === null && g === null || O !== null && b.id === O || q !== null && b.gid === q || w !== null && b.name === w || g !== null && j.getTypeIncludingTile(b) === g)
                x.push(b);
            var S = K(v, "classType", N), f = K(v, "scene", this.scene), h = K(v, "container", null), m = K(v, "key", null), y = K(v, "frame", null);
            for (var d = 0;d < x.length; d++) {
              b = x[d];
              var p = new S(f);
              if (p.setName(b.name), p.setPosition(b.x, b.y), j.setTextureAndFrame(p, m, y, b), b.width)
                p.displayWidth = b.width;
              if (b.height)
                p.displayHeight = b.height;
              if (this.orientation === D.ISOMETRIC) {
                var u = this.tileWidth / this.tileHeight, s = { x: p.x - p.y, y: (p.x + p.y) / u };
                p.x = s.x, p.y = s.y;
              }
              var c = { x: p.originX * b.width, y: (p.originY - (b.gid ? 1 : 0)) * b.height };
              if (b.rotation) {
                var n = z(b.rotation);
                Q(c, n), p.rotation = n;
              }
              if (p.x += c.x, p.y += c.y, b.flippedHorizontal !== undefined || b.flippedVertical !== undefined)
                p.setFlip(b.flippedHorizontal, b.flippedVertical);
              if (!b.visible)
                p.visible = false;
              if (j.setPropertiesFromTiledObject(p, b), h)
                h.add(p);
              else
                f.add.existing(p);
              A.push(p);
            }
          }
          return A;
        }, createFromTiles: function(X, G, V, A, F, j) {
          if (j = this.getLayer(j), j === null)
            return null;
          return R.CreateFromTiles(X, G, V, A, F, j);
        }, fill: function(X, G, V, A, F, j, T) {
          if (j === undefined)
            j = true;
          if (T = this.getLayer(T), T === null)
            return null;
          return R.Fill(X, G, V, A, F, j, T), this;
        }, filterObjects: function(X, G, V) {
          if (typeof X === "string") {
            var A = X;
            if (X = this.getObjectLayer(X), !X)
              return console.warn("No object layer found with the name: " + A), null;
          }
          return X.objects.filter(G, V);
        }, filterTiles: function(X, G, V, A, F, j, T, C) {
          if (C = this.getLayer(C), C === null)
            return null;
          return R.FilterTiles(X, G, V, A, F, j, T, C);
        }, findByIndex: function(X, G, V, A) {
          if (A = this.getLayer(A), A === null)
            return null;
          return R.FindByIndex(X, G, V, A);
        }, findObject: function(X, G, V) {
          if (typeof X === "string") {
            var A = X;
            if (X = this.getObjectLayer(X), !X)
              return console.warn("No object layer found with the name: " + A), null;
          }
          return X.objects.find(G, V) || null;
        }, findTile: function(X, G, V, A, F, j, T, C) {
          if (C = this.getLayer(C), C === null)
            return null;
          return R.FindTile(X, G, V, A, F, j, T, C);
        }, forEachTile: function(X, G, V, A, F, j, T, C) {
          if (C = this.getLayer(C), C === null)
            return null;
          return R.ForEachTile(X, G, V, A, F, j, T, C), this;
        }, getImageIndex: function(X) {
          return this.getIndex(this.images, X);
        }, getImageLayerNames: function() {
          if (!this.images || !Array.isArray(this.images))
            return [];
          return this.images.map(function(X) {
            return X.name;
          });
        }, getIndex: function(X, G) {
          for (var V = 0;V < X.length; V++)
            if (X[V].name === G)
              return V;
          return null;
        }, getLayer: function(X) {
          var G = this.getLayerIndex(X);
          return G !== null ? this.layers[G] : null;
        }, getObjectLayer: function(X) {
          var G = this.getIndex(this.objects, X);
          return G !== null ? this.objects[G] : null;
        }, getObjectLayerNames: function() {
          if (!this.objects || !Array.isArray(this.objects))
            return [];
          return this.objects.map(function(X) {
            return X.name;
          });
        }, getLayerIndex: function(X) {
          if (X === undefined)
            return this.currentLayerIndex;
          else if (typeof X === "string")
            return this.getLayerIndexByName(X);
          else if (typeof X === "number" && X < this.layers.length)
            return X;
          else if (X instanceof Y && X.tilemap === this)
            return X.layerIndex;
          else
            return null;
        }, getLayerIndexByName: function(X) {
          return this.getIndex(this.layers, X);
        }, getTileAt: function(X, G, V, A) {
          if (A = this.getLayer(A), A === null)
            return null;
          return R.GetTileAt(X, G, V, A);
        }, getTileAtWorldXY: function(X, G, V, A, F) {
          if (F = this.getLayer(F), F === null)
            return null;
          return R.GetTileAtWorldXY(X, G, V, A, F);
        }, getTileLayerNames: function() {
          if (!this.layers || !Array.isArray(this.layers))
            return [];
          return this.layers.map(function(X) {
            return X.name;
          });
        }, getTilesWithin: function(X, G, V, A, F, j) {
          if (j = this.getLayer(j), j === null)
            return null;
          return R.GetTilesWithin(X, G, V, A, F, j);
        }, getTilesWithinShape: function(X, G, V, A) {
          if (A = this.getLayer(A), A === null)
            return null;
          return R.GetTilesWithinShape(X, G, V, A);
        }, getTilesWithinWorldXY: function(X, G, V, A, F, j, T) {
          if (T = this.getLayer(T), T === null)
            return null;
          return R.GetTilesWithinWorldXY(X, G, V, A, F, j, T);
        }, getTileset: function(X) {
          var G = this.getIndex(this.tilesets, X);
          return G !== null ? this.tilesets[G] : null;
        }, getTilesetIndex: function(X) {
          return this.getIndex(this.tilesets, X);
        }, hasTileAt: function(X, G, V) {
          if (V = this.getLayer(V), V === null)
            return null;
          return R.HasTileAt(X, G, V);
        }, hasTileAtWorldXY: function(X, G, V, A) {
          if (A = this.getLayer(A), A === null)
            return null;
          return R.HasTileAtWorldXY(X, G, V, A);
        }, layer: { get: function() {
          return this.layers[this.currentLayerIndex];
        }, set: function(X) {
          this.setLayer(X);
        } }, putTileAt: function(X, G, V, A, F) {
          if (A === undefined)
            A = true;
          if (F = this.getLayer(F), F === null)
            return null;
          return R.PutTileAt(X, G, V, A, F);
        }, putTileAtWorldXY: function(X, G, V, A, F, j) {
          if (A === undefined)
            A = true;
          if (j = this.getLayer(j), j === null)
            return null;
          return R.PutTileAtWorldXY(X, G, V, A, F, j);
        }, putTilesAt: function(X, G, V, A, F) {
          if (A === undefined)
            A = true;
          if (F = this.getLayer(F), F === null)
            return null;
          return R.PutTilesAt(X, G, V, A, F), this;
        }, randomize: function(X, G, V, A, F, j) {
          if (j = this.getLayer(j), j === null)
            return null;
          return R.Randomize(X, G, V, A, F, j), this;
        }, calculateFacesAt: function(X, G, V) {
          if (V = this.getLayer(V), V === null)
            return null;
          return R.CalculateFacesAt(X, G, V), this;
        }, calculateFacesWithin: function(X, G, V, A, F) {
          if (F = this.getLayer(F), F === null)
            return null;
          return R.CalculateFacesWithin(X, G, V, A, F), this;
        }, removeLayer: function(X) {
          var G = this.getLayerIndex(X);
          if (G !== null) {
            H(this.layers, G);
            for (var V = G;V < this.layers.length; V++)
              if (this.layers[V].tilemapLayer)
                this.layers[V].tilemapLayer.layerIndex--;
            if (this.currentLayerIndex === G)
              this.currentLayerIndex = 0;
            return this;
          } else
            return null;
        }, destroyLayer: function(X) {
          var G = this.getLayerIndex(X);
          if (G !== null) {
            if (X = this.layers[G], X.tilemapLayer.destroy(), H(this.layers, G), this.currentLayerIndex === G)
              this.currentLayerIndex = 0;
            return this;
          } else
            return null;
        }, removeAllLayers: function() {
          var X = this.layers;
          for (var G = 0;G < X.length; G++)
            if (X[G].tilemapLayer)
              X[G].tilemapLayer.destroy(false);
          return X.length = 0, this.currentLayerIndex = 0, this;
        }, removeTile: function(X, G, V) {
          if (G === undefined)
            G = -1;
          if (V === undefined)
            V = true;
          var A = [];
          if (!Array.isArray(X))
            X = [X];
          for (var F = 0;F < X.length; F++) {
            var j = X[F];
            if (A.push(this.removeTileAt(j.x, j.y, true, V, j.tilemapLayer)), G > -1)
              this.putTileAt(G, j.x, j.y, V, j.tilemapLayer);
          }
          return A;
        }, removeTileAt: function(X, G, V, A, F) {
          if (V === undefined)
            V = true;
          if (A === undefined)
            A = true;
          if (F = this.getLayer(F), F === null)
            return null;
          return R.RemoveTileAt(X, G, V, A, F);
        }, removeTileAtWorldXY: function(X, G, V, A, F, j) {
          if (V === undefined)
            V = true;
          if (A === undefined)
            A = true;
          if (j = this.getLayer(j), j === null)
            return null;
          return R.RemoveTileAtWorldXY(X, G, V, A, F, j);
        }, renderDebug: function(X, G, V) {
          if (V = this.getLayer(V), V === null)
            return null;
          if (this.orientation === D.ORTHOGONAL)
            R.RenderDebug(X, G, V);
          return this;
        }, renderDebugFull: function(X, G) {
          var V = this.layers;
          for (var A = 0;A < V.length; A++)
            R.RenderDebug(X, G, V[A]);
          return this;
        }, replaceByIndex: function(X, G, V, A, F, j, T) {
          if (T = this.getLayer(T), T === null)
            return null;
          return R.ReplaceByIndex(X, G, V, A, F, j, T), this;
        }, setCollision: function(X, G, V, A, F) {
          if (G === undefined)
            G = true;
          if (V === undefined)
            V = true;
          if (F === undefined)
            F = true;
          if (A = this.getLayer(A), A === null)
            return null;
          return R.SetCollision(X, G, V, A, F), this;
        }, setCollisionBetween: function(X, G, V, A, F) {
          if (V === undefined)
            V = true;
          if (A === undefined)
            A = true;
          if (F = this.getLayer(F), F === null)
            return null;
          return R.SetCollisionBetween(X, G, V, A, F), this;
        }, setCollisionByProperty: function(X, G, V, A) {
          if (G === undefined)
            G = true;
          if (V === undefined)
            V = true;
          if (A = this.getLayer(A), A === null)
            return null;
          return R.SetCollisionByProperty(X, G, V, A), this;
        }, setCollisionByExclusion: function(X, G, V, A) {
          if (G === undefined)
            G = true;
          if (V === undefined)
            V = true;
          if (A = this.getLayer(A), A === null)
            return null;
          return R.SetCollisionByExclusion(X, G, V, A), this;
        }, setCollisionFromCollisionGroup: function(X, G, V) {
          if (X === undefined)
            X = true;
          if (G === undefined)
            G = true;
          if (V = this.getLayer(V), V === null)
            return null;
          return R.SetCollisionFromCollisionGroup(X, G, V), this;
        }, setTileIndexCallback: function(X, G, V, A) {
          if (A = this.getLayer(A), A === null)
            return null;
          return R.SetTileIndexCallback(X, G, V, A), this;
        }, setTileLocationCallback: function(X, G, V, A, F, j, T) {
          if (T = this.getLayer(T), T === null)
            return null;
          return R.SetTileLocationCallback(X, G, V, A, F, j, T), this;
        }, setLayer: function(X) {
          var G = this.getLayerIndex(X);
          if (G !== null)
            this.currentLayerIndex = G;
          return this;
        }, setBaseTileSize: function(X, G) {
          this.tileWidth = X, this.tileHeight = G, this.widthInPixels = this.width * X, this.heightInPixels = this.height * G;
          for (var V = 0;V < this.layers.length; V++) {
            this.layers[V].baseTileWidth = X, this.layers[V].baseTileHeight = G;
            var A = this.layers[V].data, F = this.layers[V].width, j = this.layers[V].height;
            for (var T = 0;T < j; T++)
              for (var C = 0;C < F; C++) {
                var v = A[T][C];
                if (v !== null)
                  v.setSize(undefined, undefined, X, G);
              }
          }
          return this;
        }, setLayerTileSize: function(X, G, V) {
          if (V = this.getLayer(V), V === null)
            return this;
          V.tileWidth = X, V.tileHeight = G;
          var { data: A, width: F, height: j } = V;
          for (var T = 0;T < j; T++)
            for (var C = 0;C < F; C++) {
              var v = A[T][C];
              if (v !== null)
                v.setSize(X, G);
            }
          return this;
        }, shuffle: function(X, G, V, A, F) {
          if (F = this.getLayer(F), F === null)
            return null;
          return R.Shuffle(X, G, V, A, F), this;
        }, swapByIndex: function(X, G, V, A, F, j, T) {
          if (T = this.getLayer(T), T === null)
            return null;
          return R.SwapByIndex(X, G, V, A, F, j, T), this;
        }, tileToWorldX: function(X, G, V) {
          if (V = this.getLayer(V), V === null)
            return null;
          return this._convert.TileToWorldX(X, G, V);
        }, tileToWorldY: function(X, G, V) {
          if (V = this.getLayer(V), V === null)
            return null;
          return this._convert.TileToWorldY(X, G, V);
        }, tileToWorldXY: function(X, G, V, A, F) {
          if (F = this.getLayer(F), F === null)
            return null;
          return this._convert.TileToWorldXY(X, G, V, A, F);
        }, getTileCorners: function(X, G, V, A) {
          if (A = this.getLayer(A), A === null)
            return null;
          return this._convert.GetTileCorners(X, G, V, A);
        }, weightedRandomize: function(X, G, V, A, F, j) {
          if (j = this.getLayer(j), j === null)
            return null;
          return R.WeightedRandomize(G, V, A, F, X, j), this;
        }, worldToTileX: function(X, G, V, A) {
          if (A = this.getLayer(A), A === null)
            return null;
          return this._convert.WorldToTileX(X, G, V, A);
        }, worldToTileY: function(X, G, V, A) {
          if (A = this.getLayer(A), A === null)
            return null;
          return this._convert.WorldToTileY(X, G, V, A);
        }, worldToTileXY: function(X, G, V, A, F, j) {
          if (j = this.getLayer(j), j === null)
            return null;
          return this._convert.WorldToTileXY(X, G, V, A, F, j);
        }, destroy: function() {
          this.removeAllLayers(), this.tiles.length = 0, this.tilesets.length = 0, this.objects.length = 0, this.scene = null;
        } });
        M.exports = P;
      }, 45939: (M, B, $) => {
        var E = $(44603), L = $(31989);
        E.register("tilemap", function(z) {
          var U = z !== undefined ? z : {};
          return L(this.scene, U.key, U.tileWidth, U.tileHeight, U.width, U.height, U.data, U.insertNull);
        });
      }, 46029: (M, B, $) => {
        var E = $(39429), L = $(31989);
        E.register("tilemap", function(z, U, K, J, Z, D, Q) {
          if (z === null)
            z = undefined;
          if (U === null)
            U = undefined;
          if (K === null)
            K = undefined;
          if (J === null)
            J = undefined;
          if (Z === null)
            Z = undefined;
          return L(this.scene, z, U, K, J, Z, D, Q);
        });
      }, 20442: (M, B, $) => {
        var E = $(83419), L = $(78389), z = $(31401), U = $(95643), K = $(81086), J = $(19218), Z = $(26099), D = new E({ Extends: U, Mixins: [z.Alpha, z.BlendMode, z.ComputedSize, z.Depth, z.Flip, z.GetBounds, z.Mask, z.Origin, z.Pipeline, z.PostPipeline, z.Transform, z.Visible, z.ScrollFactor, L, J], initialize: function Q(H, N, W, R, Y, I) {
          U.call(this, H, "TilemapLayer"), this.isTilemap = true, this.tilemap = N, this.layerIndex = W, this.layer = N.layers[W], this.layer.tilemapLayer = this, this.tileset = [], this.tilesDrawn = 0, this.tilesTotal = this.layer.width * this.layer.height, this.culledTiles = [], this.skipCull = false, this.cullPaddingX = 1, this.cullPaddingY = 1, this.cullCallback = K.GetCullTilesFunction(this.layer.orientation), this._renderOrder = 0, this.gidMap = [], this.tempVec = new Z, this.collisionCategory = 1, this.collisionMask = 1, this.setTilesets(R), this.setAlpha(this.layer.alpha), this.setPosition(Y, I), this.setOrigin(0, 0), this.setSize(N.tileWidth * this.layer.width, N.tileHeight * this.layer.height), this.initPipeline(), this.initPostPipeline(false);
        }, setTilesets: function(Q) {
          var H = [], N = [], W = this.tilemap;
          if (!Array.isArray(Q))
            Q = [Q];
          for (var R = 0;R < Q.length; R++) {
            var Y = Q[R];
            if (typeof Y === "string")
              Y = W.getTileset(Y);
            if (Y) {
              N.push(Y);
              var I = Y.firstgid;
              for (var P = 0;P < Y.total; P++)
                H[I + P] = Y;
            }
          }
          this.gidMap = H, this.tileset = N;
        }, setRenderOrder: function(Q) {
          var H = ["right-down", "left-down", "right-up", "left-up"];
          if (typeof Q === "string")
            Q = H.indexOf(Q);
          if (Q >= 0 && Q < 4)
            this._renderOrder = Q;
          return this;
        }, calculateFacesAt: function(Q, H) {
          return K.CalculateFacesAt(Q, H, this.layer), this;
        }, calculateFacesWithin: function(Q, H, N, W) {
          return K.CalculateFacesWithin(Q, H, N, W, this.layer), this;
        }, createFromTiles: function(Q, H, N, W, R) {
          return K.CreateFromTiles(Q, H, N, W, R, this.layer);
        }, cull: function(Q) {
          return this.cullCallback(this.layer, Q, this.culledTiles, this._renderOrder);
        }, copy: function(Q, H, N, W, R, Y, I) {
          return K.Copy(Q, H, N, W, R, Y, I, this.layer), this;
        }, fill: function(Q, H, N, W, R, Y) {
          return K.Fill(Q, H, N, W, R, Y, this.layer), this;
        }, filterTiles: function(Q, H, N, W, R, Y, I) {
          return K.FilterTiles(Q, H, N, W, R, Y, I, this.layer);
        }, findByIndex: function(Q, H, N) {
          return K.FindByIndex(Q, H, N, this.layer);
        }, findTile: function(Q, H, N, W, R, Y, I) {
          return K.FindTile(Q, H, N, W, R, Y, I, this.layer);
        }, forEachTile: function(Q, H, N, W, R, Y, I) {
          return K.ForEachTile(Q, H, N, W, R, Y, I, this.layer), this;
        }, setTint: function(Q, H, N, W, R, Y) {
          if (Q === undefined)
            Q = 16777215;
          var I = function(P) {
            P.tint = Q, P.tintFill = false;
          };
          return this.forEachTile(I, this, H, N, W, R, Y);
        }, setTintFill: function(Q, H, N, W, R, Y) {
          if (Q === undefined)
            Q = 16777215;
          var I = function(P) {
            P.tint = Q, P.tintFill = true;
          };
          return this.forEachTile(I, this, H, N, W, R, Y);
        }, getTileAt: function(Q, H, N) {
          return K.GetTileAt(Q, H, N, this.layer);
        }, getTileAtWorldXY: function(Q, H, N, W) {
          return K.GetTileAtWorldXY(Q, H, N, W, this.layer);
        }, getIsoTileAtWorldXY: function(Q, H, N, W, R) {
          if (N === undefined)
            N = true;
          var Y = this.tempVec;
          return K.IsometricWorldToTileXY(Q, H, true, Y, R, this.layer, N), this.getTileAt(Y.x, Y.y, W);
        }, getTilesWithin: function(Q, H, N, W, R) {
          return K.GetTilesWithin(Q, H, N, W, R, this.layer);
        }, getTilesWithinShape: function(Q, H, N) {
          return K.GetTilesWithinShape(Q, H, N, this.layer);
        }, getTilesWithinWorldXY: function(Q, H, N, W, R, Y) {
          return K.GetTilesWithinWorldXY(Q, H, N, W, R, Y, this.layer);
        }, hasTileAt: function(Q, H) {
          return K.HasTileAt(Q, H, this.layer);
        }, hasTileAtWorldXY: function(Q, H, N) {
          return K.HasTileAtWorldXY(Q, H, N, this.layer);
        }, putTileAt: function(Q, H, N, W) {
          return K.PutTileAt(Q, H, N, W, this.layer);
        }, putTileAtWorldXY: function(Q, H, N, W, R) {
          return K.PutTileAtWorldXY(Q, H, N, W, R, this.layer);
        }, putTilesAt: function(Q, H, N, W) {
          return K.PutTilesAt(Q, H, N, W, this.layer), this;
        }, randomize: function(Q, H, N, W, R) {
          return K.Randomize(Q, H, N, W, R, this.layer), this;
        }, removeTileAt: function(Q, H, N, W) {
          return K.RemoveTileAt(Q, H, N, W, this.layer);
        }, removeTileAtWorldXY: function(Q, H, N, W, R) {
          return K.RemoveTileAtWorldXY(Q, H, N, W, R, this.layer);
        }, renderDebug: function(Q, H) {
          return K.RenderDebug(Q, H, this.layer), this;
        }, replaceByIndex: function(Q, H, N, W, R, Y) {
          return K.ReplaceByIndex(Q, H, N, W, R, Y, this.layer), this;
        }, setSkipCull: function(Q) {
          if (Q === undefined)
            Q = true;
          return this.skipCull = Q, this;
        }, setCullPadding: function(Q, H) {
          if (Q === undefined)
            Q = 1;
          if (H === undefined)
            H = 1;
          return this.cullPaddingX = Q, this.cullPaddingY = H, this;
        }, setCollision: function(Q, H, N, W) {
          return K.SetCollision(Q, H, N, this.layer, W), this;
        }, setCollisionBetween: function(Q, H, N, W) {
          return K.SetCollisionBetween(Q, H, N, W, this.layer), this;
        }, setCollisionByProperty: function(Q, H, N) {
          return K.SetCollisionByProperty(Q, H, N, this.layer), this;
        }, setCollisionByExclusion: function(Q, H, N) {
          return K.SetCollisionByExclusion(Q, H, N, this.layer), this;
        }, setCollisionFromCollisionGroup: function(Q, H) {
          return K.SetCollisionFromCollisionGroup(Q, H, this.layer), this;
        }, setTileIndexCallback: function(Q, H, N) {
          return K.SetTileIndexCallback(Q, H, N, this.layer), this;
        }, setTileLocationCallback: function(Q, H, N, W, R, Y) {
          return K.SetTileLocationCallback(Q, H, N, W, R, Y, this.layer), this;
        }, shuffle: function(Q, H, N, W) {
          return K.Shuffle(Q, H, N, W, this.layer), this;
        }, swapByIndex: function(Q, H, N, W, R, Y) {
          return K.SwapByIndex(Q, H, N, W, R, Y, this.layer), this;
        }, tileToWorldX: function(Q, H) {
          return this.tilemap.tileToWorldX(Q, H, this);
        }, tileToWorldY: function(Q, H) {
          return this.tilemap.tileToWorldY(Q, H, this);
        }, tileToWorldXY: function(Q, H, N, W) {
          return this.tilemap.tileToWorldXY(Q, H, N, W, this);
        }, getTileCorners: function(Q, H, N) {
          return this.tilemap.getTileCorners(Q, H, N, this);
        }, weightedRandomize: function(Q, H, N, W, R) {
          return K.WeightedRandomize(H, N, W, R, Q, this.layer), this;
        }, worldToTileX: function(Q, H, N) {
          return this.tilemap.worldToTileX(Q, H, N, this);
        }, worldToTileY: function(Q, H, N) {
          return this.tilemap.worldToTileY(Q, H, N, this);
        }, worldToTileXY: function(Q, H, N, W, R) {
          return this.tilemap.worldToTileXY(Q, H, N, W, R, this);
        }, destroy: function(Q) {
          if (Q === undefined)
            Q = true;
          if (!this.tilemap)
            return;
          if (this.layer.tilemapLayer === this)
            this.layer.tilemapLayer = undefined;
          if (Q)
            this.tilemap.removeLayer(this);
          this.tilemap = undefined, this.layer = undefined, this.culledTiles.length = 0, this.cullCallback = null, this.gidMap = [], this.tileset = [], U.prototype.destroy.call(this);
        } });
        M.exports = D;
      }, 16153: (M, B, $) => {
        var E = $(61340), L = new E, z = new E, U = new E, K = function(J, Z, D, Q) {
          var H = Z.cull(D), N = H.length, W = D.alpha * Z.alpha;
          if (N === 0 || W <= 0)
            return;
          var R = L, Y = z, I = U;
          Y.applyITRS(Z.x, Z.y, Z.rotation, Z.scaleX, Z.scaleY), R.copyFrom(D.matrix);
          var P = J.currentContext, X = Z.gidMap;
          if (P.save(), Q)
            R.multiplyWithOffset(Q, -D.scrollX * Z.scrollFactorX, -D.scrollY * Z.scrollFactorY), Y.e = Z.x, Y.f = Z.y, R.multiply(Y, I), I.copyToContext(P);
          else
            Y.e -= D.scrollX * Z.scrollFactorX, Y.f -= D.scrollY * Z.scrollFactorY, Y.copyToContext(P);
          if (!J.antialias || Z.scaleX > 1 || Z.scaleY > 1)
            P.imageSmoothingEnabled = false;
          for (var G = 0;G < N; G++) {
            var V = H[G], A = X[V.index];
            if (!A)
              continue;
            var F = A.image.getSourceImage(), j = A.getTileTextureCoordinates(V.index), T = A.tileWidth, C = A.tileHeight;
            if (j === null || T === 0 || C === 0)
              continue;
            var v = T * 0.5, O = C * 0.5;
            if (j.x += A.tileOffset.x, j.y += A.tileOffset.y, P.save(), P.translate(V.pixelX + v, V.pixelY + O), V.rotation !== 0)
              P.rotate(V.rotation);
            if (V.flipX || V.flipY)
              P.scale(V.flipX ? -1 : 1, V.flipY ? -1 : 1);
            P.globalAlpha = W * V.alpha, P.drawImage(F, j.x, j.y, T, C, -v, -O, T, C), P.restore();
          }
          P.restore();
        };
        M.exports = K;
      }, 19218: (M, B, $) => {
        var E = $(29747), L = E, z = E;
        L = $(99558), z = $(16153), M.exports = { renderWebGL: L, renderCanvas: z };
      }, 99558: (M, B, $) => {
        var E = $(70554), L = function(z, U, K) {
          var J = U.cull(K), Z = J.length, D = K.alpha * U.alpha;
          if (Z === 0 || D <= 0)
            return;
          var Q = U.gidMap, H = z.pipelines.set(U.pipeline, U), N = E.getTintAppendFloatAlpha, W = U.scrollFactorX, R = U.scrollFactorY, Y = U.x, I = U.y, P = U.scaleX, X = U.scaleY;
          z.pipelines.preBatch(U);
          for (var G = 0;G < Z; G++) {
            var V = J[G], A = Q[V.index];
            if (!A)
              continue;
            var F = A.getTileTextureCoordinates(V.index), j = A.tileWidth, T = A.tileHeight;
            if (!F || j === 0 || T === 0)
              continue;
            var C = j * 0.5, v = T * 0.5, O = A.glTexture, q = H.setTexture2D(O, U), w = j, g = T, b = F.x, x = F.y, k = A.tileOffset.x, S = A.tileOffset.y, f = N(V.tint, D * V.alpha);
            H.batchTexture(U, O, O.width, O.height, Y + V.pixelX * P + (C * P - k), I + V.pixelY * X + (v * X - S), j, T, P, X, V.rotation, V.flipX, V.flipY, W, R, C, v, b, x, w, g, f, f, f, f, V.tintFill, 0, 0, K, null, true, q, true);
          }
          z.pipelines.postBatch(U);
        };
        M.exports = L;
      }, 33629: (M, B, $) => {
        var E = $(83419), L = $(26099), z = new E({ initialize: function U(K, J, Z, D, Q, H, N, W, R) {
          if (Z === undefined || Z <= 0)
            Z = 32;
          if (D === undefined || D <= 0)
            D = 32;
          if (Q === undefined)
            Q = 0;
          if (H === undefined)
            H = 0;
          if (N === undefined)
            N = {};
          if (W === undefined)
            W = {};
          if (this.name = K, this.firstgid = J, this.tileWidth = Z, this.tileHeight = D, this.tileMargin = Q, this.tileSpacing = H, this.tileProperties = N, this.tileData = W, this.tileOffset = new L, R !== undefined)
            this.tileOffset.set(R.x, R.y);
          this.image = null, this.glTexture = null, this.rows = 0, this.columns = 0, this.total = 0, this.texCoordinates = [];
        }, getTileProperties: function(U) {
          if (!this.containsTileIndex(U))
            return null;
          return this.tileProperties[U - this.firstgid];
        }, getTileData: function(U) {
          if (!this.containsTileIndex(U))
            return null;
          return this.tileData[U - this.firstgid];
        }, getTileCollisionGroup: function(U) {
          var K = this.getTileData(U);
          return K && K.objectgroup ? K.objectgroup : null;
        }, containsTileIndex: function(U) {
          return U >= this.firstgid && U < this.firstgid + this.total;
        }, getTileTextureCoordinates: function(U) {
          if (!this.containsTileIndex(U))
            return null;
          return this.texCoordinates[U - this.firstgid];
        }, setImage: function(U) {
          this.image = U;
          var K = U.get(), J = U.getFrameBounds();
          if (this.glTexture = K.source.glTexture, K.width > J.width || K.height > J.height)
            this.updateTileData(K.width, K.height);
          else
            this.updateTileData(J.width, J.height, J.x, J.y);
          return this;
        }, setTileSize: function(U, K) {
          if (U !== undefined)
            this.tileWidth = U;
          if (K !== undefined)
            this.tileHeight = K;
          if (this.image)
            this.updateTileData(this.image.source[0].width, this.image.source[0].height);
          return this;
        }, setSpacing: function(U, K) {
          if (U !== undefined)
            this.tileMargin = U;
          if (K !== undefined)
            this.tileSpacing = K;
          if (this.image)
            this.updateTileData(this.image.source[0].width, this.image.source[0].height);
          return this;
        }, updateTileData: function(U, K, J, Z) {
          if (J === undefined)
            J = 0;
          if (Z === undefined)
            Z = 0;
          var D = (K - this.tileMargin * 2 + this.tileSpacing) / (this.tileHeight + this.tileSpacing), Q = (U - this.tileMargin * 2 + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
          if (D % 1 !== 0 || Q % 1 !== 0)
            console.warn("Image tile area not tile size multiple in: " + this.name);
          D = Math.floor(D), Q = Math.floor(Q), this.rows = D, this.columns = Q, this.total = D * Q, this.texCoordinates.length = 0;
          var H = this.tileMargin + J, N = this.tileMargin + Z;
          for (var W = 0;W < this.rows; W++) {
            for (var R = 0;R < this.columns; R++)
              this.texCoordinates.push({ x: H, y: N }), H += this.tileWidth + this.tileSpacing;
            H = this.tileMargin + J, N += this.tileHeight + this.tileSpacing;
          }
          return this;
        } });
        M.exports = z;
      }, 72023: (M, B, $) => {
        var E = $(7423), L = function(z, U, K) {
          var J = E(z, U, true, K), Z = E(z, U - 1, true, K), D = E(z, U + 1, true, K), Q = E(z - 1, U, true, K), H = E(z + 1, U, true, K), N = J && J.collides;
          if (N)
            J.faceTop = true, J.faceBottom = true, J.faceLeft = true, J.faceRight = true;
          if (Z && Z.collides) {
            if (N)
              J.faceTop = false;
            Z.faceBottom = !N;
          }
          if (D && D.collides) {
            if (N)
              J.faceBottom = false;
            D.faceTop = !N;
          }
          if (Q && Q.collides) {
            if (N)
              J.faceLeft = false;
            Q.faceRight = !N;
          }
          if (H && H.collides) {
            if (N)
              J.faceRight = false;
            H.faceLeft = !N;
          }
          if (J && !J.collides)
            J.resetFaces();
          return J;
        };
        M.exports = L;
      }, 42573: (M, B, $) => {
        var E = $(7423), L = $(7386), z = function(U, K, J, Z, D) {
          var Q = null, H = null, N = null, W = null, R = L(U, K, J, Z, null, D);
          for (var Y = 0;Y < R.length; Y++) {
            var I = R[Y];
            if (I)
              if (I.collides)
                Q = E(I.x, I.y - 1, true, D), H = E(I.x, I.y + 1, true, D), N = E(I.x - 1, I.y, true, D), W = E(I.x + 1, I.y, true, D), I.faceTop = Q && Q.collides ? false : true, I.faceBottom = H && H.collides ? false : true, I.faceLeft = N && N.collides ? false : true, I.faceRight = W && W.collides ? false : true;
              else
                I.resetFaces();
          }
        };
        M.exports = z;
      }, 33528: (M, B, $) => {
        var E = $(26099), L = new E, z = function(U, K, J, Z) {
          var D = J.tilemapLayer, Q = D.cullPaddingX, H = D.cullPaddingY, N = D.tilemap.tileToWorldXY(U, K, L, Z, D);
          return N.x > Z.worldView.x + D.scaleX * J.tileWidth * (-Q - 0.5) && N.x < Z.worldView.right + D.scaleX * J.tileWidth * (Q - 0.5) && N.y > Z.worldView.y + D.scaleY * J.tileHeight * (-H - 1) && N.y < Z.worldView.bottom + D.scaleY * J.tileHeight * (H - 0.5);
        };
        M.exports = z;
      }, 1785: (M, B, $) => {
        var E = $(42573), L = $(7386), z = $(62991), U = $(23029), K = function(J, Z, D, Q, H, N, W, R) {
          if (W === undefined)
            W = true;
          var Y = L(J, Z, D, Q, null, R), I = [];
          Y.forEach(function(j) {
            var T = new U(j.layer, j.index, j.x, j.y, j.width, j.height, j.baseWidth, j.baseHeight);
            T.copy(j), I.push(T);
          });
          var P = H - J, X = N - Z;
          for (var G = 0;G < I.length; G++) {
            var V = I[G], A = V.x + P, F = V.y + X;
            if (z(A, F, R)) {
              if (R.data[F][A])
                V.x = A, V.y = F, V.updatePixelXY(), R.data[F][A] = V;
            }
          }
          if (W)
            E(H - 1, N - 1, D + 2, Q + 2, R);
          Y.length = 0, I.length = 0;
        };
        M.exports = K;
      }, 78419: (M, B, $) => {
        var E = $(62644), L = $(7386), z = $(27987), U = function(K, J, Z, D, Q, H) {
          if (!Z)
            Z = {};
          if (!Array.isArray(K))
            K = [K];
          var N = H.tilemapLayer;
          if (!D)
            D = N.scene;
          if (!Q)
            Q = D.cameras.main;
          var { width: W, height: R } = H, Y = L(0, 0, W, R, null, H), I = [], P, X = function(F, j, T) {
            for (var C = 0;C < T.length; C++) {
              var v = T[C];
              if (!F.hasOwnProperty(v))
                F[v] = j[v];
            }
          };
          for (P = 0;P < Y.length; P++) {
            var G = Y[P], V = E(Z);
            if (K.indexOf(G.index) !== -1) {
              var A = N.tileToWorldXY(G.x, G.y, undefined, Q, H);
              if (V.x = A.x, V.y = A.y, X(V, G, ["rotation", "flipX", "flipY", "alpha", "visible", "tint"]), !V.hasOwnProperty("origin"))
                V.x += G.width * 0.5, V.y += G.height * 0.5;
              if (V.hasOwnProperty("useSpriteSheet"))
                V.key = G.tileset.image, V.frame = G.index - 1;
              I.push(D.make.sprite(V));
            }
          }
          if (Array.isArray(J))
            for (P = 0;P < K.length; P++)
              z(K[P], J[P], 0, 0, W, R, H);
          else if (J !== null)
            for (P = 0;P < K.length; P++)
              z(K[P], J, 0, 0, W, R, H);
          return I;
        };
        M.exports = U;
      }, 19545: (M, B, $) => {
        var E = $(87841), L = $(63448), z = $(56583), U = new E, K = function(J, Z) {
          var D = J.tilemapLayer.tilemap, Q = J.tilemapLayer, H = Math.floor(D.tileWidth * Q.scaleX), N = Math.floor(D.tileHeight * Q.scaleY), W = z(Z.worldView.x - Q.x, H, 0, true) - Q.cullPaddingX, R = L(Z.worldView.right - Q.x, H, 0, true) + Q.cullPaddingX, Y = z(Z.worldView.y - Q.y, N, 0, true) - Q.cullPaddingY, I = L(Z.worldView.bottom - Q.y, N, 0, true) + Q.cullPaddingY;
          return U.setTo(W, Y, R - W, I - Y);
        };
        M.exports = K;
      }, 30003: (M, B, $) => {
        var E = $(19545), L = $(32483), z = function(U, K, J, Z) {
          if (J === undefined)
            J = [];
          if (Z === undefined)
            Z = 0;
          J.length = 0;
          var D = U.tilemapLayer, Q = E(U, K);
          if (D.skipCull || D.scrollFactorX !== 1 || D.scrollFactorY !== 1)
            Q.left = 0, Q.right = U.width, Q.top = 0, Q.bottom = U.height;
          return L(U, Q, Z, J), J;
        };
        M.exports = z;
      }, 35137: (M, B, $) => {
        var E = $(7386), L = $(42573), z = $(20576), U = function(K, J, Z, D, Q, H, N) {
          var W = N.collideIndexes.indexOf(K) !== -1, R = E(J, Z, D, Q, null, N);
          for (var Y = 0;Y < R.length; Y++)
            R[Y].index = K, z(R[Y], W);
          if (H)
            L(J - 1, Z - 1, D + 2, Q + 2, N);
        };
        M.exports = U;
      }, 40253: (M, B, $) => {
        var E = $(7386), L = function(z, U, K, J, Z, D, Q, H) {
          var N = E(K, J, Z, D, Q, H);
          return N.filter(z, U);
        };
        M.exports = L;
      }, 52692: (M) => {
        var B = function($, E, L, z) {
          if (E === undefined)
            E = 0;
          if (L === undefined)
            L = false;
          var U = 0, K, J, Z;
          if (L) {
            for (J = z.height - 1;J >= 0; J--)
              for (K = z.width - 1;K >= 0; K--)
                if (Z = z.data[J][K], Z && Z.index === $)
                  if (U === E)
                    return Z;
                  else
                    U += 1;
          } else
            for (J = 0;J < z.height; J++)
              for (K = 0;K < z.width; K++)
                if (Z = z.data[J][K], Z && Z.index === $)
                  if (U === E)
                    return Z;
                  else
                    U += 1;
          return null;
        };
        M.exports = B;
      }, 66151: (M, B, $) => {
        var E = $(7386), L = function(z, U, K, J, Z, D, Q, H) {
          var N = E(K, J, Z, D, Q, H);
          return N.find(z, U) || null;
        };
        M.exports = L;
      }, 97560: (M, B, $) => {
        var E = $(7386), L = function(z, U, K, J, Z, D, Q, H) {
          var N = E(K, J, Z, D, Q, H);
          N.forEach(z, U);
        };
        M.exports = L;
      }, 43305: (M, B, $) => {
        var E = $(91907), L = $(30003), z = $(9474), U = $(14018), K = $(29747), J = $(54503), Z = function(D) {
          if (D === E.ORTHOGONAL)
            return L;
          else if (D === E.HEXAGONAL)
            return z;
          else if (D === E.STAGGERED)
            return J;
          else if (D === E.ISOMETRIC)
            return U;
          else
            return K;
        };
        M.exports = Z;
      }, 7423: (M, B, $) => {
        var E = $(62991), L = function(z, U, K, J) {
          if (K === undefined)
            K = false;
          if (E(z, U, J)) {
            var Z = J.data[U][z] || null;
            if (!Z)
              return null;
            else if (Z.index === -1)
              return K ? Z : null;
            else
              return Z;
          } else
            return null;
        };
        M.exports = L;
      }, 60540: (M, B, $) => {
        var E = $(7423), L = $(26099), z = new L, U = function(K, J, Z, D, Q) {
          return Q.tilemapLayer.worldToTileXY(K, J, true, z, D), E(z.x, z.y, Z, Q);
        };
        M.exports = U;
      }, 55826: (M, B, $) => {
        var E = $(26099), L = function(z, U, K, J) {
          var { baseTileWidth: Z, baseTileHeight: D, tilemapLayer: Q } = J, H = 0, N = 0;
          if (Q) {
            if (!K)
              K = Q.scene.cameras.main;
            H = Q.x + K.scrollX * (1 - Q.scrollFactorX), N = Q.y + K.scrollY * (1 - Q.scrollFactorY), Z *= Q.scaleX, D *= Q.scaleY;
          }
          var W = H + z * Z, R = N + U * D;
          return [new E(W, R), new E(W + Z, R), new E(W + Z, R + D), new E(W, R + D)];
        };
        M.exports = L;
      }, 11758: (M, B, $) => {
        var E = $(91907), L = $(27229), z = $(29747), U = $(55826), K = function(J) {
          if (J === E.ORTHOGONAL)
            return U;
          else if (J === E.ISOMETRIC)
            return z;
          else if (J === E.HEXAGONAL)
            return L;
          else if (J === E.STAGGERED)
            return z;
          else
            return z;
        };
        M.exports = K;
      }, 39167: (M, B, $) => {
        var E = $(91907), L = $(29747), z = $(97281), U = function(K) {
          if (K === E.ORTHOGONAL)
            return z;
          else
            return L;
        };
        M.exports = U;
      }, 62000: (M, B, $) => {
        var E = $(91907), L = $(19951), z = $(14127), U = $(29747), K = $(97202), J = $(70326), Z = function(D) {
          if (D === E.ORTHOGONAL)
            return J;
          else if (D === E.ISOMETRIC)
            return z;
          else if (D === E.HEXAGONAL)
            return L;
          else if (D === E.STAGGERED)
            return K;
          else
            return U;
        };
        M.exports = Z;
      }, 5984: (M, B, $) => {
        var E = $(91907), L = $(29747), z = $(28054), U = $(29650), K = function(J) {
          if (J === E.ORTHOGONAL)
            return U;
          else if (J === E.STAGGERED)
            return z;
          else
            return L;
        };
        M.exports = K;
      }, 7386: (M, B, $) => {
        var E = $(95540), L = function(z, U, K, J, Z, D) {
          if (z === undefined)
            z = 0;
          if (U === undefined)
            U = 0;
          if (K === undefined)
            K = D.width;
          if (J === undefined)
            J = D.height;
          if (!Z)
            Z = {};
          var Q = E(Z, "isNotEmpty", false), H = E(Z, "isColliding", false), N = E(Z, "hasInterestingFace", false);
          if (z < 0)
            K += z, z = 0;
          if (U < 0)
            J += U, U = 0;
          if (z + K > D.width)
            K = Math.max(D.width - z, 0);
          if (U + J > D.height)
            J = Math.max(D.height - U, 0);
          var W = [];
          for (var R = U;R < U + J; R++)
            for (var Y = z;Y < z + K; Y++) {
              var I = D.data[R][Y];
              if (I !== null) {
                if (Q && I.index === -1)
                  continue;
                if (H && !I.collides)
                  continue;
                if (N && !I.hasInterestingFace)
                  continue;
                W.push(I);
              }
            }
          return W;
        };
        M.exports = L;
      }, 91141: (M, B, $) => {
        var E = $(55738), L = $(7386), z = $(91865), U = $(29747), K = $(26099), J = function(N, W) {
          return z.RectangleToTriangle(W, N);
        }, Z = new K, D = new K, Q = new K, H = function(N, W, R, Y) {
          if (N === undefined)
            return [];
          var I = U;
          if (N instanceof E.Circle)
            I = z.CircleToRectangle;
          else if (N instanceof E.Rectangle)
            I = z.RectangleToRectangle;
          else if (N instanceof E.Triangle)
            I = J;
          else if (N instanceof E.Line)
            I = z.LineToRectangle;
          Y.tilemapLayer.worldToTileXY(N.left, N.top, true, D, R);
          var { x: P, y: X } = D;
          Y.tilemapLayer.worldToTileXY(N.right, N.bottom, false, Q, R);
          var G = Math.ceil(Q.x), V = Math.ceil(Q.y), A = Math.max(G - P, 1), F = Math.max(V - X, 1), j = L(P, X, A, F, W, Y), T = Y.tileWidth, C = Y.tileHeight;
          if (Y.tilemapLayer)
            T *= Y.tilemapLayer.scaleX, C *= Y.tilemapLayer.scaleY;
          var v = [], O = new E.Rectangle(0, 0, T, C);
          for (var q = 0;q < j.length; q++) {
            var w = j[q];
            if (Y.tilemapLayer.tileToWorldXY(w.x, w.y, Z, R), O.x = Z.x, O.y = Z.y, I(N, O))
              v.push(w);
          }
          return v;
        };
        M.exports = H;
      }, 96523: (M, B, $) => {
        var E = $(7386), L = $(26099), z = new L, U = new L, K = function(J, Z, D, Q, H, N, W) {
          var R = W.tilemapLayer.tilemap._convert.WorldToTileXY;
          R(J, Z, true, z, N, W);
          var { x: Y, y: I } = z;
          R(J + D, Z + Q, false, U, N, W);
          var P = Math.ceil(U.x), X = Math.ceil(U.y);
          return E(Y, I, P - Y, X - I, H, W);
        };
        M.exports = K;
      }, 96113: (M, B, $) => {
        var E = $(91907), L = $(20242), z = $(10095), U = function(K) {
          if (K === E.ORTHOGONAL)
            return z;
          else
            return L;
        };
        M.exports = U;
      }, 16926: (M, B, $) => {
        var E = $(91907), L = $(86625), z = $(96897), U = $(29747), K = $(15108), J = $(85896), Z = function(D) {
          if (D === E.ORTHOGONAL)
            return J;
          else if (D === E.ISOMETRIC)
            return z;
          else if (D === E.HEXAGONAL)
            return L;
          else if (D === E.STAGGERED)
            return K;
          else
            return U;
        };
        M.exports = Z;
      }, 55762: (M, B, $) => {
        var E = $(91907), L = $(20242), z = $(51900), U = $(63288), K = function(J) {
          if (J === E.ORTHOGONAL)
            return U;
          else if (J === E.STAGGERED)
            return z;
          else
            return L;
        };
        M.exports = K;
      }, 45091: (M, B, $) => {
        var E = $(62991), L = function(z, U, K) {
          if (E(z, U, K)) {
            var J = K.data[U][z];
            return J !== null && J.index > -1;
          } else
            return false;
        };
        M.exports = L;
      }, 24152: (M, B, $) => {
        var E = $(45091), L = $(26099), z = new L, U = function(K, J, Z, D) {
          D.tilemapLayer.worldToTileXY(K, J, true, z, Z);
          var { x: Q, y: H } = z;
          return E(Q, H, D);
        };
        M.exports = U;
      }, 90454: (M, B, $) => {
        var E = $(63448), L = $(56583), z = function(U, K) {
          var J = U.tilemapLayer.tilemap, Z = U.tilemapLayer, D = Math.floor(J.tileWidth * Z.scaleX), Q = Math.floor(J.tileHeight * Z.scaleY), H = U.hexSideLength, N, W, R, Y;
          if (U.staggerAxis === "y") {
            var I = (Q - H) / 2 + H;
            N = L(K.worldView.x - Z.x, D, 0, true) - Z.cullPaddingX, W = E(K.worldView.right - Z.x, D, 0, true) + Z.cullPaddingX, R = L(K.worldView.y - Z.y, I, 0, true) - Z.cullPaddingY, Y = E(K.worldView.bottom - Z.y, I, 0, true) + Z.cullPaddingY;
          } else {
            var P = (D - H) / 2 + H;
            N = L(K.worldView.x - Z.x, P, 0, true) - Z.cullPaddingX, W = E(K.worldView.right - Z.x, P, 0, true) + Z.cullPaddingX, R = L(K.worldView.y - Z.y, Q, 0, true) - Z.cullPaddingY, Y = E(K.worldView.bottom - Z.y, Q, 0, true) + Z.cullPaddingY;
          }
          return { left: N, right: W, top: R, bottom: Y };
        };
        M.exports = z;
      }, 9474: (M, B, $) => {
        var E = $(90454), L = $(32483), z = function(U, K, J, Z) {
          if (J === undefined)
            J = [];
          if (Z === undefined)
            Z = 0;
          J.length = 0;
          var D = U.tilemapLayer, Q = E(U, K);
          if (D.skipCull && D.scrollFactorX === 1 && D.scrollFactorY === 1)
            Q.left = 0, Q.right = U.width, Q.top = 0, Q.bottom = U.height;
          return L(U, Q, Z, J), J;
        };
        M.exports = z;
      }, 27229: (M, B, $) => {
        var E = $(19951), L = $(26099), z = new L, U = function(K, J, Z, D) {
          var { baseTileWidth: Q, baseTileHeight: H, tilemapLayer: N } = D;
          if (N)
            Q *= N.scaleX, H *= N.scaleY;
          var W = E(K, J, z, Z, D), R = [], Y = 0.5773502691896257, I, P;
          if (D.staggerAxis === "y")
            I = Y * Q, P = H / 2;
          else
            I = Q / 2, P = Y * H;
          for (var X = 0;X < 6; X++) {
            var G = 2 * Math.PI * (0.5 - X) / 6;
            R.push(new L(W.x + I * Math.cos(G), W.y + P * Math.sin(G)));
          }
          return R;
        };
        M.exports = U;
      }, 19951: (M, B, $) => {
        var E = $(26099), L = function(z, U, K, J, Z) {
          if (!K)
            K = new E;
          var { baseTileWidth: D, baseTileHeight: Q, tilemapLayer: H } = Z, N = 0, W = 0;
          if (H) {
            if (!J)
              J = H.scene.cameras.main;
            N = H.x + J.scrollX * (1 - H.scrollFactorX), W = H.y + J.scrollY * (1 - H.scrollFactorY), D *= H.scaleX, Q *= H.scaleY;
          }
          var R = D / 2, Y = Q / 2, I, P;
          if (Z.staggerAxis === "y") {
            if (I = N + D * z + D, P = W + 1.5 * U * Y + Y, U % 2 === 0)
              if (this.staggerIndex === "odd")
                I -= R;
              else
                I += R;
          } else if (this.staggerAxis === "x" && this.staggerIndex === "odd") {
            if (I = N + 1.5 * z * R + R, P = W + Q * z + Q, z % 2 === 0)
              if (this.staggerIndex === "odd")
                P -= Y;
              else
                P += Y;
          }
          return K.set(I, P);
        };
        M.exports = L;
      }, 86625: (M, B, $) => {
        var E = $(26099), L = function(z, U, K, J, Z, D) {
          if (!J)
            J = new E;
          var { baseTileWidth: Q, baseTileHeight: H, tilemapLayer: N } = D;
          if (N) {
            if (!Z)
              Z = N.scene.cameras.main;
            z = z - (N.x + Z.scrollX * (1 - N.scrollFactorX)), U = U - (N.y + Z.scrollY * (1 - N.scrollFactorY)), Q *= N.scaleX, H *= N.scaleY;
          }
          var W = 0.5773502691896257, R = -0.3333333333333333, Y = 0, I = 0.6666666666666666, P = Q / 2, X = H / 2, G, V, A, F, j;
          if (D.staggerAxis === "y")
            G = (z - P) / (W * Q), V = (U - X) / X, A = W * G + R * V, F = Y * G + I * V;
          else
            G = (z - P) / P, V = (U - X) / (W * H), A = R * G + W * V, F = I * G + Y * V;
          j = -A - F;
          var T = Math.round(A), C = Math.round(F), v = Math.round(j), O = Math.abs(T - A), q = Math.abs(C - F), w = Math.abs(v - j);
          if (O > q && O > w)
            T = -C - v;
          else if (q > w)
            C = -T - v;
          var g, b = C;
          if (D.staggerIndex === "odd")
            g = b % 2 === 0 ? C / 2 + T : C / 2 + T - 0.5;
          else
            g = b % 2 === 0 ? C / 2 + T : C / 2 + T + 0.5;
          return J.set(g, b);
        };
        M.exports = L;
      }, 62991: (M) => {
        var B = function($, E, L) {
          return $ >= 0 && $ < L.width && E >= 0 && E < L.height;
        };
        M.exports = B;
      }, 14018: (M, B, $) => {
        var E = $(33528), L = function(z, U, K, J) {
          if (K === undefined)
            K = [];
          if (J === undefined)
            J = 0;
          K.length = 0;
          var { tilemapLayer: Z, data: D, width: Q, height: H } = z, N = Z.skipCull, W = 0, R = Q, Y = 0, I = H, P, X, G;
          if (J === 0)
            for (X = Y;X < I; X++)
              for (P = W;P < R; P++) {
                if (G = D[X][P], !G || G.index === -1 || !G.visible || G.alpha === 0)
                  continue;
                if (!N && !E(P, X, z, U))
                  continue;
                K.push(G);
              }
          else if (J === 1)
            for (X = Y;X < I; X++)
              for (P = R;P >= W; P--) {
                if (G = D[X][P], !G || G.index === -1 || !G.visible || G.alpha === 0)
                  continue;
                if (!N && !E(P, X, z, U))
                  continue;
                K.push(G);
              }
          else if (J === 2)
            for (X = I;X >= Y; X--)
              for (P = W;P < R; P++) {
                if (G = D[X][P], !G || G.index === -1 || !G.visible || G.alpha === 0)
                  continue;
                if (!N && !E(P, X, z, U))
                  continue;
                K.push(G);
              }
          else if (J === 3)
            for (X = I;X >= Y; X--)
              for (P = R;P >= W; P--) {
                if (G = D[X][P], !G || G.index === -1 || !G.visible || G.alpha === 0)
                  continue;
                if (!N && !E(P, X, z, U))
                  continue;
                K.push(G);
              }
          return Z.tilesDrawn = K.length, Z.tilesTotal = Q * H, K;
        };
        M.exports = L;
      }, 14127: (M, B, $) => {
        var E = $(26099), L = function(z, U, K, J, Z) {
          if (!K)
            K = new E;
          var { baseTileWidth: D, baseTileHeight: Q, tilemapLayer: H } = Z, N = 0, W = 0;
          if (H) {
            if (!J)
              J = H.scene.cameras.main;
            N = H.x + J.scrollX * (1 - H.scrollFactorX), D *= H.scaleX, W = H.y + J.scrollY * (1 - H.scrollFactorY), Q *= H.scaleY;
          }
          var R = N + (z - U) * (D / 2), Y = W + (z + U) * (Q / 2);
          return K.set(R, Y);
        };
        M.exports = L;
      }, 96897: (M, B, $) => {
        var E = $(26099), L = function(z, U, K, J, Z, D, Q) {
          if (!J)
            J = new E;
          var { baseTileWidth: H, baseTileHeight: N, tilemapLayer: W } = D;
          if (W) {
            if (!Z)
              Z = W.scene.cameras.main;
            U = U - (W.y + Z.scrollY * (1 - W.scrollFactorY)), N *= W.scaleY, z = z - (W.x + Z.scrollX * (1 - W.scrollFactorX)), H *= W.scaleX;
          }
          var R = H / 2, Y = N / 2;
          if (z = z - R, !Q)
            U = U - N;
          var I = 0.5 * (z / R + U / Y), P = 0.5 * (-z / R + U / Y);
          if (K)
            I = Math.floor(I), P = Math.floor(P);
          return J.set(I, P);
        };
        M.exports = L;
      }, 71558: (M, B, $) => {
        var E = $(23029), L = $(62991), z = $(72023), U = $(20576), K = function(J, Z, D, Q, H) {
          if (Q === undefined)
            Q = true;
          if (!L(Z, D, H))
            return null;
          var N, W = H.data[D][Z], R = W && W.collides;
          if (J instanceof E) {
            if (H.data[D][Z] === null)
              H.data[D][Z] = new E(H, J.index, Z, D, H.tileWidth, H.tileHeight);
            H.data[D][Z].copy(J);
          } else if (N = J, H.data[D][Z] === null)
            H.data[D][Z] = new E(H, N, Z, D, H.tileWidth, H.tileHeight);
          else
            H.data[D][Z].index = N;
          var Y = H.data[D][Z], I = H.collideIndexes.indexOf(Y.index) !== -1;
          if (N = J instanceof E ? J.index : J, N === -1)
            Y.width = H.tileWidth, Y.height = H.tileHeight;
          else {
            var P = H.tilemapLayer.tilemap, X = P.tiles, G = X[N][2], V = P.tilesets[G];
            Y.width = V.tileWidth, Y.height = V.tileHeight;
          }
          if (U(Y, I), Q && R !== Y.collides)
            z(Z, D, H);
          return Y;
        };
        M.exports = K;
      }, 26303: (M, B, $) => {
        var E = $(71558), L = $(26099), z = new L, U = function(K, J, Z, D, Q, H) {
          return H.tilemapLayer.worldToTileXY(J, Z, true, z, Q, H), E(K, z.x, z.y, D, H);
        };
        M.exports = U;
      }, 14051: (M, B, $) => {
        var E = $(42573), L = $(71558), z = function(U, K, J, Z, D) {
          if (Z === undefined)
            Z = true;
          if (!Array.isArray(U))
            return null;
          if (!Array.isArray(U[0]))
            U = [U];
          var Q = U.length, H = U[0].length;
          for (var N = 0;N < Q; N++)
            for (var W = 0;W < H; W++) {
              var R = U[N][W];
              L(R, K + W, J + N, false, D);
            }
          if (Z)
            E(K - 1, J - 1, H + 2, Q + 2, D);
        };
        M.exports = z;
      }, 77389: (M, B, $) => {
        var E = $(7386), L = $(26546), z = function(U, K, J, Z, D, Q) {
          var H, N = E(U, K, J, Z, {}, Q);
          if (!D) {
            D = [];
            for (H = 0;H < N.length; H++)
              if (D.indexOf(N[H].index) === -1)
                D.push(N[H].index);
          }
          for (H = 0;H < N.length; H++)
            N[H].index = L(D);
        };
        M.exports = z;
      }, 63557: (M, B, $) => {
        var E = $(23029), L = $(62991), z = $(72023), U = function(K, J, Z, D, Q) {
          if (Z === undefined)
            Z = true;
          if (D === undefined)
            D = true;
          if (!L(K, J, Q))
            return null;
          var H = Q.data[J][K];
          if (!H)
            return null;
          else
            Q.data[J][K] = Z ? null : new E(Q, -1, K, J, Q.tileWidth, Q.tileHeight);
          if (D && H && H.collides)
            z(K, J, Q);
          return H;
        };
        M.exports = U;
      }, 94178: (M, B, $) => {
        var E = $(63557), L = $(26099), z = new L, U = function(K, J, Z, D, Q, H) {
          return H.tilemapLayer.worldToTileXY(K, J, true, z, Q, H), E(z.x, z.y, Z, D, H);
        };
        M.exports = U;
      }, 15533: (M, B, $) => {
        var E = $(7386), L = $(3956), z = new L(105, 210, 231, 150), U = new L(243, 134, 48, 200), K = new L(40, 39, 37, 150), J = function(Z, D, Q) {
          if (D === undefined)
            D = {};
          var H = D.tileColor !== undefined ? D.tileColor : z, N = D.collidingTileColor !== undefined ? D.collidingTileColor : U, W = D.faceColor !== undefined ? D.faceColor : K, R = E(0, 0, Q.width, Q.height, null, Q);
          Z.translateCanvas(Q.tilemapLayer.x, Q.tilemapLayer.y), Z.scaleCanvas(Q.tilemapLayer.scaleX, Q.tilemapLayer.scaleY);
          for (var Y = 0;Y < R.length; Y++) {
            var I = R[Y], P = I.width, X = I.height, G = I.pixelX, V = I.pixelY, A = I.collides ? N : H;
            if (A !== null)
              Z.fillStyle(A.color, A.alpha / 255), Z.fillRect(G, V, P, X);
            if (G += 1, V += 1, P -= 2, X -= 2, W !== null) {
              if (Z.lineStyle(1, W.color, W.alpha / 255), I.faceTop)
                Z.lineBetween(G, V, G + P, V);
              if (I.faceRight)
                Z.lineBetween(G + P, V, G + P, V + X);
              if (I.faceBottom)
                Z.lineBetween(G, V + X, G + P, V + X);
              if (I.faceLeft)
                Z.lineBetween(G, V, G, V + X);
            }
          }
        };
        M.exports = J;
      }, 27987: (M, B, $) => {
        var E = $(7386), L = function(z, U, K, J, Z, D, Q) {
          var H = E(K, J, Z, D, null, Q);
          for (var N = 0;N < H.length; N++)
            if (H[N] && H[N].index === z)
              H[N].index = U;
        };
        M.exports = L;
      }, 32483: (M) => {
        var B = function($, E, L, z) {
          var { data: U, width: K, height: J, tilemapLayer: Z } = $, D = Math.max(0, E.left), Q = Math.min(K, E.right), H = Math.max(0, E.top), N = Math.min(J, E.bottom), W, R, Y;
          if (L === 0)
            for (R = H;R < N; R++)
              for (W = D;U[R] && W < Q; W++) {
                if (Y = U[R][W], !Y || Y.index === -1 || !Y.visible || Y.alpha === 0)
                  continue;
                z.push(Y);
              }
          else if (L === 1)
            for (R = H;R < N; R++)
              for (W = Q;U[R] && W >= D; W--) {
                if (Y = U[R][W], !Y || Y.index === -1 || !Y.visible || Y.alpha === 0)
                  continue;
                z.push(Y);
              }
          else if (L === 2)
            for (R = N;R >= H; R--)
              for (W = D;U[R] && W < Q; W++) {
                if (Y = U[R][W], !Y || Y.index === -1 || !Y.visible || Y.alpha === 0)
                  continue;
                z.push(Y);
              }
          else if (L === 3)
            for (R = N;R >= H; R--)
              for (W = Q;U[R] && W >= D; W--) {
                if (Y = U[R][W], !Y || Y.index === -1 || !Y.visible || Y.alpha === 0)
                  continue;
                z.push(Y);
              }
          return Z.tilesDrawn = z.length, Z.tilesTotal = K * J, z;
        };
        M.exports = B;
      }, 57068: (M, B, $) => {
        var E = $(20576), L = $(42573), z = $(9589), U = function(K, J, Z, D, Q) {
          if (J === undefined)
            J = true;
          if (Z === undefined)
            Z = true;
          if (Q === undefined)
            Q = true;
          if (!Array.isArray(K))
            K = [K];
          for (var H = 0;H < K.length; H++)
            z(K[H], J, D);
          if (Q)
            for (var N = 0;N < D.height; N++)
              for (var W = 0;W < D.width; W++) {
                var R = D.data[N][W];
                if (R && K.indexOf(R.index) !== -1)
                  E(R, J);
              }
          if (Z)
            L(0, 0, D.width, D.height, D);
        };
        M.exports = U;
      }, 37266: (M, B, $) => {
        var E = $(20576), L = $(42573), z = $(9589), U = function(K, J, Z, D, Q, H) {
          if (Z === undefined)
            Z = true;
          if (D === undefined)
            D = true;
          if (H === undefined)
            H = true;
          if (K > J)
            return;
          for (var N = K;N <= J; N++)
            z(N, Z, Q);
          if (H)
            for (var W = 0;W < Q.height; W++)
              for (var R = 0;R < Q.width; R++) {
                var Y = Q.data[W][R];
                if (Y) {
                  if (Y.index >= K && Y.index <= J)
                    E(Y, Z);
                }
              }
          if (D)
            L(0, 0, Q.width, Q.height, Q);
        };
        M.exports = U;
      }, 75661: (M, B, $) => {
        var E = $(20576), L = $(42573), z = $(9589), U = function(K, J, Z, D) {
          if (J === undefined)
            J = true;
          if (Z === undefined)
            Z = true;
          if (!Array.isArray(K))
            K = [K];
          for (var Q = 0;Q < D.height; Q++)
            for (var H = 0;H < D.width; H++) {
              var N = D.data[Q][H];
              if (N && K.indexOf(N.index) === -1)
                E(N, J), z(N.index, J, D);
            }
          if (Z)
            L(0, 0, D.width, D.height, D);
        };
        M.exports = U;
      }, 64740: (M, B, $) => {
        var E = $(20576), L = $(42573), z = $(97022), U = function(K, J, Z, D) {
          if (J === undefined)
            J = true;
          if (Z === undefined)
            Z = true;
          for (var Q = 0;Q < D.height; Q++)
            for (var H = 0;H < D.width; H++) {
              var N = D.data[Q][H];
              if (!N)
                continue;
              for (var W in K) {
                if (!z(N.properties, W))
                  continue;
                var R = K[W];
                if (!Array.isArray(R))
                  R = [R];
                for (var Y = 0;Y < R.length; Y++)
                  if (N.properties[W] === R[Y])
                    E(N, J);
              }
            }
          if (Z)
            L(0, 0, D.width, D.height, D);
        };
        M.exports = U;
      }, 63307: (M, B, $) => {
        var E = $(20576), L = $(42573), z = function(U, K, J) {
          if (U === undefined)
            U = true;
          if (K === undefined)
            K = true;
          for (var Z = 0;Z < J.height; Z++)
            for (var D = 0;D < J.width; D++) {
              var Q = J.data[Z][D];
              if (!Q)
                continue;
              var H = Q.getCollisionGroup();
              if (H && H.objects && H.objects.length > 0)
                E(Q, U);
            }
          if (K)
            L(0, 0, J.width, J.height, J);
        };
        M.exports = z;
      }, 9589: (M) => {
        var B = function($, E, L) {
          var z = L.collideIndexes.indexOf($);
          if (E && z === -1)
            L.collideIndexes.push($);
          else if (!E && z !== -1)
            L.collideIndexes.splice(z, 1);
        };
        M.exports = B;
      }, 20576: (M) => {
        var B = function($, E) {
          if (E)
            $.setCollision(true, true, true, true, false);
          else
            $.resetCollision(false);
        };
        M.exports = B;
      }, 79583: (M) => {
        var B = function($, E, L, z) {
          if (typeof $ === "number")
            z.callbacks[$] = E !== null ? { callback: E, callbackContext: L } : undefined;
          else
            for (var U = 0, K = $.length;U < K; U++)
              z.callbacks[$[U]] = E !== null ? { callback: E, callbackContext: L } : undefined;
        };
        M.exports = B;
      }, 93254: (M, B, $) => {
        var E = $(7386), L = function(z, U, K, J, Z, D, Q) {
          var H = E(z, U, K, J, null, Q);
          for (var N = 0;N < H.length; N++)
            H[N].setCollisionCallback(Z, D);
        };
        M.exports = L;
      }, 32903: (M, B, $) => {
        var E = $(7386), L = $(33680), z = function(U, K, J, Z, D) {
          var Q = E(U, K, J, Z, null, D), H = Q.map(function(W) {
            return W.index;
          });
          L(H);
          for (var N = 0;N < Q.length; N++)
            Q[N].index = H[N];
        };
        M.exports = z;
      }, 61325: (M, B, $) => {
        var E = $(63448), L = $(56583), z = function(U, K) {
          var J = U.tilemapLayer.tilemap, Z = U.tilemapLayer, D = Math.floor(J.tileWidth * Z.scaleX), Q = Math.floor(J.tileHeight * Z.scaleY), H = L(K.worldView.x - Z.x, D, 0, true) - Z.cullPaddingX, N = E(K.worldView.right - Z.x, D, 0, true) + Z.cullPaddingX, W = L(K.worldView.y - Z.y, Q / 2, 0, true) - Z.cullPaddingY, R = E(K.worldView.bottom - Z.y, Q / 2, 0, true) + Z.cullPaddingY;
          return { left: H, right: N, top: W, bottom: R };
        };
        M.exports = z;
      }, 54503: (M, B, $) => {
        var E = $(61325), L = $(32483), z = function(U, K, J, Z) {
          if (J === undefined)
            J = [];
          if (Z === undefined)
            Z = 0;
          J.length = 0;
          var D = U.tilemapLayer, Q = E(U, K);
          if (D.skipCull && D.scrollFactorX === 1 && D.scrollFactorY === 1)
            Q.left = 0, Q.right = U.width, Q.top = 0, Q.bottom = U.height;
          return L(U, Q, Z, J), J;
        };
        M.exports = z;
      }, 97202: (M, B, $) => {
        var E = $(26099), L = function(z, U, K, J, Z) {
          if (!K)
            K = new E;
          var { baseTileWidth: D, baseTileHeight: Q, tilemapLayer: H } = Z, N = 0, W = 0;
          if (H) {
            if (!J)
              J = H.scene.cameras.main;
            N = H.x + J.scrollX * (1 - H.scrollFactorX), D *= H.scaleX, W = H.y + J.scrollY * (1 - H.scrollFactorY), Q *= H.scaleY;
          }
          var R = N + z * D + U % 2 * (D / 2), Y = W + U * (Q / 2);
          return K.set(R, Y);
        };
        M.exports = L;
      }, 28054: (M) => {
        var B = function($, E, L) {
          var { baseTileHeight: z, tilemapLayer: U } = L, K = 0;
          if (U) {
            if (E === undefined)
              E = U.scene.cameras.main;
            K = U.y + E.scrollY * (1 - U.scrollFactorY), z *= U.scaleY;
          }
          return K + $ * (z / 2) + z;
        };
        M.exports = B;
      }, 15108: (M, B, $) => {
        var E = $(26099), L = function(z, U, K, J, Z, D) {
          if (!J)
            J = new E;
          var { baseTileWidth: Q, baseTileHeight: H, tilemapLayer: N } = D;
          if (N) {
            if (!Z)
              Z = N.scene.cameras.main;
            U = U - (N.y + Z.scrollY * (1 - N.scrollFactorY)), H *= N.scaleY, z = z - (N.x + Z.scrollX * (1 - N.scrollFactorX)), Q *= N.scaleX;
          }
          var W = K ? Math.floor(U / (H / 2)) : U / (H / 2), R = K ? Math.floor((z + W % 2 * 0.5 * Q) / Q) : (z + W % 2 * 0.5 * Q) / Q;
          return J.set(R, W);
        };
        M.exports = L;
      }, 51900: (M) => {
        var B = function($, E, L, z) {
          var { baseTileHeight: U, tilemapLayer: K } = z;
          if (K) {
            if (!L)
              L = K.scene.cameras.main;
            $ = $ - (K.y + L.scrollY * (1 - K.scrollFactorY)), U *= K.scaleY;
          }
          return E ? Math.floor($ / (U / 2)) : $ / (U / 2);
        };
        M.exports = B;
      }, 86560: (M, B, $) => {
        var E = $(7386), L = function(z, U, K, J, Z, D, Q) {
          var H = E(K, J, Z, D, null, Q);
          for (var N = 0;N < H.length; N++)
            if (H[N]) {
              if (H[N].index === z)
                H[N].index = U;
              else if (H[N].index === U)
                H[N].index = z;
            }
        };
        M.exports = L;
      }, 97281: (M) => {
        var B = function($, E, L) {
          var { baseTileWidth: z, tilemapLayer: U } = L, K = 0;
          if (U) {
            if (!E)
              E = U.scene.cameras.main;
            K = U.x + E.scrollX * (1 - U.scrollFactorX), z *= U.scaleX;
          }
          return K + $ * z;
        };
        M.exports = B;
      }, 70326: (M, B, $) => {
        var E = $(97281), L = $(29650), z = $(26099), U = function(K, J, Z, D, Q) {
          if (!Z)
            Z = new z(0, 0);
          return Z.x = E(K, D, Q), Z.y = L(J, D, Q), Z;
        };
        M.exports = U;
      }, 29650: (M) => {
        var B = function($, E, L) {
          var { baseTileHeight: z, tilemapLayer: U } = L, K = 0;
          if (U) {
            if (!E)
              E = U.scene.cameras.main;
            K = U.y + E.scrollY * (1 - U.scrollFactorY), z *= U.scaleY;
          }
          return K + $ * z;
        };
        M.exports = B;
      }, 77366: (M, B, $) => {
        var E = $(7386), L = $(75508), z = function(U, K, J, Z, D, Q) {
          if (!D)
            return;
          var H, N = E(U, K, J, Z, null, Q), W = 0;
          for (H = 0;H < D.length; H++)
            W += D[H].weight;
          if (W <= 0)
            return;
          for (H = 0;H < N.length; H++) {
            var R = L.RND.frac() * W, Y = 0, I = -1;
            for (var P = 0;P < D.length; P++)
              if (Y += D[P].weight, R <= Y) {
                var X = D[P].index;
                I = Array.isArray(X) ? X[Math.floor(L.RND.frac() * X.length)] : X;
                break;
              }
            N[H].index = I;
          }
        };
        M.exports = z;
      }, 10095: (M, B, $) => {
        var E = $(85896), L = $(26099), z = new L, U = function(K, J, Z, D) {
          return E(K, 0, J, z, Z, D), z.x;
        };
        M.exports = U;
      }, 85896: (M, B, $) => {
        var E = $(26099), L = function(z, U, K, J, Z, D) {
          if (K === undefined)
            K = true;
          if (!J)
            J = new E;
          var { baseTileWidth: Q, baseTileHeight: H, tilemapLayer: N } = D;
          if (N) {
            if (!Z)
              Z = N.scene.cameras.main;
            z = z - (N.x + Z.scrollX * (1 - N.scrollFactorX)), U = U - (N.y + Z.scrollY * (1 - N.scrollFactorY)), Q *= N.scaleX, H *= N.scaleY;
          }
          var W = z / Q, R = U / H;
          if (K)
            W = Math.floor(W), R = Math.floor(R);
          return J.set(W, R);
        };
        M.exports = L;
      }, 63288: (M, B, $) => {
        var E = $(85896), L = $(26099), z = new L, U = function(K, J, Z, D) {
          return E(0, K, J, z, Z, D), z.y;
        };
        M.exports = U;
      }, 81086: (M, B, $) => {
        M.exports = { CalculateFacesAt: $(72023), CalculateFacesWithin: $(42573), CheckIsoBounds: $(33528), Copy: $(1785), CreateFromTiles: $(78419), CullBounds: $(19545), CullTiles: $(30003), Fill: $(35137), FilterTiles: $(40253), FindByIndex: $(52692), FindTile: $(66151), ForEachTile: $(97560), GetCullTilesFunction: $(43305), GetTileAt: $(7423), GetTileAtWorldXY: $(60540), GetTileCorners: $(55826), GetTileCornersFunction: $(11758), GetTilesWithin: $(7386), GetTilesWithinShape: $(91141), GetTilesWithinWorldXY: $(96523), GetTileToWorldXFunction: $(39167), GetTileToWorldXYFunction: $(62000), GetTileToWorldYFunction: $(5984), GetWorldToTileXFunction: $(96113), GetWorldToTileXYFunction: $(16926), GetWorldToTileYFunction: $(55762), HasTileAt: $(45091), HasTileAtWorldXY: $(24152), HexagonalCullBounds: $(90454), HexagonalCullTiles: $(9474), HexagonalGetTileCorners: $(27229), HexagonalTileToWorldXY: $(19951), HexagonalWorldToTileXY: $(86625), IsInLayerBounds: $(62991), IsometricCullTiles: $(14018), IsometricTileToWorldXY: $(14127), IsometricWorldToTileXY: $(96897), PutTileAt: $(71558), PutTileAtWorldXY: $(26303), PutTilesAt: $(14051), Randomize: $(77389), RemoveTileAt: $(63557), RemoveTileAtWorldXY: $(94178), RenderDebug: $(15533), ReplaceByIndex: $(27987), RunCull: $(32483), SetCollision: $(57068), SetCollisionBetween: $(37266), SetCollisionByExclusion: $(75661), SetCollisionByProperty: $(64740), SetCollisionFromCollisionGroup: $(63307), SetLayerCollisionIndex: $(9589), SetTileCollision: $(20576), SetTileIndexCallback: $(79583), SetTileLocationCallback: $(93254), Shuffle: $(32903), StaggeredCullBounds: $(61325), StaggeredCullTiles: $(54503), StaggeredTileToWorldXY: $(97202), StaggeredTileToWorldY: $(28054), StaggeredWorldToTileXY: $(15108), StaggeredWorldToTileY: $(51900), SwapByIndex: $(86560), TileToWorldX: $(97281), TileToWorldXY: $(70326), TileToWorldY: $(29650), WeightedRandomize: $(77366), WorldToTileX: $(10095), WorldToTileXY: $(85896), WorldToTileY: $(63288) };
      }, 91907: (M) => {
        M.exports = { ORTHOGONAL: 0, ISOMETRIC: 1, STAGGERED: 2, HEXAGONAL: 3 };
      }, 21829: (M, B, $) => {
        var E = { ORIENTATION: $(91907) };
        M.exports = E;
      }, 62501: (M, B, $) => {
        var E = $(79291), L = $(21829), z = { Components: $(81086), Parsers: $(57442), Formats: $(80341), ImageCollection: $(16536), ParseToTilemap: $(31989), Tile: $(23029), Tilemap: $(49075), TilemapCreator: $(45939), TilemapFactory: $(46029), Tileset: $(33629), TilemapLayer: $(20442), Orientation: $(91907), LayerData: $(14977), MapData: $(87010), ObjectLayer: $(48700) };
        z = E(false, z, L.ORIENTATION), M.exports = z;
      }, 14977: (M, B, $) => {
        var E = $(83419), L = $(91907), z = $(95540), U = new E({ initialize: function K(J) {
          if (J === undefined)
            J = {};
          this.name = z(J, "name", "layer"), this.id = z(J, "id", 0), this.x = z(J, "x", 0), this.y = z(J, "y", 0), this.width = z(J, "width", 0), this.height = z(J, "height", 0), this.tileWidth = z(J, "tileWidth", 0), this.tileHeight = z(J, "tileHeight", 0), this.baseTileWidth = z(J, "baseTileWidth", this.tileWidth), this.baseTileHeight = z(J, "baseTileHeight", this.tileHeight), this.orientation = z(J, "orientation", L.ORTHOGONAL), this.widthInPixels = z(J, "widthInPixels", this.width * this.baseTileWidth), this.heightInPixels = z(J, "heightInPixels", this.height * this.baseTileHeight), this.alpha = z(J, "alpha", 1), this.visible = z(J, "visible", true), this.properties = z(J, "properties", []), this.indexes = z(J, "indexes", []), this.collideIndexes = z(J, "collideIndexes", []), this.callbacks = z(J, "callbacks", []), this.bodies = z(J, "bodies", []), this.data = z(J, "data", []), this.tilemapLayer = z(J, "tilemapLayer", null), this.hexSideLength = z(J, "hexSideLength", 0), this.staggerAxis = z(J, "staggerAxis", "y"), this.staggerIndex = z(J, "staggerIndex", "odd");
        } });
        M.exports = U;
      }, 87010: (M, B, $) => {
        var E = $(83419), L = $(91907), z = $(95540), U = new E({ initialize: function K(J) {
          if (J === undefined)
            J = {};
          if (this.name = z(J, "name", "map"), this.width = z(J, "width", 0), this.height = z(J, "height", 0), this.infinite = z(J, "infinite", false), this.tileWidth = z(J, "tileWidth", 0), this.tileHeight = z(J, "tileHeight", 0), this.widthInPixels = z(J, "widthInPixels", this.width * this.tileWidth), this.heightInPixels = z(J, "heightInPixels", this.height * this.tileHeight), this.format = z(J, "format", null), this.orientation = z(J, "orientation", L.ORTHOGONAL), this.renderOrder = z(J, "renderOrder", "right-down"), this.version = z(J, "version", "1"), this.properties = z(J, "properties", {}), this.layers = z(J, "layers", []), this.images = z(J, "images", []), this.objects = z(J, "objects", []), !Array.isArray(this.objects))
            this.objects = [];
          this.collision = z(J, "collision", {}), this.tilesets = z(J, "tilesets", []), this.imageCollections = z(J, "imageCollections", []), this.tiles = z(J, "tiles", []), this.hexSideLength = z(J, "hexSideLength", 0), this.staggerAxis = z(J, "staggerAxis", "y"), this.staggerIndex = z(J, "staggerIndex", "odd");
        } });
        M.exports = U;
      }, 48700: (M, B, $) => {
        var E = $(83419), L = $(95540), z = new E({ initialize: function U(K) {
          if (K === undefined)
            K = {};
          if (this.name = L(K, "name", "object layer"), this.id = L(K, "id", 0), this.opacity = L(K, "opacity", 1), this.properties = L(K, "properties", {}), this.propertyTypes = L(K, "propertytypes", {}), this.type = L(K, "type", "objectgroup"), this.visible = L(K, "visible", true), this.objects = L(K, "objects", []), !Array.isArray(this.objects))
            this.objects = [];
        } });
        M.exports = z;
      }, 6641: (M, B, $) => {
        var E = $(91907), L = function(z) {
          if (z = z.toLowerCase(), z === "isometric")
            return E.ISOMETRIC;
          else if (z === "staggered")
            return E.STAGGERED;
          else if (z === "hexagonal")
            return E.HEXAGONAL;
          else
            return E.ORTHOGONAL;
        };
        M.exports = L;
      }, 46177: (M, B, $) => {
        var E = $(80341), L = $(2342), z = $(82593), U = $(46594), K = $(87021), J = function(Z, D, Q, H, N, W) {
          var R;
          switch (D) {
            case E.ARRAY_2D:
              R = L(Z, Q, H, N, W);
              break;
            case E.CSV:
              R = z(Z, Q, H, N, W);
              break;
            case E.TILED_JSON:
              R = U(Z, Q, W);
              break;
            case E.WELTMEISTER:
              R = K(Z, Q, W);
              break;
            default:
              console.warn("Unrecognized tilemap data format: " + D), R = null;
          }
          return R;
        };
        M.exports = J;
      }, 2342: (M, B, $) => {
        var E = $(80341), L = $(14977), z = $(87010), U = $(23029), K = function(J, Z, D, Q, H) {
          var N = new L({ tileWidth: D, tileHeight: Q }), W = new z({ name: J, tileWidth: D, tileHeight: Q, format: E.ARRAY_2D, layers: [N] }), R = [], Y = Z.length, I = 0;
          for (var P = 0;P < Z.length; P++) {
            R[P] = [];
            var X = Z[P];
            for (var G = 0;G < X.length; G++) {
              var V = parseInt(X[G], 10);
              if (isNaN(V) || V === -1)
                R[P][G] = H ? null : new U(N, -1, G, P, D, Q);
              else
                R[P][G] = new U(N, V, G, P, D, Q);
            }
            if (I === 0)
              I = X.length;
          }
          return W.width = N.width = I, W.height = N.height = Y, W.widthInPixels = N.widthInPixels = I * D, W.heightInPixels = N.heightInPixels = Y * Q, N.data = R, W;
        };
        M.exports = K;
      }, 82593: (M, B, $) => {
        var E = $(80341), L = $(2342), z = function(U, K, J, Z, D) {
          var Q = K.trim().split("\n").map(function(N) {
            return N.split(",");
          }), H = L(U, Q, J, Z, D);
          return H.format = E.CSV, H;
        };
        M.exports = z;
      }, 6656: (M, B, $) => {
        var E = $(14977), L = $(23029), z = function(U, K) {
          var J = [];
          for (var Z = 0;Z < U.layer.length; Z++) {
            var D = U.layer[Z], Q = new E({ name: D.name, width: D.width, height: D.height, tileWidth: D.tilesize, tileHeight: D.tilesize, visible: D.visible === 1 }), H = [], N = [];
            for (var W = 0;W < D.data.length; W++) {
              for (var R = 0;R < D.data[W].length; R++) {
                var Y = D.data[W][R] - 1, I;
                if (Y > -1)
                  I = new L(Q, Y, R, W, D.tilesize, D.tilesize);
                else
                  I = K ? null : new L(Q, -1, R, W, D.tilesize, D.tilesize);
                H.push(I);
              }
              N.push(H), H = [];
            }
            Q.data = N, J.push(Q);
          }
          return J;
        };
        M.exports = z;
      }, 96483: (M, B, $) => {
        var E = $(33629), L = function(z) {
          var U = [], K = [];
          for (var J = 0;J < z.layer.length; J++) {
            var Z = z.layer[J], D = Z.tilesetName;
            if (D !== "" && K.indexOf(D) === -1)
              K.push(D), U.push(new E(D, 0, Z.tilesize, Z.tilesize, 0, 0));
          }
          return U;
        };
        M.exports = L;
      }, 87021: (M, B, $) => {
        var E = $(80341), L = $(87010), z = $(6656), U = $(96483), K = function(J, Z, D) {
          if (Z.layer.length === 0)
            return console.warn("No layers found in the Weltmeister map: " + J), null;
          var Q = 0, H = 0;
          for (var N = 0;N < Z.layer.length; N++) {
            if (Z.layer[N].width > Q)
              Q = Z.layer[N].width;
            if (Z.layer[N].height > H)
              H = Z.layer[N].height;
          }
          var W = new L({ width: Q, height: H, name: J, tileWidth: Z.layer[0].tilesize, tileHeight: Z.layer[0].tilesize, format: E.WELTMEISTER });
          return W.layers = z(Z, D), W.tilesets = U(Z), W;
        };
        M.exports = K;
      }, 52833: (M, B, $) => {
        M.exports = { ParseTileLayers: $(6656), ParseTilesets: $(96483), ParseWeltmeister: $(87021) };
      }, 57442: (M, B, $) => {
        M.exports = { FromOrientationString: $(6641), Parse: $(46177), Parse2DArray: $(2342), ParseCSV: $(82593), Impact: $(52833), Tiled: $(96761) };
      }, 51233: (M, B, $) => {
        var E = $(79291), L = function(z) {
          var U, K, J, Z, D;
          for (var Q = 0;Q < z.layers.length; Q++) {
            U = z.layers[Q], Z = null;
            for (var H = 0;H < U.data.length; H++) {
              D = U.data[H];
              for (var N = 0;N < D.length; N++) {
                if (K = D[N], K === null || K.index < 0)
                  continue;
                if (J = z.tiles[K.index][2], Z = z.tilesets[J], K.width = Z.tileWidth, K.height = Z.tileHeight, Z.tileProperties && Z.tileProperties[K.index - Z.firstgid])
                  K.properties = E(K.properties, Z.tileProperties[K.index - Z.firstgid]);
              }
            }
          }
        };
        M.exports = L;
      }, 41868: (M) => {
        var B = function($) {
          var E = window.atob($), L = E.length, z = new Array(L / 4);
          for (var U = 0;U < L; U += 4)
            z[U / 4] = (E.charCodeAt(U) | E.charCodeAt(U + 1) << 8 | E.charCodeAt(U + 2) << 16 | E.charCodeAt(U + 3) << 24) >>> 0;
          return z;
        };
        M.exports = B;
      }, 84101: (M, B, $) => {
        var E = $(33629), L = function(z) {
          var U, K, J = [];
          for (U = 0;U < z.imageCollections.length; U++) {
            var Z = z.imageCollections[U], D = Z.images;
            for (var Q = 0;Q < D.length; Q++) {
              var H = D[Q];
              K = new E(H.image, H.gid, Z.imageWidth, Z.imageHeight, 0, 0), K.updateTileData(Z.imageWidth, Z.imageHeight), z.tilesets.push(K);
            }
          }
          for (U = 0;U < z.tilesets.length; U++) {
            K = z.tilesets[U];
            var { tileMargin: N, tileMargin: W } = K, R = 0, Y = 0, I = 0;
            for (var P = K.firstgid;P < K.firstgid + K.total; P++) {
              if (J[P] = [N, W, U], N += K.tileWidth + K.tileSpacing, R++, R === K.total)
                break;
              if (Y++, Y === K.columns) {
                if (N = K.tileMargin, W += K.tileHeight + K.tileSpacing, Y = 0, I++, I === K.rows)
                  break;
              }
            }
          }
          return J;
        };
        M.exports = L;
      }, 79677: (M, B, $) => {
        var E = $(95540), L = function(z, U, K) {
          if (!U)
            return { i: 0, layers: z.layers, name: "", opacity: 1, visible: true, x: 0, y: 0 };
          var J = U.x + E(U, "startx", 0) * z.tilewidth + E(U, "offsetx", 0), Z = U.y + E(U, "starty", 0) * z.tileheight + E(U, "offsety", 0);
          return { i: 0, layers: U.layers, name: K.name + U.name + "/", opacity: K.opacity * U.opacity, visible: K.visible && U.visible, x: K.x + J, y: K.y + Z };
        };
        M.exports = L;
      }, 29920: (M) => {
        var B = 2147483648, $ = 1073741824, E = 536870912, L = function(z) {
          var U = Boolean(z & B), K = Boolean(z & $), J = Boolean(z & E);
          z = z & ~(B | $ | E);
          var Z = 0, D = false;
          if (U && K && J)
            Z = Math.PI / 2, D = true;
          else if (U && K && !J)
            Z = Math.PI, D = false;
          else if (U && !K && J)
            Z = Math.PI / 2, D = false;
          else if (U && !K && !J)
            Z = 0, D = true;
          else if (!U && K && J)
            Z = 3 * Math.PI / 2, D = false;
          else if (!U && K && !J)
            Z = Math.PI, D = true;
          else if (!U && !K && J)
            Z = 3 * Math.PI / 2, D = true;
          else if (!U && !K && !J)
            Z = 0, D = false;
          return { gid: z, flippedHorizontal: U, flippedVertical: K, flippedAntiDiagonal: J, rotation: Z, flipped: D };
        };
        M.exports = L;
      }, 12635: (M, B, $) => {
        var E = $(95540), L = $(79677), z = function(U) {
          var K = [], J = [], Z = L(U);
          while (Z.i < Z.layers.length || J.length > 0) {
            if (Z.i >= Z.layers.length) {
              if (J.length < 1) {
                console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                break;
              }
              Z = J.pop();
              continue;
            }
            var D = Z.layers[Z.i];
            if (Z.i++, D.type !== "imagelayer") {
              if (D.type === "group") {
                var Q = L(U, D, Z);
                J.push(Z), Z = Q;
              }
              continue;
            }
            var H = E(D, "offsetx", 0) + E(D, "startx", 0), N = E(D, "offsety", 0) + E(D, "starty", 0);
            K.push({ name: Z.name + D.name, image: D.image, x: Z.x + H + D.x, y: Z.y + N + D.y, alpha: Z.opacity * D.opacity, visible: Z.visible && D.visible, properties: E(D, "properties", {}) });
          }
          return K;
        };
        M.exports = z;
      }, 46594: (M, B, $) => {
        var E = $(51233), L = $(84101), z = $(91907), U = $(62644), K = $(80341), J = $(6641), Z = $(87010), D = $(12635), Q = $(22611), H = $(28200), N = $(24619), W = function(R, Y, I) {
          var P = U(Y), X = new Z({ width: P.width, height: P.height, name: R, tileWidth: P.tilewidth, tileHeight: P.tileheight, orientation: J(P.orientation), format: K.TILED_JSON, version: P.version, properties: P.properties, renderOrder: P.renderorder, infinite: P.infinite });
          if (X.orientation === z.HEXAGONAL)
            X.hexSideLength = P.hexsidelength, X.staggerAxis = P.staggeraxis, X.staggerIndex = P.staggerindex;
          X.layers = H(P, I), X.images = D(P);
          var G = N(P);
          return X.tilesets = G.tilesets, X.imageCollections = G.imageCollections, X.objects = Q(P), X.tiles = L(X), E(X), X;
        };
        M.exports = W;
      }, 52205: (M, B, $) => {
        var E = $(18254), L = $(29920), z = function(J) {
          return { x: J.x, y: J.y };
        }, U = ["id", "name", "type", "rotation", "properties", "visible", "x", "y", "width", "height"], K = function(J, Z, D) {
          if (Z === undefined)
            Z = 0;
          if (D === undefined)
            D = 0;
          var Q = E(J, U);
          if (Q.x += Z, Q.y += D, J.gid) {
            var H = L(J.gid);
            Q.gid = H.gid, Q.flippedHorizontal = H.flippedHorizontal, Q.flippedVertical = H.flippedVertical, Q.flippedAntiDiagonal = H.flippedAntiDiagonal;
          } else if (J.polyline)
            Q.polyline = J.polyline.map(z);
          else if (J.polygon)
            Q.polygon = J.polygon.map(z);
          else if (J.ellipse)
            Q.ellipse = J.ellipse;
          else if (J.text)
            Q.text = J.text;
          else if (J.point)
            Q.point = true;
          else
            Q.rectangle = true;
          return Q;
        };
        M.exports = K;
      }, 22611: (M, B, $) => {
        var E = $(95540), L = $(52205), z = $(48700), U = $(79677), K = function(J) {
          var Z = [], D = [], Q = U(J);
          while (Q.i < Q.layers.length || D.length > 0) {
            if (Q.i >= Q.layers.length) {
              if (D.length < 1) {
                console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                break;
              }
              Q = D.pop();
              continue;
            }
            var H = Q.layers[Q.i];
            if (Q.i++, H.opacity *= Q.opacity, H.visible = Q.visible && H.visible, H.type !== "objectgroup") {
              if (H.type === "group") {
                var N = U(J, H, Q);
                D.push(Q), Q = N;
              }
              continue;
            }
            H.name = Q.name + H.name;
            var W = Q.x + E(H, "startx", 0) + E(H, "offsetx", 0), R = Q.y + E(H, "starty", 0) + E(H, "offsety", 0), Y = [];
            for (var I = 0;I < H.objects.length; I++) {
              var P = L(H.objects[I], W, R);
              Y.push(P);
            }
            var X = new z(H);
            X.objects = Y, Z.push(X);
          }
          return Z;
        };
        M.exports = K;
      }, 28200: (M, B, $) => {
        var E = $(41868), L = $(91907), z = $(79677), U = $(6641), K = $(95540), J = $(14977), Z = $(29920), D = $(23029), Q = function(H, N) {
          var W = K(H, "infinite", false), R = [], Y = [], I = z(H);
          while (I.i < I.layers.length || Y.length > 0) {
            if (I.i >= I.layers.length) {
              if (Y.length < 1) {
                console.warn("TilemapParser.parseTiledJSON - Invalid layer group hierarchy");
                break;
              }
              I = Y.pop();
              continue;
            }
            var P = I.layers[I.i];
            if (I.i++, P.type !== "tilelayer") {
              if (P.type === "group") {
                var X = z(H, P, I);
                Y.push(I), I = X;
              }
              continue;
            }
            if (P.compression) {
              console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer \'" + P.name + "\'");
              continue;
            } else if (P.encoding && P.encoding === "base64") {
              if (P.chunks)
                for (var G = 0;G < P.chunks.length; G++)
                  P.chunks[G].data = E(P.chunks[G].data);
              if (P.data)
                P.data = E(P.data);
              delete P.encoding;
            }
            var V, A, F, j, T = [], C = 0;
            if (W) {
              var v = K(P, "startx", 0) + P.x, O = K(P, "starty", 0) + P.y;
              if (V = new J({ name: I.name + P.name, id: P.id, x: I.x + K(P, "offsetx", 0) + v * H.tilewidth, y: I.y + K(P, "offsety", 0) + O * H.tileheight, width: P.width, height: P.height, tileWidth: H.tilewidth, tileHeight: H.tileheight, alpha: I.opacity * P.opacity, visible: I.visible && P.visible, properties: K(P, "properties", []), orientation: U(H.orientation) }), V.orientation === L.HEXAGONAL)
                V.hexSideLength = H.hexsidelength, V.staggerAxis = H.staggeraxis, V.staggerIndex = H.staggerindex;
              for (var q = 0;q < P.height; q++) {
                T[q] = [null];
                for (var w = 0;w < P.width; w++)
                  T[q][w] = null;
              }
              for (q = 0, p = P.chunks.length;q < p; q++) {
                var g = P.chunks[q], b = g.x - v, x = g.y - O, k = 0;
                for (var S = 0, f = g.data.length;S < f; S++) {
                  var h = C + b, m = k + x;
                  if (A = Z(g.data[S]), A.gid > 0)
                    F = new D(V, A.gid, h, m, H.tilewidth, H.tileheight), F.rotation = A.rotation, F.flipX = A.flipped, T[m][h] = F;
                  else
                    j = N ? null : new D(V, -1, h, m, H.tilewidth, H.tileheight), T[m][h] = j;
                  if (C++, C === g.width)
                    k++, C = 0;
                }
              }
            } else {
              if (V = new J({ name: I.name + P.name, id: P.id, x: I.x + K(P, "offsetx", 0) + P.x, y: I.y + K(P, "offsety", 0) + P.y, width: P.width, height: P.height, tileWidth: H.tilewidth, tileHeight: H.tileheight, alpha: I.opacity * P.opacity, visible: I.visible && P.visible, properties: K(P, "properties", []), orientation: U(H.orientation) }), V.orientation === L.HEXAGONAL)
                V.hexSideLength = H.hexsidelength, V.staggerAxis = H.staggeraxis, V.staggerIndex = H.staggerindex;
              var y = [];
              for (var d = 0, p = P.data.length;d < p; d++) {
                if (A = Z(P.data[d]), A.gid > 0)
                  F = new D(V, A.gid, C, T.length, H.tilewidth, H.tileheight), F.rotation = A.rotation, F.flipX = A.flipped, y.push(F);
                else
                  j = N ? null : new D(V, -1, C, T.length, H.tilewidth, H.tileheight), y.push(j);
                if (C++, C === P.width)
                  T.push(y), C = 0, y = [];
              }
            }
            V.data = T, R.push(V);
          }
          return R;
        };
        M.exports = Q;
      }, 24619: (M, B, $) => {
        var E = $(33629), L = $(16536), z = $(52205), U = $(57880), K = function(J) {
          var Z = [], D = [], Q = null, H;
          for (var N = 0;N < J.tilesets.length; N++) {
            var W = J.tilesets[N];
            if (W.source)
              console.warn("External tilesets unsupported. Use Embed Tileset and re-export");
            else if (W.image) {
              var R = new E(W.name, W.firstgid, W.tilewidth, W.tileheight, W.margin, W.spacing, undefined, undefined, W.tileoffset);
              if (J.version > 1) {
                var Y = undefined, I = undefined;
                if (Array.isArray(W.tiles)) {
                  Y = Y || {}, I = I || {};
                  for (var P = 0;P < W.tiles.length; P++) {
                    var X = W.tiles[P];
                    if (X.properties) {
                      var G = {};
                      X.properties.forEach(function(q) {
                        G[q.name] = q.value;
                      }), I[X.id] = G;
                    }
                    if (X.objectgroup) {
                      if ((Y[X.id] || (Y[X.id] = {})).objectgroup = X.objectgroup, X.objectgroup.objects) {
                        var V = X.objectgroup.objects.map(function(q) {
                          return z(q);
                        });
                        Y[X.id].objectgroup.objects = V;
                      }
                    }
                    if (X.animation)
                      (Y[X.id] || (Y[X.id] = {})).animation = X.animation;
                    if (X.type)
                      (Y[X.id] || (Y[X.id] = {})).type = X.type;
                  }
                }
                if (Array.isArray(W.wangsets))
                  Y = Y || {}, I = I || {}, U(W.wangsets, Y);
                if (Y)
                  R.tileData = Y, R.tileProperties = I;
              } else {
                if (W.tileproperties)
                  R.tileProperties = W.tileproperties;
                if (W.tiles) {
                  R.tileData = W.tiles;
                  for (H in R.tileData) {
                    var A = R.tileData[H].objectgroup;
                    if (A && A.objects) {
                      var F = A.objects.map(function(q) {
                        return z(q);
                      });
                      R.tileData[H].objectgroup.objects = F;
                    }
                  }
                }
              }
              R.updateTileData(W.imagewidth, W.imageheight), Z.push(R);
            } else {
              var j = new L(W.name, W.firstgid, W.tilewidth, W.tileheight, W.margin, W.spacing, W.properties), T = 0;
              for (P = 0;P < W.tiles.length; P++) {
                X = W.tiles[P];
                var C = X.image, v = parseInt(X.id, 10), O = W.firstgid + v;
                j.addImage(O, C), T = Math.max(v, T);
              }
              j.maxId = T, D.push(j);
            }
            if (Q)
              Q.lastgid = W.firstgid - 1;
            Q = W;
          }
          return { tilesets: Z, imageCollections: D };
        };
        M.exports = K;
      }, 57880: (M) => {
        var B = function($, E) {
          for (var L = 0;L < $.length; L++) {
            var z = $[L], U = L;
            if (z.name && z.name !== "")
              U = z.name;
            if (Array.isArray(z.wangtiles) && z.wangtiles.length > 0) {
              var K = {}, J = {}, Z, D, Q;
              if (Array.isArray(z.edgecolors)) {
                for (Z = 0;Z < z.edgecolors.length; Z++)
                  if (Q = 1 + Z, D = z.edgecolors[Z], D.name !== "")
                    K[Q] = D.name;
              }
              if (Array.isArray(z.cornercolors)) {
                for (Z = 0;Z < z.cornercolors.length; Z++)
                  if (Q = 1 + Z, D = z.cornercolors[Z], D.name !== "")
                    J[Q] = D.name;
              }
              if (Array.isArray(z.colors)) {
                for (Z = 0;Z < z.colors.length; Z++)
                  if (D = z.colors[Z], Q = 1 + Z, D.name !== "")
                    K[Q] = J[Q] = D.name;
              }
              var H = [K, J, K, J, K, J, K, J];
              for (var N = 0;N < z.wangtiles.length; N++) {
                var W = z.wangtiles[N], R = E[W.tileid] || (E[W.tileid] = {});
                R = R.wangid || (R.wangid = {});
                var Y = [];
                for (var I = 0;I < Math.min(H.length, W.wangid.length); I++) {
                  if (D = W.wangid[I], D === 0) {
                    Y.push(undefined);
                    continue;
                  }
                  var P = H[I][D];
                  if (P !== undefined) {
                    Y.push(P);
                    continue;
                  }
                  Y.push(D);
                }
                R[U] = Y;
              }
            }
          }
        };
        M.exports = B;
      }, 96761: (M, B, $) => {
        M.exports = { AssignTileProperties: $(51233), Base64Decode: $(41868), BuildTilesetIndex: $(84101), CreateGroupLayer: $(79677), ParseGID: $(29920), ParseImageLayers: $(12635), ParseJSONTiled: $(46594), ParseObject: $(52205), ParseObjectLayers: $(22611), ParseTileLayers: $(28200), ParseTilesets: $(24619) };
      }, 33385: (M, B, $) => {
        var E = $(83419), L = $(37277), z = $(44594), U = $(94880), K = $(72905), J = new E({ initialize: function Z(D) {
          this.scene = D, this.systems = D.sys, this.now = 0, this.startTime = 0, this.timeScale = 1, this.paused = false, this._active = [], this._pendingInsertion = [], this._pendingRemoval = [], D.sys.events.once(z.BOOT, this.boot, this), D.sys.events.on(z.START, this.start, this);
        }, boot: function() {
          this.now = this.systems.game.loop.time, this.systems.events.once(z.DESTROY, this.destroy, this);
        }, start: function() {
          this.startTime = this.systems.game.loop.time;
          var Z = this.systems.events;
          Z.on(z.PRE_UPDATE, this.preUpdate, this), Z.on(z.UPDATE, this.update, this), Z.once(z.SHUTDOWN, this.shutdown, this);
        }, addEvent: function(Z) {
          var D;
          if (Z instanceof U)
            D = Z, this.removeEvent(D), D.elapsed = D.startAt, D.hasDispatched = false, D.repeatCount = D.repeat === -1 || D.loop ? 999999999999 : D.repeat;
          else
            D = new U(Z);
          return this._pendingInsertion.push(D), D;
        }, delayedCall: function(Z, D, Q, H) {
          return this.addEvent({ delay: Z, callback: D, args: Q, callbackScope: H });
        }, clearPendingEvents: function() {
          return this._pendingInsertion = [], this;
        }, removeEvent: function(Z) {
          if (!Array.isArray(Z))
            Z = [Z];
          for (var D = 0;D < Z.length; D++) {
            var Q = Z[D];
            K(this._pendingRemoval, Q), K(this._pendingInsertion, Q), K(this._active, Q);
          }
          return this;
        }, removeAllEvents: function() {
          return this._pendingRemoval = this._pendingRemoval.concat(this._active), this;
        }, preUpdate: function() {
          var Z = this._pendingRemoval.length, D = this._pendingInsertion.length;
          if (Z === 0 && D === 0)
            return;
          var Q, H;
          for (Q = 0;Q < Z; Q++) {
            H = this._pendingRemoval[Q];
            var N = this._active.indexOf(H);
            if (N > -1)
              this._active.splice(N, 1);
            H.destroy();
          }
          for (Q = 0;Q < D; Q++)
            H = this._pendingInsertion[Q], this._active.push(H);
          this._pendingRemoval.length = 0, this._pendingInsertion.length = 0;
        }, update: function(Z, D) {
          if (this.now = Z, this.paused)
            return;
          D *= this.timeScale;
          for (var Q = 0;Q < this._active.length; Q++) {
            var H = this._active[Q];
            if (H.paused)
              continue;
            if (H.elapsed += D * H.timeScale, H.elapsed >= H.delay) {
              var N = H.elapsed - H.delay;
              if (H.elapsed = H.delay, !H.hasDispatched && H.callback)
                H.hasDispatched = true, H.callback.apply(H.callbackScope, H.args);
              if (H.repeatCount > 0) {
                if (H.repeatCount--, N >= H.delay)
                  while (N >= H.delay && H.repeatCount > 0) {
                    if (H.callback)
                      H.callback.apply(H.callbackScope, H.args);
                    N -= H.delay, H.repeatCount--;
                  }
                H.elapsed = N, H.hasDispatched = false;
              } else if (H.hasDispatched)
                this._pendingRemoval.push(H);
            }
          }
        }, shutdown: function() {
          var Z;
          for (Z = 0;Z < this._pendingInsertion.length; Z++)
            this._pendingInsertion[Z].destroy();
          for (Z = 0;Z < this._active.length; Z++)
            this._active[Z].destroy();
          for (Z = 0;Z < this._pendingRemoval.length; Z++)
            this._pendingRemoval[Z].destroy();
          this._active.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0;
          var D = this.systems.events;
          D.off(z.PRE_UPDATE, this.preUpdate, this), D.off(z.UPDATE, this.update, this), D.off(z.SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          this.shutdown(), this.scene.sys.events.off(z.START, this.start, this), this.scene = null, this.systems = null;
        } });
        L.register("Clock", J, "time"), M.exports = J;
      }, 96120: (M, B, $) => {
        var E = $(83419), L = $(50792), z = $(39429), U = $(95540), K = $(44594), J = $(89809), Z = new E({ Extends: L, initialize: function D(Q, H) {
          L.call(this), this.scene = Q, this.systems = Q.sys, this.elapsed = 0, this.paused = true, this.complete = false, this.totalComplete = 0, this.loop = 0, this.iteration = 0, this.events = [];
          var N = this.systems.events;
          if (N.on(K.PRE_UPDATE, this.preUpdate, this), N.on(K.UPDATE, this.update, this), N.once(K.SHUTDOWN, this.destroy, this), H)
            this.add(H);
        }, preUpdate: function(D, Q) {
          if (this.paused)
            return;
          this.elapsed += Q;
        }, update: function() {
          if (this.paused || this.complete)
            return;
          var D, Q = this.events, H = false, N = this.systems, W;
          for (D = 0;D < Q.length; D++) {
            var R = Q[D];
            if (!R.complete && R.time <= this.elapsed) {
              if (R.complete = true, this.totalComplete++, W = R.target ? R.target : this, R.if) {
                if (!R.if.call(W, R))
                  continue;
              }
              if (R.once)
                H = true;
              if (R.set && R.target)
                for (var Y in R.set)
                  R.target[Y] = R.set[Y];
              if (this.iteration)
                R.repeat++;
              if (R.loop && R.repeat)
                R.loop.call(W);
              if (R.tween)
                N.tweens.add(R.tween);
              if (R.sound)
                if (typeof R.sound === "string")
                  N.sound.play(R.sound);
                else
                  N.sound.play(R.sound.key, R.sound.config);
              if (R.event)
                this.emit(R.event, W);
              if (R.run)
                R.run.call(W);
              if (R.stop)
                this.stop();
            }
          }
          if (H) {
            for (D = 0;D < Q.length; D++)
              if (Q[D].complete && Q[D].once)
                Q.splice(D, 1), D--;
          }
          if (this.totalComplete >= Q.length)
            if (this.loop !== 0 && (this.loop === -1 || this.loop > this.iteration))
              this.iteration++, this.reset(true);
            else
              this.complete = true;
          if (this.complete)
            this.emit(J.COMPLETE, this);
        }, play: function(D) {
          if (D === undefined)
            D = true;
          if (this.paused = false, this.complete = false, this.totalComplete = 0, D)
            this.reset();
          return this;
        }, pause: function() {
          return this.paused = true, this;
        }, repeat: function(D) {
          if (D === undefined || D === true)
            D = -1;
          if (D === false)
            D = 0;
          return this.loop = D, this;
        }, resume: function() {
          return this.paused = false, this;
        }, stop: function() {
          return this.paused = true, this.complete = true, this;
        }, reset: function(D) {
          if (D === undefined)
            D = false;
          if (this.elapsed = 0, !D)
            this.iteration = 0;
          for (var Q = 0;Q < this.events.length; Q++)
            if (this.events[Q].complete = false, !D)
              this.events[Q].repeat = 0;
          return this.play(false);
        }, add: function(D) {
          if (!Array.isArray(D))
            D = [D];
          var Q = this.events, H = 0;
          if (Q.length > 0)
            H = Q[Q.length - 1].time;
          for (var N = 0;N < D.length; N++) {
            var W = D[N], R = U(W, "at", 0), Y = U(W, "in", null);
            if (Y !== null)
              R = this.elapsed + Y;
            var I = U(W, "from", null);
            if (I !== null)
              R = H + I;
            Q.push({ complete: false, time: R, repeat: 0, if: U(W, "if", null), run: U(W, "run", null), loop: U(W, "loop", null), event: U(W, "event", null), target: U(W, "target", null), set: U(W, "set", null), tween: U(W, "tween", null), sound: U(W, "sound", null), once: U(W, "once", false), stop: U(W, "stop", false) }), H = R;
          }
          return this.complete = false, this;
        }, clear: function() {
          return this.events = [], this.elapsed = 0, this.paused = true, this;
        }, isPlaying: function() {
          return !this.paused && !this.complete;
        }, getProgress: function() {
          var D = Math.min(this.totalComplete, this.events.length);
          return D / this.events.length;
        }, destroy: function() {
          var D = this.systems.events;
          D.off(K.PRE_UPDATE, this.preUpdate, this), D.off(K.UPDATE, this.update, this), D.off(K.SHUTDOWN, this.destroy, this), this.scene = null, this.systems = null, this.events = [];
        } });
        z.register("timeline", function(D) {
          return new Z(this.scene, D);
        }), M.exports = Z;
      }, 94880: (M, B, $) => {
        var E = $(83419), L = $(95540), z = new E({ initialize: function U(K) {
          this.delay = 0, this.repeat = 0, this.repeatCount = 0, this.loop = false, this.callback, this.callbackScope, this.args, this.timeScale = 1, this.startAt = 0, this.elapsed = 0, this.paused = false, this.hasDispatched = false, this.reset(K);
        }, reset: function(U) {
          if (this.delay = L(U, "delay", 0), this.repeat = L(U, "repeat", 0), this.loop = L(U, "loop", false), this.callback = L(U, "callback", undefined), this.callbackScope = L(U, "callbackScope", this), this.args = L(U, "args", []), this.timeScale = L(U, "timeScale", 1), this.startAt = L(U, "startAt", 0), this.paused = L(U, "paused", false), this.elapsed = this.startAt, this.hasDispatched = false, this.repeatCount = this.repeat === -1 || this.loop ? 999999999999 : this.repeat, this.delay === 0 && (this.repeat > 0 || this.loop))
            throw new Error("TimerEvent infinite loop created via zero delay");
          return this;
        }, getProgress: function() {
          return this.elapsed / this.delay;
        }, getOverallProgress: function() {
          if (this.repeat > 0) {
            var U = this.delay + this.delay * this.repeat, K = this.elapsed + this.delay * (this.repeat - this.repeatCount);
            return K / U;
          } else
            return this.getProgress();
        }, getRepeatCount: function() {
          return this.repeatCount;
        }, getElapsed: function() {
          return this.elapsed;
        }, getElapsedSeconds: function() {
          return this.elapsed * 0.001;
        }, getRemaining: function() {
          return this.delay - this.elapsed;
        }, getRemainingSeconds: function() {
          return this.getRemaining() * 0.001;
        }, getOverallRemaining: function() {
          return this.delay * (1 + this.repeatCount) - this.elapsed;
        }, getOverallRemainingSeconds: function() {
          return this.getOverallRemaining() * 0.001;
        }, remove: function(U) {
          if (U === undefined)
            U = false;
          this.elapsed = this.delay, this.hasDispatched = !U, this.repeatCount = 0;
        }, destroy: function() {
          this.callback = undefined, this.callbackScope = undefined, this.args = [];
        } });
        M.exports = z;
      }, 35945: (M) => {
        M.exports = "complete";
      }, 89809: (M, B, $) => {
        M.exports = { COMPLETE: $(35945) };
      }, 90291: (M, B, $) => {
        M.exports = { Clock: $(33385), Events: $(89809), Timeline: $(96120), TimerEvent: $(94880) };
      }, 40382: (M, B, $) => {
        var E = $(72905), L = $(83419), z = $(43491), U = $(88032), K = $(37277), J = $(44594), Z = $(93109), D = $(86081), Q = $(8357), H = $(43960), N = $(26012), W = new L({ initialize: function R(Y) {
          this.scene = Y, this.events = Y.sys.events, this.timeScale = 1, this.paused = false, this.processing = false, this.tweens = [], this.time = 0, this.startTime = 0, this.nextTime = 0, this.prevTime = 0, this.maxLag = 500, this.lagSkip = 33, this.gap = 4.166666666666667, this.events.once(J.BOOT, this.boot, this), this.events.on(J.START, this.start, this);
        }, boot: function() {
          this.events.once(J.DESTROY, this.destroy, this);
        }, start: function() {
          this.timeScale = 1, this.paused = false, this.startTime = Date.now(), this.prevTime = this.startTime, this.nextTime = this.gap, this.events.on(J.UPDATE, this.update, this), this.events.once(J.SHUTDOWN, this.shutdown, this);
        }, create: function(R) {
          if (!Array.isArray(R))
            R = [R];
          var Y = [];
          for (var I = 0;I < R.length; I++) {
            var P = R[I];
            if (P instanceof D || P instanceof H)
              Y.push(P);
            else if (Array.isArray(P.tweens))
              Y.push(N(this, P));
            else
              Y.push(Q(this, P));
          }
          return Y.length === 1 ? Y[0] : Y;
        }, add: function(R) {
          var Y = R, I = this.tweens;
          if (Y instanceof D || Y instanceof H)
            I.push(Y.reset());
          else {
            if (Array.isArray(Y.tweens))
              Y = N(this, Y);
            else
              Y = Q(this, Y);
            I.push(Y.reset());
          }
          return Y;
        }, addMultiple: function(R) {
          var Y, I = [], P = this.tweens;
          for (var X = 0;X < R.length; X++) {
            if (Y = R[X], Y instanceof D || Y instanceof H)
              P.push(Y.reset());
            else {
              if (Array.isArray(Y.tweens))
                Y = N(this, Y);
              else
                Y = Q(this, Y);
              P.push(Y.reset());
            }
            I.push(Y);
          }
          return I;
        }, chain: function(R) {
          var Y = N(this, R);
          return this.tweens.push(Y.init()), Y;
        }, getChainedTweens: function(R) {
          return R.getChainedTweens();
        }, has: function(R) {
          return this.tweens.indexOf(R) > -1;
        }, existing: function(R) {
          if (!this.has(R))
            this.tweens.push(R.reset());
          return this;
        }, addCounter: function(R) {
          var Y = U(this, R);
          return this.tweens.push(Y.reset()), Y;
        }, stagger: function(R, Y) {
          return Z(R, Y);
        }, setLagSmooth: function(R, Y) {
          if (R === undefined)
            R = 1e8;
          if (Y === undefined)
            Y = 0;
          return this.maxLag = R, this.lagSkip = Math.min(Y, this.maxLag), this;
        }, setFps: function(R) {
          if (R === undefined)
            R = 240;
          return this.gap = 1000 / R, this.nextTime = this.time * 1000 + this.gap, this;
        }, getDelta: function(R) {
          var Y = Date.now() - this.prevTime;
          if (Y > this.maxLag)
            this.startTime += Y - this.lagSkip;
          this.prevTime += Y;
          var I = this.prevTime - this.startTime, P = I - this.nextTime, X = I - this.time * 1000;
          if (P > 0 || R)
            I /= 1000, this.time = I, this.nextTime += P + (P >= this.gap ? 4 : this.gap - P);
          else
            X = 0;
          return X;
        }, tick: function() {
          return this.step(true), this;
        }, update: function() {
          if (!this.paused)
            this.step(false);
        }, step: function(R) {
          if (R === undefined)
            R = false;
          var Y = this.getDelta(R);
          if (Y <= 0)
            return;
          this.processing = true;
          var I, P, X = [], G = this.tweens;
          for (I = 0;I < G.length; I++)
            if (P = G[I], P.update(Y))
              X.push(P);
          var V = X.length;
          if (V && G.length > 0) {
            for (I = 0;I < V; I++) {
              P = X[I];
              var A = G.indexOf(P);
              if (A > -1 && (P.isPendingRemove() || P.isDestroyed()))
                G.splice(A, 1), P.destroy();
            }
            X.length = 0;
          }
          this.processing = false;
        }, remove: function(R) {
          if (this.processing)
            R.setPendingRemoveState();
          else
            E(this.tweens, R), R.setRemovedState();
          return this;
        }, reset: function(R) {
          return this.existing(R), R.seek(), R.setActiveState(), this;
        }, makeActive: function(R) {
          return this.existing(R), R.setActiveState(), this;
        }, each: function(R, Y) {
          var I, P = [null];
          for (I = 1;I < arguments.length; I++)
            P.push(arguments[I]);
          return this.tweens.forEach(function(X) {
            P[0] = X, R.apply(Y, P);
          }), this;
        }, getTweens: function() {
          return this.tweens.slice();
        }, getTweensOf: function(R) {
          var Y = [], I = this.tweens;
          if (!Array.isArray(R))
            R = [R];
          else
            R = z(R);
          var P = R.length;
          for (var X = 0;X < I.length; X++) {
            var G = I[X];
            for (var V = 0;V < P; V++)
              if (!G.isDestroyed() && G.hasTarget(R[V]))
                Y.push(G);
          }
          return Y;
        }, getGlobalTimeScale: function() {
          return this.timeScale;
        }, setGlobalTimeScale: function(R) {
          return this.timeScale = R, this;
        }, isTweening: function(R) {
          var Y = this.tweens, I;
          for (var P = 0;P < Y.length; P++)
            if (I = Y[P], I.isPlaying() && I.hasTarget(R))
              return true;
          return false;
        }, killAll: function() {
          var R = this.processing ? this.getTweens() : this.tweens;
          for (var Y = 0;Y < R.length; Y++)
            R[Y].destroy();
          if (!this.processing)
            R.length = 0;
          return this;
        }, killTweensOf: function(R) {
          var Y = this.getTweensOf(R);
          for (var I = 0;I < Y.length; I++)
            Y[I].destroy();
          return this;
        }, pauseAll: function() {
          return this.paused = true, this;
        }, resumeAll: function() {
          return this.paused = false, this;
        }, shutdown: function() {
          this.killAll(), this.tweens = [], this.events.off(J.UPDATE, this.update, this), this.events.off(J.SHUTDOWN, this.shutdown, this);
        }, destroy: function() {
          this.shutdown(), this.events.off(J.START, this.start, this), this.scene = null, this.events = null;
        } });
        K.register("TweenManager", W, "tweens"), M.exports = W;
      }, 57355: (M) => {
        var B = function($, E, L) {
          if (!$)
            return L;
          else if ($.hasOwnProperty(E))
            return $[E];
          else
            return L;
        };
        M.exports = B;
      }, 6113: (M, B, $) => {
        var E = $(62640), L = $(35355), z = function(U, K) {
          var J = E.Power0;
          if (typeof U === "string")
            if (E.hasOwnProperty(U))
              J = E[U];
            else {
              var Z = "";
              if (U.indexOf(".")) {
                Z = U.substring(U.indexOf(".") + 1);
                var D = Z.toLowerCase();
                if (D === "in")
                  Z = "easeIn";
                else if (D === "out")
                  Z = "easeOut";
                else if (D === "inout")
                  Z = "easeInOut";
              }
              if (U = L(U.substring(0, U.indexOf(".") + 1) + Z), E.hasOwnProperty(U))
                J = E[U];
            }
          else if (typeof U === "function")
            J = U;
          if (!K)
            return J;
          var Q = K.slice(0);
          return Q.unshift(0), function(H) {
            return Q[0] = H, J.apply(this, Q);
          };
        };
        M.exports = z;
      }, 91389: (M, B, $) => {
        var E = $(89318), L = $(77259), z = $(28392), U = { bezier: E, catmull: L, catmullrom: L, linear: z }, K = function(J) {
          if (J === null)
            return null;
          var Z = U.linear;
          if (typeof J === "string") {
            if (U.hasOwnProperty(J))
              Z = U[J];
          } else if (typeof J === "function")
            Z = J;
          return Z;
        };
        M.exports = K;
      }, 55292: (M) => {
        var B = function($, E, L) {
          var z;
          if ($.hasOwnProperty(E)) {
            var U = typeof $[E];
            if (U === "function")
              z = function(K, J, Z, D, Q, H) {
                return $[E](K, J, Z, D, Q, H);
              };
            else
              z = function() {
                return $[E];
              };
          } else if (typeof L === "function")
            z = L;
          else
            z = function() {
              return L;
            };
          return z;
        };
        M.exports = B;
      }, 82985: (M, B, $) => {
        var E = $(81076), L = function(z) {
          var U, K = [];
          if (z.hasOwnProperty("props")) {
            for (U in z.props)
              if (U.substring(0, 1) !== "_")
                K.push({ key: U, value: z.props[U] });
          } else
            for (U in z)
              if (E.indexOf(U) === -1 && U.substring(0, 1) !== "_")
                K.push({ key: U, value: z[U] });
          return K;
        };
        M.exports = L;
      }, 62329: (M, B, $) => {
        var E = $(35154), L = function(z) {
          var U = E(z, "targets", null);
          if (U === null)
            return U;
          if (typeof U === "function")
            U = U.call();
          if (!Array.isArray(U))
            U = [U];
          return U;
        };
        M.exports = L;
      }, 17777: (M, B, $) => {
        var E = $(30976), L = $(99472);
        function z(D) {
          return !!D.getActive && typeof D.getActive === "function";
        }
        function U(D) {
          return !!D.getStart && typeof D.getStart === "function";
        }
        function K(D) {
          return !!D.getEnd && typeof D.getEnd === "function";
        }
        function J(D) {
          return U(D) || K(D) || z(D);
        }
        var Z = function(D, Q) {
          var H, N = function(g, b, x) {
            return x;
          }, W = function(g, b, x) {
            return x;
          }, R = null, Y = typeof Q;
          if (Y === "number")
            N = function() {
              return Q;
            };
          else if (Array.isArray(Q))
            W = function() {
              return Q[0];
            }, N = function() {
              return Q[Q.length - 1];
            };
          else if (Y === "string") {
            var I = Q.toLowerCase(), P = I.substring(0, 6) === "random", X = I.substring(0, 3) === "int";
            if (P || X) {
              var G = I.indexOf("("), V = I.indexOf(")"), A = I.indexOf(",");
              if (G && V && A) {
                var F = parseFloat(I.substring(G + 1, A)), j = parseFloat(I.substring(A + 1, V));
                if (P)
                  N = function() {
                    return L(F, j);
                  };
                else
                  N = function() {
                    return E(F, j);
                  };
              } else
                throw new Error("invalid random() format");
            } else {
              I = I[0];
              var T = parseFloat(Q.substr(2));
              switch (I) {
                case "+":
                  N = function(g, b, x) {
                    return x + T;
                  };
                  break;
                case "-":
                  N = function(g, b, x) {
                    return x - T;
                  };
                  break;
                case "*":
                  N = function(g, b, x) {
                    return x * T;
                  };
                  break;
                case "/":
                  N = function(g, b, x) {
                    return x / T;
                  };
                  break;
                default:
                  N = function() {
                    return parseFloat(Q);
                  };
              }
            }
          } else if (Y === "function")
            N = Q;
          else if (Y === "object")
            if (J(Q)) {
              if (z(Q))
                R = Q.getActive;
              if (K(Q))
                N = Q.getEnd;
              if (U(Q))
                W = Q.getStart;
            } else if (Q.hasOwnProperty("value"))
              H = Z(D, Q.value);
            else {
              var C = Q.hasOwnProperty("to"), v = Q.hasOwnProperty("from"), O = Q.hasOwnProperty("start");
              if (C && (v || O)) {
                if (H = Z(D, Q.to), O) {
                  var q = Z(D, Q.start);
                  H.getActive = q.getEnd;
                }
                if (v) {
                  var w = Z(D, Q.from);
                  H.getStart = w.getEnd;
                }
              }
            }
          if (!H)
            H = { getActive: R, getEnd: N, getStart: W };
          return H;
        };
        M.exports = Z;
      }, 88032: (M, B, $) => {
        var E = $(70402), L = $(69902), z = $(23568), U = $(57355), K = $(6113), J = $(55292), Z = $(35154), D = $(17777), Q = $(269), H = $(86081), N = function(W, R, Y) {
          if (R instanceof H)
            return R.parent = W, R;
          if (Y === undefined)
            Y = L;
          else
            Y = Q(L, Y);
          var I = Z(R, "from", 0), P = Z(R, "to", 1), X = [{ value: I }], G = Z(R, "delay", Y.delay), V = Z(R, "easeParams", Y.easeParams), A = Z(R, "ease", Y.ease), F = D("value", P), j = new H(W, X), T = j.add(0, "value", F.getEnd, F.getStart, F.getActive, K(Z(R, "ease", A), Z(R, "easeParams", V)), J(R, "delay", G), Z(R, "duration", Y.duration), U(R, "yoyo", Y.yoyo), Z(R, "hold", Y.hold), Z(R, "repeat", Y.repeat), Z(R, "repeatDelay", Y.repeatDelay), false, false);
          T.start = I, T.current = I, j.completeDelay = z(R, "completeDelay", 0), j.loop = Math.round(z(R, "loop", 0)), j.loopDelay = Math.round(z(R, "loopDelay", 0)), j.paused = U(R, "paused", false), j.persist = U(R, "persist", false), j.callbackScope = Z(R, "callbackScope", j);
          var C = E.TYPES;
          for (var v = 0;v < C.length; v++) {
            var O = C[v], q = Z(R, O, false);
            if (q) {
              var w = Z(R, O + "Params", []);
              j.setCallback(O, q, w);
            }
          }
          return j;
        };
        M.exports = N;
      }, 93109: (M, B, $) => {
        var E = $(6113), L = $(35154), z = $(36383), U = function(K, J) {
          if (J === undefined)
            J = {};
          var Z, D = L(J, "start", 0), Q = L(J, "ease", null), H = L(J, "grid", null), N = L(J, "from", 0), W = N === "first", R = N === "center", Y = N === "last", I = typeof N === "number", P = Array.isArray(K), X = P ? parseFloat(K[0]) : parseFloat(K), G = P ? parseFloat(K[1]) : 0, V = Math.max(X, G);
          if (P)
            D += X;
          if (H) {
            var A = H[0], F = H[1], j = 0, T = 0, C = 0, v = 0, O = [];
            if (Y)
              j = A - 1, T = F - 1;
            else if (I)
              j = N % A, T = Math.floor(N / A);
            else if (R)
              j = (A - 1) / 2, T = (F - 1) / 2;
            var q = z.MIN_SAFE_INTEGER;
            for (var w = 0;w < F; w++) {
              O[w] = [];
              for (var g = 0;g < A; g++) {
                C = j - g, v = T - w;
                var b = Math.sqrt(C * C + v * v);
                if (b > q)
                  q = b;
                O[w][g] = b;
              }
            }
          }
          var x = Q ? E(Q) : null;
          if (H)
            Z = function(k, S, f, h) {
              var m = 0, y = h % A, d = Math.floor(h / A);
              if (y >= 0 && y < A && d >= 0 && d < F)
                m = O[d][y];
              var p;
              if (P) {
                var u = G - X;
                if (x)
                  p = m / q * u * x(m / q);
                else
                  p = m / q * u;
              } else if (x)
                p = m * X * x(m / q);
              else
                p = m * X;
              return p + D;
            };
          else
            Z = function(k, S, f, h, m) {
              m--;
              var y;
              if (W)
                y = h;
              else if (R)
                y = Math.abs(m / 2 - h);
              else if (Y)
                y = m - h;
              else if (I)
                y = Math.abs(N - h);
              var d;
              if (P) {
                var p;
                if (R)
                  p = (G - X) / m * (y * 2);
                else
                  p = (G - X) / m * y;
                if (x)
                  d = p * x(y / m);
                else
                  d = p;
              } else if (x)
                d = m * V * x(y / m);
              else
                d = y * X;
              return d + D;
            };
          return Z;
        };
        M.exports = U;
      }, 8357: (M, B, $) => {
        var E = $(70402), L = $(69902), z = $(23568), U = $(57355), K = $(6113), J = $(91389), Z = $(55292), D = $(82985), Q = $(62329), H = $(35154), N = $(17777), W = $(269), R = $(86081), Y = function(I, P, X) {
          if (P instanceof R)
            return P.parent = I, P;
          if (X === undefined)
            X = L;
          else
            X = W(L, X);
          var G = Q(P);
          if (!G && X.targets)
            G = X.targets;
          var V = D(P), A = H(P, "delay", X.delay), F = H(P, "duration", X.duration), j = H(P, "easeParams", X.easeParams), T = H(P, "ease", X.ease), C = H(P, "hold", X.hold), v = H(P, "repeat", X.repeat), O = H(P, "repeatDelay", X.repeatDelay), q = U(P, "yoyo", X.yoyo), w = U(P, "flipX", X.flipX), g = U(P, "flipY", X.flipY), b = H(P, "interpolation", X.interpolation), x = function(c, n, _, l) {
            if (_ === "texture") {
              var i = l, t = undefined;
              if (Array.isArray(l))
                i = l[0], t = l[1];
              else if (l.hasOwnProperty("value")) {
                if (i = l.value, Array.isArray(l.value))
                  i = l.value[0], t = l.value[1];
                else if (typeof l.value === "string")
                  i = l.value;
              } else if (typeof l === "string")
                i = l;
              c.addFrame(n, i, t, Z(l, "delay", A), H(l, "duration", F), H(l, "hold", C), H(l, "repeat", v), H(l, "repeatDelay", O), U(l, "flipX", w), U(l, "flipY", g));
            } else {
              var $0 = N(_, l), e = J(H(l, "interpolation", b));
              c.add(n, _, $0.getEnd, $0.getStart, $0.getActive, K(H(l, "ease", T), H(l, "easeParams", j)), Z(l, "delay", A), H(l, "duration", F), U(l, "yoyo", q), H(l, "hold", C), H(l, "repeat", v), H(l, "repeatDelay", O), U(l, "flipX", w), U(l, "flipY", g), e, e ? l : null);
            }
          }, k = new R(I, G);
          for (var S = 0;S < V.length; S++) {
            var f = V[S].key, h = V[S].value;
            for (var m = 0;m < G.length; m++)
              if (f === "scale" && !G[m].hasOwnProperty("scale"))
                x(k, m, "scaleX", h), x(k, m, "scaleY", h);
              else
                x(k, m, f, h);
          }
          k.completeDelay = z(P, "completeDelay", 0), k.loop = Math.round(z(P, "loop", 0)), k.loopDelay = Math.round(z(P, "loopDelay", 0)), k.paused = U(P, "paused", false), k.persist = U(P, "persist", false), k.callbackScope = H(P, "callbackScope", k);
          var y = E.TYPES;
          for (var d = 0;d < y.length; d++) {
            var p = y[d], u = H(P, p, false);
            if (u) {
              var s = H(P, p + "Params", []);
              k.setCallback(p, u, s);
            }
          }
          return k;
        };
        M.exports = Y;
      }, 26012: (M, B, $) => {
        var E = $(70402), L = $(23568), z = $(57355), U = $(62329), K = $(35154), J = $(8357), Z = $(43960), D = function(Q, H) {
          if (H instanceof Z)
            return H.parent = Q, H;
          var N = new Z(Q);
          N.startDelay = K(H, "delay", 0), N.completeDelay = L(H, "completeDelay", 0), N.loop = Math.round(L(H, "loop", K(H, "repeat", 0))), N.loopDelay = Math.round(L(H, "loopDelay", K(H, "repeatDelay", 0))), N.paused = z(H, "paused", false), N.persist = z(H, "persist", false), N.callbackScope = K(H, "callbackScope", N);
          var W, R = E.TYPES;
          for (W = 0;W < R.length; W++) {
            var Y = R[W], I = K(H, Y, false);
            if (I) {
              var P = K(H, Y + "Params", []);
              N.setCallback(Y, I, P);
            }
          }
          var X = K(H, "tweens", null);
          if (Array.isArray(X)) {
            var G = [], V = U(H), A = undefined;
            if (V)
              A = { targets: V };
            for (W = 0;W < X.length; W++)
              G.push(J(N, X[W], A));
            N.add(G);
          }
          return N;
        };
        M.exports = D;
      }, 30231: (M, B, $) => {
        M.exports = { GetBoolean: $(57355), GetEaseFunction: $(6113), GetInterpolationFunction: $(91389), GetNewValue: $(55292), GetProps: $(82985), GetTargets: $(62329), GetValueOp: $(17777), NumberTweenBuilder: $(88032), StaggerBuilder: $(93109), TweenBuilder: $(8357) };
      }, 73685: (M) => {
        M.exports = "active";
      }, 98540: (M) => {
        M.exports = "complete";
      }, 67233: (M) => {
        M.exports = "loop";
      }, 2859: (M) => {
        M.exports = "pause";
      }, 98336: (M) => {
        M.exports = "repeat";
      }, 25764: (M) => {
        M.exports = "resume";
      }, 32193: (M) => {
        M.exports = "start";
      }, 84371: (M) => {
        M.exports = "stop";
      }, 70766: (M) => {
        M.exports = "update";
      }, 55659: (M) => {
        M.exports = "yoyo";
      }, 842: (M, B, $) => {
        M.exports = { TWEEN_ACTIVE: $(73685), TWEEN_COMPLETE: $(98540), TWEEN_LOOP: $(67233), TWEEN_PAUSE: $(2859), TWEEN_RESUME: $(25764), TWEEN_REPEAT: $(98336), TWEEN_START: $(32193), TWEEN_STOP: $(84371), TWEEN_UPDATE: $(70766), TWEEN_YOYO: $(55659) };
      }, 43066: (M, B, $) => {
        var E = { States: $(86353), Builders: $(30231), Events: $(842), TweenManager: $(40382), Tween: $(86081), TweenData: $(48177), TweenFrameData: $(42220), BaseTween: $(70402), TweenChain: $(43960) };
        M.exports = E;
      }, 70402: (M, B, $) => {
        var E = $(83419), L = $(50792), z = $(842), U = $(86353), K = new E({ Extends: L, initialize: function J(Z) {
          L.call(this), this.parent = Z, this.data = [], this.totalData = 0, this.startDelay = 0, this.hasStarted = false, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.completeDelay = 0, this.countdown = 0, this.state = U.PENDING, this.paused = false, this.callbacks = { onActive: null, onComplete: null, onLoop: null, onPause: null, onRepeat: null, onResume: null, onStart: null, onStop: null, onUpdate: null, onYoyo: null }, this.callbackScope, this.persist = false;
        }, setTimeScale: function(J) {
          return this.timeScale = J, this;
        }, getTimeScale: function() {
          return this.timeScale;
        }, isPlaying: function() {
          return !this.paused && this.isActive();
        }, isPaused: function() {
          return this.paused;
        }, pause: function() {
          if (!this.paused)
            this.paused = true, this.dispatchEvent(z.TWEEN_PAUSE, "onPause");
          return this;
        }, resume: function() {
          if (this.paused)
            this.paused = false, this.dispatchEvent(z.TWEEN_RESUME, "onResume");
          return this;
        }, makeActive: function() {
          this.parent.makeActive(this), this.dispatchEvent(z.TWEEN_ACTIVE, "onActive");
        }, onCompleteHandler: function() {
          this.setPendingRemoveState(), this.dispatchEvent(z.TWEEN_COMPLETE, "onComplete");
        }, complete: function(J) {
          if (J === undefined)
            J = 0;
          if (J)
            this.setCompleteDelayState(), this.countdown = J;
          else
            this.onCompleteHandler();
          return this;
        }, completeAfterLoop: function(J) {
          if (J === undefined)
            J = 0;
          if (this.loopCounter > J)
            this.loopCounter = J;
          return this;
        }, remove: function() {
          if (this.parent)
            this.parent.remove(this);
          return this;
        }, stop: function() {
          if (this.parent && !this.isRemoved() && !this.isPendingRemove() && !this.isDestroyed())
            this.dispatchEvent(z.TWEEN_STOP, "onStop"), this.setPendingRemoveState();
          return this;
        }, updateLoopCountdown: function(J) {
          if (this.countdown -= J, this.countdown <= 0)
            this.setActiveState(), this.dispatchEvent(z.TWEEN_LOOP, "onLoop");
        }, updateStartCountdown: function(J) {
          if (this.countdown -= J, this.countdown <= 0)
            this.hasStarted = true, this.setActiveState(), this.dispatchEvent(z.TWEEN_START, "onStart"), J = 0;
          return J;
        }, updateCompleteDelay: function(J) {
          if (this.countdown -= J, this.countdown <= 0)
            this.onCompleteHandler();
        }, setCallback: function(J, Z, D) {
          if (D === undefined)
            D = [];
          if (this.callbacks.hasOwnProperty(J))
            this.callbacks[J] = { func: Z, params: D };
          return this;
        }, setPendingState: function() {
          this.state = U.PENDING;
        }, setActiveState: function() {
          this.state = U.ACTIVE;
        }, setLoopDelayState: function() {
          this.state = U.LOOP_DELAY;
        }, setCompleteDelayState: function() {
          this.state = U.COMPLETE_DELAY;
        }, setStartDelayState: function() {
          this.state = U.START_DELAY, this.countdown = this.startDelay, this.hasStarted = false;
        }, setPendingRemoveState: function() {
          this.state = U.PENDING_REMOVE;
        }, setRemovedState: function() {
          this.state = U.REMOVED;
        }, setFinishedState: function() {
          this.state = U.FINISHED;
        }, setDestroyedState: function() {
          this.state = U.DESTROYED;
        }, isPending: function() {
          return this.state === U.PENDING;
        }, isActive: function() {
          return this.state === U.ACTIVE;
        }, isLoopDelayed: function() {
          return this.state === U.LOOP_DELAY;
        }, isCompleteDelayed: function() {
          return this.state === U.COMPLETE_DELAY;
        }, isStartDelayed: function() {
          return this.state === U.START_DELAY;
        }, isPendingRemove: function() {
          return this.state === U.PENDING_REMOVE;
        }, isRemoved: function() {
          return this.state === U.REMOVED;
        }, isFinished: function() {
          return this.state === U.FINISHED;
        }, isDestroyed: function() {
          return this.state === U.DESTROYED;
        }, destroy: function() {
          if (this.data)
            this.data.forEach(function(J) {
              J.destroy();
            });
          this.removeAllListeners(), this.callbacks = null, this.data = null, this.parent = null, this.setDestroyedState();
        } });
        K.TYPES = ["onActive", "onComplete", "onLoop", "onPause", "onRepeat", "onResume", "onStart", "onStop", "onUpdate", "onYoyo"], M.exports = K;
      }, 95042: (M, B, $) => {
        var E = $(83419), L = $(842), z = $(86353), U = new E({ initialize: function K(J, Z, D, Q, H, N, W, R, Y, I) {
          this.tween = J, this.targetIndex = Z, this.duration = Q, this.totalDuration = 0, this.delay = 0, this.getDelay = D, this.yoyo = H, this.hold = N, this.repeat = W, this.repeatDelay = R, this.repeatCounter = 0, this.flipX = Y, this.flipY = I, this.progress = 0, this.elapsed = 0, this.state = 0, this.isCountdown = false;
        }, getTarget: function() {
          return this.tween.targets[this.targetIndex];
        }, setTargetValue: function(K) {
          if (K === undefined)
            K = this.current;
          this.tween.targets[this.targetIndex][this.key] = K;
        }, setCreatedState: function() {
          this.state = z.CREATED, this.isCountdown = false;
        }, setDelayState: function() {
          this.state = z.DELAY, this.isCountdown = true;
        }, setPendingRenderState: function() {
          this.state = z.PENDING_RENDER, this.isCountdown = false;
        }, setPlayingForwardState: function() {
          this.state = z.PLAYING_FORWARD, this.isCountdown = false;
        }, setPlayingBackwardState: function() {
          this.state = z.PLAYING_BACKWARD, this.isCountdown = false;
        }, setHoldState: function() {
          this.state = z.HOLD_DELAY, this.isCountdown = true;
        }, setRepeatState: function() {
          this.state = z.REPEAT_DELAY, this.isCountdown = true;
        }, setCompleteState: function() {
          this.state = z.COMPLETE, this.isCountdown = false;
        }, isCreated: function() {
          return this.state === z.CREATED;
        }, isDelayed: function() {
          return this.state === z.DELAY;
        }, isPendingRender: function() {
          return this.state === z.PENDING_RENDER;
        }, isPlayingForward: function() {
          return this.state === z.PLAYING_FORWARD;
        }, isPlayingBackward: function() {
          return this.state === z.PLAYING_BACKWARD;
        }, isHolding: function() {
          return this.state === z.HOLD_DELAY;
        }, isRepeating: function() {
          return this.state === z.REPEAT_DELAY;
        }, isComplete: function() {
          return this.state === z.COMPLETE;
        }, setStateFromEnd: function(K) {
          if (this.yoyo)
            this.onRepeat(K, true, true);
          else if (this.repeatCounter > 0)
            this.onRepeat(K, true, false);
          else
            this.setCompleteState();
        }, setStateFromStart: function(K) {
          if (this.repeatCounter > 0)
            this.onRepeat(K, false);
          else
            this.setCompleteState();
        }, reset: function() {
          var K = this.tween, J = K.totalTargets, Z = this.targetIndex, D = K.targets[Z], Q = this.key;
          this.progress = 0, this.elapsed = 0, this.delay = this.getDelay(D, Q, 0, Z, J, K), this.repeatCounter = this.repeat === -1 ? z.MAX : this.repeat, this.setPendingRenderState();
          var H = this.duration + this.hold;
          if (this.yoyo)
            H += this.duration;
          var N = H + this.repeatDelay;
          if (this.totalDuration = this.delay + H, this.repeat === -1)
            this.totalDuration += N * z.MAX, K.isInfinite = true;
          else if (this.repeat > 0)
            this.totalDuration += N * this.repeat;
          if (this.totalDuration > K.duration)
            K.duration = this.totalDuration;
          if (this.delay < K.startDelay)
            K.startDelay = this.delay;
          if (this.delay > 0)
            this.elapsed = this.delay, this.setDelayState();
        }, onRepeat: function(K, J, Z) {
          var D = this.tween, Q = D.totalTargets, H = this.targetIndex, N = D.targets[H], W = this.key, R = W !== "texture";
          if (this.elapsed = K, this.progress = K / this.duration, this.flipX)
            N.toggleFlipX();
          if (this.flipY)
            N.toggleFlipY();
          if (R && (J || Z))
            this.start = this.getStartValue(N, W, this.start, H, Q, D);
          if (Z) {
            this.setPlayingBackwardState(), this.dispatchEvent(L.TWEEN_YOYO, "onYoyo");
            return;
          }
          if (this.repeatCounter--, R)
            this.end = this.getEndValue(N, W, this.start, H, Q, D);
          if (this.repeatDelay > 0) {
            if (this.elapsed = this.repeatDelay - K, R)
              this.current = this.start, N[W] = this.current;
            this.setRepeatState();
          } else
            this.setPlayingForwardState(), this.dispatchEvent(L.TWEEN_REPEAT, "onRepeat");
        }, destroy: function() {
          this.tween = null, this.getDelay = null, this.setCompleteState();
        } });
        M.exports = U;
      }, 69902: (M) => {
        var B = { targets: null, delay: 0, duration: 1000, ease: "Power0", easeParams: null, hold: 0, repeat: 0, repeatDelay: 0, yoyo: false, flipX: false, flipY: false, persist: false, interpolation: null };
        M.exports = B;
      }, 81076: (M) => {
        M.exports = ["callbackScope", "completeDelay", "delay", "duration", "ease", "easeParams", "flipX", "flipY", "hold", "interpolation", "loop", "loopDelay", "onActive", "onActiveParams", "onComplete", "onCompleteParams", "onLoop", "onLoopParams", "onPause", "onPauseParams", "onRepeat", "onRepeatParams", "onResume", "onResumeParams", "onStart", "onStartParams", "onStop", "onStopParams", "onUpdate", "onUpdateParams", "onYoyo", "onYoyoParams", "paused", "persist", "props", "repeat", "repeatDelay", "targets", "yoyo"];
      }, 86081: (M, B, $) => {
        var E = $(70402), L = $(83419), z = $(842), U = $(44603), K = $(39429), J = $(36383), Z = $(86353), D = $(48177), Q = $(42220), H = new L({ Extends: E, initialize: function N(W, R) {
          E.call(this, W), this.targets = R, this.totalTargets = R.length, this.isSeeking = false, this.isInfinite = false, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0;
        }, add: function(N, W, R, Y, I, P, X, G, V, A, F, j, T, C, v, O) {
          var q = new D(this, N, W, R, Y, I, P, X, G, V, A, F, j, T, C, v, O);
          return this.totalData = this.data.push(q), q;
        }, addFrame: function(N, W, R, Y, I, P, X, G, V, A) {
          var F = new Q(this, N, W, R, Y, I, P, X, G, V, A);
          return this.totalData = this.data.push(F), F;
        }, getValue: function(N) {
          if (N === undefined)
            N = 0;
          var W = null;
          if (this.data)
            W = this.data[N].current;
          return W;
        }, hasTarget: function(N) {
          return this.targets && this.targets.indexOf(N) !== -1;
        }, updateTo: function(N, W, R) {
          if (R === undefined)
            R = false;
          if (N !== "texture")
            for (var Y = 0;Y < this.totalData; Y++) {
              var I = this.data[Y];
              if (I.key === N && (I.isPlayingForward() || I.isPlayingBackward())) {
                if (I.end = W, R)
                  I.start = I.current;
              }
            }
          return this;
        }, restart: function() {
          switch (this.state) {
            case Z.REMOVED:
            case Z.FINISHED:
              this.seek(), this.parent.makeActive(this);
              break;
            case Z.PENDING:
            case Z.PENDING_REMOVE:
              this.parent.reset(this);
              break;
            case Z.DESTROYED:
              console.warn("Cannot restart destroyed Tween", this);
              break;
            default:
              this.seek();
              break;
          }
          return this.paused = false, this.hasStarted = false, this;
        }, nextState: function() {
          if (this.loopCounter > 0)
            if (this.elapsed = 0, this.progress = 0, this.loopCounter--, this.initTweenData(true), this.loopDelay > 0)
              this.countdown = this.loopDelay, this.setLoopDelayState();
            else
              this.setActiveState(), this.dispatchEvent(z.TWEEN_LOOP, "onLoop");
          else if (this.completeDelay > 0)
            this.countdown = this.completeDelay, this.setCompleteDelayState();
          else
            return this.onCompleteHandler(), true;
          return false;
        }, onCompleteHandler: function() {
          this.progress = 1, this.totalProgress = 1, E.prototype.onCompleteHandler.call(this);
        }, play: function() {
          if (this.isDestroyed())
            return console.warn("Cannot play destroyed Tween", this), this;
          if (this.isPendingRemove() || this.isFinished())
            this.seek();
          return this.paused = false, this.setActiveState(), this;
        }, seek: function(N, W, R) {
          if (N === undefined)
            N = 0;
          if (W === undefined)
            W = 16.6;
          if (R === undefined)
            R = false;
          if (this.isDestroyed())
            return console.warn("Cannot seek destroyed Tween", this), this;
          if (!R)
            this.isSeeking = true;
          this.reset(true), this.initTweenData(true), this.setActiveState(), this.dispatchEvent(z.TWEEN_ACTIVE, "onActive");
          var Y = this.paused;
          if (this.paused = false, N > 0) {
            var I = Math.floor(N / W), P = N - I * W;
            for (var X = 0;X < I; X++)
              this.update(W);
            if (P > 0)
              this.update(P);
          }
          return this.paused = Y, this.isSeeking = false, this;
        }, initTweenData: function(N) {
          if (N === undefined)
            N = false;
          this.duration = 0, this.startDelay = J.MAX_SAFE_INTEGER;
          var W = this.data;
          for (var R = 0;R < this.totalData; R++)
            W[R].reset(N);
          this.duration = Math.max(this.duration, 0.01);
          var Y = this.duration, I = this.completeDelay, P = this.loopCounter, X = this.loopDelay;
          if (P > 0)
            this.totalDuration = Y + I + (Y + X) * P;
          else
            this.totalDuration = Y + I;
        }, reset: function(N) {
          if (N === undefined)
            N = false;
          if (this.elapsed = 0, this.totalElapsed = 0, this.progress = 0, this.totalProgress = 0, this.loopCounter = this.loop, this.loop === -1)
            this.isInfinite = true, this.loopCounter = Z.MAX;
          if (!N)
            this.initTweenData(), this.setActiveState(), this.dispatchEvent(z.TWEEN_ACTIVE, "onActive");
          return this;
        }, update: function(N) {
          if (this.isPendingRemove() || this.isDestroyed())
            return true;
          else if (this.paused || this.isFinished())
            return false;
          if (N *= this.timeScale * this.parent.timeScale, this.isLoopDelayed())
            return this.updateLoopCountdown(N), false;
          else if (this.isCompleteDelayed())
            return this.updateCompleteDelay(N), false;
          else if (!this.hasStarted) {
            if (this.startDelay -= N, this.startDelay <= 0)
              this.hasStarted = true, this.dispatchEvent(z.TWEEN_START, "onStart"), N = 0;
          }
          var W = false;
          if (this.isActive()) {
            var R = this.data;
            for (var Y = 0;Y < this.totalData; Y++)
              if (R[Y].update(N))
                W = true;
          }
          if (this.elapsed += N, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += N, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), !W)
            this.nextState();
          var I = this.isPendingRemove();
          if (I && this.persist)
            this.setFinishedState(), I = false;
          return I;
        }, forward: function(N) {
          return this.update(N), this;
        }, rewind: function(N) {
          return this.update(-N), this;
        }, dispatchEvent: function(N, W) {
          if (!this.isSeeking) {
            this.emit(N, this, this.targets);
            var R = this.callbacks[W];
            if (R)
              R.func.apply(this.callbackScope, [this, this.targets].concat(R.params));
          }
        }, destroy: function() {
          E.prototype.destroy.call(this), this.targets = null;
        } });
        K.register("tween", function(N) {
          return this.scene.sys.tweens.add(N);
        }), U.register("tween", function(N) {
          return this.scene.sys.tweens.create(N);
        }), M.exports = H;
      }, 43960: (M, B, $) => {
        var E = $(72905), L = $(70402), z = $(83419), U = $(842), K = $(44603), J = $(39429), Z = $(86353), D = new z({ Extends: L, initialize: function Q(H) {
          L.call(this, H), this.currentTween = null, this.currentIndex = 0;
        }, init: function() {
          if (this.loopCounter = this.loop === -1 ? Z.MAX : this.loop, this.setCurrentTween(0), this.startDelay > 0 && !this.isStartDelayed())
            this.setStartDelayState();
          else
            this.setActiveState();
          return this.dispatchEvent(U.TWEEN_ACTIVE, "onActive"), this;
        }, add: function(Q) {
          var H = this.parent.create(Q);
          if (!Array.isArray(H))
            H = [H];
          var N = this.data;
          for (var W = 0;W < H.length; W++) {
            var R = H[W];
            R.parent = this, N.push(R.reset());
          }
          return this.totalData = N.length, this;
        }, remove: function(Q) {
          if (E(this.data, Q), Q.setRemovedState(), Q === this.currentTween)
            this.nextTween();
          return this.totalData = this.data.length, this;
        }, hasTarget: function(Q) {
          var H = this.data;
          for (var N = 0;N < this.totalData; N++)
            if (H[N].hasTarget(Q))
              return true;
          return false;
        }, restart: function() {
          if (this.isDestroyed())
            return console.warn("Cannot restart destroyed TweenChain", this), this;
          if (this.isRemoved())
            this.parent.makeActive(this);
          return this.resetTweens(), this.paused = false, this.init();
        }, reset: function(Q) {
          return Q.seek(), Q.setActiveState(), this;
        }, makeActive: function(Q) {
          return Q.reset(), Q.setActiveState(), this;
        }, nextState: function() {
          if (this.loopCounter > 0)
            if (this.loopCounter--, this.resetTweens(), this.loopDelay > 0)
              this.countdown = this.loopDelay, this.setLoopDelayState();
            else
              this.setActiveState(), this.dispatchEvent(U.TWEEN_LOOP, "onLoop");
          else if (this.completeDelay > 0)
            this.countdown = this.completeDelay, this.setCompleteDelayState();
          else
            return this.onCompleteHandler(), true;
          return false;
        }, play: function() {
          if (this.isDestroyed())
            return console.warn("Cannot play destroyed TweenChain", this), this;
          if (this.isPendingRemove() || this.isPending())
            this.resetTweens();
          if (this.paused = false, this.startDelay > 0 && !this.isStartDelayed())
            this.setStartDelayState();
          else
            this.setActiveState();
          return this;
        }, resetTweens: function() {
          var Q = this.data, H = this.totalData;
          for (var N = 0;N < H; N++)
            Q[N].reset(false);
          this.currentIndex = 0, this.currentTween = Q[0];
        }, update: function(Q) {
          if (this.isPendingRemove() || this.isDestroyed())
            return true;
          else if (this.isFinished() || this.paused)
            return false;
          if (Q *= this.parent.timeScale, this.isLoopDelayed())
            this.updateLoopCountdown(Q);
          else if (this.isCompleteDelayed())
            this.updateCompleteDelay(Q);
          else if (this.isStartDelayed())
            Q = this.updateStartCountdown(Q);
          var H = false;
          if (this.isActive() && this.currentTween) {
            if (this.currentTween.update(Q)) {
              if (this.nextTween())
                this.nextState();
            }
            if (H = this.isPendingRemove(), H && this.persist)
              this.setFinishedState(), H = false;
          }
          return H;
        }, nextTween: function() {
          if (this.currentIndex++, this.currentIndex === this.totalData)
            return true;
          else
            this.setCurrentTween(this.currentIndex);
          return false;
        }, setCurrentTween: function(Q) {
          this.currentIndex = Q, this.currentTween = this.data[Q], this.currentTween.setActiveState(), this.currentTween.dispatchEvent(U.TWEEN_ACTIVE, "onActive");
        }, dispatchEvent: function(Q, H) {
          this.emit(Q, this);
          var N = this.callbacks[H];
          if (N)
            N.func.apply(this.callbackScope, [this].concat(N.params));
        }, destroy: function() {
          L.prototype.destroy.call(this), this.currentTween = null;
        } });
        J.register("tweenchain", function(Q) {
          return this.scene.sys.tweens.chain(Q);
        }), K.register("tweenchain", function(Q) {
          return this.scene.sys.tweens.create(Q);
        }), M.exports = D;
      }, 48177: (M, B, $) => {
        var E = $(95042), L = $(45319), z = $(83419), U = $(842), K = new z({ Extends: E, initialize: function J(Z, D, Q, H, N, W, R, Y, I, P, X, G, V, A, F, j, T) {
          E.call(this, Z, D, Y, I, P, X, G, V, A, F), this.key = Q, this.getActiveValue = W, this.getEndValue = H, this.getStartValue = N, this.ease = R, this.start = 0, this.previous = 0, this.current = 0, this.end = 0, this.interpolation = j, this.interpolationData = T;
        }, reset: function(J) {
          E.prototype.reset.call(this);
          var Z = this.tween.targets[this.targetIndex], D = this.key;
          if (J)
            Z[D] = this.start;
          if (this.start = 0, this.previous = 0, this.current = 0, this.end = 0, this.getActiveValue)
            Z[D] = this.getActiveValue(Z, D, 0);
        }, update: function(J) {
          var Z = this.tween, D = Z.totalTargets, Q = this.targetIndex, H = Z.targets[Q], N = this.key;
          if (!H)
            return this.setCompleteState(), false;
          if (this.isCountdown) {
            if (this.elapsed -= J, this.elapsed <= 0) {
              if (this.elapsed = 0, J = 0, this.isDelayed())
                this.setPendingRenderState();
              else if (this.isRepeating())
                this.setPlayingForwardState(), this.dispatchEvent(U.TWEEN_REPEAT, "onRepeat");
              else if (this.isHolding())
                this.setStateFromEnd(0);
            }
          }
          if (this.isPendingRender())
            return this.start = this.getStartValue(H, N, H[N], Q, D, Z), this.end = this.getEndValue(H, N, this.start, Q, D, Z), this.current = this.start, H[N] = this.start, this.setPlayingForwardState(), true;
          var W = this.isPlayingForward(), R = this.isPlayingBackward();
          if (W || R) {
            var Y = this.elapsed, I = this.duration, P = 0, X = false;
            if (Y += J, Y >= I)
              P = Y - I, Y = I, X = true;
            else if (Y < 0)
              Y = 0;
            var G = L(Y / I, 0, 1);
            if (this.elapsed = Y, this.progress = G, this.previous = this.current, X)
              if (W)
                if (this.current = this.end, H[N] = this.end, this.hold > 0)
                  this.elapsed = this.hold, this.setHoldState();
                else
                  this.setStateFromEnd(P);
              else
                this.current = this.start, H[N] = this.start, this.setStateFromStart(P);
            else {
              if (!W)
                G = 1 - G;
              var V = this.ease(G);
              if (this.interpolation)
                this.current = this.interpolation(this.interpolationData, V);
              else
                this.current = this.start + (this.end - this.start) * V;
              H[N] = this.current;
            }
            this.dispatchEvent(U.TWEEN_UPDATE, "onUpdate");
          }
          return !this.isComplete();
        }, dispatchEvent: function(J, Z) {
          var D = this.tween;
          if (!D.isSeeking) {
            var Q = D.targets[this.targetIndex], H = this.key, N = this.current, W = this.previous;
            D.emit(J, D, H, Q, N, W);
            var R = D.callbacks[Z];
            if (R)
              R.func.apply(D.callbackScope, [D, Q, H, N, W].concat(R.params));
          }
        }, destroy: function() {
          E.prototype.destroy.call(this), this.getActiveValue = null, this.getEndValue = null, this.getStartValue = null, this.ease = null;
        } });
        M.exports = K;
      }, 42220: (M, B, $) => {
        var E = $(95042), L = $(45319), z = $(83419), U = $(842), K = new z({ Extends: E, initialize: function J(Z, D, Q, H, N, W, R, Y, I, P, X) {
          E.call(this, Z, D, N, W, false, R, Y, I, P, X), this.key = "texture", this.startTexture = null, this.endTexture = Q, this.startFrame = null, this.endFrame = H, this.yoyo = Y !== 0 ? true : false;
        }, reset: function(J) {
          E.prototype.reset.call(this);
          var Z = this.tween.targets[this.targetIndex];
          if (!this.startTexture)
            this.startTexture = Z.texture.key, this.startFrame = Z.frame.name;
          if (J)
            Z.setTexture(this.startTexture, this.startFrame);
        }, update: function(J) {
          var Z = this.tween, D = this.targetIndex, Q = Z.targets[D];
          if (!Q)
            return this.setCompleteState(), false;
          if (this.isCountdown) {
            if (this.elapsed -= J, this.elapsed <= 0) {
              if (this.elapsed = 0, J = 0, this.isDelayed())
                this.setPendingRenderState();
              else if (this.isRepeating())
                this.setPlayingForwardState(), this.dispatchEvent(U.TWEEN_REPEAT, "onRepeat");
              else if (this.isHolding())
                this.setStateFromEnd(0);
            }
          }
          if (this.isPendingRender()) {
            if (this.startTexture)
              Q.setTexture(this.startTexture, this.startFrame);
            return this.setPlayingForwardState(), true;
          }
          var H = this.isPlayingForward(), N = this.isPlayingBackward();
          if (H || N) {
            var W = this.elapsed, R = this.duration, Y = 0, I = false;
            if (W += J, W >= R)
              Y = W - R, W = R, I = true;
            else if (W < 0)
              W = 0;
            var P = L(W / R, 0, 1);
            if (this.elapsed = W, this.progress = P, I)
              if (H)
                if (Q.setTexture(this.endTexture, this.endFrame), this.hold > 0)
                  this.elapsed = this.hold, this.setHoldState();
                else
                  this.setStateFromEnd(Y);
              else
                Q.setTexture(this.startTexture, this.startFrame), this.setStateFromStart(Y);
            this.dispatchEvent(U.TWEEN_UPDATE, "onUpdate");
          }
          return !this.isComplete();
        }, dispatchEvent: function(J, Z) {
          var D = this.tween;
          if (!D.isSeeking) {
            var Q = D.targets[this.targetIndex], H = this.key;
            D.emit(J, D, H, Q);
            var N = D.callbacks[Z];
            if (N)
              N.func.apply(D.callbackScope, [D, Q, H].concat(N.params));
          }
        }, destroy: function() {
          E.prototype.destroy.call(this), this.startTexture = null, this.endTexture = null, this.startFrame = null, this.endFrame = null;
        } });
        M.exports = K;
      }, 86353: (M) => {
        var B = { CREATED: 0, DELAY: 2, PENDING_RENDER: 4, PLAYING_FORWARD: 5, PLAYING_BACKWARD: 6, HOLD_DELAY: 7, REPEAT_DELAY: 8, COMPLETE: 9, PENDING: 20, ACTIVE: 21, LOOP_DELAY: 22, COMPLETE_DELAY: 23, START_DELAY: 24, PENDING_REMOVE: 25, REMOVED: 26, FINISHED: 27, DESTROYED: 28, MAX: 999999999999 };
        M.exports = B;
      }, 83419: (M) => {
        function B(K) {
          return !!K.get && typeof K.get === "function" || !!K.set && typeof K.set === "function";
        }
        function $(K, J, Z) {
          var D = Z ? K[J] : Object.getOwnPropertyDescriptor(K, J);
          if (!Z && D.value && typeof D.value === "object")
            D = D.value;
          if (D && B(D)) {
            if (typeof D.enumerable === "undefined")
              D.enumerable = true;
            if (typeof D.configurable === "undefined")
              D.configurable = true;
            return D;
          } else
            return false;
        }
        function E(K, J) {
          var Z = Object.getOwnPropertyDescriptor(K, J);
          if (!Z)
            return false;
          if (Z.value && typeof Z.value === "object")
            Z = Z.value;
          if (Z.configurable === false)
            return true;
          return false;
        }
        function L(K, J, Z, D) {
          for (var Q in J) {
            if (!J.hasOwnProperty(Q))
              continue;
            var H = $(J, Q, Z);
            if (H !== false) {
              var N = D || K;
              if (E(N.prototype, Q)) {
                if (U.ignoreFinals)
                  continue;
                throw new Error("cannot override final property \'" + Q + "\', set Class.ignoreFinals = true to skip");
              }
              Object.defineProperty(K.prototype, Q, H);
            } else
              K.prototype[Q] = J[Q];
          }
        }
        function z(K, J) {
          if (!J)
            return;
          if (!Array.isArray(J))
            J = [J];
          for (var Z = 0;Z < J.length; Z++)
            L(K, J[Z].prototype || J[Z]);
        }
        function U(K) {
          if (!K)
            K = {};
          var J, Z;
          if (K.initialize) {
            if (typeof K.initialize !== "function")
              throw new Error("initialize must be a function");
            J = K.initialize, delete K.initialize;
          } else if (K.Extends) {
            var D = K.Extends;
            J = function() {
              D.apply(this, arguments);
            };
          } else
            J = function() {
            };
          if (K.Extends)
            J.prototype = Object.create(K.Extends.prototype), J.prototype.constructor = J, Z = K.Extends, delete K.Extends;
          else
            J.prototype.constructor = J;
          var Q = null;
          if (K.Mixins)
            Q = K.Mixins, delete K.Mixins;
          return z(J, Q), L(J, K, true, Z), J;
        }
        U.extend = L, U.mixin = z, U.ignoreFinals = false, M.exports = U;
      }, 29747: (M) => {
        var B = function() {
        };
        M.exports = B;
      }, 20242: (M) => {
        var B = function() {
          return null;
        };
        M.exports = B;
      }, 71146: (M) => {
        var B = function($, E, L, z, U) {
          if (U === undefined)
            U = $;
          if (L > 0) {
            var K = L - $.length;
            if (K <= 0)
              return null;
          }
          if (!Array.isArray(E))
            if ($.indexOf(E) === -1) {
              if ($.push(E), z)
                z.call(U, E);
              return E;
            } else
              return null;
          var J = E.length - 1;
          while (J >= 0) {
            if ($.indexOf(E[J]) !== -1)
              E.splice(J, 1);
            J--;
          }
          if (J = E.length, J === 0)
            return null;
          if (L > 0 && J > K)
            E.splice(K), J = K;
          for (var Z = 0;Z < J; Z++) {
            var D = E[Z];
            if ($.push(D), z)
              z.call(U, D);
          }
          return E;
        };
        M.exports = B;
      }, 51067: (M) => {
        var B = function($, E, L, z, U, K) {
          if (L === undefined)
            L = 0;
          if (K === undefined)
            K = $;
          if (z > 0) {
            var J = z - $.length;
            if (J <= 0)
              return null;
          }
          if (!Array.isArray(E))
            if ($.indexOf(E) === -1) {
              if ($.splice(L, 0, E), U)
                U.call(K, E);
              return E;
            } else
              return null;
          var Z = E.length - 1;
          while (Z >= 0) {
            if ($.indexOf(E[Z]) !== -1)
              E.pop();
            Z--;
          }
          if (Z = E.length, Z === 0)
            return null;
          if (z > 0 && Z > J)
            E.splice(J), Z = J;
          for (var D = Z - 1;D >= 0; D--) {
            var Q = E[D];
            if ($.splice(L, 0, Q), U)
              U.call(K, Q);
          }
          return E;
        };
        M.exports = B;
      }, 66905: (M) => {
        var B = function($, E) {
          var L = $.indexOf(E);
          if (L !== -1 && L < $.length)
            $.splice(L, 1), $.push(E);
          return E;
        };
        M.exports = B;
      }, 21612: (M, B, $) => {
        var E = $(82011), L = function(z, U, K, J, Z) {
          if (J === undefined)
            J = 0;
          if (Z === undefined)
            Z = z.length;
          var D = 0;
          if (E(z, J, Z))
            for (var Q = J;Q < Z; Q++) {
              var H = z[Q];
              if (H[U] === K)
                D++;
            }
          return D;
        };
        M.exports = L;
      }, 95428: (M) => {
        var B = function($, E, L) {
          var z, U = [null];
          for (z = 3;z < arguments.length; z++)
            U.push(arguments[z]);
          for (z = 0;z < $.length; z++)
            U[0] = $[z], E.apply(L, U);
          return $;
        };
        M.exports = B;
      }, 36914: (M, B, $) => {
        var E = $(82011), L = function(z, U, K, J, Z) {
          if (J === undefined)
            J = 0;
          if (Z === undefined)
            Z = z.length;
          if (E(z, J, Z)) {
            var D, Q = [null];
            for (D = 5;D < arguments.length; D++)
              Q.push(arguments[D]);
            for (D = J;D < Z; D++)
              Q[0] = z[D], U.apply(K, Q);
          }
          return z;
        };
        M.exports = L;
      }, 81957: (M) => {
        var B = function($, E, L) {
          if (!E.length)
            return NaN;
          else if (E.length === 1)
            return E[0];
          var z = 1, U, K;
          if (L) {
            if ($ < E[0][L])
              return E[0];
            while (E[z][L] < $)
              z++;
          } else
            while (E[z] < $)
              z++;
          if (z > E.length)
            z = E.length;
          if (L)
            return U = E[z - 1][L], K = E[z][L], K - $ <= $ - U ? E[z] : E[z - 1];
          else
            return U = E[z - 1], K = E[z], K - $ <= $ - U ? K : U;
        };
        M.exports = B;
      }, 43491: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = [];
          for (var L = 0;L < $.length; L++)
            if (Array.isArray($[L]))
              B($[L], E);
            else
              E.push($[L]);
          return E;
        };
        M.exports = B;
      }, 46710: (M, B, $) => {
        var E = $(82011), L = function(z, U, K, J, Z) {
          if (J === undefined)
            J = 0;
          if (Z === undefined)
            Z = z.length;
          var D = [];
          if (E(z, J, Z))
            for (var Q = J;Q < Z; Q++) {
              var H = z[Q];
              if (!U || U && K === undefined && H.hasOwnProperty(U) || U && K !== undefined && H[U] === K)
                D.push(H);
            }
          return D;
        };
        M.exports = L;
      }, 58731: (M, B, $) => {
        var E = $(82011), L = function(z, U, K, J, Z) {
          if (J === undefined)
            J = 0;
          if (Z === undefined)
            Z = z.length;
          if (E(z, J, Z))
            for (var D = J;D < Z; D++) {
              var Q = z[D];
              if (!U || U && K === undefined && Q.hasOwnProperty(U) || U && K !== undefined && Q[U] === K)
                return Q;
            }
          return null;
        };
        M.exports = L;
      }, 26546: (M) => {
        var B = function($, E, L) {
          if (E === undefined)
            E = 0;
          if (L === undefined)
            L = $.length;
          var z = E + Math.floor(Math.random() * L);
          return $[z] === undefined ? null : $[z];
        };
        M.exports = B;
      }, 85835: (M) => {
        var B = function($, E, L) {
          if (E === L)
            return $;
          var z = $.indexOf(E), U = $.indexOf(L);
          if (z < 0 || U < 0)
            throw new Error("Supplied items must be elements of the same array");
          if (z > U)
            return $;
          if ($.splice(z, 1), U === $.length - 1)
            $.push(E);
          else
            $.splice(U, 0, E);
          return $;
        };
        M.exports = B;
      }, 83371: (M) => {
        var B = function($, E, L) {
          if (E === L)
            return $;
          var z = $.indexOf(E), U = $.indexOf(L);
          if (z < 0 || U < 0)
            throw new Error("Supplied items must be elements of the same array");
          if (z < U)
            return $;
          if ($.splice(z, 1), U === 0)
            $.unshift(E);
          else
            $.splice(U, 0, E);
          return $;
        };
        M.exports = B;
      }, 70864: (M) => {
        var B = function($, E) {
          var L = $.indexOf(E);
          if (L > 0) {
            var z = $[L - 1], U = $.indexOf(z);
            $[L] = z, $[U] = E;
          }
          return $;
        };
        M.exports = B;
      }, 69693: (M) => {
        var B = function($, E, L) {
          var z = $.indexOf(E);
          if (z === -1 || L < 0 || L >= $.length)
            throw new Error("Supplied index out of bounds");
          if (z !== L)
            $.splice(z, 1), $.splice(L, 0, E);
          return E;
        };
        M.exports = B;
      }, 40853: (M) => {
        var B = function($, E) {
          var L = $.indexOf(E);
          if (L !== -1 && L < $.length - 1) {
            var z = $[L + 1], U = $.indexOf(z);
            $[L] = z, $[U] = E;
          }
          return $;
        };
        M.exports = B;
      }, 20283: (M) => {
        var B = function($, E, L, z) {
          var U = [], K, J = false;
          if (L || z) {
            if (J = true, !L)
              L = "";
            if (!z)
              z = "";
          }
          if (E < $)
            for (K = $;K >= E; K--)
              if (J)
                U.push(L + K.toString() + z);
              else
                U.push(K);
          else
            for (K = $;K <= E; K++)
              if (J)
                U.push(L + K.toString() + z);
              else
                U.push(K);
          return U;
        };
        M.exports = B;
      }, 593: (M, B, $) => {
        var E = $(2284), L = function(z, U, K) {
          if (z === undefined)
            z = 0;
          if (U === undefined)
            U = null;
          if (K === undefined)
            K = 1;
          if (U === null)
            U = z, z = 0;
          var J = [], Z = Math.max(E((U - z) / (K || 1)), 0);
          for (var D = 0;D < Z; D++)
            J.push(z), z += K;
          return J;
        };
        M.exports = L;
      }, 43886: (M) => {
        function B(L, z, U) {
          var K = L[z];
          L[z] = L[U], L[U] = K;
        }
        function $(L, z) {
          return L < z ? -1 : L > z ? 1 : 0;
        }
        var E = function(L, z, U, K, J) {
          if (U === undefined)
            U = 0;
          if (K === undefined)
            K = L.length - 1;
          if (J === undefined)
            J = $;
          while (K > U) {
            if (K - U > 600) {
              var Z = K - U + 1, D = z - U + 1, Q = Math.log(Z), H = 0.5 * Math.exp(2 * Q / 3), N = 0.5 * Math.sqrt(Q * H * (Z - H) / Z) * (D - Z / 2 < 0 ? -1 : 1), W = Math.max(U, Math.floor(z - D * H / Z + N)), R = Math.min(K, Math.floor(z + (Z - D) * H / Z + N));
              E(L, z, W, R, J);
            }
            var Y = L[z], I = U, P = K;
            if (B(L, U, z), J(L[K], Y) > 0)
              B(L, U, K);
            while (I < P) {
              B(L, I, P), I++, P--;
              while (J(L[I], Y) < 0)
                I++;
              while (J(L[P], Y) > 0)
                P--;
            }
            if (J(L[U], Y) === 0)
              B(L, U, P);
            else
              P++, B(L, P, K);
            if (P <= z)
              U = P + 1;
            if (z <= P)
              K = P - 1;
          }
        };
        M.exports = E;
      }, 88492: (M, B, $) => {
        var E = $(35154), L = $(33680), z = function(K, J, Z) {
          var D = [];
          for (var Q = 0;Q < K.length; Q++)
            for (var H = 0;H < J.length; H++)
              for (var N = 0;N < Z; N++)
                D.push({ a: K[Q], b: J[H] });
          return D;
        }, U = function(K, J, Z) {
          var D = E(Z, "max", 0), Q = E(Z, "qty", 1), H = E(Z, "random", false), N = E(Z, "randomB", false), W = E(Z, "repeat", 0), R = E(Z, "yoyo", false), Y = [];
          if (N)
            L(J);
          if (W === -1)
            if (D === 0)
              W = 0;
            else {
              var I = K.length * J.length * Q;
              if (R)
                I *= 2;
              W = Math.ceil(D / I);
            }
          for (var P = 0;P <= W; P++) {
            var X = z(K, J, Q);
            if (H)
              L(X);
            if (Y = Y.concat(X), R)
              X.reverse(), Y = Y.concat(X);
          }
          if (D)
            Y.splice(D);
          return Y;
        };
        M.exports = U;
      }, 72905: (M, B, $) => {
        var E = $(19133), L = function(z, U, K, J) {
          if (J === undefined)
            J = z;
          var Z;
          if (!Array.isArray(U))
            if (Z = z.indexOf(U), Z !== -1) {
              if (E(z, Z), K)
                K.call(J, U);
              return U;
            } else
              return null;
          var D = U.length - 1, Q = [];
          while (D >= 0) {
            var H = U[D];
            if (Z = z.indexOf(H), Z !== -1) {
              if (E(z, Z), Q.push(H), K)
                K.call(J, H);
            }
            D--;
          }
          return Q;
        };
        M.exports = L;
      }, 60248: (M, B, $) => {
        var E = $(19133), L = function(z, U, K, J) {
          if (J === undefined)
            J = z;
          if (U < 0 || U > z.length - 1)
            throw new Error("Index out of bounds");
          var Z = E(z, U);
          if (K)
            K.call(J, Z);
          return Z;
        };
        M.exports = L;
      }, 81409: (M, B, $) => {
        var E = $(82011), L = function(z, U, K, J, Z) {
          if (U === undefined)
            U = 0;
          if (K === undefined)
            K = z.length;
          if (Z === undefined)
            Z = z;
          if (E(z, U, K)) {
            var D = K - U, Q = z.splice(U, D);
            if (J)
              for (var H = 0;H < Q.length; H++) {
                var N = Q[H];
                J.call(Z, N);
              }
            return Q;
          } else
            return [];
        };
        M.exports = L;
      }, 31856: (M, B, $) => {
        var E = $(19133), L = function(z, U, K) {
          if (U === undefined)
            U = 0;
          if (K === undefined)
            K = z.length;
          var J = U + Math.floor(Math.random() * K);
          return E(z, J);
        };
        M.exports = L;
      }, 42169: (M) => {
        var B = function($, E, L) {
          var z = $.indexOf(E), U = $.indexOf(L);
          if (z !== -1 && U === -1)
            return $[z] = L, true;
          else
            return false;
        };
        M.exports = B;
      }, 86003: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = 1;
          var L = null;
          for (var z = 0;z < E; z++)
            L = $.shift(), $.push(L);
          return L;
        };
        M.exports = B;
      }, 49498: (M) => {
        var B = function($, E) {
          if (E === undefined)
            E = 1;
          var L = null;
          for (var z = 0;z < E; z++)
            L = $.pop(), $.unshift(L);
          return L;
        };
        M.exports = B;
      }, 82011: (M) => {
        var B = function($, E, L, z) {
          var U = $.length;
          if (E < 0 || E > U || E >= L || L > U) {
            if (z)
              throw new Error("Range Error: Values outside acceptable range");
            return false;
          } else
            return true;
        };
        M.exports = B;
      }, 89545: (M) => {
        var B = function($, E) {
          var L = $.indexOf(E);
          if (L !== -1 && L > 0)
            $.splice(L, 1), $.unshift(E);
          return E;
        };
        M.exports = B;
      }, 17810: (M, B, $) => {
        var E = $(82011), L = function(z, U, K, J, Z) {
          if (J === undefined)
            J = 0;
          if (Z === undefined)
            Z = z.length;
          if (E(z, J, Z))
            for (var D = J;D < Z; D++) {
              var Q = z[D];
              if (Q.hasOwnProperty(U))
                Q[U] = K;
            }
          return z;
        };
        M.exports = L;
      }, 33680: (M) => {
        var B = function($) {
          for (var E = $.length - 1;E > 0; E--) {
            var L = Math.floor(Math.random() * (E + 1)), z = $[E];
            $[E] = $[L], $[L] = z;
          }
          return $;
        };
        M.exports = B;
      }, 90126: (M) => {
        var B = function($) {
          var E = /\D/g;
          return $.sort(function(L, z) {
            return parseInt(L.replace(E, ""), 10) - parseInt(z.replace(E, ""), 10);
          }), $;
        };
        M.exports = B;
      }, 19133: (M) => {
        var B = function($, E) {
          if (E >= $.length)
            return;
          var L = $.length - 1, z = $[E];
          for (var U = E;U < L; U++)
            $[U] = $[U + 1];
          return $.length = L, z;
        };
        M.exports = B;
      }, 19186: (M, B, $) => {
        var E = $(82264);
        function L(J, Z) {
          return String(J).localeCompare(Z);
        }
        function z(J, Z) {
          var D = J.length;
          if (D <= 1)
            return J;
          var Q = new Array(D);
          for (var H = 1;H < D; H *= 2) {
            U(J, Z, H, Q);
            var N = J;
            J = Q, Q = N;
          }
          return J;
        }
        function U(J, Z, D, Q) {
          var H = J.length, N = 0, W = D * 2, R, Y, I, P, X;
          for (R = 0;R < H; R += W) {
            if (Y = R + D, I = Y + D, Y > H)
              Y = H;
            if (I > H)
              I = H;
            P = R, X = Y;
            while (true)
              if (P < Y && X < I)
                if (Z(J[P], J[X]) <= 0)
                  Q[N++] = J[P++];
                else
                  Q[N++] = J[X++];
              else if (P < Y)
                Q[N++] = J[P++];
              else if (X < I)
                Q[N++] = J[X++];
              else
                break;
          }
        }
        var K = function(J, Z) {
          if (Z === undefined)
            Z = L;
          if (!J || J.length < 2)
            return J;
          if (E.features.stableSort)
            return J.sort(Z);
          var D = z(J, Z);
          if (D !== J)
            U(D, null, J.length, J);
          return J;
        };
        M.exports = K;
      }, 25630: (M) => {
        var B = function($, E, L) {
          if (E === L)
            return $;
          var z = $.indexOf(E), U = $.indexOf(L);
          if (z < 0 || U < 0)
            throw new Error("Supplied items must be elements of the same array");
          return $[z] = L, $[U] = E, $;
        };
        M.exports = B;
      }, 37105: (M, B, $) => {
        M.exports = { Matrix: $(54915), Add: $(71146), AddAt: $(51067), BringToTop: $(66905), CountAllMatching: $(21612), Each: $(95428), EachInRange: $(36914), FindClosestInSorted: $(81957), Flatten: $(43491), GetAll: $(46710), GetFirst: $(58731), GetRandom: $(26546), MoveDown: $(70864), MoveTo: $(69693), MoveUp: $(40853), MoveAbove: $(85835), MoveBelow: $(83371), NumberArray: $(20283), NumberArrayStep: $(593), QuickSelect: $(43886), Range: $(88492), Remove: $(72905), RemoveAt: $(60248), RemoveBetween: $(81409), RemoveRandomElement: $(31856), Replace: $(42169), RotateLeft: $(86003), RotateRight: $(49498), SafeRange: $(82011), SendToBack: $(89545), SetAll: $(17810), Shuffle: $(33680), SortByDigits: $(90126), SpliceOne: $(19133), StableSort: $(19186), Swap: $(25630) };
      }, 86922: (M) => {
        var B = function($) {
          if (!Array.isArray($) || !Array.isArray($[0]))
            return false;
          var E = $[0].length;
          for (var L = 1;L < $.length; L++)
            if ($[L].length !== E)
              return false;
          return true;
        };
        M.exports = B;
      }, 63362: (M, B, $) => {
        var E = $(41836), L = $(86922), z = function(U) {
          var K = "";
          if (!L(U))
            return K;
          for (var J = 0;J < U.length; J++) {
            for (var Z = 0;Z < U[J].length; Z++) {
              var D = U[J][Z].toString();
              if (D !== "undefined")
                K += E(D, 2);
              else
                K += "?";
              if (Z < U[J].length - 1)
                K += " |";
            }
            if (J < U.length - 1) {
              K += "\n";
              for (var Q = 0;Q < U[J].length; Q++)
                if (K += "---", Q < U[J].length - 1)
                  K += "+";
              K += "\n";
            }
          }
          return K;
        };
        M.exports = z;
      }, 92598: (M) => {
        var B = function($) {
          return $.reverse();
        };
        M.exports = B;
      }, 21224: (M) => {
        var B = function($) {
          for (var E = 0;E < $.length; E++)
            $[E].reverse();
          return $;
        };
        M.exports = B;
      }, 98717: (M, B, $) => {
        var E = $(37829), L = function(z) {
          return E(z, 180);
        };
        M.exports = L;
      }, 44657: (M, B, $) => {
        var E = $(37829), L = function(z, U) {
          if (U === undefined)
            U = 1;
          for (var K = 0;K < U; K++)
            z = E(z, 90);
          return z;
        };
        M.exports = L;
      }, 37829: (M, B, $) => {
        var E = $(86922), L = $(2429), z = function(U, K) {
          if (K === undefined)
            K = 90;
          if (!E(U))
            return null;
          if (typeof K !== "string")
            K = (K % 360 + 360) % 360;
          if (K === 90 || K === -270 || K === "rotateLeft")
            U = L(U), U.reverse();
          else if (K === -90 || K === 270 || K === "rotateRight")
            U.reverse(), U = L(U);
          else if (Math.abs(K) === 180 || K === "rotate180") {
            for (var J = 0;J < U.length; J++)
              U[J].reverse();
            U.reverse();
          }
          return U;
        };
        M.exports = z;
      }, 92632: (M, B, $) => {
        var E = $(37829), L = function(z, U) {
          if (U === undefined)
            U = 1;
          for (var K = 0;K < U; K++)
            z = E(z, -90);
          return z;
        };
        M.exports = L;
      }, 69512: (M, B, $) => {
        var E = $(86003), L = $(49498), z = function(U, K, J) {
          if (K === undefined)
            K = 0;
          if (J === undefined)
            J = 0;
          if (J !== 0)
            if (J < 0)
              E(U, Math.abs(J));
            else
              L(U, J);
          if (K !== 0)
            for (var Z = 0;Z < U.length; Z++) {
              var D = U[Z];
              if (K < 0)
                E(D, Math.abs(K));
              else
                L(D, K);
            }
          return U;
        };
        M.exports = z;
      }, 2429: (M) => {
        var B = function($) {
          var E = $.length, L = $[0].length, z = new Array(L);
          for (var U = 0;U < L; U++) {
            z[U] = new Array(E);
            for (var K = E - 1;K > -1; K--)
              z[U][K] = $[K][U];
          }
          return z;
        };
        M.exports = B;
      }, 54915: (M, B, $) => {
        M.exports = { CheckMatrix: $(86922), MatrixToString: $(63362), ReverseColumns: $(92598), ReverseRows: $(21224), Rotate180: $(98717), RotateLeft: $(44657), RotateMatrix: $(37829), RotateRight: $(92632), Translate: $(69512), TransposeMatrix: $(2429) };
      }, 71334: (M) => {
        var B = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", $ = function(E, L) {
          var z = new Uint8Array(E), U = z.length, K = L ? "data:" + L + ";base64," : "";
          for (var J = 0;J < U; J += 3)
            K += B[z[J] >> 2], K += B[(z[J] & 3) << 4 | z[J + 1] >> 4], K += B[(z[J + 1] & 15) << 2 | z[J + 2] >> 6], K += B[z[J + 2] & 63];
          if (U % 3 === 2)
            K = K.substring(0, K.length - 1) + "=";
          else if (U % 3 === 1)
            K = K.substring(0, K.length - 2) + "==";
          return K;
        };
        M.exports = $;
      }, 53134: (M) => {
        var B = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", $ = new Uint8Array(256);
        for (var E = 0;E < B.length; E++)
          $[B.charCodeAt(E)] = E;
        var L = function(z) {
          z = z.substr(z.indexOf(",") + 1);
          var U = z.length, K = U * 0.75, J = 0, Z, D, Q, H;
          if (z[U - 1] === "=") {
            if (K--, z[U - 2] === "=")
              K--;
          }
          var N = new ArrayBuffer(K), W = new Uint8Array(N);
          for (var R = 0;R < U; R += 4)
            Z = $[z.charCodeAt(R)], D = $[z.charCodeAt(R + 1)], Q = $[z.charCodeAt(R + 2)], H = $[z.charCodeAt(R + 3)], W[J++] = Z << 2 | D >> 4, W[J++] = (D & 15) << 4 | Q >> 2, W[J++] = (Q & 3) << 6 | H & 63;
          return N;
        };
        M.exports = L;
      }, 65839: (M, B, $) => {
        M.exports = { ArrayBufferToBase64: $(71334), Base64ToArrayBuffer: $(53134) };
      }, 91799: (M, B, $) => {
        M.exports = { Array: $(37105), Base64: $(65839), Objects: $(1183), String: $(31749), NOOP: $(29747), NULL: $(20242) };
      }, 41786: (M) => {
        var B = function($) {
          var E = {};
          for (var L in $)
            if (Array.isArray($[L]))
              E[L] = $[L].slice(0);
            else
              E[L] = $[L];
          return E;
        };
        M.exports = B;
      }, 62644: (M) => {
        var B = function($) {
          var E, L, z;
          if (typeof $ !== "object" || $ === null)
            return $;
          E = Array.isArray($) ? [] : {};
          for (z in $)
            L = $[z], E[z] = B(L);
          return E;
        };
        M.exports = B;
      }, 79291: (M, B, $) => {
        var E = $(41212), L = function() {
          var z, U, K, J, Z, D, Q = arguments[0] || {}, H = 1, N = arguments.length, W = false;
          if (typeof Q === "boolean")
            W = Q, Q = arguments[1] || {}, H = 2;
          if (N === H)
            Q = this, --H;
          for (;H < N; H++)
            if ((z = arguments[H]) != null)
              for (U in z) {
                if (K = Q[U], J = z[U], Q === J)
                  continue;
                if (W && J && (E(J) || (Z = Array.isArray(J)))) {
                  if (Z)
                    Z = false, D = K && Array.isArray(K) ? K : [];
                  else
                    D = K && E(K) ? K : {};
                  Q[U] = L(W, D, J);
                } else if (J !== undefined)
                  Q[U] = J;
              }
          return Q;
        };
        M.exports = L;
      }, 23568: (M, B, $) => {
        var E = $(75508), L = $(35154), z = function(U, K, J) {
          var Z = L(U, K, null);
          if (Z === null)
            return J;
          else if (Array.isArray(Z))
            return E.RND.pick(Z);
          else if (typeof Z === "object") {
            if (Z.hasOwnProperty("randInt"))
              return E.RND.integerInRange(Z.randInt[0], Z.randInt[1]);
            else if (Z.hasOwnProperty("randFloat"))
              return E.RND.realInRange(Z.randFloat[0], Z.randFloat[1]);
          } else if (typeof Z === "function")
            return Z(K);
          return Z;
        };
        M.exports = z;
      }, 95540: (M) => {
        var B = function($, E, L) {
          var z = typeof $;
          if (!$ || z === "number" || z === "string")
            return L;
          else if ($.hasOwnProperty(E) && $[E] !== undefined)
            return $[E];
          else
            return L;
        };
        M.exports = B;
      }, 82840: (M, B, $) => {
        var E = $(35154), L = $(45319), z = function(U, K, J, Z, D) {
          if (D === undefined)
            D = J;
          var Q = E(U, K, D);
          return L(Q, J, Z);
        };
        M.exports = z;
      }, 35154: (M) => {
        var B = function($, E, L, z) {
          if (!$ && !z || typeof $ === "number")
            return L;
          else if ($ && $.hasOwnProperty(E))
            return $[E];
          else if (z && z.hasOwnProperty(E))
            return z[E];
          else if (E.indexOf(".") !== -1) {
            var U = E.split("."), K = $, J = z, Z = L, D = L, Q = true, H = true;
            for (var N = 0;N < U.length; N++) {
              if (K && K.hasOwnProperty(U[N]))
                Z = K[U[N]], K = K[U[N]];
              else
                Q = false;
              if (J && J.hasOwnProperty(U[N]))
                D = J[U[N]], J = J[U[N]];
              else
                H = false;
            }
            if (Q)
              return Z;
            else if (H)
              return D;
            else
              return L;
          } else
            return L;
        };
        M.exports = B;
      }, 69036: (M) => {
        var B = function($, E) {
          for (var L = 0;L < E.length; L++)
            if (!$.hasOwnProperty(E[L]))
              return false;
          return true;
        };
        M.exports = B;
      }, 1985: (M) => {
        var B = function($, E) {
          for (var L = 0;L < E.length; L++)
            if ($.hasOwnProperty(E[L]))
              return true;
          return false;
        };
        M.exports = B;
      }, 97022: (M) => {
        var B = function($, E) {
          return $.hasOwnProperty(E);
        };
        M.exports = B;
      }, 41212: (M) => {
        var B = function($) {
          if (!$ || typeof $ !== "object" || $.nodeType || $ === $.window)
            return false;
          try {
            if ($.constructor && !{}.hasOwnProperty.call($.constructor.prototype, "isPrototypeOf"))
              return false;
          } catch (E) {
            return false;
          }
          return true;
        };
        M.exports = B;
      }, 46975: (M, B, $) => {
        var E = $(41786), L = function(z, U) {
          var K = E(z);
          for (var J in U)
            if (!K.hasOwnProperty(J))
              K[J] = U[J];
          return K;
        };
        M.exports = L;
      }, 269: (M, B, $) => {
        var E = $(41786), L = function(z, U) {
          var K = E(z);
          for (var J in U)
            if (K.hasOwnProperty(J))
              K[J] = U[J];
          return K;
        };
        M.exports = L;
      }, 18254: (M, B, $) => {
        var E = $(97022), L = function(z, U) {
          var K = {};
          for (var J = 0;J < U.length; J++) {
            var Z = U[J];
            if (E(z, Z))
              K[Z] = z[Z];
          }
          return K;
        };
        M.exports = L;
      }, 61622: (M) => {
        var B = function($, E, L) {
          if (!$ || typeof $ === "number")
            return false;
          else if ($.hasOwnProperty(E))
            return $[E] = L, true;
          else if (E.indexOf(".") !== -1) {
            var z = E.split("."), U = $, K = $;
            for (var J = 0;J < z.length; J++)
              if (U.hasOwnProperty(z[J]))
                K = U, U = U[z[J]];
              else
                return false;
            return K[z[z.length - 1]] = L, true;
          }
          return false;
        };
        M.exports = B;
      }, 1183: (M, B, $) => {
        M.exports = { Clone: $(41786), DeepCopy: $(62644), Extend: $(79291), GetAdvancedValue: $(23568), GetFastValue: $(95540), GetMinMaxValue: $(82840), GetValue: $(35154), HasAll: $(69036), HasAny: $(1985), HasValue: $(97022), IsPlainObject: $(41212), Merge: $(46975), MergeRight: $(269), Pick: $(18254), SetValue: $(61622) };
      }, 27902: (M) => {
        var B = function($, E) {
          return $.replace(/%([0-9]+)/g, function(L, z) {
            return E[Number(z) - 1];
          });
        };
        M.exports = B;
      }, 41836: (M) => {
        var B = function($, E, L, z) {
          if (E === undefined)
            E = 0;
          if (L === undefined)
            L = " ";
          if (z === undefined)
            z = 3;
          $ = $.toString();
          var U = 0;
          if (E + 1 >= $.length)
            switch (z) {
              case 1:
                $ = new Array(E + 1 - $.length).join(L) + $;
                break;
              case 3:
                var K = Math.ceil((U = E - $.length) / 2), J = U - K;
                $ = new Array(J + 1).join(L) + $ + new Array(K + 1).join(L);
                break;
              default:
                $ = $ + new Array(E + 1 - $.length).join(L);
                break;
            }
          return $;
        };
        M.exports = B;
      }, 33628: (M) => {
        var B = function($, E) {
          if (E === 0)
            return $.slice(1);
          else
            return $.slice(0, E - 1) + $.slice(E);
        };
        M.exports = B;
      }, 27671: (M) => {
        var B = function($) {
          return $.split("").reverse().join("");
        };
        M.exports = B;
      }, 45650: (M) => {
        var B = function() {
          return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function($) {
            var E = Math.random() * 16 | 0, L = $ === "x" ? E : E & 3 | 8;
            return L.toString(16);
          });
        };
        M.exports = B;
      }, 35355: (M) => {
        var B = function($) {
          return $ && $[0].toUpperCase() + $.slice(1);
        };
        M.exports = B;
      }, 31749: (M, B, $) => {
        M.exports = { Format: $(27902), Pad: $(41836), RemoveAt: $(33628), Reverse: $(27671), UppercaseFirst: $(35355), UUID: $(45650) };
      } }, H0 = {};
      function Y0(M) {
        var B = H0[M];
        if (B !== undefined)
          return B.exports;
        var $ = H0[M] = { exports: {} };
        return R0[M]($, $.exports, Y0), $.exports;
      }
      (() => {
        Y0.g = function() {
          if (typeof globalThis === "object")
            return globalThis;
          try {
            return this || new Function("return this")();
          } catch (M) {
            if (typeof window === "object")
              return window;
          }
        }();
      })();
      var M0 = Y0(85454);
      return M0;
    })();
  });
});
var B0 = v0(j0(), 1);
export {
  x0 as createGame
};
